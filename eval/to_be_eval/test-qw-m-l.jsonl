{"problem_id":"p03371","slow_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = 5000 * 2 * 10 ** 5\n\nfor i in range(10 ** 5 + 1):\n\n    s = i * 2 * C + max(0, X - i) * A + max(0, Y - i) * B\n\n    ans = min(ans, s)\n\n\n\nprint(ans)","reference_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nif X > Y:\n\n    v = A\n\nelse:\n\n    v = B\n\n\n\nans = min(A*X+B*Y, C*max(X, Y)*2, C*min(X,Y)*2+(max(X,Y)-min(X,Y))*v)\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read input values\nA, B, C, X, Y = map(int, input().split())\n\n# Initialize the answer with a large value\nans = float('inf')\n\n# Determine the range of interest\nmax_range = max(X, Y)\n\n# Iterate over the reduced range\nfor i in range(max_range + 1):\n    # Compute the cost for the current value of i\n    s = i * 2 * C + max(0, X - i) * A + max(0, Y - i) * B\n    \n    # Update the minimum cost\n    ans = min(ans, s)\n\n# Check if buying more than max(X, Y) sets is cheaper\nif 2 * C < A + B:\n    # If so, calculate the cost for i > max(X, Y)\n    extra_sets = max(0, max(X, Y) - min(X, Y))\n    ans = min(ans, max(X, Y) * 2 * C + extra_sets * 2 * C)\n\n# Output the result\nprint(ans)"}
{"problem_id":"p02612","slow_code_col":"import sys\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN = int(read())\n\nx = N + (-N) % 1000\n\nprint((x - N))","reference_code_col":"import math\n\nN = int(eval(input()))\n\nx = math.ceil(N\/1000) * 1000\n\nprint((x-N))","model_generated_potentially_faster_code_col":"import sys\n\n# Read the input as an integer directly\nN = int(sys.stdin.buffer.read())\n\n# Compute and print the result in one step\nprint((-N) % 1000)"}
{"problem_id":"p03013","slow_code_col":"import numpy as np\n\ndef resolve():\n\n    MOD = 10 ** 9 + 7\n\n    n, m = list(map(int, input().split()))\n\n    a = [int(eval(input())) for _ in range(m)]\n\n\n\n    dp = np.array([1] * (n + 1))\n\n    dp[a] = 0\n\n\n\n    for i in range(2, n + 1):\n\n        if dp[i] != 0:\n\n            dp[i] = np.sum(dp[i - 2:i]) % MOD\n\n\n\n    print((dp[n]))\n\n    \n\nresolve()","reference_code_col":"def resolve():\n\n    MOD = 10 ** 9 + 7\n\n    n, m = list(map(int, input().split()))\n\n\n\n    # i\u6bb5\u76ee\u306b\u5230\u9054\u3059\u308b\u307e\u3067\u306e\u30eb\u30fc\u30c8\u306e\u7dcf\u6570\n\n    dp = [1] * (n + 1)\n\n\n\n    for _ in range(m):\n\n        dp[int(eval(input()))] = 0\n\n\n\n    for i in range(2, n + 1):\n\n        if dp[i] == 0:\n\n            continue\n\n\n\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n\n\n\n    print((dp[n]))\n\n    \n\nresolve()","model_generated_potentially_faster_code_col":"def resolve():\n    MOD = 10**9 + 7\n\n    # Input parsing\n    n, m = map(int, input().split())\n    forbidden = {int(input()) for _ in range(m)}  # Use a set for O(1) lookups\n\n    # Initialize DP array\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: 1 way to reach step 0\n\n    # Sliding window variables\n    prev2, prev1 = 0, 1  # dp[i-2] and dp[i-1]\n\n    for i in range(1, n + 1):\n        if i in forbidden:\n            dp[i] = 0  # No valid ways to reach forbidden steps\n        else:\n            dp[i] = (prev1 + prev2) % MOD  # Sum of previous two steps\n        # Update sliding window\n        prev2, prev1 = prev1, dp[i]\n\n    print(dp[n])\n\nresolve()"}
{"problem_id":"p02596","slow_code_col":"def c_repsept():\n\n    K = int(eval(input()))\n\n\n\n    L = 9 * K \/\/ 7 if K % 7 == 0 else 9 * K\n\n    if L % 2 == 0 or L % 5 == 0:\n\n        return -1\n\n\n\n    remainder = 1\n\n    for n in range(1, L + 1):\n\n        remainder = (10 * remainder) % L\n\n        if remainder == 1:\n\n            return n\n\n    return -1\n\n\n\nprint((c_repsept()))","reference_code_col":"def c_repsept_totient():\n\n    def euler_phi(n):\n\n        \"\"\"\u6b63\u6574\u6570 n \u306b\u5bfe\u3057\u3066\u3001n \u3068\u4e92\u3044\u306b\u7d20\u306a n \u4ee5\u4e0b\u306e\u6b63\u6574\u6570\u306e\u500b\u6570\"\"\"\n\n        ret = n\n\n        for i in range(2, int(n**0.5) + 1):\n\n            if n % i == 0:\n\n                ret = ret \/\/ i * (i - 1)\n\n                while n % i == 0:\n\n                    n \/\/= i\n\n        if n > 1:\n\n            ret -= ret \/\/ n\n\n        return ret\n\n\n\n    def divisor_list(n):\n\n        \"\"\"n \u306e\u6b63\u306e\u7d04\u6570\u306e\u30ea\u30b9\u30c8\"\"\"\n\n        ret = set()\n\n        for k in range(1, int(n**0.5) + 1):\n\n            if n % k == 0:\n\n                ret.update({k, n \/\/ k})\n\n        return sorted(ret)\n\n\n\n    K = int(eval(input()))\n\n    L = 9 * (K \/\/ 7 if K % 7 == 0 else K)\n\n\n\n    for d in divisor_list(euler_phi(L)):\n\n        if pow(10, d, L) == 1:\n\n            return d\n\n    return -1\n\n\n\nprint((c_repsept_totient()))","model_generated_potentially_faster_code_col":"def c_repsept():\n    # Read input safely\n    K = int(input())\n\n    # Calculate L based on K\n    L = 9 * K \/\/ 7 if K % 7 == 0 else 9 * K\n\n    # Early exit if L is divisible by 2 or 5\n    if L % 2 == 0 or L % 5 == 0:\n        return -1\n\n    # Dictionary to track seen remainders and their positions\n    seen_remainders = {}\n    remainder = 1\n    position = 0\n\n    while True:\n        # Check if the remainder has been seen before\n        if remainder in seen_remainders:\n            # Cycle detected, but no valid result found\n            return -1\n\n        # Store the current remainder and its position\n        seen_remainders[remainder] = position\n\n        # Update the remainder\n        remainder = (10 * remainder) % L\n\n        # Check if the remainder is 1\n        if remainder == 1:\n            return position + 1  # +1 because positions are 0-indexed\n\n        # Increment the position\n        position += 1\n\n# Print the result\nprint(c_repsept())"}
{"problem_id":"p03039","slow_code_col":"H, W, K = list(map(int, input().split()))\n\nMOD = 10 ** 9 + 7\n\n\n\nHd = sum([d * (H - d) * (W ** 2) for d in range(H)])\n\nWd = sum([d * (W - d) * (H ** 2) for d in range(W)])\n\n\n\n\n\n# \u968e\u4e57 & \u9006\u5143\u8a08\u7b97\n\nfactorial = [1]\n\ninverse = [1]\n\nfor i in range(1, H * W + 2):\n\n    factorial.append(factorial[-1] * i % MOD)\n\n    inverse.append(pow(factorial[-1], MOD - 2, MOD))\n\n\n\n\n\nans = (Hd + Wd) * factorial[H * W - 2] * inverse[K - 2] * inverse[H * W - K] % MOD\n\nprint(ans)\n","reference_code_col":"H, W, K = list(map(int, input().split()))\n\nMOD = 10 ** 9 + 7\n\n\n\nfactorial = [1, 1]  # \u5143\u30c6\u30fc\u30d6\u30eb\n\ninverse = [1, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\ninverse_from = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n\n\nfor i in range(2, H * W + 1):\n\n    factorial.append((factorial[-1] * i) % MOD)\n\n    inverse_from.append((-inverse_from[MOD % i] * (MOD \/\/ i)) % MOD)\n\n    inverse.append((inverse[-1] * inverse_from[-1]) % MOD)\n\n\n\n\n\ndef nCr(n, r):\n\n    if n < r or r < 0:\n\n        return 0\n\n    elif r == 0:\n\n        return 1\n\n    return factorial[n] * inverse[r] * inverse[n - r] % MOD\n\n\n\n\n\nans = 0\n\n# H\u306b\u3064\u3044\u3066\n\nfor d in range(1, H):\n\n    ans += d * (H - d) * pow(W, 2, MOD) * nCr(H * W - 2, K - 2) % MOD\n\n    ans %= MOD\n\n# W\u306b\u3064\u3044\u3066\n\nfor d in range(1, W):\n\n    ans += d * (W - d) * pow(H, 2, MOD) * nCr(H * W - 2, K - 2) % MOD\n\n    ans %= MOD\n\n\n\nprint((ans % MOD))\n","model_generated_potentially_faster_code_col":"Hd = sum(d * (H - d) * (W ** 2) for d in range(H))\nWd = sum(d * (W - d) * (H ** 2) for d in range(W))"}
{"problem_id":"p03078","slow_code_col":"# -*- coding: utf-8 -*-\n\nx, y, z, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\n\n\na.sort(reverse=True)\n\nb.sort(reverse=True)\n\nc.sort(reverse=True)\n\n\n\nabc = []\n\n\n\nfor i, _a in enumerate(a):\n\n    for j, _b in enumerate(b):\n\n        if (i+1) * (j+1) > k:\n\n            break\n\n        for l, _c in enumerate(c):\n\n            if (i+1) * (j+1) * (l+1) > k:\n\n                break\n\n            abc.append(_a + _b + _c)\n\n\n\nabc.sort(reverse=True)\n\nfor x in abc[:k]:\n\n    print(x)\n","reference_code_col":"# -*- coding: utf-8 -*-\n\nimport heapq\n\n\n\nx, y, z, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\n\n\nla, lb, lc = len(a), len(b), len(c)\n\n\n\na.sort(reverse=True)\n\nb.sort(reverse=True)\n\nc.sort(reverse=True)\n\n\n\nfix = set()\n\n\n\nq = [(-(a[0]+b[0]+c[0]), 0, 0, 0)]\n\n\n\nfor _ in range(k):\n\n    abc, i, j, l = heapq.heappop(q)\n\n    print((-abc))\n\n\n\n    if i+1 < la and (i+1, j, l) not in fix:\n\n        heapq.heappush(q, (-(a[i+1]+b[j]+c[l]), i+1, j, l))\n\n        fix.add((i+1, j, l))\n\n\n\n    if j+1 < lb and (i, j+1, l) not in fix:\n\n        heapq.heappush(q, (-(a[i]+b[j+1]+c[l]), i, j+1, l))\n\n        fix.add((i, j+1, l))\n\n\n\n    if l+1 < lc and (i, j, l+1) not in fix:\n\n        heapq.heappush(q, (-(a[i]+b[j]+c[l+1]), i, j, l+1))\n\n        fix.add((i, j, l+1))\n","model_generated_potentially_faster_code_col":"import heapq\n\n# Read input\nx, y, z, k = map(int, input().split())\na = sorted(map(int, input().split()), reverse=True)\nb = sorted(map(int, input().split()), reverse=True)\nc = sorted(map(int, input().split()), reverse=True)\n\n# Min-heap to store the top k sums\nheap = []\nheapq.heappush(heap, (-(a[0] + b[0] + c[0]), 0, 0, 0))  # Push negative sum for max-heap behavior\n\n# Set to track visited indices\nvisited = set()\nvisited.add((0, 0, 0))\n\nresult = []\n\nwhile len(result) < k and heap:\n    # Pop the largest sum (smallest negative sum)\n    current_sum, i, j, l = heapq.heappop(heap)\n    result.append(-current_sum)  # Negate to get the actual sum\n\n    # Explore neighboring combinations\n    if i + 1 < x and (i + 1, j, l) not in visited:\n        heapq.heappush(heap, (-(a[i + 1] + b[j] + c[l]), i + 1, j, l))\n        visited.add((i + 1, j, l))\n    \n    if j + 1 < y and (i, j + 1, l) not in visited:\n        heapq.heappush(heap, (-(a[i] + b[j + 1] + c[l]), i, j + 1, l))\n        visited.add((i, j + 1, l))\n    \n    if l + 1 < z and (i, j, l + 1) not in visited:\n        heapq.heappush(heap, (-(a[i] + b[j] + c[l + 1]), i, j, l + 1))\n        visited.add((i, j, l + 1))\n\n# Print the top k sums\nfor x in result:\n    print(x)"}
{"problem_id":"p03559","slow_code_col":"N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nA.sort()\n\nC.sort()\n\n\n\nans = 0\n\nfrom bisect import bisect, bisect_left\n\nfor b in B:\n\n    i = bisect_left(A, b)\n\n    j = bisect(C, b)\n\n    ans += i * (N-j)\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nA.sort()\n\nC.sort()\n\n\n\nfrom bisect import bisect_left, bisect\n\nans = 0\n\nfor b in B:\n\n    i = bisect_left(A,b)\n\n    j = bisect(C,b)\n\n    ans += i * (N-j)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\nfrom bisect import bisect_left, bisect\n\n# Faster input reading\ndef fast_input():\n    return sys.stdin.read().split()\n\n# Read input\ndata = fast_input()\nN = int(data[0])\nA = list(map(int, data[1:N+1]))\nB = list(map(int, data[N+1:2*N+1]))\nC = list(map(int, data[2*N+1:]))\n\n# Sort A and C\nA.sort()\nC.sort()\n\n# Precompute prefix sums for A and C\nA_counts = [0] * (N + 1)\nC_counts = [0] * (N + 1)\n\nfor i in range(N):\n    A_counts[i + 1] = A_counts[i] + (A[i] <= B[i])\n    C_counts[i + 1] = C_counts[i] + (C[i] > B[i])\n\n# Calculate answer\nans = 0\nfor b in B:\n    # Use precomputed counts instead of bisect\n    i = bisect_left(A, b)\n    j = N - bisect(C, b)\n    ans += i * j\n\nprint(ans)"}
{"problem_id":"p03674","slow_code_col":"n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nD = {i: [0] for i in range(1, n+1)}\n\nfor i in range(n+1):\n\n  D[a[i]][0] += 1\n\n  D[a[i]].append(i)\n\npl, pr = 0, 0\n\nfor i in D:\n\n  if D[i][0] == 2:\n\n    pl = D[i][1]\n\n    pr = D[i][2]\n\n    break\n\nL = pl\n\nM = pr - pl - 1\n\nN = n - pr\n\nmod = int(1e9) + 7 # <-- input modulo\n\nmaxf = n+11          # <-- input factional limitation\n\n\n\ndef make_fact(n, k):\n\n    tmp = n\n\n    perm = [i for i in range(k)]\n\n    L = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        L[i] = tmp % (i + 1)\n\n        tmp \/\/= i + 1\n\n    LL = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        LL[i] = perm[L[-i-1]]\n\n        for j in range(L[-i-1]+1, k):\n\n            perm[j-1] = perm[j]\n\n    return LL\n\n\n\ndef doubling(n, m, modulo=mod):\n\n    y = 1\n\n    base = n\n\n    tmp = m\n\n    while tmp != 0:\n\n        if tmp % 2 == 1:\n\n            y *= base\n\n            if modulo > 0:\n\n                y %= modulo\n\n        base *= base\n\n        if modulo > 0:\n\n            base %= modulo\n\n        tmp \/\/= 2\n\n    return y\n\n\n\ndef inved(a, modulo=mod):\n\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n\n    while l != 0:\n\n        x, y, u, v = u, v, x - u * (k \/\/ l), y - v * (k \/\/ l)\n\n        k, l = l, k % l\n\n    return x % modulo\n\n\n\nfact = [1 for _ in range(maxf+1)]\n\ninvf = [1 for _ in range(maxf+1)]\n\n\n\nfor i in range(maxf):\n\n    fact[i+1] = (fact[i] * (i+1)) % mod\n\ninvf[-1] = inved(fact[-1])\n\nfor i in range(maxf, 0, -1):\n\n    invf[i-1] = (invf[i] * i) % mod\n\n\n\nfor i in range(1, n+2):\n\n  S = fact[n]*invf[i-1]*invf[n-i+1]%mod\n\n  if i <= n-1:\n\n    S += fact[n-1]*invf[i]*invf[n-1-i]%mod\n\n    S %= mod\n\n  if i <= n-M:\n\n    S -= fact[n-1-M]*invf[i-1]*invf[n-M-i]%mod\n\n    S %= mod\n\n  if i <= n:\n\n    S += fact[n-1]*invf[i-1]*invf[n-i]%mod\n\n    S %= mod\n\n  print(S)","reference_code_col":"n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nD = {i: [0] for i in range(1, n+1)}\n\nfor i in range(n+1):\n\n  D[a[i]][0] += 1\n\n  D[a[i]].append(i)\n\npl, pr = 0, 0\n\nfor i in D:\n\n  if D[i][0] == 2:\n\n    pl = D[i][1]\n\n    pr = D[i][2]\n\n    break\n\nL = pl\n\nM = pr - pl - 1\n\nN = n - pr\n\nmod = int(1e9) + 7 # <-- input modulo\n\nmaxf = n+11          # <-- input factional limitation\n\n\n\ndef make_fact(n, k):\n\n    tmp = n\n\n    perm = [i for i in range(k)]\n\n    L = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        L[i] = tmp % (i + 1)\n\n        tmp \/\/= i + 1\n\n    LL = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        LL[i] = perm[L[-i-1]]\n\n        for j in range(L[-i-1]+1, k):\n\n            perm[j-1] = perm[j]\n\n    return LL\n\n\n\ndef doubling(n, m, modulo=mod):\n\n    y = 1\n\n    base = n\n\n    tmp = m\n\n    while tmp != 0:\n\n        if tmp % 2 == 1:\n\n            y *= base\n\n            if modulo > 0:\n\n                y %= modulo\n\n        base *= base\n\n        if modulo > 0:\n\n            base %= modulo\n\n        tmp \/\/= 2\n\n    return y\n\n\n\ndef inved(a, modulo=mod):\n\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n\n    while l != 0:\n\n        x, y, u, v = u, v, x - u * (k \/\/ l), y - v * (k \/\/ l)\n\n        k, l = l, k % l\n\n    return x % modulo\n\n\n\nfact = [1 for _ in range(maxf+1)]\n\ninvf = [1 for _ in range(maxf+1)]\n\n\n\nfor i in range(maxf):\n\n    fact[i+1] = (fact[i] * (i+1)) % mod\n\ninvf[-1] = inved(fact[-1])\n\nfor i in range(maxf, 0, -1):\n\n    invf[i-1] = (invf[i] * i) % mod\n\n\n\nfor i in range(1, n+2):\n\n  S = fact[n+1]*invf[i]*invf[n-i+1]%mod\n\n  if i <= n-M:\n\n    S -= fact[n-1-M]*invf[i-1]*invf[n-M-i]%mod\n\n    S %= mod\n\n  print(S)\n","model_generated_potentially_faster_code_col":"n = int(input())\na = list(map(int, input().split()))\n\n# Find duplicates directly without creating a dictionary\npl, pr = -1, -1\nfor i in range(n):\n    if a[i] in a[:i]:\n        pl = a.index(a[i])\n        pr = i\n        break\n\nL = pl\nM = pr - pl - 1\nN = n - pr"}
{"problem_id":"p02952","slow_code_col":"n = int(eval(input()))\n\n\n\n\n\ndef countKeta(num):\n\n    count = 1\n\n    while num \/ 10 >= 1:\n\n        count += 1\n\n        num = num \/\/ 10\n\n    return count\n\n\n\n\n\ncount = 0\n\n\n\nfor i in range(1, n+1):\n\n    if(countKeta(i) % 2 == 1):\n\n        count += 1\n\n\n\nprint(count)","reference_code_col":"n = int(eval(input()))\n\n\n\nif n < 10:\n\n    print(n)\n\nelif n < 100:\n\n    print((9))\n\nelif n < 1000:\n\n    print((n-90))\n\nelif n < 10000:\n\n    print((909))\n\nelif n < 100000:\n\n    print((n-9090))\n\nelif n < 1000000:\n\n    print((90909))","model_generated_potentially_faster_code_col":"n = int(input())\n\ndef count_odd_digit_numbers(n):\n    count = 0\n    power_of_10 = 1  # Start with 1-digit numbers\n\n    while power_of_10 <= n:\n        # Calculate the range of numbers with the current digit count\n        start = power_of_10\n        end = min(power_of_10 * 10 - 1, n)\n        \n        # If the current digit count is odd, add the count of numbers in this range\n        if len(str(start)) % 2 == 1:\n            count += end - start + 1\n        \n        # Move to the next power of 10\n        power_of_10 *= 10\n    \n    return count\n\nprint(count_odd_digit_numbers(n))"}
{"problem_id":"p03721","slow_code_col":"import numpy as np\n\n\n\nn, k = list(map(int, input().split()))\n\nz = np.zeros(10**5 + 1)\n\nfor i in range(n):\n\n  a, b = list(map(int, input().split()))\n\n  z[a] += b\n\n\n\na = 0\n\nfor i in range(1, 10**5 + 1):\n\n  if k <= z[i]:\n\n    a = i\n\n    break\n\n  k -= z[i]\n\n\n\nprint((int(a)))\n","reference_code_col":"n, k = list(map(int, input().split()))\n\nd = {}\n\nfor i in range(n):\n\n  a, b = list(map(int, input().split()))\n\n  d[a] = d[a] + b if a in d else b\n\n \n\na = 0\n\nfor i in range(1, 10**5+1):\n\n  if i in d and k <= d[i]:\n\n    a = i\n\n    break\n\n  k -= d[i] if i in d else 0\n\n \n\nprint(a)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read n and k\nn, k = map(int, input().split())\n\n# Initialize variables to track maximum index and store updates\nupdates = {}\nmax_a = 0\n\n# Process input pairs (a, b)\nfor _ in range(n):\n    a, b = map(int, input().split())\n    updates[a] = updates.get(a, 0) + b\n    max_a = max(max_a, a)\n\n# Create an array of size max_a + 1\nz = np.zeros(max_a + 1)\n\n# Apply updates to the array\nfor a, b in updates.items():\n    z[a] += b\n\n# Perform cumulative sum and find the result\ncumulative_sum = 0\nresult = -1  # Default value if no valid index is found\n\nfor i in range(1, max_a + 1):\n    cumulative_sum += z[i]\n    if cumulative_sum >= k:\n        result = i\n        break\n\nprint(result)"}
{"problem_id":"p02996","slow_code_col":"\n\n\n\nn = int(eval(input()))\n\n\n\nabn = [list(map(int,input().split())) for _ in range(n)]\n\n\n\n\n\nabn.sort()\n\nabn.sort(key = lambda x:x[1])\n\n\n\n\n\n#print(abn)\n\n\n\nts = 0 # time_stamp\n\nenable = True\n\nfor abi in abn:\n\n    a, b = abi\n\n\n\n    if not ts + a <= b:\n\n        enable = False\n\n        break\n\n    else:\n\n        ts += a\n\n\n\nprint(('Yes' if enable else 'No'))","reference_code_col":"\n\nn = int(eval(input()))\n\n\n\nabn = [list(map(int,input().split())) for _ in range(n)]\n\n\n\n\n\n#abn.sort()\n\nabn.sort(key = lambda x:x[1])\n\n\n\n\n\n#print(abn)\n\n\n\nts = 0 # time_stamp\n\nenable = True\n\nfor abi in abn:\n\n    a, b = abi\n\n\n\n    if not ts + a <= b:\n\n        enable = False\n\n        break\n\n    else:\n\n        ts += a\n\n\n\nprint(('Yes' if enable else 'No'))","model_generated_potentially_faster_code_col":"# Read input values\nn = int(input())\n\n# Parse the input into a list of tuples (a, b)\nabn = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Sort the list by the second element (b) only\nabn.sort(key=lambda x: x[1])\n\n# Initialize variables\nts = 0  # time_stamp\nenable = True\n\n# Iterate through the sorted list\nfor a, b in abn:\n    if ts + a > b:\n        enable = False\n        break\n    ts += a\n\n# Print the result\nprint('Yes' if enable else 'No')"}
{"problem_id":"p00053","slow_code_col":"def isPrime(x):\n\n    if x == 2:\n\n        return True\n\n    if x < 2 or x % 2 == 0:\n\n        return False\n\n    i, root_x = 3, int(pow(x, 0.5))\n\n    while i <= root_x:\n\n        if x % i == 0:\n\n            return False\n\n        i += 2\n\n    return True\n\n\n\nprimes = [2]\n\nfor i in range(3, 104730):\n\n    if isPrime(i):\n\n        primes.append(primes[-1]+i)\n\nwhile True:\n\n    n = int(eval(input()))\n\n    if n == 0:\n\n        break\n\n    print((primes[n-1]))","reference_code_col":"primes = [0, 0] + [1] * 150000\n\nfor i in range(2, 388):\n\n    if primes[i]:\n\n        for j in range(i*i, 150001, i):\n\n            primes[j] = 0\n\n\n\nvalues = [i for i, v in enumerate(primes) if v]\n\nwhile True:\n\n    n = int(eval(input()))\n\n    if n == 0:\n\n        break\n\n    print((sum(values[:n])))","model_generated_potentially_faster_code_col":"import math\n\ndef generate_primes_and_cumulative_sums(limit):\n    # Sieve of Eratosthenes to generate primes\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n\n    for i in range(2, int(math.isqrt(limit)) + 1):\n        if sieve[i]:\n            for j in range(i * i, limit + 1, i):\n                sieve[j] = False\n\n    # Extract primes and compute cumulative sums\n    primes = []\n    cumulative_sum = 0\n    for i in range(2, limit + 1):\n        if sieve[i]:\n            cumulative_sum += i\n            primes.append(cumulative_sum)\n\n    return primes\n\n\n# Generate primes and their cumulative sums up to 104730\nprimes = generate_primes_and_cumulative_sums(104730)\n\n# Process input queries\nwhile True:\n    try:\n        n = int(input())\n        if n == 0:\n            break\n        print(primes[n - 1])\n    except EOFError:\n        break"}
{"problem_id":"p03162","slow_code_col":"# https:\/\/atcoder.jp\/contests\/dp\/tasks\/dp_c\n\nimport numpy as np\n\nN = int(eval(input()))\n\nMax_List=[]\n\nN_List=[i for i in range(3)]\n\nfor i in range(N):\n\n    Current_List=list(map(int,input().split())) \n\n    if i == 0:\n\n        Max_List.append(Current_List)\n\n    else:\n\n        Current_Max_List = []\n\n        for j in range(3):\n\n            Index_List=np.array(Max_List[i-1])\n\n            ind = np.ones(3, dtype=bool)\n\n            ind[j] = False\n\n            Current_Max_List.append(max(Index_List[ind])+Current_List[j])\n\n            \n\n        Max_List.append(Current_Max_List)\n\n        \n\n    \n\nprint((max(Max_List[-1])))","reference_code_col":"# https:\/\/atcoder.jp\/contests\/dp\/tasks\/dp_c\n\nN = int(eval(input()))\n\nMax_List=[]\n\nN_List=[i for i in range(3)]\n\nfor i in range(N):\n\n    Current_List=list(map(int,input().split())) \n\n    if i == 0:\n\n        Max_List.append(Current_List)\n\n    else:\n\n        Current_Max_List = []\n\n        Search_List=Max_List[i-1]\n\n        for j in range(3):\n\n            Current_Search_List=Search_List[1:3]\n\n            Current_Max_List.append(max(Current_Search_List)+Current_List[j])\n\n            Search_List.append(Search_List[0])\n\n            del Search_List[0]\n\n        Max_List.append(Current_Max_List)\n\n        \n\n    \n\nprint((max(Max_List[-1])))","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Faster input reading using sys.stdin\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    activities = [list(map(int, data[3*i+1:3*i+4])) for i in range(N)]\n    \n    # Initialize previous max happiness values\n    prev_max = activities[0]\n    \n    # Iterate through days starting from the second day\n    for i in range(1, N):\n        current_max = [0, 0, 0]\n        \n        # Compute max happiness for each activity type\n        current_max[0] = activities[i][0] + max(prev_max[1], prev_max[2])\n        current_max[1] = activities[i][1] + max(prev_max[0], prev_max[2])\n        current_max[2] = activities[i][2] + max(prev_max[0], prev_max[1])\n        \n        # Update previous max values\n        prev_max = current_max\n    \n    # Output the maximum happiness value on the last day\n    print(max(prev_max))\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03835","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nK, S = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor z in range(K+1):\n\n    for y in range(K+1):\n\n        x = S - (z + y)\n\n        if x >= 0 and x <= K:\n\n            ans += 1\n\nprint(ans)","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nK, S = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor z in range(K+1):\n\n    for y in range(K+1):\n\n        x = S - (z + y)\n\n        if 0 <= x <= K:\n\n            ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\n# Read input values\nK, S = map(int, input().split())\n\nans = 0\n\n# Iterate over z\nfor z in range(K + 1):\n    # Calculate the range of valid y values\n    y_min = max(0, S - z - K)  # Ensure x = S - (z + y) >= 0\n    y_max = min(K, S - z)      # Ensure x = S - (z + y) <= K\n    \n    # Add the number of valid y values for this z\n    if y_min <= y_max:\n        ans += (y_max - y_min + 1)\n\nprint(ans)"}
{"problem_id":"p02996","slow_code_col":"n=int(eval(input()))\n\ntask=[] \n\nfor _ in range(n):\n\n    a,b=list(map(int,input().split()))\n\n    task.append((b, -a))\n\n\n\ntask.sort()\n\n\n\ntime=0\n\nflag=True\n\nfor i in task:\n\n    time-=i[1]\n\n    if time>i[0]:\n\n        flag=False\n\n        break\n\n\n\nif flag:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")\n\n\n","reference_code_col":"import sys\n\nfrom collections import defaultdict\n\nfrom operator import itemgetter\n\ninput = sys.stdin.readline\n\n\n\nN = int(eval(input()))\n\nd = defaultdict(int)\n\nfor _ in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    d[b] += a\n\ntask = list(d.items())\n\ntask.sort()\n\n\n\nnow = 0\n\nans = \"Yes\"\n\nfor limit, time in task:\n\n    now += time\n\n    if now > limit:\n\n        ans = \"No\"\n\n        break\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Faster input reading\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse the number of tasks\n    n = int(data[0])\n    idx = 1\n    \n    # Parse tasks and store as (b, -a)\n    task = []\n    for _ in range(n):\n        a = int(data[idx])\n        b = int(data[idx + 1])\n        task.append((b, -a))\n        idx += 2\n    \n    # Sort tasks by deadline (b) and execution time (-a)\n    task.sort()\n    \n    # Check feasibility\n    time = 0\n    for deadline, neg_a in task:\n        time -= neg_a  # Add execution time\n        if time > deadline:  # Check if the current task exceeds its deadline\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02767","slow_code_col":"import numpy as np\n\n\n\nn = int(eval(input()))\n\nx = list(map(int,input().split()))\n\nx2 = np.power(x,2)\n\n\n\np1 = sum(x)\/\/n\n\np2 = -(-sum(x)\/\/n)\n\n\n\nw1 = n*(p1**2) -2*sum(x)*p1 +sum(x2)\n\nw2 = n*(p2**2) -2*sum(x)*p2 +sum(x2)\n\n\n\nprint((min(w1,w2)))","reference_code_col":"n = int(eval(input()))\n\nX = sorted(map(int,input().split()))\n\nans = 10**6\n\n\n\nfor i in range(X[0],X[-1]+1):\n\n    HP = 0\n\n    \n\n    for j in X:\n\n        HP += (j - i) ** 2\n\n        \n\n    ans = min(ans,HP)\n\n    \n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read inputs\nn = int(input())\nx = list(map(int, input().split()))\n\n# Precompute reusable values\nsum_x = sum(x)\nsum_x2 = sum(i * i for i in x)  # Efficiently compute sum of squares\n\n# Compute p1 and p2\np1 = sum_x \/\/ n\np2 = -(-sum_x \/\/ n)  # Equivalent to math.ceil(sum_x \/ n)\n\n# Compute w1 and w2 using precomputed values\nw1 = n * (p1 ** 2) - 2 * sum_x * p1 + sum_x2\nw2 = n * (p2 ** 2) - 2 * sum_x * p2 + sum_x2\n\n# Output the minimum of w1 and w2\nprint(min(w1, w2))"}
{"problem_id":"p03038","slow_code_col":"from collections import Counter,defaultdict,deque\n\nfrom heapq import heapify,heappop,heappush\n\nfrom bisect import bisect_left,bisect_right\n\nimport sys,math,itertools,string,queue\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn,m = inpl()\n\na = inpl()\n\nb = [0] * m\n\nfor i in range(m):\n\n    x,y = inpl()\n\n    b[i] = [x,y]\n\na.sort()\n\nb.sort(key=lambda x:x[1], reverse = True)\n\nres = sum(a)\n\ni = 0\n\nj = 0\n\nwhile True:\n\n    # print(i,j)\n\n    if a[i] < b[j][1]:\n\n        res += b[j][1] - a[i]\n\n        i += 1\n\n    else:\n\n        break\n\n    b[j][0] -= 1\n\n    if b[j][0] == 0:\n\n        j += 1\n\n    if i >= n or j >= m:\n\n        break\n\nprint(res)\n","reference_code_col":"from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nfrom bisect import bisect_left,bisect_right \n\nimport sys,math,itertools,fractions,pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn,m = inpl()\n\na = inpl()\n\na.sort()\n\nbc = [inpl() for _ in range(m)]\n\nbc.sort(key = lambda x:x[1], reverse = True)\n\nlm = sum(x[1] for x in bc)\n\nnow = 0\n\nalt = 0\n\nwhile now < n and alt < m:\n\n    c,b = bc[alt]\n\n    if a[now] > b:\n\n        break\n\n    else:\n\n        a[now] = b\n\n    bc[alt][0] -= 1\n\n    if bc[alt][0] == 0:\n\n        alt += 1\n\n    now += 1\n\nprint((sum(a)))\n","model_generated_potentially_faster_code_col":"from collections import deque\n\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n# Input reading\nn, m = inpl()\na = inpl()\nb = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n\n# Sort arrays\na.sort()  # Sort `a` in ascending order\nb.sort(key=lambda x: -x[1])  # Sort `b` in descending order of `y`\n\n# Initialize result with the sum of `a`\nres = sum(a)\n\n# Use a deque for efficient popping from the left\na_deque = deque(a)\nb_deque = deque(b)\n\n# Process replacements\nwhile a_deque and b_deque:\n    x, y = b_deque[0]  # Get the current element in `b`\n    if a_deque[0] < y:  # Replace only if `a`'s smallest element is smaller than `y`\n        res += y - a_deque.popleft()  # Update result and remove smallest element\n        x -= 1  # Decrement the count of `x`\n        if x == 0:  # If no more replacements are allowed for this `b` element\n            b_deque.popleft()\n    else:\n        break  # Stop if no further improvements are possible\n\nprint(res)"}
{"problem_id":"p03325","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\na = list(map(int,input().split()))\n\nans = 0\n\na = np.array(a)\n\nwhile a.size > 0:\n\n    a = a[a%2 == 0]\n\n    ans += len(a)\n\n    a = a\/\/2\n\nprint(ans)","reference_code_col":"n = int(eval(input()))\n\na = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(n):\n\n    while a[i]%2 == 0:\n\n        a[i] \/\/=2\n\n        ans+=1\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(input())\na = list(map(int, input().split()))\n\nans = 0\n\nfor num in a:\n    while num % 2 == 0:  # Check if the number is even\n        ans += 1         # Increment the count\n        num \/\/= 2        # Divide the number by 2\n\nprint(ans)"}
{"problem_id":"p03013","slow_code_col":"import numpy as np\n\n\n\nn, m = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(m)] + [0]\n\nmod = 10 ** 9 + 7\n\n\n\ndp = np.zeros(n + 1, dtype=np.int64)\n\ndp[0] = 1\n\nb = a[0]\n\nj = 1\n\nfor i in range(1, n + 1):\n\n    if i == b:\n\n        b = a[j]\n\n        j += 1\n\n    else:\n\n        tmp = dp[i - 2] + dp[i - 1]\n\n        if tmp >= mod:\n\n            tmp -= mod\n\n        dp[i] = tmp\n\nprint((int(dp[-1])))","reference_code_col":"n, m = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(m)] + [0]\n\nmod = 10 ** 9 + 7\n\n\n\ndp = [0] * (n + 1)\n\ndp[0] = 1\n\nb = a[0]\n\nj = 1\n\nfor i in range(1, n + 1):\n\n    if i == b:\n\n        b = a[j]\n\n        j += 1\n\n    else:\n\n        tmp = dp[i - 2] + dp[i - 1]\n\n        if tmp >= mod:\n\n            tmp -= mod\n\n        dp[i] = tmp\n\nprint((int(dp[-1])))","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Faster input reading\n    n, m = map(int, sys.stdin.readline().split())\n    a = [int(sys.stdin.readline()) for _ in range(m)] + [n + 1]  # Add sentinel value\n    \n    mod = 10**9 + 7\n    \n    # Initialize variables for dynamic programming\n    prev2, prev1 = 0, 1  # dp[i-2], dp[i-1]\n    \n    j = 0  # Pointer for forbidden indices\n    b = a[j]  # Next forbidden index\n    \n    for i in range(1, n + 1):\n        if i == b:  # Skip forbidden index\n            b = a[j := j + 1]  # Update to next forbidden index\n            curr = 0\n        else:\n            curr = (prev2 + prev1) % mod\n        \n        # Update previous states\n        prev2, prev1 = prev1, curr\n    \n    print(prev1)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03013","slow_code_col":"N, M = list(map(int, input().split(\" \")))\n\nA = {int(eval(input())) for _ in range(M)}\n\n\n\nmemo = [0] * (N + 1)\n\nmemo[0] = 1\n\nmemo[1] = 0 if 1 in A else 1\n\n\n\nif N == 1:\n\n    print((memo[1]))\n\nelse:\n\n    for i in range(2, N + 1):\n\n        if i in A:\n\n            continue\n\n        memo[i] = (memo[i - 2] + memo[i - 1]) % 1000000007\n\n\n\n    print((memo[N]))\n","reference_code_col":"N, M = list(map(int, input().split(\" \")))\n\nA = {int(input()) for _ in range(M)}\n\n\n\nmemo = [0] * (N + 1)\n\nmemo[0] = 1\n\nmemo[1] = 0 if 1 in A else 1\n\n\n\nif N == 1:\n\n    print((memo[1]))\n\nelse:\n\n    for i in range(2, N + 1):\n\n        if i in A:\n\n            continue\n\n        memo[i] = (memo[i - 2] + memo[i - 1]) % 1000000007\n\n    print((memo[N]))\n","model_generated_potentially_faster_code_col":"# Optimized code\nN, M = map(int, input().split())\nA = set(map(int, (input() for _ in range(M))))\n\n# Initialize memoization array\nmemo = [0] * (N + 1)\nmemo[0] = 1  # Base case: 1 way to stay at step 0\n\n# Compute memoization values\nfor i in range(1, N + 1):\n    if i in A:  # Skip steps in set A\n        continue\n    # Use previous two values to compute current value\n    if i == 1:\n        memo[i] = memo[i - 1]\n    else:\n        memo[i] = (memo[i - 1] + memo[i - 2]) % 1000000007\n\n# Output the result\nprint(memo[N])"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nn = int(eval(input()))\n\nprint((math.factorial(n) % (10 ** 9 + 7)))","reference_code_col":"n = int(eval(input()))\n\np = 1\n\nfor i in range(1, n + 1):\n\n  p = p * i % (10 ** 9 + 7)\n\nprint(p)","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\nn = int(input())  # Removed eval for safety; use int() instead.\n\nif n >= MOD:\n    # If n >= MOD, the factorial will include MOD as a factor, making the result 0.\n    print(0)\nelse:\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % MOD\n    print(result)"}
{"problem_id":"p02883","slow_code_col":"N, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nF = list(map(int, input().split()))\n\n\n\nA.sort()\n\nF.sort(reverse=True)\n\n\n\n#\u7a4d\u3092x\u4ee5\u4e0b\u306b\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u4fee\u884c\u56de\u6570\n\ndef f(x):\n\n    r = 0\n\n    for i in range(N):\n\n        a, f = A[i], F[i]\n\n        m = a * f\n\n        if m > x:\n\n            r += (m - x + f - 1) \/\/ f\n\n    return r\n\n\n\nunder = -1\n\nr = 10**18\n\nwhile r - under > 1:\n\n    m = (under + r) \/\/ 2\n\n    if f(m) > K: under = m\n\n    else: r = m\n\nprint(r)","reference_code_col":"# \u3067\u3064oO(YOU PLAY WITH THE CARDS YOU'RE DEALT..)\n\nimport sys\n\ndef main(N, K, A, F):\n\n    A.sort()\n\n    F.sort(reverse=True)\n\n\n\n    def f(x):\n\n        sy = 0\n\n        for a, f in zip(A, F):\n\n            m = a * f\n\n            if m > x:\n\n                sy += (m - x + f - 1) \/\/ f\n\n        return sy\n\n\n\n    under = -1\n\n    hi = 10**12 + 1\n\n    while hi - under > 1:\n\n        m = (hi + under) \/\/ 2\n\n        if f(m) <= K: hi = m\n\n        else: under = m\n\n    print(hi)\n\n\n\nif __name__ == '__main__':\n\n    input = sys.stdin.readline\n\n    N, K = list(map(int, input().split()))\n\n    *A, = list(map(int, input().split()))\n\n    *F, = list(map(int, input().split()))\n\n    main(N, K, A, F)\n","model_generated_potentially_faster_code_col":"# Input parsing\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nF = list(map(int, input().split()))\n\n# Sorting\nA.sort()\nF.sort(reverse=True)\n\n# Precompute the maximum possible value of x\nmax_x = max(a * f for a, f in zip(A, F))\n\n# Define the function f(x)\ndef f(x):\n    required_training = 0\n    for a, f in zip(A, F):\n        if a * f > x:\n            required_training += (a * f - x + f - 1) \/\/ f\n            if required_training > K:  # Early termination\n                return required_training\n    return required_training\n\n# Binary search\nunder, r = -1, max_x\nwhile r - under > 1:\n    m = (under + r) \/\/ 2\n    if f(m) > K:\n        under = m\n    else:\n        r = m\n\nprint(r)"}
{"problem_id":"p03035","slow_code_col":"a,b=list(map(int,input().split()))\n\nprint((b if 13<=a else b\/\/2 if 6<=a else 0))","reference_code_col":"a,b=list(map(int,input().split()))\n\nprint((b if 12<a else b\/\/2 if 5<a else 0))","model_generated_potentially_faster_code_col":"a, b = list(map(int, input().split()))\nprint((b if 13 <= a else b \/\/ 2 if 6 <= a else 0))"}
{"problem_id":"p02688","slow_code_col":"N,K=list(map(int,input().split()))\n\n\n\ncon = 0\n\nans = list(int() for _ in range(100000))\n\npre = 0\n\n\n\n\n\nfor _ in range(K):\n\n\n\n    D = int(eval(input()))\n\n    arr = list(map(int,input().split()))\n\n\n\n    for j in range(D):\n\n\n\n        ans[pre+j]=arr[j]\n\n\n\n    pre += D\n\n\n\n        \n\nfin = (N+1) - len(set(ans))\n\n\n\nprint(fin)","reference_code_col":"N,K=list(map(int,input().split()))\n\n\n\ncon = 0\n\nans = list(int() for _ in range(10001))\n\npre = 0\n\n\n\n\n\nfor _ in range(K):\n\n\n\n    D = int(eval(input()))\n\n    arr = list(map(int,input().split()))\n\n\n\n    for j in range(D):\n\n\n\n        ans[pre+j]=arr[j]\n\n\n\n    pre += D\n\n\n\n        \n\nfin = (N+1) - len(set(ans))\n\n\n\nprint(fin)","model_generated_potentially_faster_code_col":"N, K = map(int, input().split())\n\nunique_elements = set()  # Use a set to track unique elements efficiently\n\nfor _ in range(K):\n    D = int(input())  # Read D as an integer directly\n    arr = list(map(int, input().split()))  # Read the array of size D\n\n    # Add all elements of arr to the set of unique elements\n    unique_elements.update(arr)\n\n# Calculate the final result\nfin = N - len(unique_elements)\n\nprint(fin)"}
{"problem_id":"p03162","slow_code_col":"def main():\n\n  n = int(eval(input()))\n\n  a = [0]\n\n  b = [0]\n\n  c = [0]\n\n\n\n  for i in range(n):\n\n      aa,bb,cc = list(map(int,input().split()))\n\n      a.append(max(b[i] + aa, c[i] + aa))\n\n      b.append(max(a[i] + bb, c[i] + bb))\n\n      c.append(max(a[i] + cc, b[i] + cc))\n\n\n\n  print((max(a[-1], b[-1], c[-1])))\n\n\n\nmain()","reference_code_col":"def main():\n\n    n = int(eval(input()))\n\n    a = 0\n\n    b = 0\n\n    c = 0\n\n\n\n    for i in range(n):\n\n        aa,bb,cc = list(map(int,input().split()))\n\n        a,b,c = max(b,c)+aa, max(a,c)+bb, max(a,b)+cc\n\n\n\n    print((max(a,b,c)))\n\n\n\nmain()\n","model_generated_potentially_faster_code_col":"def main():\n    # Read the number of iterations\n    n = int(input())\n\n    # Initialize variables for the previous state\n    prev_a, prev_b, prev_c = 0, 0, 0\n\n    for _ in range(n):\n        # Read the input values for aa, bb, cc\n        aa, bb, cc = map(int, input().split())\n\n        # Compute the new state based on the previous state\n        curr_a = max(prev_b + aa, prev_c + aa)\n        curr_b = max(prev_a + bb, prev_c + bb)\n        curr_c = max(prev_a + cc, prev_b + cc)\n\n        # Update the previous state for the next iteration\n        prev_a, prev_b, prev_c = curr_a, curr_b, curr_c\n\n    # Output the maximum value among the last states\n    print(max(prev_a, prev_b, prev_c))\n\n\nmain()"}
{"problem_id":"p03078","slow_code_col":"def main():\n\n    import sys\n\n    input = sys.stdin.readline\n\n    sys.setrecursionlimit(10**7)\n\n    from collections import Counter, deque\n\n    #from collections import defaultdict\n\n    from itertools import combinations, permutations, accumulate, groupby\n\n    #from itertools import product\n\n    from bisect import bisect_left,bisect_right\n\n    import heapq\n\n    from math import floor, ceil\n\n    #from operator import itemgetter\n\n\n\n    #inf = 10**17\n\n    #mod = 10**9 + 7\n\n\n\n    x,y,z,k = list(map(int, input().split()))\n\n    a = list(map(int, input().split()))\n\n    b = list(map(int, input().split()))\n\n    c = list(map(int, input().split()))\n\n    ab = []\n\n    for i in a:\n\n        for j in b:\n\n            ab.append(i+j)\n\n    ab.sort(reverse=1)\n\n    ab = ab[:k]\n\n    abc = []\n\n    for i in ab:\n\n        for j in c:\n\n            abc.append(i+j)\n\n    abc.sort(reverse=1)\n\n    for i in range(k):\n\n        print((abc[i]))\n\n\n\nif __name__ == '__main__':\n\n    main()","reference_code_col":"#xyz\u306e\u5168\u901a\u308a\u8abf\u3079\u308b\u3068\u9593\u306b\u5408\u308f\u306a\u3044\n\n#\u307e\u305a\u554f\u984c\u3092\u5206\u3051\u3088\u3046\n\n#\u5148\u306bxy\u3060\u3051\u8003\u3048\u3066\u307f\u308b\n\n#xy\u306e\u548c\u3092\u3068\u3063\u3066\u304b\u3089\u305d\u308c\u3068z\u306e\u548c\u3092\u3068\u308b\u3068\u304d\n\n#xy\u306e\u548c\u306b\u304a\u3044\u3066k\u756a\u76ee\u4ee5\u964d\u306e\u5024\u3092\u4f7f\u3046\u3053\u3068\u306f\u7121\u3044\n\n#\n\n\n\ndef main():\n\n    import sys\n\n    input = sys.stdin.readline\n\n    sys.setrecursionlimit(10**7)\n\n    from collections import Counter, deque\n\n    #from collections import defaultdict\n\n    from itertools import combinations, permutations, accumulate, groupby\n\n    #from itertools import product\n\n    from bisect import bisect_left,bisect_right\n\n    import heapq\n\n    from math import floor, ceil\n\n    #from operator import itemgetter\n\n\n\n    #inf = 10**17\n\n    #mod = 10**9 + 7\n\n\n\n    x,y,z,k = list(map(int, input().split()))\n\n    a = list(map(int, input().split()))\n\n    b = list(map(int, input().split()))\n\n    c = list(map(int, input().split()))\n\n    a.sort(reverse=1)\n\n    b.sort(reverse=1)\n\n    c.sort(reverse=1)\n\n    abc = []\n\n    for i in range(x):\n\n        for j in range(y):\n\n            if i*j>k:\n\n                continue\n\n            for t in range(z):\n\n                if i*j*t>k:\n\n                    continue\n\n                abc.append(a[i]+b[j]+c[t])\n\n    abc.sort(reverse=1)\n\n    for i in range(k):\n\n        print((abc[i]))\n\n\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"import sys\nimport heapq\n\ndef main():\n    input = sys.stdin.readline\n\n    # Read input\n    x, y, z, k = map(int, input().split())\n    a = sorted(map(int, input().split()), reverse=True)\n    b = sorted(map(int, input().split()), reverse=True)\n    c = sorted(map(int, input().split()), reverse=True)\n\n    # Step 1: Compute top k sums of a and b using a heap\n    heap_ab = []\n    for i in a:\n        for j in b:\n            s = i + j\n            if len(heap_ab) < k:\n                heapq.heappush(heap_ab, s)\n            else:\n                if s > heap_ab[0]:\n                    heapq.heappushpop(heap_ab, s)\n                else:\n                    break  # Early exit since lists are sorted in descending order\n\n    # Step 2: Compute top k sums of ab and c using a heap\n    heap_abc = []\n    for s in heap_ab:\n        for val in c:\n            total = s + val\n            if len(heap_abc) < k:\n                heapq.heappush(heap_abc, total)\n            else:\n                if total > heap_abc[0]:\n                    heapq.heappushpop(heap_abc, total)\n                else:\n                    break  # Early exit since lists are sorted in descending order\n\n    # Output the results in descending order\n    result = sorted(heap_abc, reverse=True)\n    print(*result, sep='\\n')\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02414","slow_code_col":"import sys\n\ne=[list(map(int,e.split()))for e in sys.stdin]\n\nn=e[0][0]+1\n\nfor c in e[1:n]:\n\n t=''\n\n for l in zip(*e[n:]):t+=f'{sum(s*t for s,t in zip(c,l))} '\n\n print((t[:-1]))\n","reference_code_col":"import sys\n\ne=[list(map(int,e.split()))for e in sys.stdin]\n\nn=e[0][0]+1\n\nt=''\n\nfor c in e[1:n]:\n\n for l in zip(*e[n:]):t+=f'{sum(s*t for s,t in zip(c,l))} '\n\n t=t[:-1]+'\\n'\n\nprint((t[:-1]))\n","model_generated_potentially_faster_code_col":"import sys\n\n# Read input and parse into integers\ndata = [list(map(int, line.split())) for line in sys.stdin]\n\n# Extract the number of vectors and the matrix\nn = data[0][0] + 1\nvectors = data[1:n]\nmatrix = data[n:]\n\n# Precompute the transposed matrix\ntransposed_matrix = list(zip(*matrix))\n\n# Process each vector\nfor vector in vectors:\n    # Compute dot products using list comprehension\n    dot_products = [sum(a * b for a, b in zip(vector, col)) for col in transposed_matrix]\n    \n    # Print the result as a space-separated string\n    print(' '.join(map(str, dot_products)))"}
{"problem_id":"p02886","slow_code_col":"n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nimport itertools as it\n\nimport numpy as np\n\nal=list(it.combinations(a,2))\n\ntotal=0\n\nfor i in al:\n\n    total+=np.prod(i)\n\nprint(total)","reference_code_col":"n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nans=0\n\nfor i in range(n-1):\n\n    for j in range(i+1,n):\n\n        ans+=a[i]*a[j]\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read input values\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate the sum of elements and the sum of squares of elements\nsum_a = sum(a)\nsum_a_squared = sum(x * x for x in a)\n\n# Use the formula to compute the sum of products of all pairs\ntotal = (sum_a * sum_a - sum_a_squared) \/\/ 2\n\n# Print the result\nprint(total)"}
{"problem_id":"p02552","slow_code_col":"x = int(eval(input()))\n\nif x == 0:\n\n  print((1))\n\nelse:\n\n  print((0))","reference_code_col":"x = int(eval(input()))\n\nprint((x^1))\n","model_generated_potentially_faster_code_col":"x = int(input())\n\nprint(1 if x == 0 else 0)"}
{"problem_id":"p03325","slow_code_col":"import numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.array(input().split(),dtype=np.int32)\n\n\n\ndef ord(n):\n\n  cnt = 0\n\n  while not n&1:\n\n    n >>= 1\n\n    cnt += 1\n\n  return cnt\n\n\n\nnp_ord = np.frompyfunc(ord,1,1)\n\nanswer = np_ord(A).sum()\n\nprint(answer)","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport numpy as np\n\n\n\nN = int(readline())\n\nA = np.array(read().split(),np.int32)\n\n\n\nanswer = 0\n\nfor _ in range(32):\n\n    A = A[A%2 == 0]\n\n    answer += len(A)\n\n    A >>= 1\n\n\n\nprint(answer)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN = int(input())\nA = np.array(input().split(), dtype=np.int32)\n\n# Efficiently calculate trailing zeros using NumPy\ndef trailing_zeros_vectorized(arr):\n    # Create a mask for powers of 2\n    mask = 1\n    count = np.zeros_like(arr, dtype=np.int32)\n    \n    # Iteratively check for trailing zeros\n    while arr.min() > 0:  # Stop when all elements are zero\n        is_even = (arr & mask) == 0  # Check if the least significant bit is 0\n        count += is_even  # Increment count for even numbers\n        arr = np.where(is_even, arr >> 1, arr)  # Right-shift only even numbers\n    \n    return count\n\n# Calculate the sum of trailing zeros\nanswer = trailing_zeros_vectorized(A).sum()\n\n# Output the result\nprint(answer)"}
{"problem_id":"p02994","slow_code_col":"import numpy as np\n\n\n\nn,l = [int(x) for x in input().split()] \n\nx = np.arange(l,l+n)\n\ny = np.abs(x)\n\nx = np.delete(x, np.argmin(y))\n\nprint((np.sum(x)))","reference_code_col":"N, L = list(map(int, input().split()))\n\napples = [i for i in range(L, L+N)]\n\napples_abs = [abs(i) for i in apples]\n\nmin_idx = apples_abs.index(min(apples_abs))\n\n\n\nprint((sum(apples) - apples[min_idx]))","model_generated_potentially_faster_code_col":"n, l = [int(x) for x in input().split()]"}
{"problem_id":"p02792","slow_code_col":"N=int(eval(input()))\n\nC=[[0]*9  for i in range(9)]\n\ncount=0\n\n\n\nfor n in range(1,N+1):\n\n   if str(n)[-1]!=\"0\":\n\n      left=int(str(n)[0])-1\n\n      right=int(str(n)[-1])-1\n\n      C[left][right]+=1\n\n      \n\nfor i in range(1,10):\n\n   for j in range(1,10):\n\n      count+=C[i-1][j-1]*C[j-1][i-1]\n\n\n\nprint(count)","reference_code_col":"from sys import stdin\n\ndef main():\n\n    #\u5165\u529b\n\n    readline=stdin.readline\n\n    N=int(readline())\n\n    d=dict()\n\n    for i in range(1,N+1):\n\n        i=str(i)\n\n        head=i[0]\n\n        tail=i[-1]\n\n        if tail==\"0\":\n\n            continue\n\n        if (head,tail) not in d:\n\n            d[(head,tail)]=1\n\n        else:\n\n            d[(head,tail)]+=1\n\n\n\n    ans=0\n\n    s=set()\n\n    for k in list(d.keys()):\n\n        m,l=k[0],k[1]\n\n        if (m,l) in s:\n\n            continue\n\n        if (l,m) in d:\n\n            ans+=d[(m,l)]*d[(l,m)]\n\n            if (m,l)!=(l,m):\n\n                ans+=d[(m,l)]*d[(l,m)]\n\n        s.add((m,l))\n\n        s.add((l,m))\n\n\n\n    print(ans)\n\n\n\nif __name__==\"__main__\":\n\n    main()","model_generated_potentially_faster_code_col":"N = int(input())  # Avoid eval for safety and efficiency\n\n# Initialize the 9x9 matrix\nC = [[0] * 9 for _ in range(9)]\n\n# First loop: Populate the matrix C\nfor n in range(1, N + 1):\n    last_digit = n % 10  # Get the last digit\n    if last_digit != 0:  # Skip numbers ending with 0\n        first_digit = n\n        while first_digit >= 10:  # Extract the first digit\n            first_digit \/\/= 10\n        C[first_digit - 1][last_digit - 1] += 1\n\n# Second loop: Compute the count\ncount = 0\nfor i in range(9):\n    for j in range(i, 9):  # Iterate only over the upper triangle (including diagonal)\n        if i == j:\n            count += C[i][j] * C[i][j]  # Diagonal elements are squared\n        else:\n            count += 2 * C[i][j] * C[j][i]  # Symmetric pairs are doubled\n\nprint(count)"}
{"problem_id":"p03254","slow_code_col":"import numpy as np\n\nN, x = list(map(int, input().split()))\n\na = np.array(list(map(int, input().split())))\n\n\n\ncs = np.sort(a).cumsum()\n\n\n\nif cs[-1]<x:\n\n    print((N-1))\n\nelif cs[-1]==x:\n\n    print(N)\n\nelse:\n\n    print((np.where(cs<=x)[0].shape[0]))","reference_code_col":"from bisect import bisect_right\n\nfrom itertools import accumulate\n\n\n\nn, x = list(map(int, input().split()))\n\narr = list(map(int, input().split()))\n\n\n\narr.sort()\n\narr = list(accumulate(arr))\n\n\n\n\n\nhappy = bisect_right(arr, x)\n\n\n\nif happy == n:\n\n    if arr[-1] != x:\n\n        happy -= 1\n\n\n\nprint(happy)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input reading: Use faster methods to parse input\nN, x = map(int, input().split())\na = np.fromstring(input(), dtype=int, sep=' ')\n\n# Sort the array efficiently\ncs = np.sort(a).cumsum()\n\n# Conditional checks: Avoid redundant computations\nif cs[-1] < x:\n    print(N - 1)\nelif cs[-1] == x:\n    print(N)\nelse:\n    # Use binary search for faster lookup of the threshold\n    idx = np.searchsorted(cs, x, side='right')\n    print(idx)"}
{"problem_id":"p02959","slow_code_col":"from sys import stdin,stdout\n\n\n\nif __name__==\"__main__\":\n\n    n=int(stdin.readline())\n\n\n\n    a=[int(x) for x in stdin.readline().split()]\n\n    b=[int(x) for x in stdin.readline().split()]\n\n\n\n    cnt=0\n\n\n\n    for i in range(n):\n\n        if(a[i]>=b[i]):\n\n            cnt+=b[i]\n\n        else:\n\n            cnt+=a[i]\n\n            d=b[i]-a[i]\n\n            cnt+=min(a[i+1],d)\n\n            if(d>a[i+1]):\n\n                a[i+1]=0\n\n            else: a[i+1]-=d\n\n            \n\n    stdout.write(str(cnt)+\"\\n\")\n","reference_code_col":"n = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\na1 = sum(A)\n\nfor i in range(n):\n\n  b = B[i]\n\n  if A[i] >= b:A[i] -= b\n\n  else:\n\n    if A[i+1]+A[i] >= b:\n\n      A[i+1] = A[i+1]+A[i]-b\n\n      A[i] = 0\n\n    else:A[i], A[i+1] = 0, 0\n\na2 = sum(A)\n\nprint((a1-a2))","model_generated_potentially_faster_code_col":"from sys import stdin, stdout\n\nif __name__ == \"__main__\":\n    n = int(stdin.readline())\n    a = [int(x) for x in stdin.readline().split()]\n    b = [int(x) for x in stdin.readline().split()]\n\n    cnt = 0\n\n    for i in range(n):\n        if a[i] >= b[i]:\n            cnt += b[i]\n        else:\n            cnt += a[i]\n            d = b[i] - a[i]\n            if i + 1 < n:  # Ensure we don't go out of bounds\n                take_from_next = min(a[i + 1], d)\n                cnt += take_from_next\n                a[i + 1] -= take_from_next\n\n    stdout.write(str(cnt) + \"\\n\")"}
{"problem_id":"p03608","slow_code_col":"def main():\n\n    from itertools import permutations\n\n\n\n    n, m, r, *x = list(map(int, open(0).read().split()))\n\n    to = x[:r]\n\n\n\n    dis = [[float(\"Inf\")] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n\n        dis[i][i] = 0\n\n\n\n    for a, b, c in zip(*[iter(x[r:])] * 3):\n\n        dis[a][b] = c\n\n        dis[b][a] = c\n\n\n\n    for k in range(1, n + 1):\n\n        for i in range(1, n + 1):\n\n            for j in range(1, n + 1):\n\n                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n\n\n    ans = float(\"Inf\")\n\n    for p in permutations(to):\n\n        tmp = 0\n\n        nw = p[0]\n\n        for nx in p[1:]:\n\n            tmp += dis[nw][nx]\n\n            nw = nx\n\n\n\n        ans = min(ans, tmp)\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def main():\n\n    from itertools import permutations\n\n\n\n    n, m, r, *x = list(map(int, open(0).read().split()))\n\n    to = x[:r]\n\n\n\n    dis = [[10 ** 8] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n\n        dis[i][i] = 0\n\n\n\n    for a, b, c in zip(*[iter(x[r:])] * 3):\n\n        dis[a][b] = c\n\n        dis[b][a] = c\n\n\n\n    for k in range(1, n + 1):\n\n        for i in range(1, n + 1):\n\n            for j in range(1, n + 1):\n\n                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n\n\n    ans = 10 ** 8\n\n    for p in permutations(to):\n\n        tmp = 0\n\n        nw = p[0]\n\n        for nx in p[1:]:\n\n            tmp += dis[nw][nx]\n\n            nw = nx\n\n\n\n        ans = min(ans, tmp)\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"from itertools import permutations\nimport sys\n\ndef main():\n    # Faster input reading\n    input_data = sys.stdin.read().split()\n    n, m, r = map(int, input_data[:3])\n    to = list(map(int, input_data[3:3+r]))\n    edges = list(map(int, input_data[3+r:]))\n\n    # Initialize distance matrix\n    dis = [[float(\"inf\")] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dis[i][i] = 0\n\n    # Populate distance matrix with edge weights\n    for i in range(0, len(edges), 3):\n        a, b, c = edges[i:i+3]\n        dis[a][b] = min(dis[a][b], c)\n        dis[b][a] = min(dis[b][a], c)\n\n    # Floyd-Warshall algorithm with optimization\n    for k in range(1, n + 1):\n        for i in range(1, n + 1):\n            if dis[i][k] == float(\"inf\"):  # Skip if no path exists\n                continue\n            for j in range(1, n + 1):\n                if dis[k][j] != float(\"inf\"):\n                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n    # Precompute distances for the 'to' nodes\n    to_distances = {u: {v: dis[u][v] for v in to} for u in to}\n\n    # Find the minimum path cost over all permutations\n    ans = float(\"inf\")\n    for p in permutations(to):\n        tmp = sum(to_distances[p[i]][p[i+1]] for i in range(len(p)-1))\n        ans = min(ans, tmp)\n\n    print(ans)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03416","slow_code_col":"counter = 0\n\nc = list(map(int, input().split(' ')))\n\nfor i in range(c[0], c[1] + 1):\n\n  if str(i)[0] != str(i)[4]:\n\n    continue\n\n  if str(i)[1] != str(i)[3]:\n\n    continue\n\n  counter += 1\n\n\n\nprint(counter)","reference_code_col":"a = list(map(int, input().split()))\n\ncounter = 0\n\nfor i in range(a[0], a[1] + 1):\n\n  stri = str(i)\n\n  if (stri[0] == stri[4] and stri[1] == stri[3]):\n\n    counter += 1\n\n    \n\nprint(counter)","model_generated_potentially_faster_code_col":"# Input parsing\nc = list(map(int, input().split()))\n\n# Initialize counter\ncounter = 0\n\n# Helper function to generate a 5-digit palindrome from its first three digits\ndef generate_palindrome(a, b, c):\n    return int(f\"{a}{b}{c}{b}{a}\")\n\n# Iterate over possible first three digits (a, b, c) to generate palindromes\nfor a in range(1, 10):  # First digit (a) cannot be zero\n    for b in range(10):  # Second digit (b)\n        for c in range(10):  # Third digit (c)\n            palindrome = generate_palindrome(a, b, c)\n            \n            # Check if the palindrome is within the range [c[0], c[1]]\n            if c[0] <= palindrome <= c[1]:\n                counter += 1\n\n# Output the result\nprint(counter)"}
{"problem_id":"p03038","slow_code_col":"I=lambda:list(map(int,input().split()))\n\nn,m=I()\n\na=I()\n\na.sort(reverse=True)\n\nqq=[I() for i in range(m)]\n\nqq.sort(key=lambda x:x[1],reverse=True)\n\nans=0\n\nfor x,y in qq:\n\n    for j in range(x):\n\n        if not a:\n\n            break\n\n        aa=a.pop()\n\n        ans+=max(aa,y)\n\nans+=sum(a)\n\nprint(ans)\n\n        ","reference_code_col":"I=lambda : list(map(int,input().split()))\n\nn,m = I()\n\nl=I();s=sum(l);l.sort();d=[]\n\nfor _ in range(m):\n\n    b,c=I()\n\n    d.append([c,b])\n\np=s=0    \n\nfor i in sorted(d,reverse=True):\n\n    while i[1]:\n\n        if p>=n or l[p]>=i[0]:\n\n            break\n\n        i[1]-=1\n\n        s+=i[0]\n\n        p+=1\n\n    if p>=n:\n\n        break\n\ns+=sum(l[p:])\n\nprint(s)","model_generated_potentially_faster_code_col":"I = lambda: list(map(int, input().split()))\n\n# Read inputs\nn, m = I()\na = I()\na.sort(reverse=True)  # Sort descending\n\nqq = [I() for _ in range(m)]\nqq.sort(key=lambda x: x[1], reverse=True)  # Sort queries by y in descending order\n\nans = 0\nptr = 0  # Pointer to track position in `a`\n\nfor x, y in qq:\n    count = 0\n    while count < x and ptr < len(a):\n        ans += max(a[ptr], y)\n        ptr += 1\n        count += 1\n\n# Add remaining elements in `a` to `ans`\nans += sum(a[ptr:])\nprint(ans)"}
{"problem_id":"p02780","slow_code_col":"import numpy as np\n\nn,k=list(map(int,input().split()))\n\nexp=tuple([(int(x)+1)\/2 for x in input().split()])\n\nl=np.cumsum(exp)\n\n\n\nans=l[k-1]\n\nfor i in range(0,n-k):\n\n  x=l[i+k]-l[i]\n\n  ans=max(ans,x)\n\nprint(ans)","reference_code_col":"def main():\n\n    from itertools import accumulate\n\n    n, k = list(map(int, input().split()))\n\n    *exp, = [(int(x) + 1) \/ 2 for x in input().split()]\n\n    l = accumulate(exp)\n\n    l = list(l)\n\n    ans = l[k - 1]\n\n    for i in range(0, n - k):\n\n        x = l[i + k] - l[i]\n\n        ans = max(ans, x)\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn, k = map(int, input().split())\nexp = np.array([((int(x) + 1) \/ 2) for x in input().split()])\n\n# Compute cumulative sum\ncumsum = np.cumsum(exp)\n\n# Compute the sliding window sums using slicing\nwindow_sums = cumsum[k-1:] - np.concatenate(([0], cumsum[:n-k]))\n\n# Find the maximum sum\nans = np.max(window_sums)\n\nprint(ans)"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\nimport sys\n\n\n\nn = int(eval(input()))\n\na = np.array(list(map(int, input().split())))\n\n\n\ncnt = 1\n\n\n\nif np.any(a%2==1):\n\n    print((0))\n\n    sys.exit()\n\n\n\nwhile True:\n\n    a2 = a % 2**cnt\n\n    if np.all(a2==0):\n\n        cnt += 1\n\n        continue\n\n    else:\n\n        print((cnt-1))\n\n        break","reference_code_col":"N = int(eval(input()))\n\na = list(map(int,input().split()))\n\nans = 0\n\nwhile all(A%2 == 0 for A in a):\n\n\ta = [i\/2 for i in a ]\n\n\tans += 1\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input\nn = int(input())\na = np.array(list(map(int, input().split())))\n\n# Early exit if any element is odd\nif np.any(a % 2 == 1):\n    print(0)\nelse:\n    cnt = 0\n    while True:\n        # Divide all elements by 2\n        a \/\/= 2\n        \n        # Check if any element becomes odd\n        if np.any(a % 2 == 1):\n            print(cnt + 1)\n            break\n        \n        cnt += 1"}
{"problem_id":"p03723","slow_code_col":"a,b,c=list(map(int,input().split()))\n\ne=(a-b)|(b-c)\n\nprint((bool(e|(a|b|c)%2)*(e^~-e).bit_length()-1))","reference_code_col":"a,b,c=list(map(int,input().split()))\n\ne=(a-b)|(b-c)\n\nprint((bool(e|b%2)*(e^~-e).bit_length()-1))","model_generated_potentially_faster_code_col":"a, b, c = map(int, input().split())"}
{"problem_id":"p02970","slow_code_col":"import numpy as np\n\nN, D = list(map(int, input().split()))\n\nprint((int(np.ceil(N\/(2*D+1)))))","reference_code_col":"N, D = list(map(int, input().split()))\n\nimport math\n\nprint((math.ceil(N\/(2*D+1))))","model_generated_potentially_faster_code_col":"# Read input and parse integers\nN, D = map(int, input().split())\n\n# Compute the result using integer arithmetic\nresult = (N + 2 * D) \/\/ (2 * D + 1)\n\n# Print the result\nprint(result)"}
{"problem_id":"p03037","slow_code_col":"N, M =list(map(int, input().split()))\n\nL = [0 for i in range(N+1)]\n\nR = [0 for i in range(N+1)]\n\nfor i in range(M):\n\n    l,r = list(map(int, input().split()))\n\n    L[l] += 1\n\n    R[r] += 1\n\ncnt = 0\n\ntmp = 0\n\nfor i in range(N+1):\n\n    tmp += L[i]\n\n    if tmp == M:\n\n        cnt += 1\n\n    tmp -= R[i]\n\nprint(cnt)\n","reference_code_col":"n,m = list(map(int, input().split()))\n\nll = 1\n\nrr = n\n\nfor i in range(m):\n\n    l,r = list(map(int,input().split()))\n\n    if l > ll:\n\n        ll = l\n\n    if r < rr:\n\n        rr = r\n\nprint((max(rr - ll + 1, 0)))\n","model_generated_potentially_faster_code_col":"import sys\n\n# Faster input reading\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse N and M\nN, M = int(data[0]), int(data[1])\n\n# Initialize a single array to track changes\ndelta = [0] * (N + 2)  # Use N+2 to handle 1-based indexing safely\n\n# Process all M queries\nindex = 2\nfor _ in range(M):\n    l, r = int(data[index]), int(data[index + 1])\n    delta[l] += 1\n    delta[r + 1] -= 1  # Mark the end of the interval\n    index += 2\n\n# Count how many times tmp == M\ncnt = 0\ntmp = 0\nfor i in range(1, N + 1):\n    tmp += delta[i]\n    if tmp == M:\n        cnt += 1\n\nprint(cnt)"}
{"problem_id":"p03457","slow_code_col":"import numpy as np\n\n\n\nn = int(eval(input()))\n\ninput_X = [[int(i) for i in input().split()] for i in range(n)]\n\nX = np.array(input_X)\n\n\n\npre_t = 0\n\npre_x = 0\n\npre_y = 0\n\nfor i in range(n):\n\n    x_move = abs(X[i][1] - pre_x)\n\n    y_move = abs(X[i][2] - pre_y)\n\n    xy_sum = x_move + y_move\n\n    spend_time = X[i][0]-pre_t\n\n    if xy_sum%2 == spend_time%2 and spend_time >= xy_sum:\n\n        pre_t = X[i][0]\n\n        pre_x = X[i][1]\n\n        pre_y = X[i][2]\n\n        if i+1 == n:\n\n            print('Yes')\n\n        else:\n\n            continue\n\n    else:\n\n        print('No')\n\n        break","reference_code_col":"# C\n\nimport copy\n\nn = int(eval(input()))\n\npreX = [0,0,0]\n\nans = True\n\nfor i in range(n):\n\n    curX = list(map(int, input().split()))\n\n    dt = curX[0] - preX[0]\n\n    dx = abs(curX[1] - preX[1])\n\n    dy = abs(curX[2] - preX[2])\n\n    if dt < dx + dy  or (dt % 2) != ((dx + dy) % 2):\n\n        ans = False\n\n    preX = copy.copy(curX)\n\nif ans:\n\n    print('Yes')\n\nelse:\n\n    print('No')","model_generated_potentially_faster_code_col":"n = int(input())\n\n# Parse input directly into a list of tuples to avoid intermediate structures\ninput_X = [tuple(map(int, input().split())) for _ in range(n)]\n\npre_t, pre_x, pre_y = 0, 0, 0\n\nfor t, x, y in input_X:\n    # Calculate movement and time difference\n    x_move = abs(x - pre_x)\n    y_move = abs(y - pre_y)\n    xy_sum = x_move + y_move\n    spend_time = t - pre_t\n\n    # Check conditions\n    if xy_sum % 2 == spend_time % 2 and spend_time >= xy_sum:\n        # Update previous state\n        pre_t, pre_x, pre_y = t, x, y\n    else:\n        print('No')\n        break\nelse:\n    # If the loop completes without breaking, print 'Yes'\n    print('Yes')"}
{"problem_id":"p03558","slow_code_col":"from collections import deque\n\nK = int(eval(input()))\n\nG = [[] for i in range(K)]\n\n\n\nfor n in range(K):\n\n    G[n].append([(n + 1) % K, 1])\n\n    G[n].append([(10 * n) % K, 0])\n\n\n\nque = deque([[1, 1]])\n\ndist = [float('inf')] * K\n\n\n\nwhile que:\n\n    node, cost = que.pop()\n\n    dist[node] = min(cost, dist[node])\n\n    for e, e_cost in G[node]:\n\n        if dist[e] != float('inf'):\n\n            continue\n\n\n\n        if e_cost == 0:\n\n            que.append([e, cost + 0])\n\n\n\n        if e_cost == 1:\n\n            que.appendleft([e, cost + 1])\n\n\n\nprint((dist[0]))\n","reference_code_col":"from collections import deque\n\nK = int(eval(input()))\n\nG = [[] for i in range(K)]\n\nfor i in range(K):\n\n    G[i].append(((10 * i) % K, 0))\n\n    G[i].append(((i + 1) % K, 1))\n\n\n\ndist = [float('inf')] * K\n\ndist[1] = 1\n\nque = deque()\n\nque.append(1)\n\n\n\nwhile que:\n\n    n = que.pop()\n\n    for v, c in G[n]:\n\n        if dist[v] > dist[n] + c:\n\n            dist[v] = dist[n] + c\n\n            if c == 0:\n\n                que.append(v)\n\n            else:\n\n                que.appendleft(v)\n\n\n\nprint((dist[0]))\n","model_generated_potentially_faster_code_col":"from collections import deque\n\nK = int(input())  # Avoid using eval; it's unnecessary and unsafe\n\n# Precompute the graph structure\nG = [[] for _ in range(K)]\nfor n in range(K):\n    G[n].append(((n + 1) % K, 1))  # Edge with cost 1\n    G[n].append(((10 * n) % K, 0))  # Edge with cost 0\n\n# Initialize the queue and distance array\nque = deque([(1, 1)])  # Start from node 1 with cost 1\ndist = [float('inf')] * K\ndist[1] = 1  # Distance to node 1 is initialized to 1\n\n# Perform BFS with priority-like behavior\nwhile que:\n    node, cost = que.popleft()\n\n    # Early termination: If we reach node 0, print the result and exit\n    if node == 0:\n        print(cost)\n        break\n\n    # Explore neighbors\n    for neighbor, edge_cost in G[node]:\n        new_cost = cost + edge_cost\n        if new_cost < dist[neighbor]:  # Only process if we find a shorter path\n            dist[neighbor] = new_cost\n            if edge_cost == 0:\n                que.appendleft((neighbor, new_cost))  # Higher priority\n            else:\n                que.append((neighbor, new_cost))  # Lower priority"}
{"problem_id":"p03720","slow_code_col":"import numpy as np\n\n\n\nN, M = [int(x) for x in input().split()]\n\nL = [[int (y) for y in input().split()] for _ in range(M)]\n\nL = sum(L, [])\n\n\n\nfor i in np.arange(1, N+1):\n\n    print((L.count(i)))","reference_code_col":"N, M = [int(x) for x in input().split()]\n\nL = [[int (y) for y in input().split()] for _ in range(M)]\n\nL = sum(L, [])\n\n\n\nfor i in range(1, N+1):\n\n    print((L.count(i)))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Step 1: Read N and M\nN, M = map(int, input().split())\n\n# Step 2: Read all rows of integers and flatten the list efficiently\nL = []\nfor _ in range(M):\n    L.extend(map(int, input().split()))\n\n# Step 3: Count occurrences using numpy's histogram for efficiency\ncounts, _ = np.histogram(L, bins=np.arange(1, N + 2))\n\n# Step 4: Print the counts for each number from 1 to N\nprint(\"\\n\".join(map(str, counts)))"}
{"problem_id":"p02881","slow_code_col":"import numpy as np\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n\n\n    INF = 10**6 + 100\n\n\n\n    x = np.arange(1,INF,dtype=np.int64)\n\n    div = x[N % x == 0]\n\n    #print(div)\n\n    #print(N \/\/ div)\n\n    \n\n    ans = (div + N\/\/div).min() - 2\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nfrom math import sqrt\n\n\n\ndef divisor_enumeration(n):\n\n    div = []\n\n    for i in range(1, int(sqrt(n))+1):\n\n        if n % i == 0:\n\n            if n \/\/ i != i:\n\n                div.append((i, n \/\/ i))\n\n            else:\n\n                div.append((i, i))\n\n        \n\n    return div\n\n\n\n\n\ndef main():\n\n    N = int(readline())\n\n\n\n    d = divisor_enumeration(N)\n\n    \n\n    ans = 10**15\n\n    for x, y in d:\n\n        ans = min(ans, x + y - 2)\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import numpy as np\nimport math\n\n\ndef main():\n    # Read input value for N\n    N = int(input())\n\n    # Initialize an empty list to store divisors\n    divisors = []\n\n    # Efficiently find divisors by iterating up to \u221aN\n    for i in range(1, int(math.sqrt(N)) + 1):\n        if N % i == 0:\n            divisors.append(i)\n            if i != N \/\/ i:  # Avoid adding the square root twice\n                divisors.append(N \/\/ i)\n\n    # Convert the list of divisors to a NumPy array\n    divisors = np.array(divisors, dtype=np.int64)\n\n    # Compute the minimum value of (divisor + N \/\/ divisor)\n    ans = (divisors + N \/\/ divisors).min() - 2\n\n    # Print the result\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02555","slow_code_col":"from math import factorial as fac\n\n\n\nS = int(eval(input()))\n\nans = 0\n\n\n\nif S == 1 or S == 2:\n\n  print((0))\n\nelif S == 3:\n\n  print((1))\n\nelse:\n\n  for k in range(1,S):\n\n    if S-2*k-1 >= 0 and S-3*k >= 0:\n\n      ans += fac(S-2*k-1)\/\/(fac(k-1)*fac(S-3*k))\n\n  print((ans%1000000007))","reference_code_col":"S = int(eval(input()))\n\n\n\nif S == 1 or S ==2:\n\n  print((0))\n\nelif S == 3 or S == 4 or S == 5:\n\n  print((1))\n\nelse:\n\n  #\u521d\u671f\u5316\n\n  dp = [0]*S\n\n  dp[2] = 1\n\n  dp[3] = 1\n\n  dp[4] = 1\n\n  dp_S = 0\n\n  #dp\n\n  for i in range(5,S):\n\n    dp_S += dp[i-3] \n\n    dp[i] = 1+dp_S\n\n\n\n  print((dp[S-1]%1000000007))","model_generated_potentially_faster_code_col":"from math import factorial as fac\n\nMOD = 1000000007\n\n# Function to compute modular inverse using Fermat's Little Theorem\ndef mod_inverse(x, mod):\n    return pow(x, mod - 2, mod)\n\n# Precompute factorials and modular inverses up to max_value\ndef precompute_factorials(max_value, mod):\n    fact = [1] * (max_value + 1)\n    inv_fact = [1] * (max_value + 1)\n    \n    for i in range(2, max_value + 1):\n        fact[i] = fact[i - 1] * i % mod\n    \n    inv_fact[max_value] = mod_inverse(fact[max_value], mod)\n    for i in range(max_value - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n    \n    return fact, inv_fact\n\n# Read input\nS = int(input())\n\n# Handle special cases\nif S == 1 or S == 2:\n    print(0)\nelif S == 3:\n    print(1)\nelse:\n    # Precompute factorials and inverses\n    fact, inv_fact = precompute_factorials(S, MOD)\n    \n    ans = 0\n    # Determine the range for k\n    max_k = min((S - 1) \/\/ 2, S \/\/ 3)\n    \n    for k in range(1, max_k + 1):\n        if S - 2 * k - 1 >= 0 and S - 3 * k >= 0:\n            numerator = fact[S - 2 * k - 1]\n            denominator = (fact[k - 1] * fact[S - 3 * k]) % MOD\n            ans += numerator * inv_fact[k - 1] % MOD * inv_fact[S - 3 * k] % MOD\n            ans %= MOD\n    \n    print(ans)"}
{"problem_id":"p02555","slow_code_col":"import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, gcd\n\nfrom itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce, lru_cache\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\nS = INT()\n\n\n\n@lru_cache(maxsize=None)\n\ndef rec(x):\n\n    if x == 0: return 1\n\n\n\n    ret = 0\n\n    for i in range(x-2):\n\n        ret += rec(i)\n\n        ret %= mod\n\n    return ret\n\n\n\nprint((rec(S)))\n","reference_code_col":"import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, gcd\n\nfrom itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce, lru_cache\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\nS = INT()\n\n\n\n@lru_cache(maxsize=None)\n\ndef rec(x):\n\n    if x == 0: return 1\n\n\n\n    ret = 0\n\n    if x >= 3:\n\n        return (rec(x-1)+rec(x-3))%mod\n\n    else:\n\n        return 0\n\n\n\nprint((rec(S)))\n","model_generated_potentially_faster_code_col":"import sys\n\n# Constants\nmod = 10**9 + 7\n\n# Input\nS = int(sys.stdin.readline().strip())\n\n# Dynamic Programming Array\ndp = [0] * (S + 1)\n\n# Base Case\ndp[0] = 1\n\n# Prefix Sum for Optimization\nprefix_sum = 0\n\n# Fill DP Table Iteratively\nfor x in range(1, S + 1):\n    if x >= 3:  # Only start adding when x >= 3\n        prefix_sum += dp[x - 3]\n        prefix_sum %= mod\n    dp[x] = prefix_sum\n\n# Output Result\nprint(dp[S])"}
{"problem_id":"p03250","slow_code_col":"# \u30a4\u30f3\u30dd\u30fc\u30c8\n\nimport numpy as np\n\n# A,B,C\u306e\u5024\u306e\u7372\u5f97\n\nnum = list(map(int, input().split()))\n\n# num\u30ea\u30b9\u30c8\u306e\u6700\u5927\u5024\u309210\u500d\n\nnum[num.index(max(num))] = max(num) * 10\n\n# np\u3067\u8981\u7d20\u306e\u548c\u3092\u8a08\u7b97\u3057\u3001\u51fa\u529b\n\nprint((np.sum(num)))","reference_code_col":"# A,B,C\u306e\u5024\u306e\u7372\u5f97\n\nnum = list(map(int, input().split()))\n\n# num\u30ea\u30b9\u30c8\u306e\u6700\u5927\u5024\u309210\u500d\n\nnum[num.index(max(num))] *= 10\n\n# np\u3067\u8981\u7d20\u306e\u548c\u3092\u8a08\u7b97\u3057\u3001\u51fa\u529b\n\nprint((sum(num)))\n","model_generated_potentially_faster_code_col":"# \u30a4\u30f3\u30dd\u30fc\u30c8 (NumPy\u306f\u4e0d\u8981\u306a\u306e\u3067\u524a\u9664)\n\n# A, B, C\u306e\u5024\u3092\u53d6\u5f97\nnum = list(map(int, input().split()))\n\n# \u6700\u5927\u5024\u3068\u305d\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u4e00\u5ea6\u306b\u53d6\u5f97\nmax_value = max(num)\nmax_index = num.index(max_value)\n\n# \u6700\u5927\u5024\u309210\u500d\u3057\u3066\u66f4\u65b0\nnum[max_index] = max_value * 10\n\n# \u8981\u7d20\u306e\u548c\u3092\u8a08\u7b97\u3057\u3001\u51fa\u529b\nprint(sum(num))"}
{"problem_id":"p03037","slow_code_col":"import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nlr = list(zip(*[iter(lr)] * 2))\n\n\n\ndef main():\n\n    cnt = [0] * (n + 1)\n\n    for l, r in lr:\n\n        cnt[l-1] += 1\n\n        cnt[r] -= 1\n\n    \n\n    for i in range(n):\n\n        cnt[i+1] += cnt[i]\n\n    \n\n    res = 0\n\n    for i in range(n):\n\n        res += (cnt[i] == m) & 1\n\n    \n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","reference_code_col":"import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nl, r = lr[::2], lr[1::2]\n\n\n\ndef main():\n\n    ans = max(min(r) - max(l) + 1, 0)\n\n    return ans\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","model_generated_potentially_faster_code_col":"import sys\n\n# Read input efficiently\ninput_data = sys.stdin.read().split()\nn, m = int(input_data[0]), int(input_data[1])\nlr = [(int(input_data[i]), int(input_data[i + 1])) for i in range(2, len(input_data), 2)]\n\ndef main():\n    # Initialize difference array\n    cnt = [0] * (n + 1)\n\n    # Update difference array for each interval\n    for l, r in lr:\n        cnt[l - 1] += 1\n        cnt[r] -= 1\n\n    # Compute prefix sums\n    res = 0\n    current_sum = 0\n    for i in range(n):\n        current_sum += cnt[i]\n        # Check if the current position has exactly m overlaps\n        if current_sum == m:\n            res += 1\n\n    return res\n\nif __name__ == '__main__':\n    ans = main()\n    print(ans)"}
{"problem_id":"p01438","slow_code_col":"from collections import defaultdict\n\nwhile 1:\n\n    n = int(input())\n\n    if n == 0: break\n\n    L = [0]*n\n\n    D = [0]*n\n\n    for man in range(n):\n\n        m,l = list(map(int,input().split()))\n\n        L[man] = l\n\n        t = 0\n\n        for date in range(m):\n\n            s,e = list(map(int,input().split()))\n\n            for s in range(s-6,e-6):\n\n                t |= 1 << s\n\n        D[man] = t\n\n\n\n    dp = [defaultdict(int) for i in range(n)]\n\n    dp[0][D[0]] = L[0]\n\n    for i in range(1,n):\n\n        for bit in list(dp[i-1].keys()):\n\n            if bit&D[i] == 0:\n\n                dp[i][bit|D[i]] = max(dp[i][bit|D[i]], dp[i-1][bit]+L[i])\n\n            dp[i][bit] = max(dp[i][bit],dp[i-1][bit])\n\n        dp[i][D[i]] = max(dp[i][D[i]], L[i])\n\n        \n\n    ans = max(max(dp[i].values()) for i in range(n))\n\n    print(ans)","reference_code_col":"from collections import defaultdict\n\nwhile 1:\n\n    n = int(input())\n\n    if n == 0: break\n\n    L = [0]*n\n\n    T = [0]*n\n\n    for man in range(n):\n\n        m,l = list(map(int,input().split()))\n\n        L[man] = l\n\n        t = 0\n\n        for date in range(m):\n\n            s,e = list(map(int,input().split()))\n\n            t |= 2**(e-6)-2**(s-6)\n\n        T[man] = t\n\n\n\n    dp = defaultdict(int)\n\n    dp[T[0]] = L[0]\n\n    for i in range(1,n):\n\n        for bit in list(dp.keys()):\n\n            if bit&T[i] == 0:\n\n                dp[bit|T[i]] = max(dp[bit|T[i]], dp[bit]+L[i])\n\n        dp[T[i]] = max(dp[T[i]], L[i])\n\n        \n\n    print(max(dp.values()))","model_generated_potentially_faster_code_col":"from collections import defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    idx = 0\n    while True:\n        n = int(data[idx])\n        idx += 1\n\n        if n == 0:\n            break\n\n        L = [0] * n\n        D = [0] * n\n\n        for man in range(n):\n            m, l = map(int, data[idx].split())\n            idx += 1\n            L[man] = l\n            t = 0\n\n            for _ in range(m):\n                s, e = map(int, data[idx].split())\n                idx += 1\n                # Optimize bitmask creation\n                for day in range(s - 6, e - 6):\n                    t |= 1 << day\n\n            D[man] = t\n\n        # Initialize DP\n        dp_prev = defaultdict(int)\n        dp_prev[D[0]] = L[0]\n\n        for i in range(1, n):\n            dp_curr = defaultdict(int)\n\n            for bit, val in dp_prev.items():\n                # Case 1: Include current man's schedule\n                if bit & D[i] == 0:\n                    new_bit = bit | D[i]\n                    dp_curr[new_bit] = max(dp_curr[new_bit], val + L[i])\n\n                # Case 2: Exclude current man's schedule\n                dp_curr[bit] = max(dp_curr[bit], val)\n\n            # Handle standalone inclusion of current man's schedule\n            dp_curr[D[i]] = max(dp_curr[D[i]], L[i])\n\n            dp_prev = dp_curr\n\n        # Compute the final answer\n        ans = max(dp_prev.values())\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02767","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nX = np.array(input().split()).astype(int)\n\nP = round(np.average(X))\n\nprint((int(np.sum((P-X)**2))))","reference_code_col":"n = int(eval(input()))\n\nx = [int(i) for i in input().split()]\n\nmin_x = round(sum(x) \/ n)\n\nans = sum([(min_x - i)**2 for i in x])\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input parsing\nN = int(input())\nX = np.fromstring(input(), sep=' ', dtype=int)\n\n# Compute the average and round it\nP = round(np.mean(X))\n\n# Compute the sum of squared differences efficiently\nresult = np.sum((P - X) ** 2)\n\n# Output the result\nprint(int(result))"}
{"problem_id":"p02780","slow_code_col":"N, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\ns = [0] * 1000000\n\nfor i in range(N):\n\n    s[i+1] = s[i] + A[i]\n\n\n\nmax_s = 0\n\nfor i in range(N):\n\n    if max_s < s[i+K] - s[i]:\n\n        max_s = s[i+K] - s[i]\n\n\n\n\n\nprint(((max_s+K) \/ 2))","reference_code_col":"N, K = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\nm = [(e + 1) \/ 2 for e in p]\n\n\n\nt = sum(m[0:K])\n\nresult = t\n\nfor i in range(N - K):\n\n    t -= m[i]\n\n    t += m[i + K]\n\n    if t > result:\n\n        result = t\n\nprint(result)","model_generated_potentially_faster_code_col":"import sys\n\n# Fast input reading\ndef fast_input():\n    return sys.stdin.read().split()\n\n# Read input\ndata = fast_input()\nN, K = int(data[0]), int(data[1])\nA = list(map(int, data[2:2+N]))\n\n# Compute prefix sums dynamically\ns = [0] * (N + 1)\nfor i in range(N):\n    s[i + 1] = s[i] + A[i]\n\n# Find the maximum sum of any subarray of length K\nmax_s = float('-inf')\nfor i in range(N - K + 1):\n    current_sum = s[i + K] - s[i]\n    if current_sum > max_s:\n        max_s = current_sum\n\n# Output the result\nprint((max_s + K) \/ 2)"}
{"problem_id":"p03208","slow_code_col":"N, K = list(map(int, input().split()))\n\n\n\nheight = []\n\nfor _ in range(N) :\n\n    height.append(int(eval(input())))\n\n\n\nheight.sort()\n\nans = float('inf')\n\n\n\nfor i in range(N-K+1) :\n\n    diff = height[i + K - 1] - height[i]\n\n    ans = min(ans, diff)\n\n\n\nprint(ans)","reference_code_col":"N, K = list(map(int, input().split()))\n\nH = [int(eval(input())) for _ in range(N)]\n\nH.sort()\n\n\n\nans = 10**18\n\nfor i in range(N - K + 1):\n\n    ans = min(ans, H[i + K - 1] - H[i])\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read input values for N and K\nN, K = map(int, input().split())\n\n# Read all heights at once and convert them to integers\nheight = [int(input()) for _ in range(N)]\n\n# Sort the heights\nheight.sort()\n\n# Initialize the answer to infinity\nans = float('inf')\n\n# Use a sliding window to find the minimum difference\nfor i in range(N - K + 1):\n    diff = height[i + K - 1] - height[i]\n    ans = min(ans, diff)\n\n# Output the result\nprint(ans)"}
{"problem_id":"p03032","slow_code_col":"from collections import deque\n\n\n\nn, k = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor t in range(k\/\/2 + 1):\n\n    hand = deque(V[:k-t])\n\n    rest = deque(V[k-t:])\n\n    cur_sum = sum(hand)\n\n\n\n    for j in range(k-t+1):\n\n        put_back = 0\n\n        rev_hand = sorted(hand)\n\n\n\n        for i in range(t):\n\n            jewel = rev_hand[i]\n\n            if jewel < 0:\n\n                put_back -= jewel\n\n            else:\n\n                break\n\n\n\n        candidate = cur_sum + put_back\n\n        ans = max(candidate, ans)\n\n\n\n        to_rest = hand.pop()\n\n        rest.appendleft(to_rest)\n\n        to_hand = rest.pop()\n\n        hand.appendleft(to_hand)\n\n\n\n        cur_sum += to_hand - to_rest\n\n\n\nprint(ans)","reference_code_col":"n, k = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\n\n\ndef get_jewelries(box, left_pop, right_pop):\n\n    if left_pop + right_pop >= len(box):\n\n        return box[:]\n\n\n\n    left = box[:left_pop]\n\n    right = box[-right_pop:] if right_pop else []\n\n\n\n    return left + right\n\n\n\n\n\ncandidates = []\n\npop_max = min(k, n)\n\nfor pop_count in range(pop_max+1):\n\n    residue = k - pop_count\n\n\n\n    for left_pop in range(pop_count+1):\n\n        right_pop = pop_count - left_pop\n\n        jewelries = get_jewelries(V, left_pop, right_pop)\n\n        jewelries.sort(reverse=True)\n\n\n\n        for _ in range(residue):\n\n            if not jewelries:\n\n                break\n\n            if jewelries[-1] < 0:\n\n                jewelries.pop()\n\n\n\n        value = sum(jewelries)\n\n        candidates.append(value)\n\n\n\nprint((max(candidates)))\n","model_generated_potentially_faster_code_col":"import heapq\n\n# Input reading\nn, k = map(int, input().split())\nV = list(map(int, input().split()))\n\nans = 0\n\nfor t in range(k \/\/ 2 + 1):\n    window_size = k - t\n    max_heap = []  # Min-heap to track negative jewels\n    cur_sum = sum(V[:window_size])\n    \n    # Initialize heap with negative jewels\n    for jewel in V[:window_size]:\n        if jewel < 0:\n            heapq.heappush(max_heap, jewel)\n    \n    # Evaluate the first window\n    put_back = -sum(max_heap[:t]) if len(max_heap) >= t else -sum(max_heap)\n    candidate = cur_sum + put_back\n    ans = max(ans, candidate)\n    \n    # Sliding window over the rest of the array\n    for i in range(window_size, n):\n        # Remove the outgoing element\n        outgoing = V[i - window_size]\n        if outgoing < 0:\n            max_heap.remove(outgoing)\n            heapq.heapify(max_heap)  # Rebuild heap after removal\n        \n        # Add the incoming element\n        incoming = V[i]\n        if incoming < 0:\n            heapq.heappush(max_heap, incoming)\n        \n        # Update the current sum\n        cur_sum += incoming - outgoing\n        \n        # Calculate the candidate answer for the current window\n        put_back = -sum(max_heap[:t]) if len(max_heap) >= t else -sum(max_heap)\n        candidate = cur_sum + put_back\n        ans = max(ans, candidate)\n\nprint(ans)"}
{"problem_id":"p02863","slow_code_col":"n,t=list(map(int,input().split()))\n\nab=[list(map(int,input().split()))for _ in range(n)]\n\nab.sort()\n\ndp=[(6007)*[0]for _ in range(n+1)]\n\ndp[0][0]=0\n\nans=0\n\nfor i in range(n):\n\n  for j in range(6007):\n\n    dp[i+1][j]=max(dp[i+1][j],dp[i][j])\n\n    if j<t:dp[i+1][j+ab[i][0]]=max(dp[i][j]+ab[i][1],dp[i][j+ab[i][0]])\n\n    ans=max(ans,dp[i+1][j])\n\nprint(ans)\n","reference_code_col":"n,t=list(map(int,input().split()))\n\ndp=[[0]*(t+3001)for _ in range(n+1)]\n\nans=0\n\nab=[list(map(int,input().split()))for _ in range(n)]\n\nab.sort()\n\nfor i in range(1,n+1):\n\n    a,b=ab[i-1]\n\n    for j in range(t):\n\n        dp[i][j]=max(dp[i-1][j],dp[i][j])\n\n        dp[i][j+a]=dp[i-1][j]+b\n\n        ans=max(dp[i][j],dp[i][j+a],ans)\n\nprint(ans)   ","model_generated_potentially_faster_code_col":"n, t = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(n)]\n\n# Sort items by their time (a[i])\nab.sort()\n\n# Use a 1D DP array to store the maximum value for each time\ndp = [0] * (t + 1)\n\n# Iterate through each item\nfor a, b in ab:\n    # Update DP array in reverse order to avoid overwriting\n    for j in range(t, a - 1, -1):\n        dp[j] = max(dp[j], dp[j - a] + b)\n\n# The answer is the maximum value in the DP array\nprint(max(dp))"}
{"problem_id":"p03399","slow_code_col":"a, b, c, d = int(eval(input())), int(eval(input())), int(eval(input())), int(eval(input())),\n\nprint((min(a, b)+min(c, d)))","reference_code_col":"print((min(int(eval(input())), int(eval(input()))) + min(int(eval(input())), int(eval(input())))))","model_generated_potentially_faster_code_col":"# Read inputs directly as integers\na, b, c, d = (int(input()) for _ in range(4))\n\n# Compute the result using a single line\nprint(min(a, b) + min(c, d))"}
{"problem_id":"p02837","slow_code_col":"def popcount(x):\n\n  r = 0\n\n  while x:\n\n    if x & 1:\n\n      r += 1\n\n    x >>= 1\n\n  return r\n\n\n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [[0, 0] for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y] |= 1 << (x - 1)\n\n\n\nm = 0\n\nl = (1 << n) - 1\n\nfor x in range(1, l + 1):\n\n  if all(a[i][0] & x == a[i][1] & l - x == 0 for i in r if x >> i & 1):\n\n    m = max(m, popcount(x))\n\nprint(m)\n","reference_code_col":"from itertools import combinations\n\n \n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [(set(), set()) for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y].add(x - 1)\n\n \n\nfail = lambda x: not all(a[i][0].isdisjoint(x) and a[i][1] < x for i in x)\n\n \n\nwhile all(map(fail, list(map(set, combinations(r, n))))):\n\n  n -= 1\n\nprint(n)","model_generated_potentially_faster_code_col":"def popcount(x):\n    # Use Python's built-in method to count set bits\n    return bin(x).count('1')\n\n# Read input safely and efficiently\nn = int(input())\n\na = [[0, 0] for _ in range(n)]\n\nfor i in range(n):\n    num_queries = int(input())\n    for _ in range(num_queries):\n        x, y = map(int, input().split())\n        a[i][y] |= 1 << (x - 1)\n\nm = 0\nl = (1 << n) - 1\n\n# Precompute bit masks for efficiency\nfor x in range(1, l + 1):\n    if all((a[i][0] & x == 0) and (a[i][1] & (l - x) == 0) for i in range(n) if x >> i & 1):\n        m = max(m, popcount(x))\n\nprint(m)"}
{"problem_id":"p03039","slow_code_col":"n, m, k = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\nMAX = n * m\n\n\n\n\n\nclass ModInt:\n\n    def __init__(self, num):\n\n        self.num = num\n\n\n\n    def __str__(self):\n\n        return str(self.num)\n\n\n\n    def __repr__(self):\n\n        return \"ModInt(num: {}, mod: {}\".format(self.num, mod)\n\n\n\n    def __add__(self, other):\n\n        ret = self.num + other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def __sub__(self, other):\n\n        ret = self.num - other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def __mul__(self, other):\n\n        ret = self.num * other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def pow(self, times):\n\n        pw = pow(self.num, times, mod)\n\n        return ModInt(pw)\n\n\n\n    def inverse(self):\n\n        return ModInt(inv[self.num])\n\n\n\n    def __truediv__(self, other):\n\n        num = self * other.inverse()\n\n        return ModInt(num)\n\n\n\n\n\ndef comb(n, k):\n\n    return fact[n] * inv[n-k] * inv[k]\n\n\n\n\n\nfact = [None] * (MAX + 1)\n\nfact[0] = ModInt(1)\n\nfor i in range(1, MAX + 1):\n\n    fact[i] = fact[i-1] * ModInt(i)\n\n\n\ninv = [None] * (MAX + 1)\n\ninv[MAX] = fact[MAX].pow(mod - 2)\n\nfor i in range(MAX, 0, -1):\n\n    inv[i-1] = inv[i] * ModInt(i)\n\n\n\nans = ModInt(0)\n\nfor i in range(n):\n\n    for j in range(m):\n\n        add = ModInt(n - i) * ModInt(m - j) * ModInt(i + j)\n\n        if i != 0 and j != 0:\n\n            add *= ModInt(2)\n\n\n\n        ans += add\n\n\n\nans *= comb(n * m - 2, k - 2)\n\nprint(ans)\n","reference_code_col":"n, m, k = list(map(int, input().split()))\n\n\n\nmod = 10 ** 9 + 7\n\nMAX = n * m\n\n\n\nfact = [1] * (MAX + 1)\n\nfor i in range(1, MAX + 1):\n\n    fact[i] = (fact[i-1] * i) % mod\n\n\n\ninv = [1] * (MAX + 1)\n\ninv[MAX] = pow(fact[MAX], mod - 2, mod)\n\nfor i in range(MAX, 0, -1):\n\n    inv[i-1] = (inv[i] * i) % mod\n\n\n\n\n\ndef comb(n, k):\n\n    return fact[n] * inv[n-k] * inv[k] % mod\n\n\n\n\n\nans = 0\n\nfor i in range(n):\n\n    for j in range(m):\n\n        add = (n - i) * (m - j) * (i + j) % mod\n\n        if i != 0 and j != 0:\n\n            add *= 2\n\n            add %= mod\n\n\n\n        ans += add\n\n        ans %= mod\n\n\n\nans *= comb(MAX - 2, k - 2)\n\nans %= mod\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"n, m, k = map(int, input().split())\nmod = 10**9 + 7\n\n# Precompute factorials and modular inverses\nMAX = n * m\nfact = [1] * (MAX + 1)\nfor i in range(1, MAX + 1):\n    fact[i] = fact[i - 1] * i % mod\n\ninv_fact = [1] * (MAX + 1)\ninv_fact[MAX] = pow(fact[MAX], mod - 2, mod)\nfor i in range(MAX - 1, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n# Combination function\ndef comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * inv_fact[k] % mod * inv_fact[n - k] % mod\n\n# Main computation\nans = 0\nfor i in range(n):\n    for j in range(m):\n        add = (n - i) * (m - j) * (i + j)\n        if i != 0 and j != 0:\n            add *= 2\n        ans = (ans + add) % mod\n\n# Multiply by combination\nans = ans * comb(n * m - 2, k - 2) % mod\n\nprint(ans)"}
{"problem_id":"p02792","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\n# A\u306e\u5148\u982d\u306e\u6841\u3068\u672b\u5c3e\u306e\u6841\u306e\u7d44\u307f\u5408\u308f\u305b\u306f9*10=90\u901a\u308a\u3060\u3051\n\ntable = [[0] * 10 for i in range(10)]\n\nfor x in range(1, N+1):\n\n    x = str(x)\n\n    i = int(x[0])\n\n    j = int(x[-1])\n\n    table[i][j] += 1\n\n\n\ntable = np.array(table)\n\nanswer = (table * table.T).sum()\n\nprint(answer)\n","reference_code_col":"import sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\ncount = [[0] * 10 for _ in range(10)] # dp[head][tail]\n\nfor i in range(1, N+1):\n\n    s = str(i)\n\n    head = int(s[0]); tail = int(s[-1])\n\n    count[head][tail] += 1\n\n\n\nanswer = 0\n\nfor h in range(10):\n\n    for t in range(10):\n\n        answer += count[h][t] * count[t][h]\n\nprint(answer)\n","model_generated_potentially_faster_code_col":"import sys\n\n# Fast input functions\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN = ir()\n\n# A's first digit and last digit combinations are limited to 9*10=90 possibilities\ntable = [[0] * 10 for _ in range(10)]\n\n# Efficiently compute the first and last digits without converting to strings\nfor x in range(1, N + 1):\n    # Extract the first digit\n    first_digit = x\n    while first_digit >= 10:\n        first_digit \/\/= 10\n    \n    # Extract the last digit\n    last_digit = x % 10\n    \n    # Update the table\n    table[first_digit][last_digit] += 1\n\n# Compute the result using nested loops instead of NumPy (to avoid overhead)\nanswer = 0\nfor i in range(10):\n    for j in range(10):\n        answer += table[i][j] * table[j][i]\n\nprint(answer)"}
{"problem_id":"p03241","slow_code_col":"N,M = list(map(int,input().split()))\n\nif N==1:\n\n    nmax=M\n\nelse:\n\n    nmax = 1\n\n    for i in range(2,int(M**0.5)+1):\n\n        if M%i==0 and M\/\/i>=N:\n\n            nmax = max(nmax,i)\n\n        if M%i==0 and i>=N:\n\n            nmax = max(nmax,M\/\/i)\n\nprint(nmax)","reference_code_col":"N,M = list(map(int,input().split()))\n\namax = 1\n\nfor i in range(1,int(M**0.5)+1):\n\n    if M%i==0:\n\n        a = i\n\n        b = M\/\/i\n\n        if b>=N:\n\n            amax = max(amax,a)\n\n        a,b = b,a\n\n        if b>=N:\n\n            amax = max(amax,a)\n\nprint(amax)","model_generated_potentially_faster_code_col":"N, M = map(int, input().split())\n\nif N == 1:\n    print(M)\nelse:\n    nmax = 1\n    sqrt_M = int(M**0.5)  # Precompute square root of M\n\n    for i in range(2, sqrt_M + 1):\n        if M % i == 0:  # Check if i is a factor of M\n            if M \/\/ i >= N:  # Check if the complementary factor is valid\n                nmax = max(nmax, i)\n            if i >= N:  # Check if the current factor is valid\n                nmax = max(nmax, M \/\/ i)\n\n    print(nmax)"}
{"problem_id":"p03162","slow_code_col":"import numpy as np\n\n\n\nN = int(eval(input()))\n\na = np.array([input().split() for i in range(N)], dtype=int)\n\n\n\ndp = np.zeros((N, 3), dtype=int)\n\ndp[0] = a[0]\n\n\n\nfor i in range(1, N):\n\n    dp[i] = [\n\n        a[i][0] + max(dp[i - 1][1], dp[i - 1][2]),\n\n        a[i][1] + max(dp[i - 1][2], dp[i - 1][0]),\n\n        a[i][2] + max(dp[i - 1][0], dp[i - 1][1]),\n\n    ]\n\n\n\nprint((np.max(dp[-1])))\n","reference_code_col":"N = int(eval(input()))\n\na = [list(map(int, input().split())) for _ in range(N)]\n\n\n\ndp = [[0, 0, 0] for _ in range(N+1)]\n\n\n\nfor i in range(N):\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j == k:\n\n                continue\n\n            dp[i+1][k] = max(dp[i+1][k], dp[i][j] + a[i][k])\n\n\n\nprint((max(dp[-1])))\n","model_generated_potentially_faster_code_col":"import numpy as np\nimport sys\n\ndef main():\n    # Efficient input reading\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    a = np.array(list(map(int, data[1:])), dtype=int).reshape(N, 3)\n    \n    # Initialize DP arrays for the first two rows\n    prev_dp = a[0].copy()\n    \n    for i in range(1, N):\n        # Precompute max values for reuse\n        max_12 = max(prev_dp[1], prev_dp[2])\n        max_20 = max(prev_dp[2], prev_dp[0])\n        max_01 = max(prev_dp[0], prev_dp[1])\n        \n        # Compute the current DP row\n        curr_dp = np.array([\n            a[i][0] + max_12,\n            a[i][1] + max_20,\n            a[i][2] + max_01\n        ])\n        \n        # Update prev_dp for the next iteration\n        prev_dp = curr_dp\n    \n    # Output the result\n    print(max(prev_dp))\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02596","slow_code_col":"import sys\n\n\n\nreadline = sys.stdin.readline\n\nreadall = sys.stdin.read\n\nns = lambda: readline().rstrip()\n\nni = lambda: int(readline().rstrip())\n\nnm = lambda: map(int, readline().split())\n\nnl = lambda: list(map(int, readline().split()))\n\nprn = lambda x: print(*x, sep='\\n')\n\n\n\ndef solve():\n\n    d = dict()\n\n    k = ni()\n\n    c = 7 % k\n\n    x = d[c] = 1\n\n    while True:\n\n        c = (c * 10 + 7) % k\n\n        if c in d:\n\n            break\n\n        x += 1\n\n        d[c] = x\n\n    print(d.get(0, -1))\n\n    return\n\n\n\nsolve()\n","reference_code_col":"import sys\n\n\n\nreadline = sys.stdin.readline\n\nreadall = sys.stdin.read\n\nns = lambda: readline().rstrip()\n\nni = lambda: int(readline().rstrip())\n\nnm = lambda: map(int, readline().split())\n\nnl = lambda: list(map(int, readline().split()))\n\nprn = lambda x: print(*x, sep='\\n')\n\n\n\ndef solve():\n\n    k = ni()\n\n    c = 0\n\n    for i in range(k):\n\n        c = (c * 10 + 7) % k\n\n        if c == 0:\n\n            print(i+1)\n\n            break\n\n    else:\n\n        print(-1)\n\n    return\n\n\n\nsolve()\n","model_generated_potentially_faster_code_col":"def solve():\n    # Read input\n    k = int(input())\n    \n    # Edge case: k must be greater than 0\n    if k == 0:\n        print(-1)\n        return\n    \n    # Initialize variables\n    c = 7 % k  # Initial remainder\n    seen = set()  # To track seen remainders\n    x = 1  # Iteration count\n    \n    while True:\n        if c == 0:  # If remainder is 0, we found the solution\n            print(x)\n            return\n        \n        if c in seen:  # If remainder repeats, no solution exists\n            print(-1)\n            return\n        \n        # Mark the remainder as seen\n        seen.add(c)\n        \n        # Update remainder and iteration count\n        c = (c * 10 + 7) % k\n        x += 1\n\n\n# Call the function\nsolve()"}
{"problem_id":"p02959","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nN = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\nbefore = sum(A)\n\n\n\nfor i in range(N):\n\n    nokori = B[i]\n\n    for j in range(i,i+2):\n\n        if nokori >= A[j]:\n\n            nokori -= A[j]\n\n            A[j] = 0\n\n        else:\n\n            A[j] -= nokori\n\n            nokori = 0\n\nafter = sum(A)\n\n\n\nprint((before - after))","reference_code_col":"N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\n\n\ncnt = 0\n\nfor i in range(N):\n\n    if B[i] >= A[i]:\n\n        cnt += A[i]\n\n        B[i] -= A[i]\n\n    else:\n\n        cnt += B[i]\n\n        B[i] = 0\n\n    if B[i] == 0:\n\n        continue\n\n    if B[i] >= A[i+1]:\n\n        cnt += A[i+1]\n\n        A[i+1] = 0\n\n    else:\n\n        cnt += B[i]\n\n        A[i+1] -= B[i]\n\n\n\nprint(cnt)","model_generated_potentially_faster_code_col":"import sys\n\n# Faster input reading\ninput = sys.stdin.readline\n\n# Read inputs\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\n# Track the total reduction in A\ntotal_reduction = 0\n\n# Process each B[i] and update A accordingly\nfor i in range(N):\n    # Remaining value from B[i]\n    remaining = B[i]\n    \n    # Subtract from A[i]\n    reduction = min(A[i], remaining)\n    A[i] -= reduction\n    remaining -= reduction\n    total_reduction += reduction\n    \n    # If there's still remaining, subtract from A[i+1]\n    if remaining > 0 and i + 1 < N:\n        reduction = min(A[i + 1], remaining)\n        A[i + 1] -= reduction\n        remaining -= reduction\n        total_reduction += reduction\n\n# Output the result\nprint(total_reduction)"}
{"problem_id":"p03457","slow_code_col":"N = int(eval(input()))\n\ntxy = [(0, 0, 0)] + [tuple(map(int, input().split())) for _ in range(N)]\n\nfor i in range(N):\n\n    t1, x1, y1 = txy[i]\n\n    t2, x2, y2 = txy[i+1]\n\n    if abs(x2-x1) + abs(y2-y1) <= t2 - t1 and (x1+y1+x2+y2) % 2 == (t2-t1) % 2:\n\n        continue\n\n    else:\n\n        print('No')\n\n        exit()\n\nprint('Yes')","reference_code_col":"N = int(eval(input()))\n\nt0 = x0 = y0 = 0\n\nfor _ in range(N):\n\n    t1, x1, y1 = list(map(int, input().split()))\n\n    d = abs(x1 - x0) + abs(y1 - y0)\n\n    if d > t1 - t0 or d % 2 != (t1 - t0) % 2:\n\n        print('No')\n\n        exit()\n\n    t0, x0, y0 = t1, x1, y1\n\nprint('Yes')\n","model_generated_potentially_faster_code_col":"# Read the number of test cases\nN = int(input())\n\n# Parse the input tuples efficiently\ntxy = [(0, 0, 0)] + [tuple(map(int, input().split())) for _ in range(N)]\n\n# Iterate through consecutive pairs\nfor i in range(N):\n    t1, x1, y1 = txy[i]\n    t2, x2, y2 = txy[i + 1]\n\n    # Compute the time difference once\n    dt = t2 - t1\n\n    # Compute the Manhattan distance once\n    dist = abs(x2 - x1) + abs(y2 - y1)\n\n    # Check reachability and parity conditions\n    if dist <= dt and (x1 + y1 + x2 + y2 + dt) % 2 == 0:\n        continue\n    else:\n        print('No')\n        exit()\n\n# If all conditions are satisfied\nprint('Yes')"}
{"problem_id":"p02834","slow_code_col":"n,u,v=list(map(int,input().split()))\n\nanss=0\n\nu-=1\n\nv-=1\n\nd=[[]for _ in range(n)]\n\ninf=float('inf')\n\naoki=[inf]*n\n\nfor i in range(n-1):\n\n  a,b=list(map(int,input().split()))\n\n  a-=1\n\n  b-=1\n\n  d[a].append(b)\n\n  d[b].append(a)\n\nQ=d[v]\n\naoki[v]=0\n\ndis=1\n\nvisited={v}\n\nwhile Q:\n\n  P=[]\n\n  for i in Q:\n\n    visited.add(i)\n\n    for j in d[i]:\n\n      if j not in visited:P.append(j)\n\n    aoki[i]=dis\n\n  dis+=1\n\n  Q=P\n\nQ=d[u]\n\nchokudai=[-1]*n\n\nchokudai[u]=0\n\ndis=1\n\nvisited={u}\n\npoint=-1\n\nwhile Q:\n\n  P=[]\n\n  for i in Q:\n\n    visited.add(i)\n\n    for j in d[i]:\n\n      if aoki[j]<=dis+1:\n\n        if aoki[j]==dis+1:anss=1\n\n        if point<0:point=i\n\n        continue\n\n      if j not in visited:P.append(j)\n\n    chokudai[i]=dis\n\n  dis+=1\n\n  Q=P\n\nQ=d[point]\n\ndis=chokudai[point]+1\n\nvisited={point}\n\nwhile Q:\n\n  P=[]\n\n  for i in Q:\n\n    visited.add(i)\n\n    if chokudai[i]==-1:continue\n\n    chokudai[i]=max(dis,chokudai[i])\n\n    for j in d[i]:\n\n      if j not in visited:P.append(j)\n\n  dis+=1\n\n  Q=P\n\nans=0\n\nfor i in range(n):\n\n  if aoki[i]>chokudai[i]:ans=max(ans,chokudai[i])\n\nprint((ans+anss))\n\n#print(aoki)\n\n#print(chokudai)","reference_code_col":"n,u,v=list(map(int,input().split()))\n\nu-=1\n\nv-=1\n\ne=[[]for _ in range(n)]\n\nfor i in range(n-1):\n\n  a,b=list(map(int,input().split()))\n\n  a-=1\n\n  b-=1\n\n  e[a].append(b)\n\n  e[b].append(a)\n\ncho=[u]\n\ncho_dis=[10**7]*n\n\ncho_dis[u]=0\n\ncho_visited={u}\n\ncountt=1\n\nwhile cho:\n\n  CHO=[]\n\n  for i in cho:\n\n    for j in e[i]:\n\n      if j in cho_visited:continue\n\n      cho_visited.add(j)\n\n      CHO.append(j)\n\n      cho_dis[j]=countt\n\n  countt+=1\n\n  cho=CHO\n\naok=[v]\n\naok_dis=[10**7]*n\n\naok_dis[v]=0\n\naok_visited={v}\n\ncountt=1\n\nwhile aok:\n\n  AOK=[]\n\n  for i in aok:\n\n    for j in e[i]:\n\n      if j in aok_visited:continue\n\n      aok_visited.add(j)\n\n      AOK.append(j)\n\n      aok_dis[j]=countt\n\n  countt+=1\n\n  aok=AOK\n\nans=0\n\nfor i in range(n):\n\n  if cho_dis[i]<aok_dis[i]:ans=max(ans,aok_dis[i]-1)\n\nprint(ans)","model_generated_potentially_faster_code_col":"from collections import deque\n\n# Input\nn, u, v = map(int, input().split())\nu -= 1\nv -= 1\n\n# Graph representation\ngraph = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    graph[a].append(b)\n    graph[b].append(a)\n\n# BFS function\ndef bfs(start, graph, n):\n    distances = [-1] * n\n    distances[start] = 0\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        current_distance = distances[node]\n        \n        for neighbor in graph[node]:\n            if distances[neighbor] == -1:  # Not visited\n                distances[neighbor] = current_distance + 1\n                queue.append(neighbor)\n    \n    return distances\n\n# Compute distances from Aoki and Chokudai\naoki_distances = bfs(v, graph, n)\nchokudai_distances = bfs(u, graph, n)\n\n# Find the farthest point Chokudai can reach before Aoki catches up\nmax_distance = 0\nfor i in range(n):\n    if aoki_distances[i] > chokudai_distances[i]:\n        max_distance = max(max_distance, chokudai_distances[i])\n\n# Output the result\nprint(max_distance)"}
{"problem_id":"p02537","slow_code_col":"d=[0]*6**8\n\nn,k,*a=list(map(int,open(0).read().split()+d))\n\nfor i in range(n):d[i]=max(d[j]for j in range(i-99,i+1)if abs(a[i]-a[j])<=k)+1\n\nprint((max(d)))","reference_code_col":"d=[0]*6**8\n\nn,k,*a=list(map(int,open(0).read().split()))\n\na=d+a\n\nwhile n:d[n]=max(d[j]for j in range(n,n+99)if abs(a[-n]-a[-j])<=k)+1;n-=1\n\nprint((max(d)))","model_generated_potentially_faster_code_col":"from collections import deque\n\n# Read input and initialize variables\nd = [0] * (6**8)\nn, k, *a = map(int, open(0).read().split() + d)\n\n# Use a deque to maintain indices of the sliding window\ndq = deque()\n\nfor i in range(n):\n    # Remove indices outside the sliding window of size 100\n    if dq and dq[0] < i - 99:\n        dq.popleft()\n    \n    # Compute d[i] using the front of the deque (maximum valid d[j])\n    if dq:\n        d[i] = d[dq[0]] + 1\n    else:\n        d[i] = 1\n    \n    # Maintain the deque in decreasing order of d values\n    while dq and d[i] >= d[dq[-1]]:\n        dq.pop()\n    \n    # Add current index to the deque if it satisfies the condition\n    if all(abs(a[i] - a[j]) <= k for j in dq):\n        dq.append(i)\n\n# Output the maximum value in d\nprint(max(d[:n]))"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\n# Me\n\n\n\n\n\ndef f():\n\n    i = int(eval(input()))\n\n    nums = np.array(list(map(int, input().split())))\n\n    # nums = [int(x) for x in input().split()]\n\n    c = 0\n\n    while True:\n\n        if any(nums % 2 == 1):\n\n            break\n\n        c += 1\n\n        nums = nums \/ 2\n\n    print(c)\n\n\n\n\n\nf()\n\n\n\n\n\n# Other\n","reference_code_col":"def divide_all(a):\n\n    success = True\n\n    for i, n in enumerate(a):\n\n        if n % 2 != 0:\n\n            success = False\n\n            break\n\n        a[i] = n \/ 2\n\n    if success is False:\n\n        return (a, False)\n\n    return (a, True)\n\n\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\nc = 0\n\nwhile True:\n\n    a, r = divide_all(a)\n\n    if r is False:\n\n        break\n\n    c += 1\n\n\n\n\n\nprint(c)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\ndef f():\n    # Read input values\n    _ = int(input())  # Ignore the first input since it's not used in the logic\n    nums = np.fromstring(input(), sep=' ', dtype=int)\n\n    c = 0  # Initialize counter\n\n    while True:\n        # Check if any number in nums is odd using bitwise AND\n        if np.any(nums & 1):\n            break\n\n        # Divide all numbers by 2 using bitwise right shift\n        nums >>= 1\n        c += 1\n\n    print(c)\n\nf()"}
{"problem_id":"p03253","slow_code_col":"from math import floor, sqrt\n\nfrom collections import defaultdict\n\ndef factors(n):\n\n    d = defaultdict(int)\n\n    for i in range(2,floor(sqrt(n))+1):\n\n        while n % i == 0:\n\n            n \/\/= i\n\n            d[i] += 1\n\n        if n == 1:\n\n            break\n\n    if n != 1:\n\n        d[n] += 1\n\n    return d\n\ndef inv(x, mod):\n\n    k = mod - 2\n\n    ret = 1\n\n    while k > 0:\n\n        if k&1:\n\n            ret = (ret*x) % mod\n\n        x = (x*x) % mod\n\n        k >>= 1\n\n    return ret\n\nN, M = list(map(int,input().split()))\n\nmod = 10**9+7\n\ndic = factors(M)\n\nK = len(dic)\n\nSIZE = N+max(dic.values()) if list(dic.values()) else N\n\nfact = [None]*(SIZE+1)\n\nfinv = [None]*(SIZE+1)\n\nfact[0] = 1\n\nfor i in range(1,SIZE+1):\n\n    fact[i] = (fact[i-1]*i) % mod\n\nfinv[SIZE] = inv(fact[SIZE], mod=mod)\n\nfor i in range(SIZE, 0, -1):\n\n    finv[i-1] = (finv[i]*i) % mod\n\ndef comb(n,k):\n\n    tmp = (finv[k]*finv[n-k]) % mod\n\n    return (fact[n]*tmp) % mod\n\nans = 1\n\nfor p in dic:\n\n    ans = (ans*comb(dic[p]+N-1, dic[p])) % mod\n\nprint(ans)","reference_code_col":"from math import floor, sqrt\n\nfrom collections import defaultdict\n\nN,M = list(map(int,input().split()))\n\nd = defaultdict(int)\n\nfor i in range(2, floor(sqrt(M))+1):\n\n    while M % i == 0:\n\n        d[i] += 1\n\n        M \/\/= i\n\nif M != 1:\n\n    d[M] += 1\n\ndef comb(n,k):\n\n    if k == 0:\n\n        return 1\n\n    return comb(n-1,k-1) * n \/\/ k\n\nans = 1\n\nfor e in list(d.values()):\n\n    ans *= comb(N+e-1, e)\n\nprint((ans % (10**9+7)))","model_generated_potentially_faster_code_col":"from math import floor, sqrt\nfrom collections import defaultdict\n\n# Sieve of Eratosthenes to generate primes up to a given limit\ndef sieve(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(sqrt(limit)) + 1):\n        if is_prime[i]:\n            for j in range(i * i, limit + 1, i):\n                is_prime[j] = False\n    return [x for x in range(limit + 1) if is_prime[x]]\n\n# Optimized prime factorization using a sieve\ndef factors(n, primes):\n    d = defaultdict(int)\n    for p in primes:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n \/\/= p\n            d[p] += 1\n    if n > 1:\n        d[n] += 1\n    return d\n\n# Modular inverse using binary exponentiation\ndef inv(x, mod):\n    k = mod - 2\n    ret = 1\n    while k > 0:\n        if k & 1:\n            ret = (ret * x) % mod\n        x = (x * x) % mod\n        k >>= 1\n    return ret\n\n# Precompute factorials and their modular inverses\ndef precompute_factorials(SIZE, mod):\n    fact = [1] * (SIZE + 1)\n    for i in range(1, SIZE + 1):\n        fact[i] = (fact[i - 1] * i) % mod\n    finv = [1] * (SIZE + 1)\n    finv[SIZE] = inv(fact[SIZE], mod)\n    for i in range(SIZE, 0, -1):\n        finv[i - 1] = (finv[i] * i) % mod\n    return fact, finv\n\n# Combination calculation using precomputed factorials\ndef comb(n, k, fact, finv, mod):\n    if k < 0 or k > n:\n        return 0\n    tmp = (finv[k] * finv[n - k]) % mod\n    return (fact[n] * tmp) % mod\n\n# Main function\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N, M = map(int, data[:2])\n    mod = 10**9 + 7\n\n    # Generate primes up to sqrt(M)\n    primes = sieve(int(sqrt(M)) + 1)\n    dic = factors(M, primes)\n\n    # Determine the maximum size for precomputation\n    max_exp = max(dic.values(), default=0)\n    SIZE = N + max_exp\n\n    # Precompute factorials and inverses\n    fact, finv = precompute_factorials(SIZE, mod)\n\n    # Compute the result\n    ans = 1\n    for p in dic:\n        ans = (ans * comb(dic[p] + N - 1, dic[p], fact, finv, mod)) % mod\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03416","slow_code_col":"a , b = input().split()\n\na = int(a)\n\nb = int(b)\n\ncount=0\n\nfor i in range(a,b+1):\n\n    test = list(str(i))\n\n    if (test[0] == test[4]) and (test[1]==test[3]):\n\n        count=count+1\n\nprint(count)","reference_code_col":"A,B=list(map(int,input().split()))\n\nct=0\n\nfor i in range(A,B+1):\n\n    s=str(i)\n\n    if s==s[::-1]:\n\n        ct+=1\n\nprint(ct)","model_generated_potentially_faster_code_col":"a, b = map(int, input().split())\n\n# Helper function to check if a number is a 5-digit palindrome\ndef is_palindrome(num):\n    # Extract digits using arithmetic\n    d1 = num \/\/ 10000       # First digit\n    d2 = (num \/\/ 1000) % 10 # Second digit\n    d4 = (num \/\/ 10) % 10   # Fourth digit\n    d5 = num % 10           # Fifth digit\n    return d1 == d5 and d2 == d4\n\n# Count valid palindromes in the range [a, b]\ncount = 0\nfor num in range(max(a, 10000), min(b, 99999) + 1):  # Only consider 5-digit numbers\n    if is_palindrome(num):\n        count += 1\n\nprint(count)"}
{"problem_id":"p03034","slow_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport numpy as np\n\n\n\nN = int(readline())\n\nS = np.array(read().split(),np.int64)\n\n\n\ndef F(d):\n\n    # \u516c\u5dee\u3092\u56fa\u5b9a\n\n    L = S[:-d:d].cumsum()\n\n    R = S[::-1][:-d:d].cumsum()\n\n    if (N-1)%d == 0:\n\n        n = (N-1)\/\/d\n\n        x = np.arange(1,n+1)\n\n        bl = (x+x <= n+1)\n\n        L = L[bl]; R = R[bl]\n\n    return (L+R).max()\n\n\n\ndef G(n):\n\n    # \u9805\u6570n+1\u3092\u56fa\u5b9a\n\n    D = (N-1-n)\/\/n\n\n    L = np.zeros(D+1,np.int64)\n\n    R = np.zeros(D+1,np.int64)\n\n    for i in range(1,n+1):\n\n        L += S[:i*(D+1):i]\n\n        R += S[::-1][:i*(D+1):i]\n\n    ok = np.ones(D+1,np.bool)\n\n    overlap = (np.arange(D+1) * (n+n) >= N-1)\n\n    overlap[1:] &= ((N-1)%np.arange(1,D+1) == 0)\n\n    x = L+R\n\n    x[overlap] = 0\n\n    return x.max()\n\n\n\nL = int((N-1)**.5 + 10)\n\nL = min(N-1,L)\n\n\n\nx = max(F(n) for n in range(1,L+1))\n\ny = max(G(n) for n in range(1,L+1))\n\nanswer = max(x,y)\n\nprint(answer)","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\n\n\nN = int(readline())\n\nS = list(map(int,read().split()))\n\n\n\nanswer = 0\n\nfor d in range(1,N):\n\n    n = (N-1)\/\/d\n\n    if (N-1)%d == 0:\n\n        n = ((N-1)\/\/d+1)\/\/2\n\n    if n <= 1:\n\n        continue\n\n    x = max(itertools.accumulate(x+y for x,y in zip(S[d:d*n:d],S[N-1-d:N-1-d*n:-d])))\n\n    if answer < x:\n\n        answer = x\n\n\n\nprint(answer)","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Fast input handling\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n# Read input\nN = int(readline())\nS = np.array(read().split(), dtype=np.int64)\n\ndef F(d):\n    # Precompute slices for efficiency\n    L_slice = slice(None, None, d)\n    R_slice = slice(None, None, -d)\n    \n    # Compute cumulative sums\n    L = S[L_slice].cumsum()\n    R = S[::-1][R_slice].cumsum()\n    \n    if (N - 1) % d == 0:\n        n = (N - 1) \/\/ d\n        x = np.arange(1, n + 1)\n        bl = (x + x <= n + 1)\n        L = L[bl]\n        R = R[bl]\n    \n    return (L + R).max()\n\ndef G(n):\n    D = (N - 1 - n) \/\/ n\n    max_D = D + 1\n    \n    # Preallocate arrays for L and R\n    L = np.zeros(max_D, dtype=np.int64)\n    R = np.zeros(max_D, dtype=np.int64)\n    \n    # Vectorized computation of L and R\n    indices = np.arange(1, n + 1)\n    step_sizes = np.arange(1, max_D + 1)\n    for i in indices:\n        L += S[:i * max_D:i]\n        R += S[::-1][:i * max_D:i]\n    \n    # Filter overlapping cases\n    overlap = (step_sizes * (n + n) >= N - 1)\n    overlap[1:] &= ((N - 1) % step_sizes[1:] == 0)\n    \n    x = L + R\n    x[overlap] = 0  # Set overlapping values to 0\n    \n    return x.max()\n\n# Set limit for d and n\nL = min(N - 1, int((N - 1) ** 0.5 + 10))\n\n# Evaluate F(d) and G(n) using list comprehensions\nx = max(F(d) for d in range(1, L + 1))\ny = max(G(n) for n in range(1, L + 1))\n\n# Final result\nanswer = max(x, y)\nprint(answer)"}
{"problem_id":"p03835","slow_code_col":"K,S=list(map(int,input().split()))\n\nO=0\n\nfor X in range(K+1):\n\n  for Y in range(K+1):\n\n    Z=S-X-Y\n\n    if 0<=Z<=K:\n\n      O+=1\n\nprint(O)\n","reference_code_col":"K,S=list(map(int,input().split()))\n\nans=0\n\nfor X in range(K+1):\n\n    for Y in range(K+1):\n\n        Z=S-X-Y\n\n        if 0<=Z<=K:\n\n            ans+=1\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"K, S = map(int, input().split())\n\ncount = 0\n\nfor X in range(K + 1):\n    # Calculate the valid range for Y\n    Y_min = max(0, S - X - K)\n    Y_max = min(K, S - X)\n    \n    # Count the number of valid Y values\n    if Y_min <= Y_max:\n        count += Y_max - Y_min + 1\n\nprint(count)"}
{"problem_id":"p04020","slow_code_col":"import sys\n\nstdin = sys.stdin\n\n \n\nsys.setrecursionlimit(10**8) \n\n \n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x)-1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\n\n\nn = ni()\n\na = [ni() for _ in range(n)]\n\n\n\ncnt = {i+1: ai for i, ai in enumerate(a)}\n\n\n\nprev = -100\n\ncur = 0\n\nans = 0\n\nfor key in sorted(cnt.keys()):\n\n    if cnt[key] == 0:\n\n        continue\n\n    \n\n    if prev == -100:\n\n        prev = key\n\n    \n\n    if (key-prev) < 2:\n\n        cur += cnt[key]\n\n    else:\n\n        cur = cnt[key]\n\n        \n\n    ans += cur \/\/ 2\n\n    cur -= 2 * (cur\/\/2)\n\n    \n\n    prev = key\n\n        \n\nprint(ans)","reference_code_col":"import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\n\n\nans = 0\n\nplus = 0\n\na = [ni() for _ in range(n)]\n\n\n\nfor ai in a:\n\n    ans += ((ai+plus) \/\/ 2)\n\n    plus = (ai+plus) % 2 if ai > 0 else 0\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\n\n# Fast input reading\nstdin = sys.stdin.read().splitlines()\nni = lambda idx: int(stdin[idx])\n\nn = ni(0)\na = [ni(i + 1) for i in range(n)]\n\nans = 0\ncur = 0\nprev = -2  # Initialize to a value that ensures the first element is handled correctly\n\nfor i in range(n):\n    if a[i] == 0:\n        continue\n\n    if i - prev < 2:\n        cur += a[i]\n    else:\n        cur = a[i]\n\n    ans += cur \/\/ 2\n    cur %= 2  # Simplify subtraction operation\n\n    prev = i\n\nprint(ans)"}
{"problem_id":"p03164","slow_code_col":"def main():\n\n    N, W = list(map(int, input().split()))\n\n    w = [0] * N\n\n    v = [0] * N\n\n    for i in range(N):\n\n        w[i], v[i] = list(map(int, input().split()))\n\n\n\n    max_v = max(v)\n\n    dp = [[float('inf')] * (max_v * N + 5) for _ in range(N + 5)]\n\n\n\n    dp[0][0] = 0\n\n\n\n    for i in range(N):\n\n        for j in range(max_v * N):\n\n            if j + v[i] <= max_v * N:\n\n                dp[i+1][j + v[i]] = min(dp[i+1][j + v[i]], dp[i][j] + w[i])\n\n            dp[i+1][j] = min(dp[i+1][j], dp[i][j]) \n\n\n\n    ans = 0\n\n    for j in range(max_v * N + 1):\n\n        if dp[N][j] <= W:\n\n            ans = j\n\n\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()","reference_code_col":"def main():\n\n    N, W = list(map(int, input().split()))\n\n    weight = [0] * N\n\n    value = [0] * N\n\n    for i in range(N):\n\n        weight[i], value[i] = list(map(int, input().split()))\n\n    V = sum(value)\n\n    dp = [[float('inf')] * (V + 5) for _ in range(N + 5)]\n\n    dp[0][0] = 0\n\n    for i in range(N):\n\n        for v in range(V+1):\n\n            if v - value[i] >= 0:\n\n                dp[i+1][v] = min(dp[i][v-value[i]] + weight[i], dp[i][v])\n\n            else:\n\n                dp[i+1][v] = dp[i][v]\n\n    ans = 0\n\n    for v in range(V+1):\n\n        if dp[N][v] <= W:\n\n            ans = v\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()","model_generated_potentially_faster_code_col":"def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Read input\n    N, W = map(int, data[:2])\n    w = []\n    v = []\n    index = 2\n    for _ in range(N):\n        w.append(int(data[index]))\n        v.append(int(data[index + 1]))\n        index += 2\n    \n    # Compute the maximum possible value\n    max_v = sum(v)\n    \n    # Initialize a 1D DP array\n    dp = [float('inf')] * (max_v + 1)\n    dp[0] = 0  # Base case: 0 value requires 0 weight\n    \n    # Update DP array for each item\n    for i in range(N):\n        for j in range(max_v, v[i] - 1, -1):\n            if dp[j - v[i]] + w[i] < dp[j]:\n                dp[j] = dp[j - v[i]] + w[i]\n    \n    # Find the maximum value such that the weight does not exceed W\n    ans = 0\n    for j in range(max_v + 1):\n        if dp[j] <= W:\n            ans = j\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03038","slow_code_col":"import numpy as np\n\nNM = list(map(int,input().split()))\n\nN = NM[0]\n\nM = NM[1]\n\nA = list(map(int,input().split()))\n\nlistBC =[]\n\nwhile True:\n\n    try:\n\n        listBC.append(list(map(int,input().split())))\n\n    except:\n\n        break;\n\nBC = np.array(listBC)\n\nBCnum = np.argsort(BC[:,1])[::-1]\n\nBC = BC[BCnum,:]\n\n\n\nA.sort()\n\nj=0\n\nfor i in range(len(A)):\n\n    times = BC[j,0]\n\n    if BC[j,0]==0:\n\n        j+=1\n\n        if j == BC.shape[0]:\n\n            break\n\n        times = BC[j,0]\n\n    if A[i]<BC[j,1]:\n\n        A[i]=BC[j,1]\n\n        BC[j,0] += -1\n\noutput = sum(A)\n\nprint(output)","reference_code_col":"N,M = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\nfrom collections import Counter\n\nD = dict(Counter(A))\n\n\n\nfor i in range(M):\n\n    B,C = list(map(int,input().split()))\n\n    D[C]=D.get(C,0)+B\n\n\n\nK = sorted(list(D.keys()),reverse=True)\n\n\n\nout = 0\n\ncnt = 0\n\nnow = 0\n\nwhile cnt<=N-1:\n\n    if D[K[now]]>0:\n\n        out += K[now]\n\n        D[K[now]] += -1\n\n        cnt+=1\n\n    else:\n\n        now+=1\n\nprint(out)","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Read all input at once\ninput_data = sys.stdin.read().splitlines()\n\n# Parse N, M\nN, M = map(int, input_data[0].split())\n\n# Parse A\nA = np.array(list(map(int, input_data[1].split())))\n\n# Parse BC\nBC = np.array([list(map(int, line.split())) for line in input_data[2:]])\n\n# Sort A in ascending order\nA.sort()\n\n# Sort BC by the second column (value) in descending order\nBC = BC[np.argsort(BC[:, 1])[::-1]]\n\n# Initialize pointers\ni, j = 0, 0\n\n# Process A and BC using a two-pointer technique\nwhile i < N and j < len(BC):\n    count, value = BC[j]\n    \n    # Determine the number of elements to update\n    update_count = min(count, N - i)\n    \n    # Update A[i:i+update_count] with the value from BC[j]\n    A[i:i + update_count] = value\n    \n    # Move pointers\n    i += update_count\n    j += 1\n\n# Compute the sum of A\noutput = np.sum(A)\n\n# Print the result\nprint(output)"}
{"problem_id":"p03309","slow_code_col":"n = int(eval(input()))\n\na = list(map(int,input().split()))\n\naa = []\n\nfor i in range(n):\n\n    aa.append(a[i]-(i+1))\n\nb = (sorted(aa)[n\/\/2])\n\n\n\nans = 0\n\nfor i in range(n):\n\n    ans += abs(a[i]-(b+i+1))\n\nprint(ans)","reference_code_col":"N= int(eval(input()))\n\nA = list(map(int,input().split()))\n\n\n\nB = []\n\nfor i in range(N):\n\n    B.append(A[i]-(i+1))\n\n#print(B)\n\nb= (sorted(B)[N\/\/2])\n\n#print(b)\n\nans = 0\n\nfor i in range(N):\n\n    ans += abs(B[i]-b)\n\nprint(ans)","model_generated_potentially_faster_code_col":"n = int(input())  # Read n directly without eval\na = list(map(int, input().split()))  # Read the list of integers\n\n# Compute the median of transformed values without creating aa explicitly\nb = sorted(a[i] - (i + 1) for i in range(n))[n \/\/ 2]\n\n# Compute the final answer using a single loop\nans = sum(abs(a[i] - (b + i + 1)) for i in range(n))\n\nprint(ans)"}
{"problem_id":"p02794","slow_code_col":"N = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\n\n\nP = [-1] * N\n\nDE = [0] * N\n\nQ = [0]\n\nwhile Q:\n\n    i = Q.pop()\n\n    for a in X[i][::-1]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            DE[a] = DE[i] + 1\n\n            X[a].remove(i)\n\n            Q.append(a)\n\n\n\ndef lp(u, v):\n\n    t = 0\n\n    while u != v:\n\n        if DE[u] > DE[v]:\n\n            t += 1 << u-1\n\n            u = P[u]\n\n        elif DE[u] < DE[v]:\n\n            t += 1 << v-1\n\n            v = P[v]\n\n        else:\n\n            t += 1 << u-1\n\n            t += 1 << v-1\n\n            u = P[u]\n\n            v = P[v]\n\n    \n\n    return t\n\n\n\nY = []\n\nM = int(eval(input()))\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    a, b = a-1, b-1\n\n    Y.append(lp(a, b))\n\n\n\nD = {1<<i: i for i in range(50)}\n\nZ = [0] * (1<<M)\n\nans = 0\n\nCC = [0] * N\n\nBC = [0] * (1<<17)\n\nfor m in range(1, 1<<17):\n\n    a = m & (-m)\n\n    BC[m] = BC[m^a] + 1\n\nfor m in range(1<<M):\n\n    a = m & (-m)\n\n    if a == m:\n\n        if a == 0:\n\n            Z[m] = 0\n\n        else:\n\n            Z[m] = Y[D[a]]\n\n    else:\n\n        Z[m] = Z[m^a] | Y[D[a]]\n\n    \n\n    aa = Z[m]\n\n    bc = BC[aa % (1<<17)]\n\n    aa >>= 17\n\n    bc += BC[aa % (1<<17)]\n\n    aa >>= 17\n\n    bc += BC[aa]\n\n    CC[N - 1 - bc] += (1 if BC[m%1024] + BC[m>>10] & 1 == 0 else -1)\n\n\n\nprint((sum([2 ** i * CC[i] for i in range(N)])))","reference_code_col":"N = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\n\n\nP = [-1] * N\n\nDE = [0] * N\n\nQ = [0]\n\nwhile Q:\n\n    i = Q.pop()\n\n    for a in X[i][::-1]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            DE[a] = DE[i] + 1\n\n            X[a].remove(i)\n\n            Q.append(a)\n\n\n\ndef lp(u, v):\n\n    t = 0\n\n    while u != v:\n\n        if DE[u] > DE[v]:\n\n            t += 1 << u-1\n\n            u = P[u]\n\n        elif DE[u] < DE[v]:\n\n            t += 1 << v-1\n\n            v = P[v]\n\n        else:\n\n            t += 1 << u-1\n\n            t += 1 << v-1\n\n            u = P[u]\n\n            v = P[v]\n\n    \n\n    return t\n\n\n\nY = []\n\nM = int(eval(input()))\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    a, b = a-1, b-1\n\n    Y.append(lp(a, b))\n\n\n\ndef popcnt(n):\n\n    c = (n & 0x5555555555555555) + ((n>>1) & 0x5555555555555555)\n\n    c = (c & 0x3333333333333333) + ((c>>2) & 0x3333333333333333)\n\n    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c>>4) & 0x0f0f0f0f0f0f0f0f)\n\n    c = (c & 0x00ff00ff00ff00ff) + ((c>>8) & 0x00ff00ff00ff00ff)\n\n    c = (c & 0x0000ffff0000ffff) + ((c>>16) & 0x0000ffff0000ffff)\n\n    c = (c & 0x00000000ffffffff) + ((c>>32) & 0x00000000ffffffff)\n\n    return c\n\n\n\nD = {1<<i: i for i in range(50)}\n\nZ = [0] * (1<<M)\n\nans = 0\n\nCC = [0] * N\n\nfor m in range(1<<M):\n\n    a = m & (-m)\n\n    if a == m:\n\n        if a == 0:\n\n            Z[m] = 0\n\n        else:\n\n            Z[m] = Y[D[a]]\n\n    else:\n\n        Z[m] = Z[m^a] | Y[D[a]]\n\n    \n\n    CC[N - 1 - popcnt(Z[m])] += (1 if popcnt(m) & 1 == 0 else -1)\n\n\n\nprint((sum([2 ** i * CC[i] for i in range(N)])))","model_generated_potentially_faster_code_col":"N = int(input())\nX = [[] for _ in range(N)]\n\nfor _ in range(N - 1):\n    x, y = map(int, input().split())\n    X[x - 1].append(y - 1)\n    X[y - 1].append(x - 1)"}
{"problem_id":"p03720","slow_code_col":"import numpy as np\n\n\n\nncity, nlines = list(map(int, input().rstrip(\"\\n\").split()))\n\nmatrix = np.zeros((ncity, ncity), dtype=int)\n\nfor _ in range(nlines):\n\n    l, c = [int(x) - 1 for x in input().rstrip(\"\\n\").split()]\n\n    matrix[l][c] += 1\n\n    matrix[c][l] += 1\n\n\n\nfor list_ in matrix:\n\n    print((sum(list_)))","reference_code_col":"n, m = map(int, input().split())\n\nroads = [0] * n\n\n[exec(\"roads[%d] += 1; roads[%d] += 1\" % tuple(map(lambda c: int(c) - 1, input().split()))) for _ in range(m)]\n\nprint(*roads, sep=\"\\n\", end=\"\")\n","model_generated_potentially_faster_code_col":"import sys\nfrom collections import defaultdict\n\ndef main():\n    # Read all input at once and split into lines\n    lines = sys.stdin.read().splitlines()\n    \n    # Parse the first line: ncity and nlines\n    ncity, nlines = map(int, lines[0].split())\n    \n    # Use a list to track the degree of each city\n    degree = [0] * ncity\n    \n    # Process each connection\n    for line in lines[1:]:\n        l, c = map(int, line.split())\n        l, c = l - 1, c - 1  # Convert to 0-based indexing\n        \n        # Increment the degree for both cities\n        degree[l] += 1\n        degree[c] += 1\n    \n    # Print the degree of each city\n    print(\"\\n\".join(map(str, degree)))\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03078","slow_code_col":"\n\nfrom heapq import heappop, heappush\n\n\n\nX, Y, Z, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nA.sort(reverse=True)\n\nB.sort(reverse=True)\n\nC.sort(reverse=True)\n\n\n\npq = []\n\nheappush(pq, (-A[0] - B[0] - C[0], 0, 0, 0))\n\nappeared = set((0, 0, 0))\n\n\n\nfor _ in range(K):\n\n    # Pop maximum value\n\n    val, i, j, k = heappop(pq)\n\n    print((-val))\n\n\n\n    # Add next value\n\n    if i + 1 < X and (i + 1, j, k) not in appeared:\n\n        heappush(pq, (-A[i + 1] - B[j] - C[k], i + 1, j, k))\n\n        appeared.add((i + 1, j, k))\n\n\n\n    if j + 1 < Y and (i, j + 1, k) not in appeared:\n\n        heappush(pq, (-A[i] - B[j + 1] - C[k], i, j + 1, k))\n\n        appeared.add((i, j + 1, k))\n\n\n\n    if k + 1 < Z and (i, j, k + 1) not in appeared:\n\n        heappush(pq, (-A[i] - B[j] - C[k + 1], i, j, k + 1))\n\n        appeared.add((i, j, k + 1))\n","reference_code_col":"\n\nX, Y, Z, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nA.sort(reverse=True)\n\nB.sort(reverse=True)\n\nC.sort(reverse=True)\n\n\n\nres = []\n\nfor i in range(X):\n\n    for j in range(Y):\n\n        for k in range(Z):\n\n            if (i + 1) * (j + 1) * (k + 1) <= K:\n\n                res.append(A[i] + B[j] + C[k])\n\n            else:\n\n                break\n\n\n\nres.sort(reverse=True)\n\nfor i in range(K):\n\n    print((res[i]))\n","model_generated_potentially_faster_code_col":"from heapq import heappop, heappush\n\n# Input\nX, Y, Z, K = map(int, input().split())\nA = sorted(map(int, input().split()), reverse=True)\nB = sorted(map(int, input().split()), reverse=True)\nC = sorted(map(int, input().split()), reverse=True)\n\n# Initialize priority queue and visited matrix\npq = []\nheappush(pq, (-A[0] - B[0] - C[0], 0, 0, 0))  # Start with the largest sum\nvisited = [[[False] * (Z + 1) for _ in range(Y + 1)] for _ in range(X + 1)]\nvisited[0][0][0] = True\n\n# Process K largest sums\nfor _ in range(K):\n    # Pop the maximum value\n    val, i, j, k = heappop(pq)\n    print(-val)  # Output the current largest sum\n\n    # Add next possible candidates\n    if i + 1 < X and not visited[i + 1][j][k]:\n        heappush(pq, (-A[i + 1] - B[j] - C[k], i + 1, j, k))\n        visited[i + 1][j][k] = True\n\n    if j + 1 < Y and not visited[i][j + 1][k]:\n        heappush(pq, (-A[i] - B[j + 1] - C[k], i, j + 1, k))\n        visited[i][j + 1][k] = True\n\n    if k + 1 < Z and not visited[i][j][k + 1]:\n        heappush(pq, (-A[i] - B[j] - C[k + 1], i, j, k + 1))\n        visited[i][j][k + 1] = True"}
{"problem_id":"p03371","slow_code_col":"a,b,c,x,y = list(map(int,input().split()))\n\nxy = max(x,y)*2+1\n\nprint((min([c*i + max(0,a*(x-i\/\/2)) +max(0,b*(y-i\/\/2)) for i in range(0,xy,2)])))","reference_code_col":"a,b,c,x,y = list(map(int,input().split()))\n\nif x < y:\n\n    a, b, x, y = b, a, y, x\n\nprint((min(a*x+b*y,2*c*y + a*(x-y),2*c*x)))","model_generated_potentially_faster_code_col":"# Input parsing\na, b, c, x, y = map(int, input().split())\n\n# Initialize the result with a large value\nresult = float('inf')\n\n# Iterate over possible values of k = i \/\/ 2\nfor k in range(max(x, y) + 1):\n    # Compute the cost for the current k\n    cost = c * (2 * k) + max(0, a * (x - k)) + max(0, b * (y - k))\n    \n    # Update the result if the current cost is smaller\n    result = min(result, cost)\n\n# Print the minimum cost\nprint(result)"}
{"problem_id":"p02412","slow_code_col":"while True:\n\n    n, x = [int(i) for i in input().split()]\n\n\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    for s in range(1, n - 1):\n\n        for m in range(s + 1, n):\n\n            for e in range(m + 1, n + 1):\n\n                if x == sum([s, m, e]):\n\n                    count += 1\n\n\n\n    print(count)","reference_code_col":"while True:\n\n    n, x = [int(i) for i in input().split()]\n\n\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    for s in range(1, n - 1):\n\n        for m in range(s + 1, n):\n\n            for e in range(m + 1, n + 1):\n\n                if x == s+m+e:\n\n                    count += 1\n\n\n\n    print(count)","model_generated_potentially_faster_code_col":"while True:\n    # Read input and parse n, x\n    n, x = map(int, input().split())\n    \n    # Break condition\n    if n == 0 and x == 0:\n        break\n\n    count = 0\n\n    # Iterate over all pairs (s, m)\n    for s in range(1, n - 1):\n        for m in range(s + 1, n):\n            # Calculate the required third number\n            e = x - (s + m)\n            \n            # Check if e is valid\n            if m < e <= n:\n                count += 1\n\n    # Output the result\n    print(count)"}
{"problem_id":"p02837","slow_code_col":"n = int(eval(input()))\n\nv = [[tuple(map(int, input().split()))for i in range(int(eval(input())))]\n\n     for i in range(n)]\n\n\n\nans = 0\n\nfor i in range(2**n):\n\n    f = [False] * n\n\n    xy = []\n\n    for j in range(n):\n\n        if (i >> j) & 1:\n\n            f[j] = True\n\n            xy.append(v[j])\n\n    flag = True\n\n    for xyi in xy:\n\n        for x, y in xyi:\n\n            if f[x - 1] is not bool(y):\n\n                flag = False\n\n                break\n\n    if flag:\n\n        ans = max(ans, len(xy))\n\nprint(ans)\n","reference_code_col":"n = int(eval(input()))\n\nv = [[tuple(map(int, input().split()))for i in range(int(eval(input())))]\n\n     for i in range(n)]\n\n\n\nans = 0\n\nfor i in range(2**n):\n\n    f = [0] * n\n\n    xy = []\n\n    for j in range(n):\n\n        if (i >> j) & 1:\n\n            f[j] = 1\n\n            xy.append(v[j])\n\n    flag = True\n\n    for xyi in xy:\n\n        for x, y in xyi:\n\n            #print(f,x,y,bin(i))\n\n            if (i>>(x-1))&1 != y:\n\n                flag = False\n\n                break\n\n    if flag:\n\n        ans = max(ans, len(xy))\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"n = int(input())\n\n# Preprocess the input data\nv = []\nfor _ in range(n):\n    m = int(input())\n    v.append([tuple(map(int, input().split())) for _ in range(m)])\n\nans = 0\n\n# Iterate over all subsets using bitmasking\nfor mask in range(1 << n):  # Equivalent to 2**n\n    flag = True\n    subset_size = bin(mask).count('1')  # Count active bits (subset size)\n\n    # Check constraints for the current subset\n    for j in range(n):\n        if mask & (1 << j):  # If j-th element is in the subset\n            for x, y in v[j]:\n                if ((mask >> (x - 1)) & 1) != y:  # Check constraint\n                    flag = False\n                    break\n        if not flag:\n            break\n\n    # Update the answer if the subset is valid\n    if flag:\n        ans = max(ans, subset_size)\n\nprint(ans)"}
{"problem_id":"p03000","slow_code_col":"N,X = list(map(int,input().split()))\n\nL = [0] + [int(x) for x in input().split()]\n\n\n\nD = [0] * (N+2)\n\nanswer = 1\n\nfor n in range(2,N+2):\n\n  D[n] = D[n-1] + L[n-1]\n\n  if D[n] <= X:\n\n    answer += 1\n\n    \n\nprint(answer)","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\n\n\nN,X,*L = list(map(int,read().split()))\n\n\n\nanswer = sum(x <= X for x in itertools.accumulate([0]+L))\n\nprint(answer)","model_generated_potentially_faster_code_col":"import sys\n\n# Faster input reading\ninput_data = sys.stdin.read().split()\nN, X = map(int, input_data[:2])\nL = [0] + list(map(int, input_data[2:]))\n\n# Initialize variables\ncumulative_sum = 0\nanswer = 1  # Start with the first position (index 0)\n\n# Iterate through the list and compute cumulative sums\nfor i in range(1, N + 1):\n    cumulative_sum += L[i]\n    if cumulative_sum <= X:\n        answer += 1\n\nprint(answer)"}
{"problem_id":"p02983","slow_code_col":"mod = 2019\n\nl, r = list(map(int, input().split()))\n\n\n\nif r\/\/mod - l\/\/mod > 0:\n\n  print((0))\n\nelse:\n\n  l %= mod\n\n  r %= mod\n\n  ans = mod\n\n  for i in range(l+1, r+1):\n\n    for j in range(l, i):\n\n      ans = min(i*j%mod, ans)\n\n    if ans == 0:\n\n      break\n\n  print(ans)","reference_code_col":"mod = 2019\n\nl, r = list(map(int, input().split()))\n\n\n\nif r\/\/mod - l\/\/mod > 0:\n\n  print((0))\n\nelse:\n\n  l %= mod\n\n  r %= mod\n\n  ans = mod\n\n  for i in range(l, r):\n\n    for j in range(i+1, r+1):\n\n      ans = min(i*j%mod, ans)\n\n    if ans == 0:\n\n      break\n\n  print(ans)","model_generated_potentially_faster_code_col":"mod = 2019\n\n# Input reading\nl, r = map(int, input().split())\n\n# Early exit if the range spans a multiple of mod\nif r \/\/ mod - l \/\/ mod > 0:\n    print(0)\nelse:\n    # Reduce range using modulo\n    l %= mod\n    r %= mod\n\n    # Ensure l <= r\n    if l > r:\n        l, r = r, l\n\n    # Initialize answer\n    ans = mod\n\n    # Iterate over all pairs (i, j) in the reduced range\n    for i in range(l, r + 1):\n        for j in range(l, i):  # Only consider j < i to avoid redundancy\n            product_mod = (i * j) % mod\n            ans = min(ans, product_mod)\n            if ans == 0:  # Early exit if 0 is found\n                break\n        if ans == 0:\n            break\n\n    print(ans)"}
{"problem_id":"p00053","slow_code_col":"prim=[True]*1000000\n\nprim[0],prim[1]=False,False\n\nfor i in range(2,1000):\n\n    if prim[i]:\n\n        for j in range(i*2,1000000,i):\n\n            prim[j]=False\n\nprime=[i for i,j in enumerate(prim) if j==True]\n\n\n\nwhile True:\n\n    n=int(eval(input()))\n\n    if n==0:\n\n        break\n\n    print((sum(prime[:n])))","reference_code_col":"prim=[True]*1000000\n\nprim[0]=prim[1]=False\n\nfor i in range(2,350):\n\n    if prim[i]:\n\n        for j in range(i*2,110000,i):\n\n            prim[j]=False\n\nprime=[i for i,j in enumerate(prim) if j==True]\n\n\n\nwhile True:\n\n    n=int(eval(input()))\n\n    if n==0:\n\n        break\n\n    print((sum(prime[:n])))","model_generated_potentially_faster_code_col":"# Step 1: Initialize the sieve\nMAX_LIMIT = 1000000\nprim = [True] * MAX_LIMIT\nprim[0], prim[1] = False, False\n\n# Step 2: Sieve of Eratosthenes optimization\nfor i in range(2, int(MAX_LIMIT**0.5) + 1):  # Only go up to sqrt(MAX_LIMIT)\n    if prim[i]:\n        for j in range(i * i, MAX_LIMIT, i):  # Start from i * i\n            prim[j] = False\n\n# Step 3: Generate the list of primes and their cumulative sums\nprime = [i for i, is_prime in enumerate(prim) if is_prime]\ncumulative_sum = [0] * (len(prime) + 1)\nfor i in range(len(prime)):\n    cumulative_sum[i + 1] = cumulative_sum[i] + prime[i]\n\n# Step 4: Process inputs efficiently\nwhile True:\n    try:\n        n = int(input())\n        if n == 0:\n            break\n        # Binary search to find the index where prime[i] <= n\n        left, right = 0, len(prime) - 1\n        while left <= right:\n            mid = (left + right) \/\/ 2\n            if prime[mid] <= n:\n                left = mid + 1\n            else:\n                right = mid - 1\n        # Sum of primes up to n is cumulative_sum[left]\n        print(cumulative_sum[left])\n    except EOFError:\n        break"}
{"problem_id":"p03037","slow_code_col":"n, m = list(map(int, input().split()))\n\ngate = []\n\nl, r = list(map(int, input().split()))\n\nfor i in range(1, m):\n\n    m, s = list(map(int, input().split()))\n\n    if l < m:\n\n        l = m\n\n    if s < r:\n\n        r = s\n\nprint((len([i for i in range(l, r + 1)])))","reference_code_col":"n, m = list(map(int, input().split()))\n\nl, r = [0] * m, [0] * m\n\nfor i in range(m):\n\n    l[i], r[i] = list(map(int, input().split()))\n\nprint((max(min(r) - max(l) + 1, 0)))","model_generated_potentially_faster_code_col":"# Read the initial input values\nn, m = map(int, input().split())\n\n# Initialize l_max and r_min with the first pair of inputs\nl_max, r_min = map(int, input().split())\n\n# Process the remaining (m-1) pairs\nfor _ in range(m - 1):\n    m_val, s_val = map(int, input().split())\n    if m_val > l_max:\n        l_max = m_val\n    if s_val < r_min:\n        r_min = s_val\n\n# Calculate the number of integers in the range [l_max, r_min]\nresult = max(0, r_min - l_max + 1)\n\n# Output the result\nprint(result)"}
{"problem_id":"p02596","slow_code_col":"K=int(eval(input()))\n\n\n\nif K%2==0:\n\n    print((-1))\n\n    exit(0)\n\n    \n\nans=[0]*(pow(10,6)+1)\n\nans[0]=0\n\n\n\nfor i in range(1,pow(10,6)):\n\n    ans[i]=(ans[i-1]*10+7)%K\n\n    if ans[i]==0:\n\n        print(i)\n\n        exit(0)\n\n\n\nprint((-1))","reference_code_col":"import functools\n\n\n\nK=int(eval(input()))\n\n \n\nif K%2==0:\n\n    print((-1))\n\n    exit(0)\n\n\n\nmod=0\n\n\n\nfor i in range(1,pow(10,6)):\n\n    mod=(mod*10+7)%K\n\n    if mod==0:\n\n        print(i)\n\n        exit(0)\n\n        \n\nprint((-1))","model_generated_potentially_faster_code_col":"K = int(input())\n\nif K % 2 == 0 or K % 5 == 0:\n    print(-1)\n    exit(0)\n\nremainder = 0\nfor i in range(1, 10**6 + 1):\n    remainder = (remainder * 10 + 7) % K\n    if remainder == 0:\n        print(i)\n        exit(0)\n\nprint(-1)"}
{"problem_id":"p02537","slow_code_col":"def segfunc(x, y): return max(x, y)\n\n\n\nclass SegmentTree:\n\n    def __init__(self, arr):\n\n        size = len(arr)\n\n        n = 2 ** (size - 1).bit_length()\n\n        self.n = n\n\n        self.node = [0] * (2*n)\n\n        for i in range(size):\n\n            self.node[i+n-1] = arr[i]\n\n        for i in reversed(list(range(n-2))):\n\n            self.node[i] = segfunc(self.node[2*i+1], self.node[2*i+2])\n\n\n\n    def update(self, i, x):\n\n        i += self.n - 1\n\n        self.node[i] = x\n\n        while i > 0:\n\n            i = (i - 1) \/\/ 2\n\n            self.node[i] = segfunc(self.node[i * 2 + 1], self.node[i * 2 + 2])\n\n\n\n    def update(self, x, val):\n\n        x += (self.n - 1)\n\n        self.node[x] = val\n\n        while x > 0:\n\n            x = (x - 1) \/\/ 2\n\n            self.node[x] = segfunc(self.node[2 * x + 1], self.node[2 * x + 2])\n\n\n\n    def query(self, a, b):\n\n        res = 0\n\n        l = self.n - 1 + a\n\n        r = self.n - 1 + (b - 1)\n\n\n\n        while l <= r:\n\n            if l == r:\n\n                res = segfunc(res, self.node[l])\n\n                break\n\n\n\n            if l % 2 == 0:\n\n                res = segfunc(res, self.node[l])\n\n            if r % 2 == 1:\n\n                res = segfunc(res, self.node[r])\n\n            l = l \/\/ 2\n\n            r = r \/\/ 2 - 1\n\n\n\n        return res\n\n\n\nN, K = list(map(int, input().split()))\n\nINF = 0\n\nseg = SegmentTree([0] * 300000)\n\nfor i in range(N):\n\n    a = int(eval(input()))\n\n    tmp = seg.query(max(a - K, 0), min(a + K, 300000) + 1) + 1\n\n    seg.update(a, tmp)\n\nprint((seg.query(0, 300000)))\n","reference_code_col":"def segfunc(x, y): return max(x, y)\n\ndef update(i, x):\n\n    i += MAX_N-1\n\n    node[i] = x\n\n    while i:\n\n        i = (i-1)\/\/2\n\n        node[i] = segfunc(node[i*2+1], node[i*2+2])\n\n\n\ndef query(l, r):\n\n    L = l + MAX_N\n\n    R = r + MAX_N\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = segfunc(s, node[R - 1])\n\n        if L & 1:\n\n            s = segfunc(s, node[L - 1])\n\n            L += 1\n\n        L >>= 1\n\n        R >>= 1\n\n    return s\n\n\n\nN, K = list(map(int, input().split()))\n\nMAX_N = 2**(300005).bit_length()\n\na = [int(eval(input())) for _ in range(N)]\n\nnode = [0] * (2 * MAX_N)\n\nINF = 0\n\nans = 0\n\n\n\n#for i in range(N):\n\n#    update(i, a[i])\n\n\n\nfor i in a:\n\n    tmp = query(max(i - K, 0), min(300005, i + K) + 1)\n\n    update(i, tmp + 1)\n\n    ans = max(ans, tmp + 1)\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"def segfunc(x, y):\n    return max(x, y)\n\n\nclass SegmentTree:\n    def __init__(self, arr):\n        # Initialize segment tree size\n        self.n = 1 << (len(arr) - 1).bit_length()  # Smallest power of 2 >= len(arr)\n        self.node = [0] * (2 * self.n)  # Initialize all nodes to 0\n\n        # Assign values to leaf nodes\n        for i in range(len(arr)):\n            self.node[self.n + i] = arr[i]\n\n        # Build the tree by propagating upwards\n        for i in range(self.n - 1, 0, -1):\n            self.node[i] = segfunc(self.node[2 * i], self.node[2 * i + 1])\n\n    def update(self, i, val):\n        # Update the value at index i\n        i += self.n  # Shift to the leaf node\n        self.node[i] = val\n        while i > 1:\n            i \/\/= 2  # Move to parent\n            self.node[i] = segfunc(self.node[2 * i], self.node[2 * i + 1])\n\n    def query(self, a, b):\n        # Query the maximum in the range [a, b)\n        res = 0\n        l, r = a + self.n, b + self.n  # Shift to leaf nodes\n\n        while l < r:\n            if l % 2 == 1:  # If l is a right child\n                res = segfunc(res, self.node[l])\n                l += 1\n            if r % 2 == 1:  # If r-1 is a left child\n                r -= 1\n                res = segfunc(res, self.node[r])\n            l \/\/= 2\n            r \/\/= 2\n\n        return res\n\n\n# Input handling\nN, K = map(int, input().split())\nINF = 0\nseg = SegmentTree([0] * 300000)\n\nfor _ in range(N):\n    a = int(input())  # Read input as integer\n    tmp = seg.query(max(a - K, 0), min(a + K, 300000)) + 1\n    seg.update(a, tmp)\n\nprint(seg.query(0, 300000))"}
{"problem_id":"p03037","slow_code_col":"N,M = list(map(int, input().split()))\n\nL = []\n\nR = []\n\nfor _ in range(M):\n\n  l,r = list(map(int, input().split()))\n\n  L.append(l)\n\n  R.append(r)\n\n\n\nans = min(R)-max(L)+1\n\nif ans < 0:\n\n  print((0))\n\nelse:\n\n  print(ans)\n\n  ","reference_code_col":"n,m = list(map(int, input().split()))\n\nmax_l = float(\"-inf\")\n\nmin_r = float(\"inf\")\n\nfor _ in range(m):\n\n  l,r = list(map(int, input().split()))\n\n  max_l = max(max_l, l)\n\n  min_r = min(min_r, r)\n\nans = min_r - max_l + 1\n\nif ans > 0:\n\n  print(ans)\n\nelse:\n\n  print((0))","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Read N and M\n    N, M = map(int, sys.stdin.readline().split())\n    \n    # Initialize max_l and min_r\n    max_l = float('-inf')\n    min_r = float('inf')\n    \n    # Process each pair of l and r\n    for _ in range(M):\n        l, r = map(int, sys.stdin.readline().split())\n        \n        # Update max_l and min_r on the fly\n        max_l = max(max_l, l)\n        min_r = min(min_r, r)\n        \n        # Early termination if min_r < max_l\n        if min_r < max_l:\n            print(0)\n            return\n    \n    # Compute the final result\n    ans = min_r - max_l + 1\n    print(max(ans, 0))\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02595","slow_code_col":"from decimal import *\n\ngetcontext().prec = 14\n\n\n\nN, D = list(map(int, input().split()))\n\n\n\n\n\ndef distance(x1, x2, y1, y2):\n\n    dx = x2-x1\n\n    dy = y2-y1\n\n    return (dx*dx + dy*dy).sqrt()\n\n\n\n\n\nX = [0] * N\n\nY = [0] * N\n\nans = 0\n\nfor i in range(N):\n\n    X[i], Y[i] = list(map(Decimal, input().split()))\n\n    if (distance(0, X[i], 0, Y[i]) <= D):\n\n        ans += 1\n\n\n\nprint(ans)\n","reference_code_col":"from decimal import *\n\ngetcontext().prec = 14  # \u3042\u3093\u307e\u308a\u5927\u304d\u3044\u3068\u8a08\u7b97\u9045\u3044\u304b\u3082\n\n\n\nN, D = list(map(int, input().split()))\n\n\n\ndef distance(x1, x2, y1, y2):\n\n    dx = x2-x1\n\n    dy = y2-y1\n\n    return (dx*dx + dy*dy).sqrt()\n\n\n\nans = 0\n\nfor i in range(N):\n\n    X, Y = list(map(Decimal, input().split()))\n\n    if (distance(0, X, 0, Y) <= D):\n\n        ans += 1\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"# Optimize performance by avoiding Decimal and reducing redundant computations\n\nN, D = map(int, input().split())\nD_squared = D * D  # Precompute squared radius for comparison\n\nans = 0\n\nfor _ in range(N):\n    x, y = map(float, input().split())  # Use float instead of Decimal\n    if x * x + y * y <= D_squared:     # Compare squared distances\n        ans += 1\n\nprint(ans)"}
{"problem_id":"p03325","slow_code_col":"N = int(eval(input()))\n\n\n\nseq = list(map(int, input().split()))\n\n\n\ncnt = 0\n\n\n\nfor num in seq:\n\n    while num % 2 == 0:\n\n        cnt += 1\n\n        num \/= 2\n\n\n\nprint(cnt)\n","reference_code_col":"n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nans = 0\n\nfor num in a:\n\n    ans += format(num, 'b')[::-1].find('1')\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(input())  # Read the size of the sequence\ncnt = 0           # Initialize the counter\n\n# Process each number in the sequence\nfor _ in range(N):\n    num = int(input())  # Read each number\n    while num & 1 == 0:  # Check if the number is even\n        cnt += 1         # Increment the counter\n        num >>= 1        # Right-shift the number (equivalent to dividing by 2)\n\nprint(cnt)"}
{"problem_id":"p03371","slow_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n# input = sys.stdin.readline    ####\n\nint1 = lambda x: int(x) - 1\n\ndef II(): return int(eval(input()))\n\n\n\ndef MI(): return list(map(int, input().split()))\n\ndef MI1(): return list(map(int1, input().split()))\n\n\n\ndef LI(): return list(map(int, input().split()))\n\ndef LI1(): return list(map(int1, input().split()))\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n\n\ndef printlist(lst, k='\\n'): print((k.join(list(map(str, lst)))))\n\nINF = float('inf')\n\n\n\ndef solve():\n\n    a, b, c, x, y = MI()\n\n\n\n    ans = INF\n\n    for k in range(100001):\n\n        yen = 2 * c * k + max(0, x-k) * a + max(0, y-k) * b\n\n        ans = min(ans, yen)\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n","reference_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n# input = sys.stdin.readline    ####\n\nint1 = lambda x: int(x) - 1\n\ndef II(): return int(eval(input()))\n\n\n\ndef MI(): return list(map(int, input().split()))\n\ndef MI1(): return list(map(int1, input().split()))\n\n\n\ndef LI(): return list(map(int, input().split()))\n\ndef LI1(): return list(map(int1, input().split()))\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n\n\ndef printlist(lst, k='\\n'): print((k.join(list(map(str, lst)))))\n\nINF = float('inf')\n\n\n\ndef solve():\n\n    a, b, c, x, y = MI()\n\n\n\n    ans = 0\n\n    if a + b <= 2 * c:\n\n        mn = min(x, y)\n\n        ans = a * mn + b * mn + max(0, x-mn) * min(a, 2*c) + max(0, y-mn) * min(b, 2*c)\n\n\n\n    else:\n\n        mn = min(x, y)\n\n        ans = mn * 2 * c + max(0, x-mn) * min(a, 2*c) + max(0, y-mn) * min(b, 2*c)\n\n\n\n    print(ans)\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n","model_generated_potentially_faster_code_col":"def solve():\n    # Input values\n    a, b, c, x, y = map(int, input().split())\n    \n    # Initialize the answer with a very large value\n    ans = float('inf')\n    \n    # Only iterate up to min(x, y) + 1\n    max_k = min(x, y) + 1\n    \n    for k in range(max_k):\n        # Calculate the cost for the current k\n        yen = 2 * c * k + max(0, x - k) * a + max(0, y - k) * b\n        # Update the minimum cost\n        ans = min(ans, yen)\n    \n    # Check the case where we buy more combos than needed\n    if x < y:\n        ans = min(ans, 2 * c * x + (y - x) * b)\n    elif y < x:\n        ans = min(ans, 2 * c * y + (x - y) * a)\n    else:\n        ans = min(ans, 2 * c * x)\n    \n    # Output the result\n    print(ans)\n\nif __name__ == '__main__':\n    solve()"}
{"problem_id":"p03796","slow_code_col":"import math\n\nn = int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))","reference_code_col":"n = int(eval(input()))\n\nans = 1\n\nmod = 10**9+7\n\nfor i in range(1, n+1):\n\n    ans *= i\n\n    ans %= mod\n\n\n\nans %= mod\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\nn = int(input())  # Avoid using eval; directly convert input to int\n\nif n >= MOD:\n    # If n >= MOD, factorial(n) will include MOD as a factor, making the result 0 modulo MOD\n    print(0)\nelse:\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % MOD  # Apply modulus at each step\n    print(result)"}
{"problem_id":"p03845","slow_code_col":"n,t=int(input()),list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n","reference_code_col":"input();t=list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Fast input reading\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse n and t\n    n = int(data[0])\n    t = list(map(int, data[1:n+1]))\n    T = sum(t)\n    \n    # Parse the number of queries\n    q_index = n + 1\n    q = int(data[q_index])\n    \n    # Process queries directly without intermediate lists\n    result = []\n    for i in range(q):\n        idx, j = map(int, data[q_index + 1 + 2 * i:q_index + 1 + 2 * i + 2])\n        result.append(str(T - t[idx - 1] + j))\n    \n    # Print all results at once\n    print('\\n'.join(result))\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03363","slow_code_col":"n = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nS = [0]*(n+1)\n\nnum={}\n\nfor i in range(n):\n\n    S[i+1] = S[i] + A[i]\n\nfor i in S:\n\n    if str(i) in list(num.keys()):\n\n        num[str(i)] += 1\n\n    else:\n\n        num[str(i)] = 1\n\nout = [i*(i-1)\/\/2 for i in list(num.values()) if i>1]\n\nprint((sum(out)))","reference_code_col":"n = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nS = [0]*(n+1)\n\nnum = {}\n\nfor i in range(n):\n\n    S[i+1] = S[i] + A[i]\n\nfor i in S:\n\n    s = str(i)\n\n    num[s] = 1 if s not in list(num.keys()) else num[s]+1\n\nout = [i*(i-1)\/\/2 for i in list(num.values()) if i > 1]\n\nprint((sum(out)))","model_generated_potentially_faster_code_col":"from collections import defaultdict\n\n# Input parsing\nn = int(input())\nA = list(map(int, input().split()))\n\n# Compute prefix sums\nS = [0] * (n + 1)\nfor i in range(n):\n    S[i + 1] = S[i] + A[i]\n\n# Count frequencies of prefix sums\nnum = defaultdict(int)\nfor i in S:\n    num[i] += 1\n\n# Compute the result\nresult = sum(count * (count - 1) \/\/ 2 for count in num.values() if count > 1)\n\n# Output the result\nprint(result)"}
{"problem_id":"p02555","slow_code_col":"def resolve():\n\n  base = 10**9+7\n\n  S = int(eval(input()))\n\n  dp = [0] * (S+1)\n\n  dp[0] = 1\n\n\n\n  for i in range(1, S+1):\n\n    for u in range(i-2):\n\n      dp[i] += dp[u]\n\n      dp[i] %= base\n\n  # print(dp)\n\n  print((dp[S]%base))\n\n\n\nif __name__ == \"__main__\":\n\n  resolve()\n","reference_code_col":"def resolve():\n\n  base = 10**9+7\n\n  S = int(eval(input()))\n\n  dp = [0] * (S+1)\n\n  dp[0] = 1\n\n\n\n  for i in range(3, S+1):\n\n    dp[i] = dp[i-1] + dp[i-3]\n\n  # print(dp)\n\n  print((dp[S]%base))\n\n\n\nif __name__ == \"__main__\":\n\n  resolve()","model_generated_potentially_faster_code_col":"def resolve():\n    base = 10**9 + 7\n\n    S = int(eval(input()))\n\n    # Initialize dp array\n    dp = [0] * (S + 1)\n    dp[0] = 1\n\n    # Cumulative sum to store the sum of dp[u] for u <= i-3\n    cumulative_sum = 0\n\n    for i in range(1, S + 1):\n        if i >= 3:\n            cumulative_sum += dp[i - 3]\n            cumulative_sum %= base\n\n        dp[i] = cumulative_sum\n\n    print(dp[S] % base)\n\n\nif __name__ == \"__main__\":\n    resolve()"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nA = np.array(A)\n\ncount = 0\n\nwhile 1:\n\n    x = 0\n\n    for i in range(N):\n\n        if A[i] % 2 == 1:\n\n            x = 1\n\n    if x == 1:\n\n        break\n\n    else:\n\n        A = A \/ 2\n\n        count+=1\n\nprint(count)","reference_code_col":"import math\n\nn = eval(input())\n\na = list(map(int, input().split()))\n\nans = float('inf')\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind('1') - 1)\n\nprint((round(ans)))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input efficiently\nN = int(input())\nA = np.fromstring(input(), dtype=int, sep=' ')\n\n# Compute the number of trailing zeros (divisions by 2) for each element\ntrailing_zeros = np.vectorize(lambda x: (x & -x).bit_length() - 1)(A)\n\n# The result is the minimum number of divisions across all elements\nprint(trailing_zeros.min())"}
{"problem_id":"p03796","slow_code_col":"n = int(eval(input()))\n\nres = 1\n\nfor num in range(1, n+1):\n\n  res = res * num\n\n  res = res % (pow(10,9) + 7)\n\nprint(res)","reference_code_col":"n = int(eval(input()))\n\nres = 1\n\nfor num in range(1, n+1):\n\n    res = res * num\n\n    res = res % (10**9 + 7)\n\nprint(res)\n","model_generated_potentially_faster_code_col":"# Precompute the modulus value\nMOD = 10**9 + 7\n\n# Read input as an integer directly\nn = int(input())\n\n# Initialize the result\nres = 1\n\n# Compute factorial with modular arithmetic\nfor num in range(1, n + 1):\n    res = (res * num) % MOD\n\n# Print the result\nprint(res)"}
{"problem_id":"p03371","slow_code_col":"#!\/usr\/bin\/env python3\n\nimport sys, math, fractions, itertools\n\n\n\n\n\ndef solve(A: int, B: int, C: int, X: int, Y: int):\n\n    mn = 1e9\n\n    for i in range(0, 2*(max(X, Y)+1), 2):\n\n        mn = min(mn, C*i+A*max(X-i\/\/2, 0)+B*max(Y-i\/\/2, 0))\n\n    print((int(mn)))\n\n    return\n\n\n\n\n\n# Generated by 1.1.4 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    A = int(next(tokens))  # type: int\n\n    B = int(next(tokens))  # type: int\n\n    C = int(next(tokens))  # type: int\n\n    X = int(next(tokens))  # type: int\n\n    Y = int(next(tokens))  # type: int\n\n    solve(A, B, C, X, Y)\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\n\n\n\n\n\ndef solve(A: int, B: int, C: int, X: int, Y: int):\n\n    c = 0\n\n    if (A + B < 2 * C):\n\n        c += min(X, Y) * (A + B)\n\n    else:\n\n        c += min(X, Y) * 2 * C\n\n    if X > Y:\n\n        c += (X - Y) * min(A, 2 * C)\n\n    else:\n\n        c += (Y - X) * min(B, 2 * C)\n\n    print(c)\n\n    return\n\n\n\n\n\n# Generated by 1.1.5 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    A = int(next(tokens))  # type: int\n\n    B = int(next(tokens))  # type: int\n\n    C = int(next(tokens))  # type: int\n\n    X = int(next(tokens))  # type: int\n\n    Y = int(next(tokens))  # type: int\n\n    solve(A, B, C, X, Y)\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\n\n\ndef solve(A: int, B: int, C: int, X: int, Y: int):\n    # Evaluate the cost function at critical points\n    def cost(i):\n        return C * i + A * max(X - i \/\/ 2, 0) + B * max(Y - i \/\/ 2, 0)\n\n    # Critical points to evaluate\n    candidates = [0, 2 * min(X, Y), 2 * X, 2 * Y]\n\n    # Calculate the minimum cost\n    mn = min(cost(i) for i in candidates)\n\n    print(int(mn))\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n\n    tokens = iterate_tokens()\n    A = int(next(tokens))  # Cost of pizza A\n    B = int(next(tokens))  # Cost of pizza B\n    C = int(next(tokens))  # Cost of combined pizza\n    X = int(next(tokens))  # Required quantity of pizza A\n    Y = int(next(tokens))  # Required quantity of pizza B\n\n    solve(A, B, C, X, Y)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02917","slow_code_col":"N = int(eval(input()))\n\nB =list(map(int,input().split()))\n\nA=[0]*N\n\n\n\nA[0]=B[0]\n\nfor i in range(1,N-1):\n\n    A[i]=min(B[i],B[i-1])\n\nA[-1]=B[-1]\n\nprint((sum(A)))","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N=I()\n\n    B=LI()\n\n    A=[0]*N\n\n    A[0]=B[0]\n\n    A[-1]=B[-1]\n\n    for i in range(N-2):\n\n        A[i+1]=min(B[i],B[i+1])\n\n        \n\n    print((sum(A)))\n\n\n\nmain()\n","model_generated_potentially_faster_code_col":"# Read inputs\nN = int(input())\nB = list(map(int, input().split()))\n\n# Initialize variables for sum calculation\ntotal_sum = B[0]  # Start with A[0] = B[0]\n\n# Compute A[i] for i in [1, N-2] and accumulate the sum\nfor i in range(1, N - 1):\n    total_sum += min(B[i], B[i - 1])\n\n# Add the last element A[-1] = B[-1]\nif N > 1:  # Ensure there is a last element to add\n    total_sum += B[-1]\n\n# Print the result\nprint(total_sum)"}
{"problem_id":"p02700","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\nA, B, C, D = list(map(int, input().split()))\n\n\n\nwhile True:\n\n    C -= B\n\n    \n\n    if C<=0:\n\n        print('Yes')\n\n        exit()\n\n    \n\n    A -= D\n\n    \n\n    if A<=0:\n\n        print('No')\n\n        exit()","reference_code_col":"A, B, C, D = list(map(int, input().split()))\n\nc1 = (C+B-1)\/\/B\n\nc2 = (A+D-1)\/\/D\n\n\n\nif c1<=c2:\n\n    print('Yes')\n\nelse:\n\n    print('No')","model_generated_potentially_faster_code_col":"import sys\nfrom math import ceil\n\ninput = sys.stdin.readline\n\n# Read input values\nA, B, C, D = map(int, input().split())\n\n# Calculate the number of turns for each entity to be defeated\nturns_to_defeat_C = ceil(C \/ B)\nturns_to_defeat_A = ceil(A \/ D)\n\n# Compare the turns and print the result\nif turns_to_defeat_C <= turns_to_defeat_A:\n    print('Yes')\nelse:\n    print('No')"}
{"problem_id":"p03575","slow_code_col":"icase=0\n\nif icase==0:\n\n    n,m=list(map(int, input().split()))\n\n    a=[]\n\n    b=[]\n\n    for i in range(m):\n\n        ai,bi=list(map(int, input().split()))\n\n        a.append(ai)\n\n        b.append(bi)\n\nelif icase==1:\n\n    n=6\n\n    m=5\n\n#    a=[[1],[2],[3],[4],[5]]\n\n#    b=[[2],[3],[4],[5],[6]]\n\n    a=[1,2,3,4,5]\n\n    b=[2,3,4,5,6]\n\nelif icase==2:\n\n    n=7\n\n    m=7\n\n    a=[1,2,3,4,4,5,6]\n\n    b=[3,7,4,5,6,6,7]\n\n\n\n    \n\nvtx=[]\n\nfor i in range(n):\n\n    vtx.append([i+1])\n\nicnt=0\n\n\n\nfor j in range(m):    \n\n    vtx1=vtx.copy()\n\n    a1=a.copy()\n\n    b1=b.copy()\n\n    del a1[j]\n\n    del b1[j]\n\n    \n\n    for i in range(m-1):\n\n        for v1 in vtx1:\n\n            if a1[i] in v1:\n\n                if not b1[i] in v1:\n\n                    for v2 in vtx1:\n\n                        if v1!=v2:\n\n                            if b1[i] in v2:\n\n                                break\n\n                    vtx1.remove(v1)\n\n                    vtx1.remove(v2)\n\n                    v3=v1+v2\n\n                    vtx1.append(v3)\n\n#        print(a[i],b[i],len(vtx1),vtx1)\n\n#    print(len(vtx1),vtx1)\n\n    if len(vtx1)!=1:\n\n        icnt=icnt+1\n\nprint(icnt)        ","reference_code_col":"limit=50\n\ngraph=[[False]*limit for i in range(limit)]\n\nvisited=[]*limit\n\n\n\ndef dfs(v,n,graph,visited):\n\n    visited[v]=True\n\n    for v2 in range(n):\n\n        if graph[v][v2]==False:\n\n            continue\n\n        if visited[v2]==True:\n\n            continue\n\n        dfs(v2,n,graph,visited)\n\n\n\nn,m=list(map(int,input().split()))\n\na=[0]*m\n\nb=[0]*m\n\nfor i in range(m):\n\n    ai,bi=list(map(int,input().split()))\n\n    a[i]=ai-1\n\n    b[i]=bi-1\n\n    graph[a[i]][b[i]]=True\n\n    graph[b[i]][a[i]]=True\n\n    \n\nans=0 \n\nfor i in range(m):\n\n    graph[a[i]][b[i]]=False\n\n    graph[b[i]][a[i]]=False\n\n    visited=[False]*n\n\n    dfs(0,n,graph,visited)\n\n    bridge=False\n\n    for j in range(n):\n\n        if visited[j]==False:\n\n            bridge=True\n\n    if bridge:\n\n        ans+=1\n\n    graph[a[i]][b[i]]=True\n\n    graph[b[i]][a[i]]=True\n\n    \n\nprint(ans)","model_generated_potentially_faster_code_col":"class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n + 1))  # 1-based indexing\n        self.rank = [1] * (n + 1)\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])  # Path compression\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x != root_y:\n            # Union by rank\n            if self.rank[root_x] > self.rank[root_y]:\n                self.parent[root_y] = root_x\n            elif self.rank[root_x] < self.rank[root_y]:\n                self.parent[root_x] = root_y\n            else:\n                self.parent[root_y] = root_x\n                self.rank[root_x] += 1\n\ndef count_critical_edges(n, m, a, b):\n    icnt = 0\n\n    for j in range(m):\n        uf = UnionFind(n)\n        \n        # Build the graph excluding edge (a[j], b[j])\n        for i in range(m):\n            if i != j:\n                uf.union(a[i], b[i])\n        \n        # Check if the graph is still connected\n        root = uf.find(1)\n        for node in range(2, n + 1):\n            if uf.find(node) != root:\n                icnt += 1\n                break\n\n    return icnt\n\n# Input handling\nicase = 0\n\nif icase == 0:\n    n, m = map(int, input().split())\n    a = []\n    b = []\n    for _ in range(m):\n        ai, bi = map(int, input().split())\n        a.append(ai)\n        b.append(bi)\nelif icase == 1:\n    n = 6\n    m = 5\n    a = [1, 2, 3, 4, 5]\n    b = [2, 3, 4, 5, 6]\nelif icase == 2:\n    n = 7\n    m = 7\n    a = [1, 2, 3, 4, 4, 5, 6]\n    b = [3, 7, 4, 5, 6, 6, 7]\n\n# Compute and print the result\nprint(count_critical_edges(n, m, a, b))"}
{"problem_id":"p03060","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nV = np.array([int(i) for i in input().split(\" \")])\n\nC = np.array([int(i) for i in input().split(\" \")])\n\n\n\nvc = V-C\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    if vc[i]>0:\n\n        val+=vc[i]\n\nprint(val)","reference_code_col":"N = int(eval(input()))\n\nV = [int(i) for i in input().split(\" \")]\n\nC = [int(i) for i in input().split(\" \")]\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    vc=V[i]-C[i]\n\n    if vc>0:\n\n        val+=vc\n\nprint(val)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN = int(input())\nV = np.fromstring(input(), dtype=int, sep=' ')\nC = np.fromstring(input(), dtype=int, sep=' ')\n\n# Compute V - C\nvc = V - C\n\n# Use boolean indexing to sum only positive values\nval = np.sum(vc[vc > 0])\n\n# Print the result\nprint(val)"}
{"problem_id":"p02394","slow_code_col":"a=input().split()\n\nb=list(map(int,a))\n\nW=b[0]\n\nH=b[1]\n\nx=b[2]\n\ny=b[3]\n\nr=b[4]\n\nif (r <= x <= (W - r)) and (r <= y <= (H - r)):\n\n  print('Yes')\n\nelse:\n\n  print('No')","reference_code_col":"W,H,x,y,r = [int(i) for i in input().split()]\n\nif (r <= x <= (W - r)) and (r <= y <= (H - r)):\n\n  print('Yes')\n\nelse:\n\n  print('No')","model_generated_potentially_faster_code_col":"# Read input as a single line and split into integers directly\nW, H, x, y, r = map(int, input().split())\n\n# Check the condition and print the result\nif r <= x <= W - r and r <= y <= H - r:\n    print('Yes')\nelse:\n    print('No')"}
{"problem_id":"p02394","slow_code_col":"ia = [int(i) for i in input().split(\" \")]\n\nW=ia[0]\n\nH=ia[1]\n\nx=ia[2]\n\ny=ia[3]\n\nr=ia[4]\n\nprint((\"Yes\" if 0<=x-r and x+r<=W and 0<=y-r and y+r<=H else \"No\"))","reference_code_col":"# encoding:utf-8\n\n\n\ninput = list(map(int, input().split()))\n\nW, H, x, y, r = input\n\n\n\nif x - r < 0 or x + r > W:\n\n\tprint(\"No\")\n\nelif y - r < 0 or y + r > H:\n\n\tprint(\"No\")\n\nelse:\n\n\tprint(\"Yes\")","model_generated_potentially_faster_code_col":"# Read input and parse integers directly into variables\nW, H, x, y, r = map(int, input().split())\n\n# Check if the circle fits within the rectangle and print the result\nprint(\"Yes\" if 0 <= x - r and x + r <= W and 0 <= y - r and y + r <= H else \"No\")"}
{"problem_id":"p03457","slow_code_col":"N=eval(input())\n\na=[]\n\nt=True\n\nfor _ in range(int(N)):\n\n    a+=[list(map(int,input().split()))]\n\nfor i in range(int(N)):\n\n    if a[i][0]%2==0:\n\n        if abs(a[i][1]+a[i][2])<=a[i][0] and (a[i][1]+a[i][2])%2==0:\n\n            continue\n\n        else:\n\n            print('No')\n\n            t=False\n\n            break\n\n    else:\n\n        if abs(a[i][1]+a[i][2]<=a[i][0]) and (a[i][1]+a[i][2])%2==1:\n\n            continue\n\n        else:\n\n            print('No')\n\n            t=False\n\n            break\n\nif t:\n\n    print('Yes')","reference_code_col":"import sys\n\nn=int(eval(input()))\n\nt=[]\n\nfor i in range(n):\n\n    t.append(list(map(int,input().split())))\n\nfor i,d in enumerate(t):\n\n    if i>0:\n\n        b=d[0]-a\n\n        c=abs(d[1]+d[2]-aa)\n\n    a=d[0]\n\n    aa=d[1]+d[2]\n\n    if i==0:\n\n        if not (a >= aa and a % 2 == aa % 2):\n\n            print('No')\n\n            sys.exit()\n\n        else:\n\n            continue\n\n    if not (b>=c and b%2==c%2):\n\n        print('No')\n\n        sys.exit()\n\nprint('Yes')","model_generated_potentially_faster_code_col":"# Read the number of test cases\nN = int(input())\n\nresult = \"Yes\"  # Assume the result is \"Yes\" initially\n\nfor _ in range(N):\n    # Read and process each input line directly\n    x, y, z = map(int, input().split())\n    total = y + z  # Precompute the sum of y and z\n\n    if x % 2 == 0:  # If x is even\n        if abs(total) <= x and total % 2 == 0:\n            continue\n        else:\n            result = \"No\"\n            break\n    else:  # If x is odd\n        if abs(total) <= x and total % 2 == 1:\n            continue\n        else:\n            result = \"No\"\n            break\n\n# Print the final result\nprint(result)"}
{"problem_id":"p03371","slow_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\n\n\nyenmin=a*x+b*y\n\nfor zz in range(2*10**5+1):\n\n    xx=max(x-zz\/\/2,0)\n\n    yy=max(y-zz\/\/2,0)\n\n    yen=a*xx+b*yy+c*zz\n\n    if yen<yenmin:\n\n        yenmin=yen\n\nprint(yenmin)\n\n#print(xx,yy,zz)","reference_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\n\n\ncmax=max(x,y)*2\n\nzmin=(a+b)*10**5\n\nfor nc in range(0,cmax+1,2):\n\n    na=max(x-nc\/\/2,0)\n\n    nb=max(y-nc\/\/2,0)\n\n    z=a*na+b*nb+c*nc\n\n    zmin=min(zmin,z)\n\n    \n\nprint(zmin)\n","model_generated_potentially_faster_code_col":"# Input parsing\na, b, c, x, y = map(int, input().split())\n\n# Initial cost without any reduction\nyenmin = a * x + b * y\n\n# Early termination condition: stop when both xx and yy are zero\nmax_reduction = 2 * max(x, y)  # Maximum possible reductions needed\n\nfor zz in range(max_reduction + 1):\n    xx = max(x - zz \/\/ 2, 0)\n    yy = max(y - zz \/\/ 2, 0)\n    \n    # Calculate the total cost\n    yen = a * xx + b * yy + c * zz\n    \n    # Update the minimum cost if the current cost is lower\n    if yen < yenmin:\n        yenmin = yen\n\nprint(yenmin)"}
{"problem_id":"p02772","slow_code_col":"import sys\n\nimport numpy as np\n\nn = int(eval(input()))\n\ninput = sys.stdin.readline\n\na = np.array(list(map(int, input().split())))\n\nfor i in a:\n\n    if i % 2 == 0:\n\n        if i % 3 != 0 and i % 5 != 0:\n\n            print('DENIED')\n\n            exit()\n\nprint('APPROVED')\n","reference_code_col":"#import sys\n\n#import numpy as np\n\nn = int(eval(input()))\n\n#input = sys.stdin.readline\n\n#a = np.array(list(map(int, input().split())))\n\na = list(map(int, input().split()))\n\nfor i in a:\n\n    if i % 2 == 0:\n\n        if i % 3 != 0 and i % 5 != 0:\n\n            print('DENIED')\n\n            exit()\n\nprint('APPROVED')\n","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Read the number of elements (not used in logic, so skip processing)\n    n = int(sys.stdin.readline())\n    \n    # Read the array of integers\n    a = list(map(int, sys.stdin.readline().split()))\n    \n    # Check for the denied condition\n    for i in a:\n        if i % 2 == 0 and i % 3 != 0 and i % 5 != 0:\n            print('DENIED')\n            return\n    \n    # If no denied condition is found, print APPROVED\n    print('APPROVED')\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03837","slow_code_col":"import queue\n\n\n\nINF = 123456789\n\n\n\ndef main():\n\n    n,m = list(map(int,input().split()))\n\n\n\n    G = [[] for _ in range(n)]\n\n    for _ in range(m):\n\n        a,b,c = list(map(int,input().split()))\n\n        a -= 1\n\n        b -= 1\n\n        G[a].append((b,c))\n\n        G[b].append((a,c))\n\n\n\n    used = set()\n\n    for i in range(n):\n\n        d = [INF for _ in range(n)]\n\n        par = [-1 for _ in range(n)]\n\n\n\n        # dijkstra\n\n        que = queue.PriorityQueue()\n\n        d[i] = 0\n\n        que.put((0,i))\n\n        while not que.empty():\n\n            p = que.get()\n\n            v = p[1]\n\n            if d[v] < p[0]:\n\n                continue\n\n            for (to,cost) in G[v]:\n\n                if d[to] > d[v]+cost:\n\n                    d[to] = d[v]+cost\n\n                    par[to] = v\n\n                    que.put((d[to],to))\n\n\n\n        for j in range(n):\n\n            if i != j:\n\n                a,b = j,par[j]\n\n                if a>b:\n\n                    a,b = b,a\n\n                used.add((a,b))\n\n\n\n    print((m - len(used)))\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"INF = 123456789\n\n\n\ndef main():\n\n    n,m = list(map(int,input().split()))\n\n\n\n    d = [ [INF for i in range(n)] for j in range(n) ]\n\n    for i in range(n):\n\n        d[i][i] = 0\n\n\n\n    a = [0 for _ in range(m)]\n\n    b = [0 for _ in range(m)]\n\n    c = [0 for _ in range(m)]\n\n    for i in range(m):\n\n        a[i],b[i],c[i] = list(map(int,input().split()))\n\n        a[i] -= 1\n\n        b[i] -= 1\n\n        d[a[i]][b[i]] = min(d[a[i]][b[i]], c[i])\n\n        d[b[i]][a[i]] = min(d[b[i]][a[i]], c[i])\n\n\n\n    # Warshall-Floyd\n\n    for k in range(n):\n\n        for i in range(n):\n\n            for j in range(n):\n\n                d[i][j] = min(d[i][j], d[i][k]+d[k][j])\n\n\n\n    ans = 0\n\n    for i in range(m):\n\n        found = 1\n\n        for j in range(n):\n\n            if d[j][a[i]] + c[i] == d[j][b[i]]:\n\n                found = 0\n\n                break\n\n        ans += found\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import heapq\n\nINF = 123456789\n\ndef main():\n    n, m = map(int, input().split())\n\n    # Adjacency list representation of the graph\n    G = [[] for _ in range(n)]\n    edges = []  # To store edges for marking usage\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        a -= 1\n        b -= 1\n        G[a].append((b, c))\n        G[b].append((a, c))\n        edges.append((a, b))\n\n    # Track whether each edge is used in any shortest path\n    used_edges = [False] * m\n\n    def dijkstra(start):\n        d = [INF] * n\n        par = [-1] * n\n\n        # Min-heap for Dijkstra's algorithm\n        heap = [(0, start)]  # (distance, node)\n        d[start] = 0\n\n        while heap:\n            dist, v = heapq.heappop(heap)\n\n            # Skip outdated entries in the heap\n            if d[v] < dist:\n                continue\n\n            # Process neighbors\n            for to, cost in G[v]:\n                if d[to] > d[v] + cost:\n                    d[to] = d[v] + cost\n                    par[to] = v\n                    heapq.heappush(heap, (d[to], to))\n\n        # Mark edges used in the shortest paths\n        for j in range(n):\n            if j != start:\n                parent = par[j]\n                while parent != -1:\n                    # Find the edge index\n                    edge_idx = -1\n                    if (parent, j) in edges:\n                        edge_idx = edges.index((parent, j))\n                    elif (j, parent) in edges:\n                        edge_idx = edges.index((j, parent))\n                    \n                    if edge_idx != -1 and not used_edges[edge_idx]:\n                        used_edges[edge_idx] = True\n                    parent = par[parent]\n\n    # Run Dijkstra for each node\n    for i in range(n):\n        dijkstra(i)\n\n    # Count unused edges\n    unused_count = sum(1 for used in used_edges if not used)\n    print(unused_count)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03416","slow_code_col":"a,b = list(map(int,input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    s = str(i)\n\n    l = len(s)\n\n    if all(s[j] == s[l-j-1] for j in range(l)):\n\n            count += 1\n\nprint(count)","reference_code_col":"a,b = list(map(int,input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    s = str(i)\n\n    if s == s[::-1]:\n\n         count += 1\n\nprint(count)","model_generated_potentially_faster_code_col":"def count_palindromes(a, b):\n    count = 0\n\n    for num in range(a, b + 1):\n        # Convert number to string only once\n        s = str(num)\n        # Check if the string is a palindrome using slicing\n        if s == s[::-1]:\n            count += 1\n\n    return count\n\n# Input handling\na, b = map(int, input().split())\nprint(count_palindromes(a, b))"}
{"problem_id":"p03575","slow_code_col":"\n\nclass UnionFind:\n\n    def __init__(self, size):\n\n        self.table = [i for i in range(size)]\n\n\n\n    def find(self, x):\n\n        return self.table[x]\n\n\n\n    def union(self, x, y):\n\n        x1 = self.find(x)\n\n        y1 = self.find(y)\n\n\n\n        if x1 == y1:\n\n            return False\n\n\n\n        for i in range(len(self.table)):\n\n            if self.table[i] == y1:\n\n                self.table[i] = x1\n\n        return True\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nedges = []\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1])\n\n\n\nmat = [[0]*N for _ in range(N)]\n\nfor s, g in edges:\n\n    mat[s][g] = 1\n\n    mat[g][s] = 1\n\n\n\nans = 0\n\n\n\nfor i in range(M):\n\n    uni = UnionFind(N)\n\n\n\n    for j in range(M):\n\n        if i != j:\n\n            uni.union(edges[j][0], edges[j][1])\n\n\n\n    if not all(uni.find(0) == uni.find(x) for x in range(N)):\n\n        ans += 1\n\nprint(ans)\n","reference_code_col":"# python template for atcoder1\n\nimport sys\n\nsys.setrecursionlimit(10**9)\n\ninput = sys.stdin.readline\n\n\n\n\n\nclass UnionFind:\n\n    def __init__(self, size):\n\n        \"\"\"\n\n        size:\u9802\u70b9\u306e\u6570\n\n        \"\"\"\n\n        self.parent = [i for i in range(size)]\n\n        self.rank = [0 for _ in range(size)]\n\n\n\n    def find(self, x):\n\n        \"\"\"\n\n        x\u306eroot\u3092\u8fd4\u3059\n\n        \"\"\"\n\n        if self.parent[x] == x:\n\n            return x\n\n        else:\n\n            return self.find(self.parent[x])\n\n\n\n    def union(self, x, y):\n\n        \"\"\"\n\n        x,y\u3092\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u3068\u3057\u3066\u307e\u3068\u3081\u308b\n\n        \"\"\"\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        if x == y:\n\n            return\n\n\n\n        if self.rank[x] < self.rank[y]:\n\n            self.parent[x] = y\n\n        else:\n\n            self.parent[y] = x\n\n            if self.rank[x] == self.rank[y]:\n\n                self.rank[x] += 1\n\n\n\n    def same(self, x, y):\n\n        \"\"\"\n\n        x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306a\u3089True\n\n        \"\"\"\n\n        return self.find(x) == self.find(y)\n\n\n\n    def component(self):\n\n        \"\"\"\n\n        \u5404\u9023\u7d50\u6210\u5206\u306eroot\u306e\u96c6\u5408\u3092\u8fd4\u3059\n\n        len()\u3092\u3068\u308c\u3070\u9023\u7d50\u6210\u5206\u306e\u6570\u304c\u6c42\u3081\u3089\u308c\u308b\n\n        return-> set()\n\n        \"\"\"\n\n        comp = set()\n\n        for i in self.parent:\n\n            p = self.find(i)\n\n            comp.add(p)\n\n        return comp\n\n\n\n    def __str__(self):\n\n        \"\"\"\n\n        for debug\n\n        \u30af\u30e9\u30b9\u306elist\u306e\u60c5\u5831\u3092\u51fa\u529b\n\n        \"\"\"\n\n        ret = \"parents\\n\"\n\n        ret += \" \".join(map(str, self.parent))\n\n        ret += '\\n'\n\n        ret += \" \".join(map(str, self.rank))\n\n        return ret\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\nedges = []\n\n\n\nfor _ in range(M):\n\n    a, b = [int(x)-1 for x in input().split()]\n\n    edges.append([a, b])\n\n\n\nans = 0\n\nfor e in edges:\n\n    Un = UnionFind(N)\n\n    for g in edges:\n\n        if e == g:\n\n            continue\n\n        else:\n\n            Un.union(g[0], g[1])\n\n    if not Un.same(e[0], e[1]):\n\n        ans += 1\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])  # Path compression\n        return self.parent[x]\n\n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n\n        if rootX == rootY:\n            return False\n\n        # Union by rank\n        if self.rank[rootX] > self.rank[rootY]:\n            self.parent[rootY] = rootX\n        elif self.rank[rootX] < self.rank[rootY]:\n            self.parent[rootX] = rootY\n        else:\n            self.parent[rootY] = rootX\n            self.rank[rootX] += 1\n        return True\n\n\ndef main():\n    N, M = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n\n    # Step 1: Build initial Union-Find structure\n    uf_initial = UnionFind(N)\n    for a, b in edges:\n        uf_initial.union(a - 1, b - 1)\n\n    # Step 2: Count critical edges\n    ans = 0\n    for i in range(M):\n        uf = UnionFind(N)\n        for j in range(M):\n            if i != j:\n                uf.union(edges[j][0] - 1, edges[j][1] - 1)\n\n        # Check if the graph is disconnected after removing edge i\n        root = uf.find(0)\n        if any(uf.find(x) != root for x in range(N)):\n            ans += 1\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02688","slow_code_col":"import numpy as np\n\nN, K = list(map(int, input().split()))\n\n \n\nA = np.zeros(N, dtype=int)\n\n \n\nfor _ in range(K):\n\n    eval(input())\n\n    for i in input().split():\n\n        A[int(i) - 1] += 1\n\n \n\nans = 0\n\nfor i in A:\n\n    if i == 0:\n\n        ans += 1\n\nprint(ans)\n\n ","reference_code_col":"N, K = list(map(int, input().split()))\n\n\n\nA = [0] * N\n\n\n\nfor _ in range(K):\n\n    eval(input())\n\n    for i in map(int, input().split()):\n\n        A[i - 1] += 1\n\n\n\nprint((A.count(0)))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read N and K from input\nN, K = map(int, input().split())\n\n# Initialize the array A with zeros\nA = np.zeros(N, dtype=int)\n\n# Process each group of indices\nfor _ in range(K):\n    # Skip the first input (unnecessary eval)\n    input()\n    # Update the counts for the given indices\n    indices = list(map(int, input().split()))\n    A[np.array(indices) - 1] += 1\n\n# Count the number of zeros in A using NumPy's vectorized operation\nans = np.sum(A == 0)\n\n# Print the result\nprint(ans)"}
{"problem_id":"p03575","slow_code_col":"import numpy as np\n\n\n\nn,m = list(map(int, input().split()))\n\n\n\nconnect = np.zeros((n,n))\n\n\n\nfor i in range(m):\n\n    a, b = list(map(int, input().split()))\n\n    connect[a-1, b-1] = 1\n\n    connect[b-1, a-1] = 1\n\n\n\nnotbridge = 0\n\n\n\n\n\nfor i in range(n):\n\n    for j in range(n):\n\n        if connect[i,j] == 1:\n\n            connect[i,j] = 0\n\n            connect[j,i] = 0\n\n            stack =[1]\n\n            visited = [1]\n\n            while stack:\n\n                p = stack.pop()\n\n                for k in range(n):\n\n                    if connect[p,k] == 1:\n\n                        if k not in visited:\n\n                            stack.append(k)\n\n                            visited.append(k)\n\n            if len(visited) == n:\n\n                notbridge += 1\n\n            connect[i,j] = 1\n\n            connect[j,i] = 1\n\n\n\n\n\n\n\nprint((m-notbridge\/\/2))\n\n\n\n\n","reference_code_col":"n,m = list(map(int, input().split()))\n\n\n\nconnect = [[0 for i in range(n)] for j in range(n)]\n\n\n\nfor i in range(m):\n\n    a, b = list(map(int, input().split()))\n\n    connect[a-1][b-1] = 1\n\n    connect[b-1][a-1] = 1\n\n\n\nnotbridge = 0\n\n\n\n\n\nfor i in range(n):\n\n    for j in range(n):\n\n        if connect[i][j] == 1:\n\n            connect[i][j] = 0\n\n            connect[j][i] = 0\n\n            stack =[1]\n\n            visited = [1]\n\n            while stack:\n\n                p = stack.pop()\n\n                for k in range(n):\n\n                    if connect[p][k] == 1:\n\n                        if k not in visited:\n\n                            stack.append(k)\n\n                            visited.append(k)\n\n            if len(visited) == n:\n\n                notbridge += 1\n\n            connect[i][j] = 1\n\n            connect[j][i] = 1\n\n\n\n\n\n\n\nprint((m-notbridge\/\/2))\n\n\n\n\n","model_generated_potentially_faster_code_col":"import sys\nfrom collections import defaultdict\n\ndef find_bridges(n, edges):\n    # Initialize adjacency list\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Variables for Tarjan's algorithm\n    visited = [False] * (n + 1)  # Mark nodes as visited\n    disc = [-1] * (n + 1)        # Discovery times of nodes\n    low = [-1] * (n + 1)         # Low-link values\n    parent = [-1] * (n + 1)      # Parent of each node in DFS tree\n    bridges = []                 # List to store bridges\n    time = [0]                   # Global timer\n\n    def dfs(u):\n        # Perform DFS and update discovery and low-link values\n        visited[u] = True\n        disc[u] = low[u] = time[0]\n        time[0] += 1\n\n        for v in graph[u]:\n            if not visited[v]:\n                parent[v] = u\n                dfs(v)\n                low[u] = min(low[u], low[v])\n\n                # If low[v] > disc[u], then (u, v) is a bridge\n                if low[v] > disc[u]:\n                    bridges.append((u, v))\n            elif v != parent[u]:  # Ignore the edge to the parent\n                low[u] = min(low[u], disc[v])\n\n    # Run DFS for all components of the graph\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i)\n\n    return len(bridges)\n\n\n# Input reading\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    edges = []\n    index = 2\n    for _ in range(m):\n        a = int(data[index])\n        b = int(data[index + 1])\n        edges.append((a, b))\n        index += 2\n    \n    # Find the number of bridges\n    num_bridges = find_bridges(n, edges)\n    \n    # Output the result: total edges minus bridges\n    print(m - num_bridges)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03579","slow_code_col":"import sys\n\nsys.setrecursionlimit(100000)\n\nN, M = list(map(int, input().split()))\n\nedges = [list(map(int, input().split())) for _ in range(M)]\n\n\n\ngraph = [[] for _ in range(N)]\n\nfor x, y in edges:\n\n    graph[x - 1].append(y - 1)\n\n    graph[y - 1].append(x - 1)\n\n\n\ndef dfs(v, c):\n\n    # c: color = 1 or -1\n\n    node[v] = c\n\n    for i in graph[v]:\n\n        if node[i] == c:\n\n            return False\n\n        \n\n        if node[i] == 0 and not dfs(i, -c):\n\n            return False\n\n        \n\n    return True\n\n\n\nnode = [0] * N\n\nif dfs(0, 1):\n\n    x = sum(v + 1 for v in node) \/\/ 2\n\n    print((x * (N - x) - M))\n\nelse:\n\n    print((N * (N - 1) \/\/ 2 - M))\n","reference_code_col":"from collections import deque\n\nN, M = list(map(int, input().split()))\n\nedges = [list(map(int, input().split())) for _ in range(M)]\n\n\n\ngraph = [[] for _ in range(N)]\n\nfor x, y in edges:\n\n    graph[x - 1].append(y - 1)\n\n    graph[y - 1].append(x - 1)\n\n\n\ndef dfs(s, c):\n\n    q = deque()\n\n    q.append(s)\n\n    visited[s] = True\n\n    color[s] = c\n\n    \n\n    while len(q) > 0:\n\n        v = q.pop()\n\n        for i in graph[v]:\n\n            if visited[i] and color[i] == color[v]:\n\n                return False\n\n            \n\n            if not visited[i]:\n\n                visited[i] = True\n\n                color[i] = -color[v]\n\n                q.append(i)\n\n                \n\n    return True\n\n\n\nvisited = [False] * N\n\ncolor = [0] * N\n\n\n\nif dfs(0, 1):\n\n    x = sum(v + 1 for v in color) \/\/ 2\n\n    print((x * (N - x) - M))\n\nelse:\n\n    print((N * (N - 1) \/\/ 2 - M))\n\n    \n\n    ","model_generated_potentially_faster_code_col":"import sys\nfrom collections import defaultdict\n\n# Set recursion limit (optional if using iterative DFS)\nsys.setrecursionlimit(100000)\n\n# Fast input reading\ninput_data = sys.stdin.read().split()\nN, M = map(int, input_data[:2])\nedges = [list(map(int, input_data[2 + 2 * i: 4 + 2 * i])) for i in range(M)]\n\n# Graph representation using defaultdict\ngraph = defaultdict(list)\nfor x, y in edges:\n    graph[x - 1].append(y - 1)\n    graph[y - 1].append(x - 1)\n\n# Node coloring array\nnode = [0] * N\n\n# Iterative DFS implementation\ndef dfs(start):\n    stack = [(start, 1)]  # Stack stores pairs of (vertex, color)\n    while stack:\n        v, c = stack.pop()\n        if node[v] != 0:\n            if node[v] != c:\n                return False\n            continue\n        node[v] = c\n        for neighbor in graph[v]:\n            if node[neighbor] == c:\n                return False\n            if node[neighbor] == 0:\n                stack.append((neighbor, -c))\n    return True\n\n# Check bipartiteness\nis_bipartite = True\nfor v in range(N):\n    if node[v] == 0:\n        if not dfs(v):\n            is_bipartite = False\n            break\n\n# Compute result based on bipartiteness\nif is_bipartite:\n    x = sum(node)  # Sum of all positive colors (1s)\n    print((x * (N - x) - M))\nelse:\n    print((N * (N - 1) \/\/ 2 - M))"}
{"problem_id":"p03457","slow_code_col":"def main():\n\n    import sys\n\n    input = sys.stdin.buffer.readline\n\n    N = int(input())\n\n    TXY = [[int(i) for i in input().split()] for j in range(N)]\n\n    time, px, py = 0, 0, 0\n\n    for t, x, y in TXY:\n\n        move = abs(x-px) + abs(y-py)\n\n        # print(move, t-time)\n\n        if (t - time) % 2 != move % 2 or t - time < move:\n\n            return print(\"No\")\n\n        time, px, py = t, x, y\n\n    print(\"Yes\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def main():\n\n    import sys\n\n    input = sys.stdin.buffer.readline\n\n    N = int(input())\n\n    TXY = [[int(i) for i in input().split()] for j in range(N)]\n\n    time = 0\n\n    px = 0\n\n    py = 0\n\n    for t, x, y in TXY:\n\n        move = abs(py-y) + abs(px - x)\n\n        if (t-time) < move or (t - time) % 2 != move % 2:\n\n            return print(\"No\")\n\n        time = t\n\n        px = x\n\n        py = y\n\n    print(\"Yes\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    import sys\n\n    input = sys.stdin.buffer.readline\n\n    # Read the number of steps\n    N = int(input())\n\n    # Initialize starting position and time\n    time, px, py = 0, 0, 0\n\n    # Process each step directly without storing the entire list\n    for _ in range(N):\n        # Read and parse the current step\n        t, x, y = map(int, input().split())\n\n        # Calculate the Manhattan distance (move)\n        move = abs(x - px) + abs(y - py)\n\n        # Check if the move is possible\n        if (t - time) % 2 != move % 2 or t - time < move:\n            return print(\"No\")\n\n        # Update the current position and time\n        time, px, py = t, x, y\n\n    # If all moves are valid, print \"Yes\"\n    print(\"Yes\")\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03309","slow_code_col":"import numpy as np\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmed = np.median(np.array(al))\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(a-med)\n\nprint((int(ans)))","reference_code_col":"import statistics\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmedian = statistics.median(al)\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(median - a)\n\n\n\nprint((int(ans)))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input reading: Avoid eval and directly convert input to integer\nn = int(input())\nal = list(map(int, input().split()))\n\n# Vectorized subtraction: Subtract (i + 1) from each element\nal = np.array(al) - np.arange(1, n + 1)\n\n# Efficient median calculation\nal_sorted = np.sort(al)\nif n % 2 == 0:\n    med = (al_sorted[n \/\/ 2 - 1] + al_sorted[n \/\/ 2]) \/ 2\nelse:\n    med = al_sorted[n \/\/ 2]\n\n# Compute the sum of absolute differences\nans = np.sum(np.abs(al - med))\n\nprint(int(ans))"}
{"problem_id":"p03287","slow_code_col":"import numpy as np\n\n(n, m) = list(map(int, input().split()))\n\na = np.array(list(map(int, input().split()))).astype(\"int64\") \n\na = np.cumsum(a)\n\na %= m\n\ncount = np.sum(a == 0)\n\na.sort()\n\ntc = 1\n\nfor i in range(1, n):\n\n    if a[i - 1] == a[i]:\n\n        tc += 1\n\n    else:\n\n        count += tc * (tc - 1) \/\/ 2\n\n        tc = 1\n\nelse:\n\n    count += tc * (tc - 1) \/\/ 2\n\nprint(count)","reference_code_col":"(n, m) = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nunique_a = {a[0] % m: 1}\n\nfor i in range(1, n):\n\n    a[i] += a[i - 1]\n\n    a[i] %= m\n\n    if a[i] in unique_a:\n\n        unique_a[a[i]] += 1\n\n    else:\n\n        unique_a[a[i]] = 1\n\ncount = 0\n\nif 0 in unique_a:\n\n    count += unique_a[0]\n\nfor k in unique_a:\n\n    count += unique_a[k] * (unique_a[k] - 1) \/\/ 2\n\nprint(count)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn, m = map(int, input().split())\na = np.fromiter(map(int, input().split()), dtype=np.int64)\n\n# Compute cumulative sum and modulo\na = np.cumsum(a) % m\n\n# Count occurrences of zero remainders\ncount = np.sum(a == 0)\n\n# Use np.unique to count frequencies of each unique remainder\nunique_values, counts = np.unique(a, return_counts=True)\n\n# Add combinations of pairs for each unique remainder\nfor c in counts:\n    count += c * (c - 1) \/\/ 2\n\nprint(count)"}
{"problem_id":"p03553","slow_code_col":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\n\n\nsys.setrecursionlimit(10**7)\n\ninf = 10**20\n\neps = 1.0 \/ 10**15\n\nmod = 10**9+7\n\n\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\n\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\n\ndef LS(): return sys.stdin.readline().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef F(): return float(sys.stdin.readline())\n\ndef S(): return input()\n\ndef pf(s): return print(s, flush=True)\n\ndef divisions(n):\n\n    sq = int(math.sqrt(n)+1)\n\n    d = collections.defaultdict(int)\n\n    while n % 2 == 0:\n\n        n \/\/= 2\n\n        d[2] += 1\n\n    i = 3\n\n    while n > 1 and sq >= i:\n\n        if n % i == 0:\n\n            n \/\/= i\n\n            d[i] += 1\n\n        else:\n\n            i += 2\n\n\n\n    if n > 1:\n\n        d[n] += 1\n\n\n\n    r = [1]\n\n    for k, v in d.items():\n\n        for c in r[:]:\n\n            for i in range(1,v+1):\n\n                r.append(c*(k**i))\n\n\n\n    return sorted(r)\n\n\n\ndef main():\n\n    n = I()\n\n    a = LI()\n\n    s = set()\n\n    for i in range(n,0,-1):\n\n        d = divisions(i)\n\n        ld = len(d)\n\n        for j in range(1,2**ld):\n\n            c = []\n\n            ff = True\n\n            for k in range(ld):\n\n                if j & (1<<k):\n\n                    f = True\n\n                    for e in c:\n\n                        if d[k] % e == 0:\n\n                            f = False\n\n                            ff = False\n\n                            break\n\n                    if f:\n\n                        c.append(d[k])\n\n                if not ff:\n\n                    break\n\n            if ff:\n\n                s.add(tuple(c + [n+1]))\n\n    b = sorted(list(s), reverse=True)\n\n    for c in b:\n\n        t = 0\n\n        for j in range(1,n+1):\n\n            f = False\n\n            for e in c:\n\n                if j%e == 0:\n\n                    f = True\n\n                    break\n\n            if f:\n\n                t += a[j-1]\n\n        if t < 0:\n\n            for j in range(1,n+1):\n\n                f = False\n\n                for e in c:\n\n                    if j%e == 0:\n\n                        f = True\n\n                        break\n\n                if f:\n\n                    a[j-1] = 0\n\n\n\n    return sum(a)\n\n\n\n\n\n\n\nprint(main())\n\n\n\n\n","reference_code_col":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nimport time,random\n\n\n\nsys.setrecursionlimit(10**7)\n\ninf = 10**20\n\neps = 1.0 \/ 10**10\n\nmod = 10**9+7\n\nmod2 = 998244353\n\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\n\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\n\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\n\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\n\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\n\ndef LS(): return sys.stdin.readline().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef F(): return float(sys.stdin.readline())\n\ndef S(): return input()\n\ndef pf(s): return print(s, flush=True)\n\ndef pe(s): return print(str(s), file=sys.stderr)\n\ndef JA(a, sep): return sep.join(map(str, a))\n\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\n\n\n\nclass Flow():\n\n    def __init__(self, e, N):\n\n        self.E = e\n\n        self.N = N\n\n\n\n    def max_flow(self, s, t):\n\n        r = 0\n\n        e = self.E\n\n\n\n        def f(c, cap):\n\n            v = self.v\n\n            v[c] = 1\n\n            if c == t:\n\n                return cap\n\n            for i in range(self.N):\n\n                if v[i] or e[c][i] <= 0:\n\n                    continue\n\n                cp = min(cap, e[c][i])\n\n                k = f(i, cp)\n\n                if k > 0:\n\n                    e[c][i] -= k\n\n                    e[i][c] += k\n\n                    return k\n\n            return 0\n\n\n\n        while True:\n\n            self.v = [None] * self.N\n\n            fs = f(s, inf)\n\n            if fs == 0:\n\n                break\n\n            r += fs\n\n\n\n        return r\n\n\n\n\n\ndef main():\n\n    n = I()\n\n    a = LI()\n\n\n\n    s = n\n\n    t = n + 1\n\n    e = [[0] * (n+2) for _ in range(n+2)]\n\n    for i in range(n):\n\n        c = a[i]\n\n        if c < 0:\n\n            e[s][i] = -c\n\n            ii = i + 1\n\n            for j in range(ii*2, n+1, ii):\n\n                e[i][j-1] = inf\n\n        else:\n\n            e[i][t] = c\n\n\n\n\n\n    fl = Flow(e, n+2)\n\n    r = fl.max_flow(s,t)\n\n\n\n    return sum(map(lambda x: max(0,x), a)) - r\n\n\n\n# start = time.time()\n\nprint(main())\n\n# pe(time.time() - start)\n\n\n\n\n\n\n","model_generated_potentially_faster_code_col":"def divisions(n):\n    d = collections.defaultdict(int)\n    # Handle factor of 2 separately\n    while n % 2 == 0:\n        n \/\/= 2\n        d[2] += 1\n    # Check odd factors\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            n \/\/= i\n            d[i] += 1\n        i += 2\n    # If remaining n > 1, it's a prime factor\n    if n > 1:\n        d[n] += 1\n    # Generate all divisors from prime factors\n    divisors = [1]\n    for k, v in d.items():\n        new_divisors = []\n        for dk in range(1, v + 1):\n            new_divisors.extend([d_ * (k ** dk) for d_ in divisors])\n        divisors.extend(new_divisors)\n    return sorted(divisors)"}
{"problem_id":"p02881","slow_code_col":"N = int(eval(input()))\n\nans = N - 1\n\np = 1\n\nfor i in range(2, int((N ** 0.5) + 1)):\n\n    if p % 2 == 1 and i > (N ** 0.5):\n\n        break\n\n    if N % i == 0:\n\n        p = i\n\n        j = N \/\/ i\n\n        m = i + j - 2\n\n        if m < ans:\n\n            ans = m\n\n        else:\n\n            continue\n\n    else:\n\n        continue\n\nprint(ans)\n","reference_code_col":"N = int(eval(input()))\n\nans = N - 1\n\nfor i in range(2, int((N ** 0.5) + 1)):\n\n    if N % i == 0:\n\n        j = N \/\/ i\n\n        m = i + j - 2\n\n        ans = min(ans, m)\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"N = int(input())  # Directly convert input to integer\n\nans = N - 1  # Initialize with the worst-case value\nsqrt_N = int(N ** 0.5)  # Precompute square root of N\n\nfor i in range(2, sqrt_N + 1):\n    if N % i == 0:  # Check if i is a divisor of N\n        j = N \/\/ i  # Compute the corresponding quotient\n        m = i + j - 2  # Compute the candidate value\n        if m < ans:  # Update ans if a smaller value is found\n            ans = m\n\nprint(ans)"}
{"problem_id":"p03078","slow_code_col":"import sys\n\nimport heapq\n\n\n\n\n\n# \\n\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\n\n\n\n\ndef main():\n\n    X, Y, Z, K = list(map(int, input().split()))\n\n    A = list(map(int, input().split()))\n\n    B = list(map(int, input().split()))\n\n    C = list(map(int, input().split()))\n\n\n\n    A.sort(reverse=True)\n\n    B.sort(reverse=True)\n\n    C.sort(reverse=True)\n\n\n\n    Q = []\n\n    S = set()\n\n    heapq.heapify(Q)\n\n    heapq.heappush(Q, (-A[0] - B[0] - C[0], 0, 0, 0))\n\n    for i in range(K):\n\n        m, a, b, c = heapq.heappop(Q)\n\n        print((-m))\n\n        if (a + 1, b, c) not in S and a + 1 < X:\n\n            heapq.heappush(Q, (-A[a + 1] - B[b] - C[c], a + 1, b, c))\n\n            S.add((a + 1, b, c))\n\n        if (a, b + 1, c) not in S and b + 1 < Y:\n\n            heapq.heappush(Q, (-A[a] - B[b + 1] - C[c], a, b + 1, c))\n\n            S.add((a, b + 1, c))\n\n        if (a, b, c + 1) not in S and c + 1 < Z:\n\n            heapq.heappush(Q, (-A[a ] - B[b] - C[c+1], a, b, c + 1))\n\n            S.add((a, b, c + 1))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"import sys\n\n\n\n\n\n# \\n\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\n\n\n\n\ndef main():\n\n    X, Y, Z, K = list(map(int, input().split()))\n\n    A = list(map(int, input().split()))\n\n    B = list(map(int, input().split()))\n\n    C = list(map(int, input().split()))\n\n\n\n    A.sort(reverse=True)\n\n    B.sort(reverse=True)\n\n    C.sort(reverse=True)\n\n\n\n    L = []\n\n\n\n    for i in range(X):\n\n        for j in range(min(Y, K \/\/ (i + 1) + 1)):\n\n            for k in range(min(Z, K \/\/ (i + 1) \/\/ (j + 1) + 1)):\n\n                L.append(A[i] + B[j] + C[k])\n\n\n\n    L.sort(reverse=True)\n\n\n\n    for i in range(K):\n\n        print((L[i]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\nimport heapq\n\ndef main():\n    # Read inputs\n    X, Y, Z, K = map(int, sys.stdin.readline().split())\n    A = sorted(map(int, sys.stdin.readline().split()), reverse=True)\n    B = sorted(map(int, sys.stdin.readline().split()), reverse=True)\n    C = sorted(map(int, sys.stdin.readline().split()), reverse=True)\n\n    # Initialize heap and visited array\n    heap = [(-A[0] - B[0] - C[0], 0, 0, 0)]  # (negative sum, a_index, b_index, c_index)\n    visited = [[[False] * Z for _ in range(Y)] for _ in range(X)]\n    visited[0][0][0] = True\n\n    # Process the heap to find the top K sums\n    for _ in range(K):\n        if not heap:\n            break  # Exit if no more elements in the heap\n\n        m, a, b, c = heapq.heappop(heap)\n        print(-m)  # Output the current largest sum\n\n        # Push the next possible candidates into the heap\n        if a + 1 < X and not visited[a + 1][b][c]:\n            heapq.heappush(heap, (-A[a + 1] - B[b] - C[c], a + 1, b, c))\n            visited[a + 1][b][c] = True\n\n        if b + 1 < Y and not visited[a][b + 1][c]:\n            heapq.heappush(heap, (-A[a] - B[b + 1] - C[c], a, b + 1, c))\n            visited[a][b + 1][c] = True\n\n        if c + 1 < Z and not visited[a][b][c + 1]:\n            heapq.heappush(heap, (-A[a] - B[b] - C[c + 1], a, b, c + 1))\n            visited[a][b][c + 1] = True\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03494","slow_code_col":"def two_count(x):\n\n\tif int(str(x)[-1]) % 2 == 0:\n\n\t\treturn 1 + two_count(x\/\/2)\n\n\telse:\n\n\t\treturn 0\n\n\n\nn = int(eval(input()))\n\nn_list = [int(n) for n in input().split(\" \")]\n\n\n\nn_two_count_list = [two_count(n) for n in n_list]\n\n\n\nprint((min(n_two_count_list)))","reference_code_col":"def two_count(x):\n\n\tif x % 2 == 0:\n\n\t\treturn 1 + two_count(x\/\/2)\n\n\telse:\n\n\t\treturn 0\n\n\n\nn = int(eval(input()))\n\nn_list = [int(n) for n in input().split(\" \")]\n\n\n\nn_two_count_list = [two_count(n) for n in n_list]\n\n\n\nprint((min(n_two_count_list)))","model_generated_potentially_faster_code_col":"def two_count(x):\n    \"\"\"Count the number of trailing zeros in the binary representation of x.\"\"\"\n    count = 0\n    while x % 2 == 0:\n        x \/\/= 2\n        count += 1\n    return count\n\n\n# Input handling\nn = int(input())\nn_list = list(map(int, input().split()))\n\n# Calculate the minimum number of trailing zeros across all numbers\nmin_two_count = min(two_count(n) for n in n_list)\n\nprint(min_two_count)"}
{"problem_id":"p02883","slow_code_col":"import numpy as np\n\nN, K= list(map(int, input().split()))\n\nA=[int(i) for i in input().split()]\n\nF=[int(i) for i in input().split()]\n\n\n\nA=np.array(sorted(A, reverse=True))\n\nF=np.array(sorted(F))\n\n\n\nlower_bound=0\n\nupper_bound=np.max(A*F)\n\nK_tmp=0\n\n\n\nwhile upper_bound>=lower_bound:\n\n    mid=(lower_bound+upper_bound)\/\/2\n\n    K_tmp=np.sum(np.maximum(A-mid\/\/F, 0))\n\n    if K_tmp<=K:\n\n        upper_bound=mid-1\n\n    else:\n\n        lower_bound=mid+1\n\n\n\nprint(lower_bound)","reference_code_col":"n,k=list(map(int,input().split()))\n\n*a,= list(map(int,input().split()))\n\n*f,= list(map(int,input().split()))\n\na=sorted(a)\n\nf=sorted(f, reverse=True)\n\n\n\ndef is_ok(arg):\n\n    cnt=0\n\n    for i in range(n):\n\n        cnt+=max(a[i]-arg\/\/f[i], 0)\n\n    return cnt<=k\n\n\n\ndef meguru_bisect(ng, ok):\n\n    while (abs(ok - ng) > 1):\n\n        mid = (ok + ng) \/\/ 2\n\n        if is_ok(mid):\n\n            ok = mid\n\n        else:\n\n            ng = mid\n\n    return ok\n\n\n\nprint((meguru_bisect(-1, 10**12)))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input reading\nN, K = map(int, input().split())\nA = np.array(list(map(int, input().split())))\nF = np.array(list(map(int, input().split())))\n\n# Sort A in descending order and F in ascending order\nA = np.sort(A)[::-1]\nF = np.sort(F)\n\n# Initialize binary search bounds\nlower_bound = 0\nupper_bound = A[0] * F[-1]  # Maximum possible value of A[i] * F[i]\n\n# Binary search\nwhile lower_bound <= upper_bound:\n    mid = (lower_bound + upper_bound) \/\/ 2\n    \n    # Compute K_tmp efficiently\n    K_tmp = np.sum(np.maximum(A - mid \/\/ F, 0))\n    \n    if K_tmp <= K:\n        upper_bound = mid - 1  # Try for a smaller value\n    else:\n        lower_bound = mid + 1  # Increase the lower bound\n\n# Output the result\nprint(lower_bound)"}
{"problem_id":"p02635","slow_code_col":"def main():\n\n    mod = 998244353\n\n    s, k = input().split()\n\n    k = int(k)\n\n    n = len(s)\n\n\n\n    one = s.count(\"1\")\n\n\n\n    cnt = 0\n\n    zero_list = []\n\n    for i in range(n):\n\n        if s[i] == \"0\":\n\n            zero_list.append(cnt)\n\n            cnt = 0\n\n        else:\n\n            cnt += 1\n\n\n\n    z = 0\n\n    mm = min(one, k)\n\n\n\n    dp = [[0]*(one+1) for _ in [0]*(one+1)]\n\n    dp[0][0] = 1\n\n\n\n    for i in range(len(zero_list)):\n\n        dp2 = [[0]*(mm+1) for _ in [0]*(one+1)]\n\n        base = zero_list[i]\n\n        # j:\u4f55\u500b\u4eca\u307e\u3067\u306b\u5165\u308c\u305f\u304b\n\n        for j in range(one+1):\n\n            # l:\u4f55\u500b\u5165\u308c\u308b\u304b\n\n            for l in range(one+1-j):\n\n                if l < z+base-j:\n\n                    continue\n\n                ml = max(l-base, 0)\n\n                # p:\u3053\u308c\u307e\u3067\u306e\u30da\u30ca\u30eb\u30c6\u30a3\n\n                for p in range(min(one, k)+1):\n\n                    q = p+ml\n\n                    if q <= mm:\n\n                        dp2[j+l][q] = (dp2[j+l][q]+dp[j][p]) % mod\n\n                    else:\n\n                        break\n\n        z += base\n\n        dp = dp2\n\n    print((sum([sum(i) for i in dp]) % mod))\n\n\n\n\n\nmain()","reference_code_col":"def main():\n\n    mod = 998244353\n\n    s, k = input().split()\n\n    k, n, one, cnt, z, zero_list = int(k), len(s), s.count(\"1\")+1, 0, 0, []\n\n    for i in range(n):\n\n        if s[i] == \"0\":\n\n            zero_list.append(cnt)\n\n            cnt = 0\n\n        else:\n\n            cnt += 1\n\n    mm = min(one-1, k)\n\n\n\n    dp = [[0]*(mm+1) for _ in [0]*one]\n\n    dp[0][0] = 1\n\n\n\n    for i in zero_list:\n\n        dp2 = [[0]*(mm+1) for _ in [0]*one]\n\n        for j in range(one):\n\n            for l in range(max(z+i-j, 0), one-j):\n\n                ml = max(l-i, 0)\n\n                for p in range(min(j, mm-ml)+1):\n\n                    dp2[j+l][p+ml] = (dp2[j+l][p+ml]+dp[j][p]) % mod\n\n        z += i\n\n        dp = dp2\n\n    print((sum([sum(i) for i in dp]) % mod))\n\n\n\n\n\nmain()","model_generated_potentially_faster_code_col":"def main():\n    MOD = 998244353\n\n    # Input parsing\n    s, k = input().split()\n    k = int(k)\n    n = len(s)\n\n    # Count '1's and preprocess '0's\n    one = s.count(\"1\")\n    zero_list = []\n    cnt = 0\n    for char in s:\n        if char == \"0\":\n            if cnt > 0:\n                zero_list.append(cnt)\n                cnt = 0\n        else:\n            cnt += 1\n    if cnt > 0:  # Append the last group of '1's\n        zero_list.append(cnt)\n\n    mm = min(one, k)\n\n    # Initialize DP\n    dp = [1] + [0] * mm  # dp[p]: ways to achieve penalty p\n    z = 0\n\n    # Process each group of '1's separated by '0's\n    for base in zero_list:\n        dp_new = [0] * (mm + 1)\n        for p in range(mm + 1):\n            if dp[p]:\n                for l in range(max(0, z + base - one), min(base, mm - p) + 1):\n                    ml = max(l - base, 0)\n                    q = p + ml\n                    if q <= mm:\n                        dp_new[q] = (dp_new[q] + dp[p]) % MOD\n        z += base\n        dp = dp_new\n\n    # Output the result\n    print(sum(dp) % MOD)\n\n\nmain()"}
{"problem_id":"p02386","slow_code_col":"n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in('012345','152043','215304','302541','410352','514320'):\n\n    f=[d[int(k)]for k in p]\n\n    g=f[1:5]*2\n\n    for k in range(4):\n\n     if(g[k:k+4]==e[1:5])*(f[0]==e[0])*(f[5]==e[5]):return 'No'\n\n return 'Yes'\n\nprint((f()))\n","reference_code_col":"n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in('012345','152043','215304','302541','410352','514320'):\n\n    f=[d[int(k)]for k in p]\n\n    g=f[1:5]*2\n\n    for k in range(4):\n\n     if g[k:k+4]==e[1:5]:\n\n      if f[0]==e[0]:\n\n       if f[5]==e[5]:return 'No'\n\n return 'Yes'\n\nprint((f()))\n","model_generated_potentially_faster_code_col":"n = int(eval(input()))\na = [list(map(int, input().split())) for _ in range(n)]\n\n# Predefined permutations\npermutations = [\n    '012345', '152043', '215304',\n    '302541', '410352', '514320'\n]\n\ndef f():\n    # Precompute swapped rows\n    swapped_rows = []\n    for row in a:\n        swapped = row[:]\n        swapped[3], swapped[4] = swapped[4], swapped[3]\n        swapped_rows.append(swapped)\n\n    for i in range(n - 1):\n        d = swapped_rows[i]\n        \n        for j in range(i + 1, n):\n            e = swapped_rows[j]\n            \n            for p in permutations:\n                # Transform `d` using permutation `p`\n                f_transformed = [d[int(k)] for k in p]\n                \n                # Check if the middle four elements of `f_transformed` match `e[1:5]`\n                # and the first and last elements match `e[0]` and `e[5]`\n                if (f_transformed[1:5] == e[1:5] and\n                    f_transformed[0] == e[0] and\n                    f_transformed[5] == e[5]):\n                    return 'No'\n    \n    return 'Yes'\n\nprint(f())"}
{"problem_id":"p03038","slow_code_col":"import sys\n\ninput = lambda: sys.stdin.readline()[:-1]\n\nn,m=list(map(int,input().split()))\n\na0=list(map(int,input().split()))\n\ndata=[list(map(int,input().split())) for i in range(m)]\n\nfor i in a0:\n\n\tdata.append([1,i])\n\ndata.sort(key=lambda tup:-tup[1])\n\nans=0\n\nfor num,val in data:\n\n\tif n>=num:\n\n\t\tn-=num\n\n\t\tans+=val*num\n\n\telse:\n\n\t\tans+=val*n\n\n\t\tbreak\n\nprint(ans)\n","reference_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\n\nfrom collections import Counter\n\ninput = lambda: sys.stdin.readline()[:-1]\n\nsys.setrecursionlimit(10**8)\n\n\n\nans=0\n\nn,m=list(map(int,input().split()))\n\nA=list(map(int,input().split()))\n\nbc=[]\n\nfor i in range(m):\n\n    b,c=list(map(int,input().split()))\n\n    bc.append((c,b))\n\nC=Counter(A)\n\nbc+=list(C.items())\n\nbc.sort(key=lambda tup:-tup[0])\n\n# print(bc)\n\nfor c,b in bc:\n\n    if n>=b:\n\n        n-=b\n\n        ans+=c*b\n\n    else:\n\n        ans+=c*n\n\n        break\n\nprint(ans)\n\n\n","model_generated_potentially_faster_code_col":"import sys\n\ninput = lambda: sys.stdin.readline()[:-1]\n\n# Read inputs\nn, m = map(int, input().split())\na0 = list(map(int, input().split()))\ndata = [list(map(int, input().split())) for _ in range(m)]\n\n# Sort `data` and `a0` separately by their second values in descending order\ndata.sort(key=lambda x: -x[1])\na0 = [[1, val] for val in a0]\na0.sort(key=lambda x: -x[1])\n\n# Merge the two sorted lists\nmerged_data = []\ni, j = 0, 0\nwhile i < len(data) and j < len(a0):\n    if data[i][1] >= a0[j][1]:\n        merged_data.append(data[i])\n        i += 1\n    else:\n        merged_data.append(a0[j])\n        j += 1\n\n# Append any remaining elements\nmerged_data.extend(data[i:])\nmerged_data.extend(a0[j:])\n\n# Greedy computation\nans = 0\nfor num, val in merged_data:\n    if n >= num:\n        n -= num\n        ans += val * num\n    else:\n        ans += val * n\n        break\n\nprint(ans)"}
{"problem_id":"p03434","slow_code_col":"import numpy as np\n\n\n\nN = int(eval(input()))\n\na = np.array(list(map(int, input().split())))\n\n\n\na.sort()\n\na = a[::-1]\n\n\n\nprint((a[0::2].sum() - a[1::2].sum()))","reference_code_col":"n = int(eval(input()))\n\narr = list(map(int, input().split()))\n\n\n\narr.sort(reverse=True)\n\n\n\nprint((sum(arr[0::2]) - sum(arr[1::2])))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN = int(input())\na = np.fromstring(input(), dtype=int, sep=' ')\n\n# Sort the array in descending order\na.sort()\na = a[::-1]\n\n# Compute the alternating sum without slicing\nresult = 0\nfor i in range(N):\n    if i % 2 == 0:\n        result += a[i]\n    else:\n        result -= a[i]\n\nprint(result)"}
{"problem_id":"p02780","slow_code_col":"class SegmentTree:\n\n    seg_len = 1\n\n    node = []\n\n    def __init__(self, n):\n\n        while self.seg_len < n:\n\n            self.seg_len <<= 1\n\n        self.node = [ 0 for _ in range(self.seg_len*2) ]\n\n\n\n    def add(self, idx, v):\n\n        idx += self.seg_len\n\n        self.node[idx] += v\n\n        while True:\n\n            idx \/\/= 2\n\n            if idx == 0:\n\n                break\n\n            self.node[idx] = self.node[idx*2] + self.node[idx*2+1]\n\n\n\n    def sum(self, l, r):\n\n        l += self.seg_len\n\n        r += self.seg_len\n\n        ret = 0\n\n        while l < r:\n\n            if l & 1 == 1:\n\n                ret += self.node[l]\n\n                l += 1\n\n            if r & 1 == 1:\n\n                ret += self.node[r-1]\n\n                r -= 1\n\n            l \/\/= 2; r \/\/= 2;\n\n        return ret\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\np = [ int(x) for x in input().split() ]\n\n\n\nseg_tree = SegmentTree(n)\n\nfor i in range(n):\n\n    seg_tree.add(i, (1+p[i])\/2)\n\n\n\nans = 0\n\nfor i in range(n-k+1):\n\n    ans = max(ans, seg_tree.sum(i, i+k))\n\n\n\nprint(ans)\n","reference_code_col":"class SegmentTree:\n\n    seg_len = 1\n\n    node = []\n\n    def __init__(self, n):\n\n        while self.seg_len < n:\n\n            self.seg_len <<= 1\n\n        self.node = [ 0 for _ in range(self.seg_len*2) ]\n\n\n\n    def add(self, idx, v):\n\n        idx += self.seg_len\n\n        self.node[idx] += v\n\n        while True:\n\n            idx >>= 1\n\n            if idx == 0:\n\n                break\n\n            self.node[idx] = self.node[idx*2] + self.node[idx*2+1]\n\n\n\n    def sum(self, l, r):\n\n        l += self.seg_len\n\n        r += self.seg_len\n\n        ret = 0\n\n        while l < r:\n\n            if l & 1 == 1:\n\n                ret += self.node[l]\n\n                l += 1\n\n            if r & 1 == 1:\n\n                ret += self.node[r-1]\n\n                r -= 1\n\n            l >>= 1; r >>= 1;\n\n        return ret\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\np = [ int(x) for x in input().split() ]\n\n\n\nseg_tree = SegmentTree(n)\n\nfor i in range(n):\n\n    seg_tree.add(i, (1+p[i])\/2)\n\n\n\nans = 0\n\nfor i in range(n-k+1):\n\n    ans = max(ans, seg_tree.sum(i, i+k))\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"class SegmentTree:\n    def __init__(self, n):\n        self.seg_len = 1\n        while self.seg_len < n:\n            self.seg_len <<= 1\n        self.node = [0] * (self.seg_len * 2)\n\n    def add(self, idx, v):\n        idx += self.seg_len\n        self.node[idx] += v\n        while idx > 1:\n            idx \/\/= 2\n            self.node[idx] = self.node[idx * 2] + self.node[idx * 2 + 1]\n\n    def sum(self, l, r):\n        l += self.seg_len\n        r += self.seg_len\n        ret = 0\n        while l < r:\n            if l % 2 == 1:\n                ret += self.node[l]\n                l += 1\n            if r % 2 == 1:\n                ret += self.node[r - 1]\n                r -= 1\n            l \/\/= 2\n            r \/\/= 2\n        return ret\n\n\n# Input parsing\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Precompute values\nvalues = [(1 + x) \/ 2 for x in p]\n\n# Build segment tree\nseg_tree = SegmentTree(n)\nfor i in range(n):\n    seg_tree.add(i, values[i])\n\n# Sliding window approach\ncurrent_sum = seg_tree.sum(0, k)\nans = current_sum\n\nfor i in range(1, n - k + 1):\n    # Update sum by removing the leftmost element and adding the rightmost element\n    current_sum = current_sum - values[i - 1] + values[i + k - 1]\n    ans = max(ans, current_sum)\n\nprint(ans)"}
{"problem_id":"p03723","slow_code_col":"import time\n\nt=time.time()\n\nA,B,C=list(map(int,input().split()))\n\ncnt=0\n\nwhile(A%2==B%2==C%2==0):\n\n    a,b,c=A,B,C\n\n    A=b\/\/2+c\/\/2;B=a\/\/2+c\/\/2;C=a\/\/2+b\/\/2\n\n    cnt+=1\n\n    if(time.time()-t>=1):\n\n        print((-1))\n\n        exit()\n\nprint(cnt)","reference_code_col":"A,B,C=list(map(int,input().split()))\n\ncnt=0\n\nif(A==B==C):\n\n    if A%2!=0:\n\n        print((0))\n\n    else:\n\n        print((-1))\n\n    exit()\n\nwhile(A%2==B%2==C%2==0):\n\n    a,b,c=A,B,C\n\n    A=b\/\/2+c\/\/2;B=a\/\/2+c\/\/2;C=a\/\/2+b\/\/2\n\n    cnt+=1\n\nprint(cnt)","model_generated_potentially_faster_code_col":"A, B, C = map(int, input().split())\n\n# Calculate the sum of A, B, and C\nS = A + B + C\n\n# Initialize the counter\ncnt = 0\n\n# Loop until at least one of A, B, or C becomes odd\nwhile (A & 1 == 0) and (B & 1 == 0) and (C & 1 == 0):\n    # Update A, B, and C using the sum S\n    A = (B >> 1) + (C >> 1)\n    B = (A >> 1) + (C >> 1)\n    C = (A >> 1) + (B >> 1)\n    \n    # Increment the counter\n    cnt += 1\n\nprint(cnt)"}
{"problem_id":"p03416","slow_code_col":"a,b = list(map(int, input().split()))\n\nn = 0\n\nfor i in range(a, b + 1):\n\n    f = True\n\n    s = str(i)\n\n    l = len(s)\n\n    for j in range(l\/\/2 + 1):\n\n        if s[j] != s[- j - 1]:\n\n            f = False\n\n            break\n\n    if f:\n\n        n += 1\n\nprint(n)","reference_code_col":"a,b = list(map(int, input().split()))\n\nn = 0\n\nfor i in range(1, 10):\n\n    for j in range(10):\n\n        for k in range(10):\n\n            s = 10000 * i + 1000 * j + 100 * k + 10 * j + i\n\n            if a <= s <= b:\n\n                n += 1\n\nprint(n)","model_generated_potentially_faster_code_col":"def count_palindromes(a, b):\n    def is_palindrome(num):\n        # Reverse the digits of the number using arithmetic\n        original = num\n        reversed_num = 0\n        while num > 0:\n            reversed_num = reversed_num * 10 + num % 10\n            num \/\/= 10\n        return original == reversed_num\n\n    count = 0\n    for i in range(a, b + 1):\n        if is_palindrome(i):\n            count += 1\n    return count\n\n# Input\na, b = map(int, input().split())\n\n# Output\nprint(count_palindromes(a, b))"}
{"problem_id":"p03723","slow_code_col":"import numpy as np\n\ncookies = np.array([int(x) for x in input().split()])\n\n\n\nif any(cookies%2):\n\n  ans = 0\n\nelif cookies[0] == cookies[1] == cookies[2]:\n\n  ans = -1\n\nelse:\n\n  ans = 0\n\n  while True:\n\n    if not any(cookies%2):\n\n      cookies = cookies\/\/2\n\n      ans += 1\n\n      continue\n\n    if all(cookies%2):\n\n      ans += 1\n\n    break\n\nprint(ans)","reference_code_col":"a, b, c = list(map(int, input().split()))\n\nif a == b == c and a%2 == 0:\n\n  print((-1))\n\nelif a%2 or b%2 or c%2:\n\n  print((0))\n\nelse:\n\n  ans = 0\n\n  while a%2 == b%2 == c%2 == 0:\n\n    a, b, c = (b+c)\/\/2, (a+c)\/\/2, (a+b)\/\/2\n\n    ans += 1\n\n  print(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input handling\ncookies = np.array([int(x) for x in input().split()])\n\n# Initial check: if any cookie count is odd\nif np.any(cookies % 2):\n    ans = 0\nelif np.all(cookies == cookies[0]):  # Check if all cookie counts are equal\n    ans = -1\nelse:\n    ans = 0\n    while True:\n        # Check if all elements are even\n        if np.all((cookies % 2) == 0):\n            cookies \/\/= 2  # Integer division by 2\n            ans += 1\n        else:\n            # If any element becomes odd, increment ans and exit\n            ans += 1\n            break\n\nprint(ans)"}
{"problem_id":"p03752","slow_code_col":"import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\n\n\n\n\ndef main():\n\n    N, K, *A = list(map(int, read().split()))\n\n\n\n    ans = INF\n\n    for bit in range(1 << N):\n\n        if (not (bit & 1)) or bin(bit).count('1') != K:\n\n            continue\n\n\n\n        total = 0\n\n        max_height = A[0]\n\n        for i, a in enumerate(A[1:], 1):\n\n            if a <= max_height:\n\n                if bit & (1 << i):\n\n                    total += max_height - a + 1\n\n                    max_height += 1\n\n            else:\n\n                max_height = a\n\n\n\n        if ans > total:\n\n            ans = total\n\n\n\n    print(ans)\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"import sys\n\nfrom itertools import combinations\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\n\n\n\n\ndef main():\n\n    N, K, *A = list(map(int, read().split()))\n\n\n\n    ans = INF\n\n    for comb in combinations(list(range(1, N)), K - 1):\n\n        included = [False] * N\n\n        for i in comb:\n\n            included[i] = True\n\n\n\n        total = 0\n\n        max_height = A[0]\n\n        for i, a in enumerate(A[1:], 1):\n\n            if a <= max_height:\n\n                if included[i]:\n\n                    total += max_height - a + 1\n\n                    max_height += 1\n\n            else:\n\n                max_height = a\n\n\n\n        if ans > total:\n\n            ans = total\n\n\n\n    print(ans)\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\n\ndef main():\n    # Read input efficiently\n    data = list(map(int, read().split()))\n    N, K = data[:2]\n    A = data[2:]\n\n    ans = INF\n\n    # Generate all bitmasks with exactly K set bits\n    from itertools import combinations\n\n    indices = list(range(N))\n    for selected_bits in combinations(indices, K):\n        # Ensure the first bit is always set\n        if 0 not in selected_bits:\n            continue\n\n        total = 0\n        max_height = A[0]\n\n        for i, a in enumerate(A[1:], 1):\n            if a <= max_height:\n                if i in selected_bits:\n                    total += max_height - a + 1\n                    max_height += 1\n                else:\n                    pass  # No change to max_height\n            else:\n                max_height = a\n\n            # Early termination if total exceeds current best\n            if total >= ans:\n                break\n\n        if total < ans:\n            ans = total\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02952","slow_code_col":"import math\n\nn = int(eval(input()))\n\ncnt = 0\n\nfor i in range(1, n + 1):\n\n    if math.floor(math.log10(i) + 1) % 2:\n\n        cnt += 1\n\nprint(cnt)","reference_code_col":"n = int(eval(input()))\n\ncnt = 0\n\nfor i in range(1, n + 1):\n\n    if len(str(i)) % 2:\n\n        cnt += 1\n\nprint(cnt)","model_generated_potentially_faster_code_col":"n = int(input())\n\ncnt = 0\ndigits = 1  # Start with 1-digit numbers\n\nwhile True:\n    # Calculate the range of numbers with `digits` digits\n    start = 10**(digits - 1)  # First number with `digits` digits\n    end = min(10**digits - 1, n)  # Last number with `digits` digits (or n, whichever is smaller)\n    \n    if start > n:  # If the range starts beyond n, stop\n        break\n    \n    # Count numbers in this range\n    cnt += (end - start + 1) if digits % 2 == 1 else 0\n    \n    # Move to the next digit length\n    digits += 1\n\nprint(cnt)"}
{"problem_id":"p03721","slow_code_col":"n,k = list(map(int,input().split()))\n\nl = [0]*(10**5+1)\n\nfor i in range(n):\n\n    ai,bi = list(map(int,input().split()))\n\n    l[ai]+=bi\n\nfor index,i in enumerate(l):\n\n    if i:\n\n        k-=i\n\n        if k<=0:\n\n            break\n\nprint(index)","reference_code_col":"from collections import defaultdict\n\nfrom sys import stdin\n\ninput = stdin.readline\n\nd = defaultdict(int)\n\nn,k = list(map(int,input().split()))\n\nfor _ in range(n):\n\n    a,b = list(map(int,input().split()))\n\n    d[a]+=b\n\nfor key in sorted(d.keys()):\n\n    v = d[key]\n\n    k-=v\n\n    if k <= 0:\n\n        break\n\nprint(key)","model_generated_potentially_faster_code_col":"import sys\n\n# Faster input reading\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse n and k\nn, k = int(data[0]), int(data[1])\n\n# Use a dictionary to store non-zero values\nl = {}\n\n# Parse the remaining inputs\nfor i in range(n):\n    ai, bi = int(data[2 + 2 * i]), int(data[2 + 2 * i + 1])\n    if ai in l:\n        l[ai] += bi\n    else:\n        l[ai] = bi\n\n# Iterate over sorted keys of the dictionary\nfor index in sorted(l.keys()):\n    k -= l[index]\n    if k <= 0:\n        print(index)\n        break"}
{"problem_id":"p03416","slow_code_col":"A, B = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(A, B+1):\n\n    l = list(str(i))\n\n\n\n    if l == list(reversed(l)):\n\n        cnt += 1\n\n\n\nprint(cnt)\n","reference_code_col":"A, B = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(A, B+1):\n\n    l = str(i)\n\n    if l == l[::-1]:\n\n        cnt += 1\n\n\n\nprint(cnt)\n","model_generated_potentially_faster_code_col":"A, B = map(int, input().split())\n\ncnt = 0\n\nfor num in range(A, B + 1):\n    # Convert number to string once\n    str_num = str(num)\n    \n    # Check if the string is a palindrome using slicing (faster than reversed())\n    if str_num == str_num[::-1]:\n        cnt += 1\n\nprint(cnt)"}
{"problem_id":"p03363","slow_code_col":"n = int(eval(input()))\n\nary = list(map(int, input().split()))\n\n#print(n,ary)\n\n\n\nary_2 = [ary[0]]\n\nfor i in range(1, n):\n\n    ary_2.append(ary[i] + ary_2[i-1])\n\nary_2 = [0] + ary_2\n\n#print(ary_2)\n\n\n\nfrom collections import Counter\n\nc = Counter(ary_2)\n\nv = (list(c.values()))\n\n#print(v)\n\n\n\nfrom math import factorial\n\ndef combinations_count(n, r):\n\n    return factorial(n) \/\/ (factorial(n - r) * factorial(r))\n\n\n\nans = 0\n\nfor j in v:\n\n    if j >1:\n\n        ans += combinations_count(j,2)\n\n\n\nprint(ans)","reference_code_col":"n = int(eval(input()))\n\nary = list(map(int, input().split()))\n\n#print(n,ary)\n\n\n\nary_2 = [ary[0]]\n\nfor i in range(1, n):\n\n    ary_2.append(ary[i] + ary_2[i-1])\n\nary_2 = [0] + ary_2\n\n#print(ary_2)\n\n\n\nfrom collections import Counter\n\nc = Counter(ary_2)\n\nv = (list(c.values()))\n\n#print(v)\n\n\n\nans = 0\n\nfor j in v:\n\n    if j >1:\n\n        ans += j * (j-1) \/\/ 2\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"from collections import Counter\n\n# Step 1: Read input\nn = int(input())\nary = list(map(int, input().split()))\n\n# Step 2: Compute prefix sums\nary_2 = [0]  # Start with 0\nfor i in range(n):\n    ary_2.append(ary_2[-1] + ary[i])\n\n# Step 3: Count occurrences of prefix sums\ncounter = Counter(ary_2)\n\n# Step 4: Calculate the result using combinatorics\nans = 0\nfor count in counter.values():\n    if count > 1:\n        ans += count * (count - 1) \/\/ 2  # Equivalent to nC2\n\n# Step 5: Output the result\nprint(ans)"}
{"problem_id":"p02983","slow_code_col":"import numpy as np\n\n\n\ndef ABC133C(l, r):\n\n    Min = np.inf\n\n    for i in range(l, r):\n\n        for j in range(i+1, r+1):\n\n            a = (i * j) % 2019\n\n            if a < Min:\n\n                Min = a\n\n                if a == 0: # \u3053\u3053\u306b\u6ce8\u76ee\n\n                    print(Min)\n\n                    return\n\n    print(Min)\n\n\n\nl, r = list(map(int, input().split()))\n\nABC133C(l, r)\n","reference_code_col":"def ABC133C(l, r):\n\n    Min = 1e10\n\n    for i in range(l, r):\n\n        for j in range(i+1, r+1):\n\n            a = (i * j) % 2019\n\n            if a < Min:\n\n                Min = a\n\n                if a == 0: # \u3053\u3053\u306b\u6ce8\u76ee\n\n                    print(Min)\n\n                    return\n\n    print(Min)\n\n\n\nl, r = list(map(int, input().split()))\n\nABC133C(l, r)\n","model_generated_potentially_faster_code_col":"def ABC133C(l, r):\n    MOD = 2019\n\n    # If the range is large enough, there will always be a pair with product % 2019 == 0\n    if r - l + 1 >= MOD:\n        print(0)\n        return\n\n    # Compute the unique remainders of numbers in the range [l, r] modulo 2019\n    remainders = [x % MOD for x in range(l, r + 1)]\n\n    # Initialize the minimum value to a large number\n    Min = float('inf')\n\n    # Check all unique pairs of remainders\n    n = len(remainders)\n    for i in range(n):\n        for j in range(i + 1, n):\n            product_mod = (remainders[i] * remainders[j]) % MOD\n            if product_mod < Min:\n                Min = product_mod\n                if Min == 0:  # Early exit if minimum is 0\n                    print(0)\n                    return\n\n    # Print the minimum value found\n    print(Min)\n\n\n# Input handling\nl, r = map(int, input().split())\nABC133C(l, r)"}
{"problem_id":"p02792","slow_code_col":"N = int(eval(input()))\n\nmem = [[0]*10 for i in range(10)]\n\n\n\nfor i in range(1,N+1):\n\n    a = int(str(i)[0])\n\n    b = int(str(i)[-1])\n\n    mem[a][b] += 1\n\n\n\nans = 0\n\nfor i in range(1,N+1):\n\n    a = int(str(i)[0])\n\n    b = int(str(i)[-1])\n\n    ans += mem[b][a]\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\n\n\nd = [[0]*10 for i in range(10)]\n\nfor n in range(1,N+1):\n\n    s = str(n)\n\n    d[int(s[0])][int(s[-1])] += 1\n\nans = 0\n\nfor i in range(10):\n\n    for j in range(10):\n\n        ans += d[i][j] * d[j][i]\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Initialize a 10x10 matrix to store counts of numbers with specific first and last digits\nmem = [[0] * 10 for _ in range(10)]\n\n# Precompute counts of numbers with specific first and last digits\nfor i in range(1, N + 1):\n    # Extract the first digit using integer division\n    first_digit = i\n    while first_digit >= 10:\n        first_digit \/\/= 10\n    \n    # Extract the last digit using modulo\n    last_digit = i % 10\n    \n    # Increment the count for this pair of first and last digits\n    mem[first_digit][last_digit] += 1\n\n# Calculate the final answer using the precomputed counts\nans = 0\nfor first_digit in range(1, 10):  # First digit ranges from 1 to 9\n    for last_digit in range(10):  # Last digit ranges from 0 to 9\n        ans += mem[first_digit][last_digit] * mem[last_digit][first_digit]\n\nprint(ans)"}
{"problem_id":"p03796","slow_code_col":"N = int(eval(input()))\n\np = 1\n\nfor i in range(N):\n\n    p *= (i + 1)\n\n    p %= (1e9 + 7)\n\nprint((int(p)))","reference_code_col":"N = int(eval(input()))\n\np = 1\n\nfor i in range(N):\n\n    p = p * (i + 1) % (1e9 + 7)\n\nprint((int(p)))","model_generated_potentially_faster_code_col":"MOD = int(1e9 + 7)  # Define the modulo constant as an integer\n\nN = int(input())  # Read input as an integer\n\np = 1  # Initialize the result\n\nfor i in range(1, N + 1):  # Iterate directly from 1 to N\n    p = (p * i) % MOD  # Compute factorial modulo efficiently\n\nprint(p)  # Print the result"}
{"problem_id":"p02725","slow_code_col":"k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\ndiff = []\n\n\n\nfor i in range(n - 1):\n\n    diff.append(a[i + 1] - a[i])\n\ndiff.append(k - a[-1] + a[0])\n\n\n\nprint((k - max(diff)))\n","reference_code_col":"k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\na.append(k + a[0])\n\ndiff = [a1 - a0 for a0, a1 in zip(a, a[1:])]\n\n\n\nprint((k - max(diff)))\n","model_generated_potentially_faster_code_col":"# Input parsing\nk, n = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate all differences, including the circular difference\ndiff = [a[i + 1] - a[i] for i in range(n - 1)] + [k - a[-1] + a[0]]\n\n# Compute the result\nprint(k - max(diff))"}
{"problem_id":"p03253","slow_code_col":"class Calc:\n\n    def __init__(self, max_value, mod):\n\n        \"\"\"combination(max_value, all)\"\"\"\n\n        fact = [-1] * (max_value + 1)\n\n        fact[0] = 1\n\n        fact[1] = 1\n\n        for x in range(2, max_value + 1):\n\n            fact[x] = x * fact[x - 1] % mod\n\n\n\n        invs = [1] * (max_value + 1)\n\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n\n        for x in range(max_value - 1, 0, -1):\n\n            invs[x] = invs[x + 1] * (x + 1) % mod\n\n\n\n        self.fact = fact\n\n        self.invs = invs\n\n        self.mod = mod\n\n\n\n    def combination(self, n, r):\n\n        if n - r < r:\n\n            return self.combination(n, n - r)\n\n        if r < 0:\n\n            return 0\n\n        if r == 0:\n\n            return 1\n\n        if r == 1:\n\n            return n\n\n        return self.fact[n] * self.invs[r] * self.invs[n - r] % self.mod\n\n\n\n\n\ndef gen(n):\n\n    x = n\n\n    d = 2\n\n    cnt = 0\n\n    while x % d == 0:\n\n        x \/\/= d\n\n        cnt += 1\n\n    yield cnt\n\n\n\n    d = 3\n\n    ma = d * d\n\n    while ma <= n:\n\n        cnt = 0\n\n        while x % d == 0:\n\n            x \/\/= d\n\n            cnt += 1\n\n        yield cnt\n\n        ma += d * 4 + 4\n\n        d += 2\n\n\n\n    if x > 1:\n\n        yield 1\n\n\n\n\n\ndef main():\n\n    MOD = 10 ** 9 + 7\n\n\n\n    N, M = list(map(int, input().split()))\n\n\n\n    cal = Calc(max_value=N + 30, mod=MOD)\n\n\n\n    ans = 1\n\n    for cnt in gen(M):\n\n        ans = (ans * cal.combination(N + cnt - 1, cnt)) % MOD\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def gen(n):\n\n    x = n\n\n    d = 2\n\n    cnt = 0\n\n    while x % d == 0:\n\n        x \/\/= d\n\n        cnt += 1\n\n    yield cnt\n\n\n\n    d = 3\n\n    while d * d <= n:\n\n        cnt = 0\n\n        while x % d == 0:\n\n            x \/\/= d\n\n            cnt += 1\n\n        yield cnt\n\n        d += 2\n\n\n\n    if x > 1:\n\n        yield 1\n\n\n\n\n\ndef main():\n\n    MOD = 10 ** 9 + 7\n\n\n\n    N, M = list(map(int, input().split()))\n\n\n\n    ans = 1\n\n    for cnt in gen(M):\n\n        for d in range(cnt):\n\n            ans = (ans * (N - 1 + cnt - d) % MOD) * pow(d + 1, MOD - 2, MOD) % MOD\n\n            \n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"class Calc:\n    def __init__(self, max_value, mod):\n        \"\"\"Precompute factorials and modular inverses.\"\"\"\n        self.mod = mod\n\n        # Precompute factorials\n        fact = [1] * (max_value + 1)\n        for x in range(2, max_value + 1):\n            fact[x] = fact[x - 1] * x % mod\n\n        # Precompute modular inverses iteratively\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)  # Fermat's Little Theorem\n        for x in range(max_value, 1, -1):\n            invs[x - 1] = invs[x] * x % mod\n\n        self.fact = fact\n        self.invs = invs\n\n    def combination(self, n, r):\n        \"\"\"Efficiently compute nCr % mod.\"\"\"\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return self.fact[n] * self.invs[r] % self.mod * self.invs[n - r] % self.mod"}
{"problem_id":"p02983","slow_code_col":"def c_remainder_minimization_2019(L, R):\n\n    ans = float('inf')\n\n    for i in range(L, min(R, L + 2019)):\n\n        for j in range(i + 1, min(R + 1, L + 2020)):\n\n            ans = min(ans, (i * j) % 2019)\n\n    return ans\n\n\n\nL, R = [int(i) for i in input().split()]\n\nprint((c_remainder_minimization_2019(L, R)))","reference_code_col":"def c_remainder_minimization_2019(L, R):\n\n    ans = float('inf')\n\n    for i in range(L, min(R, L + 2019)):\n\n        for j in range(i + 1, min(R + 1, L + 2020)):\n\n            ans = min(ans, (i * j) % 2019)\n\n            if ans == 0:\n\n                return 0\n\n    return ans\n\n\n\nL, R = [int(i) for i in input().split()]\n\nprint((c_remainder_minimization_2019(L, R)))","model_generated_potentially_faster_code_col":"def c_remainder_minimization_2019(L, R):\n    MOD = 2019\n\n    # If the range [L, R] spans more than 2019, the minimum remainder is guaranteed to be 0\n    if R - L >= MOD:\n        return 0\n\n    # Collect unique remainders modulo 2019 within the range [L, R]\n    remainders = [(x % MOD) for x in range(L, R + 1)]\n\n    # Initialize the answer to a large value\n    ans = float('inf')\n\n    # Iterate over all pairs of remainders\n    n = len(remainders)\n    for i in range(n):\n        for j in range(i + 1, n):\n            product_mod = (remainders[i] * remainders[j]) % MOD\n            ans = min(ans, product_mod)\n\n    return ans\n\n\n# Input handling\nL, R = map(int, input().split())\nprint(c_remainder_minimization_2019(L, R))"}
{"problem_id":"p03371","slow_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\nval = float('inf')\n\nfor k in range(10 ** 5 + 1):\n\n    val = min(val, 2 * c * k + max(x - k, 0) * a + max(y - k, 0) * b)\n\nprint(val)","reference_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = 0\n\nans += min(A + B, 2 * C) * min(X, Y)\n\nif X > Y:\n\n    ans += min(A, 2 * C) * (X - Y)\n\nelif X < Y:\n\n    ans += min(B, 2 * C) * (Y - X)\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"# Input values\na, b, c, x, y = list(map(int, input().split()))\n\n# Function to compute the value of the expression for a given k\ndef compute_value(k):\n    return 2 * c * k + max(x - k, 0) * a + max(y - k, 0) * b\n\n# Evaluate the expression at critical points\ncritical_points = [0, x, y]\nval = float('inf')\n\nfor k in critical_points:\n    val = min(val, compute_value(k))\n\n# Also check a small range around the critical points (optional refinement)\nfor k in range(max(0, min(x, y) - 10), min(x, y) + 10):\n    val = min(val, compute_value(k))\n\nprint(val)"}
{"problem_id":"p03796","slow_code_col":"from math import factorial as f\n\nn = int(eval(input()))\n\nprint((f(n) % (10 ** 9 + 7)))","reference_code_col":"n = int(eval(input()))\n\np = 1\n\nfor i in range(n):\n\n    p = (p * (i+1)) % (10 ** 9 + 7)\n\nprint(p)","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\nn = int(input())  # Avoid using eval for security reasons\n\n# Compute factorial modulo MOD efficiently\nresult = 1\nfor i in range(2, n + 1):\n    result = (result * i) % MOD\n\nprint(result)"}
{"problem_id":"p03039","slow_code_col":"n,m,k=list(map(int,input().split()))\n\nmod=10**9+7\n\nf=[1]\n\nfor i in range(2*10**5+7):f+=[f[-1]*(i+1)%mod]\n\ndef comb(a,b):return f[a]*pow(f[b],mod-2,mod)*pow(f[a-b],mod-2,mod)%mod\n\nans=0\n\nfor i in range(1,n):\n\n  ans+=(i*(n-i)*m**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nfor i in range(1,m):\n\n  ans+=(i*(m-i)*n**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nprint(ans)","reference_code_col":"n,m,k=list(map(int,input().split()))\n\n\n\nmod = 10**9+7\n\nf = [1]\n\nfor i in range(n*m):\n\n  f += [f[-1]*(i+1) % mod]\n\ndef comb(a, b):\n\n  return f[a]*pow(f[b], mod-2, mod)*pow(f[a-b], mod-2, mod) % mod\n\n\n\nans=0\n\nfor dist in range(1,n):\n\n  c=n-dist\n\n  p=(c*m*m)%mod\n\n  ans+=p*dist\n\nfor dist in range(1,m):\n\n  c=m-dist\n\n  p=(c*n*n)%mod\n\n  ans+=p*dist\n\nans%=mod\n\nprint((ans*comb(n*m-2,k-2)%mod))","model_generated_potentially_faster_code_col":"n, m, k = map(int, input().split())\nmod = 10**9 + 7\n\n# Step 1: Precompute factorials and inverse factorials\nmax_fact = 2 * 10**5 + 7\nf = [1] * (max_fact + 1)\nfor i in range(2, max_fact + 1):\n    f[i] = f[i - 1] * i % mod\n\n# Precompute modular inverses of factorials\ninv_f = [1] * (max_fact + 1)\ninv_f[-1] = pow(f[-1], mod - 2, mod)\nfor i in range(max_fact - 1, 0, -1):\n    inv_f[i] = inv_f[i + 1] * (i + 1) % mod\n\n# Optimized combination function\ndef comb(a, b):\n    if b < 0 or b > a:\n        return 0\n    return f[a] * inv_f[b] % mod * inv_f[a - b] % mod\n\n# Precompute comb(n*m-2, k-2)\nconstant_comb = comb(n * m - 2, k - 2)\n\n# Helper function for the main computation\ndef compute_sum(limit, multiplier):\n    return sum(i * (limit - i) * multiplier % mod for i in range(1, limit)) % mod\n\n# Main computation\nans = 0\nans += compute_sum(n, m**2) * constant_comb % mod\nans += compute_sum(m, n**2) * constant_comb % mod\nans %= mod\n\nprint(ans)"}
{"problem_id":"p03796","slow_code_col":"import math\n\nprint((math.factorial(int(eval(input())))%(10**9+7)))","reference_code_col":"ans=1\n\nn=int(eval(input()))\n\nfor i in range(1,n+1):\n\n  ans*=i\n\n  ans=ans%(10**9+7)\n\nprint(ans)","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\ndef factorial_mod(n, mod):\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % mod\n    return result\n\ntry:\n    n = int(input())\n    print(factorial_mod(n, MOD))\nexcept ValueError as e:\n    print(\"Invalid input:\", e)"}
{"problem_id":"p03371","slow_code_col":"A, B, C, X, Y = [int(_) for _ in input().split()]\n\nans = A * X + B * Y\n\nfor i in range(max(X, Y) + 1):\n\n    cost = 2 * C * i\n\n    if X > i:\n\n        cost += A * (X - i)\n\n    if Y > i:\n\n        cost += B * (Y - i)\n\n    ans = min(ans, cost)\n\nprint(ans)","reference_code_col":"A, B, C, X, Y = [int(_) for _ in input().split()]\n\nM = max(X, Y)\n\nprint((min(2 * C * M, 2 * C * (X + Y - M) + A *\n\n          (M - Y) + B * (M - X), A * X + B * Y)))\n","model_generated_potentially_faster_code_col":"# Input parsing\nA, B, C, X, Y = map(int, input().split())\n\n# Initial cost without any bundles\nans = A * X + B * Y\n\n# Determine the range of i where meaningful cost changes occur\n# i ranges from 0 to min(X, Y), as beyond this point, one of X or Y becomes zero\nfor i in range(min(X, Y) + 1):\n    # Calculate the cost for buying i bundles\n    cost = 2 * C * i  # Cost of i bundles\n    cost += A * max(0, X - i)  # Remaining items of type X\n    cost += B * max(0, Y - i)  # Remaining items of type Y\n    \n    # Update the minimum cost\n    ans = min(ans, cost)\n\nprint(ans)"}
{"problem_id":"p03371","slow_code_col":"import math\n\n\n\na,b,c,x,y = list(map(int,input().split()))\n\n\n\n# c\u3092\u5168\u63a2\u7d22\uff1f\n\nres = float('inf')\n\nfor i in range(max(x,y)*2+1):\n\n    money = i * c\n\n    if i\/2<x:\n\n        money += math.ceil(x-i\/2) * a\n\n    if i\/2<y:\n\n        money += math.ceil(y-i\/2) * b\n\n    res = min(res,money)\n\n\n\nprint(res)\n","reference_code_col":"res = 10**30\n\na,b,c,x,y = list(map(int,input().split()))\n\nfor i in range(0,max(x,y)+1):\n\n    # AB\u30922*i\u307e\u3044\u8cb7\u3046\n\n    tmp = 2 * i * c\n\n    xx,yy = x - i, y - i\n\n    tmp += max(0,xx) * a\n\n    tmp += max(0,yy) * b\n\n    res = min(res, tmp)\n\nprint(res)\n","model_generated_potentially_faster_code_col":"import math\n\n# Input values\na, b, c, x, y = map(int, input().split())\n\n# Initialize result with infinity\nres = float('inf')\n\n# Limit the range of i to 2 * min(x, y)\nmax_i = 2 * min(x, y)\n\nfor i in range(max_i + 1):\n    # Calculate the total cost\n    money = i * c\n    \n    # Calculate remaining quantities\n    remaining_x = x - (i \/\/ 2)\n    remaining_y = y - (i \/\/ 2)\n    \n    # Add costs for remaining quantities\n    if remaining_x > 0:\n        money += remaining_x * a\n    if remaining_y > 0:\n        money += remaining_y * b\n    \n    # Update the minimum cost\n    res = min(res, money)\n\n# Output the result\nprint(res)"}
{"problem_id":"p03000","slow_code_col":"import numpy as np\n\n\n\ntemp=list(map(int, input().split()))\n\n\n\nN=temp[0]\n\nX=temp[1]\n\n\n\nL=list(map(int, input().split()))\n\n\n\nind=1\n\nwhile np.sum(L[:ind])<=X and ind<=N:\n\n  ind+=1\n\n  \n\nprint(ind)","reference_code_col":"N, X=list(map(int, input().split()))\n\nL=list(map(int, input().split()))\n\nL=[0]+L\n\n \n\nl=int(0)\n\ncounter=int(0)\n\nwhile l+L[counter]<=X and counter<=N:\n\n  l+=L[counter]\n\n  counter+=int(1)\n\n  if counter==N+1:\n\n    break\n\n  \n\nprint(counter)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\ntemp = list(map(int, input().split()))\nN = temp[0]\nX = temp[1]\n\n# Read the list L\nL = list(map(int, input().split()))\n\n# Initialize variables\nrunning_sum = 0\nind = 0\n\n# Iterate through the list while the sum is within the limit\nfor i in range(N):\n    running_sum += L[i]\n    if running_sum > X:\n        break\n    ind += 1\n\n# Print the result\nprint(ind + 1)"}
{"problem_id":"p03558","slow_code_col":"import heapq\n\nK=int(eval(input()))\n\ndist=[10**15 for i in range(K)]\n\ndist[1]=1\n\nq=[]\n\nheapq.heappush(q,(0,1))\n\nwhile (len(q)!=0):\n\n    prc,src=heapq.heappop(q)\n\n    if dist[src]<prc:\n\n        continue\n\n    if dist[(src+1)%K]>dist[src]+1:\n\n        dist[(src+1)%K]=dist[src]+1\n\n        heapq.heappush(q,(dist[(src+1)%K],(src+1)%K))\n\n    if dist[(10*src)%K]>dist[src]:\n\n        dist[(10*src)%K]=dist[src]\n\n        heapq.heappush(q,(dist[(src*10)%K],(src*10)%K))\n\nprint((dist[0]))\n","reference_code_col":"from collections import deque\n\nK=int(eval(input()))\n\ndist=[10**15 for i in range(K)]\n\ndist[1]=1\n\nq=deque([1])\n\nwhile(len(q)>0):\n\n    r=q.popleft()\n\n    s=(r+1)%K\n\n    if dist[r]+1<dist[s]:\n\n        dist[s]=dist[r]+1\n\n        q.append(s)\n\n    t=(r*10)%K\n\n    if dist[r]<dist[t]:\n\n        dist[t]=dist[r]\n\n        q.appendleft(t)\n\nprint((dist[0]))\n","model_generated_potentially_faster_code_col":"import heapq\n\n# Read input efficiently\nK = int(input())\n\n# Initialize distances and priority queue\ndist = [float('inf')] * K\ndist[1] = 1\nq = [(1, 1)]  # (distance, node)\nvisited = set()\n\nwhile q:\n    prc, src = heapq.heappop(q)\n\n    # Skip if the node has already been processed\n    if src in visited:\n        continue\n    visited.add(src)\n\n    # If we've reached the target node (0), terminate early\n    if src == 0:\n        print(prc)\n        break\n\n    # Explore neighbors: (src + 1) % K\n    neighbor1 = (src + 1) % K\n    if dist[neighbor1] > prc + 1:\n        dist[neighbor1] = prc + 1\n        heapq.heappush(q, (prc + 1, neighbor1))\n\n    # Explore neighbors: (10 * src) % K\n    neighbor2 = (10 * src) % K\n    if dist[neighbor2] > prc:\n        dist[neighbor2] = prc\n        heapq.heappush(q, (prc, neighbor2))\nelse:\n    # If the loop completes without finding a path to 0\n    print(dist[0])"}
{"problem_id":"p02994","slow_code_col":"import numpy as np\n\nN,L = list(map(int, input().split()))\n\ntaste = np.array([L+i-1 for i in range(1,N+1)])\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min(np.abs(taste))))\n\nelse:\n\n  print((sum(taste) - min(np.abs(taste))))","reference_code_col":"N,L = list(map(int, input().split()))\n\ntaste = [L+i-1 for i in range(1,N+1)]\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min([abs(x) for x in taste])))\n\nelse:\n\n  print((sum(taste) - min([abs(x) for x in taste])))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input reading\nN, L = map(int, input().split())\n\n# Compute the sum of the sequence using the arithmetic progression formula\ntotal_sum = N * (2 * L + N - 1) \/\/ 2\n\n# Determine the element closest to zero\nif L <= 0 <= L + N - 1:\n    # If zero lies within the range [L, L+N-1], the closest element to zero is 0\n    closest_to_zero = 0\nelse:\n    # Otherwise, the closest element to zero is either L or L+N-1\n    closest_to_zero = L if abs(L) < abs(L + N - 1) else L + N - 1\n\n# Adjust the total sum based on the sign of the last element\nif L + N - 1 < 0:\n    result = total_sum + abs(closest_to_zero)\nelse:\n    result = total_sum - abs(closest_to_zero)\n\n# Output the result\nprint(result)"}
{"problem_id":"p03371","slow_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\n\n\nans = float('inf')\n\n\n\nfor i in range(2 * 10**5 + 1):\n\n    ans = min(ans, a * max(x - i, 0) + b * max(y - i, 0) + 2 * c * i)\n\n\n\nprint(ans)","reference_code_col":"A,B,C,X,Y = list(map(int,input().split()))\n\nmin_xy = min(X,Y)\n\nmax_xy = max(X,Y)\n\nans1 = 2 * C * min_xy + A * (X-min_xy) + B * (Y-min_xy) # \u7121\u99c4\u306b\u306a\u3089\u306a\u3044\u7bc4\u56f2\u3067AB\u30d4\u30b6\u3092\u8cb7\u3044\u3001\u6b8b\u308a\u3092\u8cb7\u3046\n\nans2 = A*X + B*Y # AB\u30d4\u30b6\u3092\u8cb7\u308f\u306a\u3044\n\nans3 = 2 * C * max_xy # AB\u30d4\u30b6\u3060\u3051\u3092\u8cb7\u3046\n\nprint((min(ans1,ans2,ans3)))","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\n\n# Initialize the answer to infinity\nans = float('inf')\n\n# Iterate only up to max(x, y)\nfor i in range(max(x, y) + 1):\n    ans = min(ans, a * max(x - i, 0) + b * max(y - i, 0) + 2 * c * i)\n\nprint(ans)"}
{"problem_id":"p02792","slow_code_col":"n = int(eval(input()))\n\n\n\ncnt = 0\n\nfor i in range(1, n+1):\n\n    i_str = str(i)\n\n    if len(i_str) == 1:\n\n        cnt += 1\n\n        continue\n\n    if len(i_str) == 2:\n\n        if int(i_str[0]) == int(i_str[1]):\n\n            cnt += 3\n\n        elif int(i_str[1]) != 0 and int(i_str[0]) > int(i_str[1]):\n\n            cnt += 2\n\n        continue\n\n    if len(i_str) == 3:\n\n        if int(i_str[0]) == int(i_str[2]):\n\n            cnt += 4 + (2 * (int(i_str[1])+1) - 1)\n\n        elif int(i_str[2]) != 0 and int(i_str[0]) > int(i_str[2]):\n\n            cnt += 22\n\n        elif int(i_str[0]) < int(i_str[2]):\n\n            cnt += 2\n\n        continue\n\n    if len(i_str) == 4:\n\n        if int(i_str[0]) == int(i_str[3]):\n\n            cnt += 24 + 20 * int(i_str[1]) + 2 * (int(i_str[2])+1) - 1\n\n        elif int(i_str[3]) != 0 and int(i_str[0]) > int(i_str[3]):\n\n            cnt += 222\n\n        elif int(i_str[0]) < int(i_str[3]):\n\n            cnt += 22\n\n        continue\n\n    if len(i_str) == 5:\n\n        if int(i_str[0]) == int(i_str[4]):\n\n            cnt += 224 + 200 * int(i_str[1]) + 20 * int(i_str[2]) + 2 * (int(i_str[3])+1) - 1\n\n        elif int(i_str[4]) != 0 and int(i_str[0]) > int(i_str[4]):\n\n            cnt += 2222\n\n        elif int(i_str[0]) < int(i_str[4]):\n\n            cnt += 222\n\n        continue\n\n    if len(i_str) == 6:\n\n        if int(i_str[0]) == int(i_str[5]):\n\n            cnt += 2224 + 2000 * int(i_str[1]) + 200 * int(i_str[2]) + 20 * int(i_str[3]) + 2 * (int(i_str[4])+1) - 1\n\n        elif int(i_str[5]) != 0 and int(i_str[0]) > int(i_str[5]):\n\n            cnt += 22222\n\n        elif int(i_str[0]) < int(i_str[5]):\n\n            cnt += 2222\n\n        continue\n\n\n\nprint(cnt)","reference_code_col":"n = int(eval(input()))\n\n\n\nc = [[0 for _ in range(10)] for __ in range(10)]\n\nfor i in range(1, n+1):\n\n    str_i = str(i)\n\n    head = int(str_i[0])\n\n    tail = int(str_i[-1])\n\n    c[head][tail] += 1\n\n\n\ncnt = 0\n\nfor i in range(10):\n\n    for j in range(10):\n\n        cnt += c[i][j] * c[j][i]\n\n\n\nprint(cnt)","model_generated_potentially_faster_code_col":"def optimized_count(n):\n    cnt = 0\n\n    # Helper function to extract digits of a number\n    def get_digits(x):\n        digits = []\n        while x > 0:\n            digits.append(x % 10)\n            x \/\/= 10\n        return digits[::-1]\n\n    for i in range(1, n + 1):\n        digits = get_digits(i)\n        length = len(digits)\n\n        if length == 1:\n            cnt += 1\n        elif length == 2:\n            if digits[0] == digits[1]:\n                cnt += 3\n            elif digits[1] != 0 and digits[0] > digits[1]:\n                cnt += 2\n        elif length == 3:\n            if digits[0] == digits[2]:\n                cnt += 4 + (2 * (digits[1] + 1) - 1)\n            elif digits[2] != 0 and digits[0] > digits[2]:\n                cnt += 22\n            elif digits[0] < digits[2]:\n                cnt += 2\n        elif length == 4:\n            if digits[0] == digits[3]:\n                cnt += 24 + 20 * digits[1] + 2 * (digits[2] + 1) - 1\n            elif digits[3] != 0 and digits[0] > digits[3]:\n                cnt += 222\n            elif digits[0] < digits[3]:\n                cnt += 22\n        elif length == 5:\n            if digits[0] == digits[4]:\n                cnt += 224 + 200 * digits[1] + 20 * digits[2] + 2 * (digits[3] + 1) - 1\n            elif digits[4] != 0 and digits[0] > digits[4]:\n                cnt += 2222\n            elif digits[0] < digits[4]:\n                cnt += 222\n        elif length == 6:\n            if digits[0] == digits[5]:\n                cnt += 2224 + 2000 * digits[1] + 200 * digits[2] + 20 * digits[3] + 2 * (digits[4] + 1) - 1\n            elif digits[5] != 0 and digits[0] > digits[5]:\n                cnt += 22222\n            elif digits[0] < digits[5]:\n                cnt += 2222\n\n    return cnt\n\n\n# Input and output\nn = int(eval(input()))\nprint(optimized_count(n))"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nN = int(eval(input()))\n\nans = math.factorial(N) % (10**9 + 7)\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nmod = 10**9 + 7\n\nans = 1\n\nfor i in range(1, N + 1):\n\n    ans *= i\n\n    ans %= mod\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\n# Input\nN = int(eval(input()))\n\n# Compute factorial iteratively with modulo\nans = 1\nfor i in range(2, N + 1):\n    ans = (ans * i) % MOD\n\nprint(ans)"}
{"problem_id":"p03038","slow_code_col":"from heapq import heappop, heappush\n\n\n\nn, m = list(map(int, input().split()))\n\na = tuple(map(int, input().split()))\n\n\n\nhq = []\n\nfor aa in a:\n\n    heappush(hq, (-aa, 1))\n\n\n\nfor _ in range(m):\n\n    b, c = list(map(int, input().split()))\n\n    heappush(hq, (-c, b))\n\n\n\nrest = n\n\nans = 0\n\nwhile rest > 0:\n\n    num, cnt = heappop(hq)\n\n\n\n    num *= (-1)\n\n    use = min(rest, cnt)\n\n    ans += use * num\n\n    rest -= use\n\n\n\nprint(ans)\n","reference_code_col":"def main():\n\n    from collections import Counter\n\n    from operator import itemgetter\n\n\n\n    import sys\n\n    input = sys.stdin.readline\n\n\n\n    N, M = list(map(int, input().split()))\n\n    a = list(map(int, input().split()))\n\n\n\n    ctr = Counter(a)\n\n    for _ in range(M):\n\n        b, c = list(map(int, input().split()))\n\n        ctr[c] += b\n\n\n\n    ans = 0\n\n    rest = N\n\n    for integer, count in sorted(list(ctr.items()), key=itemgetter(0), reverse=True):\n\n        take = min(rest, count)\n\n        ans += take * integer\n\n        rest -= take\n\n        if not rest:\n\n            break\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n\n# import sys\n\n# input = sys.stdin.readline\n\n# \n\n# sys.setrecursionlimit(10 ** 7)\n\n# \n\n# (int(x)-1 for x in input().split())\n\n# rstrip()\n","model_generated_potentially_faster_code_col":"n, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Read and sort the operation values in descending order\noperations = []\nfor _ in range(m):\n    b, c = map(int, input().split())\n    operations.append((c, b))\n\n# Sort operations by value (c) in descending order\noperations.sort(reverse=True, key=lambda x: x[0])\n\n# Sort the original array in descending order\na.sort(reverse=True)\n\n# Merge the two sorted lists and calculate the result\nans = 0\nrest = n\ni, j = 0, 0\n\nwhile rest > 0:\n    if i < len(a) and (j >= len(operations) or a[i] >= operations[j][0]):\n        # Use an element from the original array\n        use = min(rest, 1)\n        ans += use * a[i]\n        rest -= use\n        i += 1\n    elif j < len(operations):\n        # Use an element from the operations\n        use = min(rest, operations[j][1])\n        ans += use * operations[j][0]\n        rest -= use\n        j += 1\n\nprint(ans)"}
{"problem_id":"p03837","slow_code_col":"import numpy as np\n\n\n\nn, m = list(map(int, input().split()))\n\n\n\nd = np.ones((n, n)) * 1001\n\n\n\nes = []\n\nfor i in range(m):\n\n    es.append(list(map(int, input().split())))\n\n\n\nfor (i, j, w) in es:\n\n    d[i - 1][j - 1] = w\n\n    d[j - 1][i - 1] = w\n\n\n\n\n\nfor k in range(n):\n\n    for i in range(n):\n\n        for j in range(n):\n\n            l = d[i][k] + d[k][j]\n\n            if d[i][j] > l:\n\n                d[i][j] = l\n\n\n\nc = 0\n\nfor (i, j, w) in es:\n\n    if d[i - 1][j - 1] < w:\n\n        c += 1\n\n\n\nprint(c)\n","reference_code_col":"n, m = list(map(int, input().split()))\n\n\n\nd = [[1001] * n for i in range(n)]\n\n\n\nes = []\n\nfor i in range(m):\n\n    es.append(list(map(int, input().split())))\n\n\n\nfor (i, j, w) in es:\n\n    d[i - 1][j - 1] = w\n\n    d[j - 1][i - 1] = w\n\n\n\n\n\nfor k in range(n):\n\n    for i in range(n):\n\n        for j in range(n):\n\n            l = d[i][k] + d[k][j]\n\n            if d[i][j] > l:\n\n                d[i][j] = l\n\n\n\nc = 0\n\nfor (i, j, w) in es:\n\n    if d[i - 1][j - 1] < w:\n\n        c += 1\n\n\n\nprint(c)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input: Number of nodes (n) and edges (m)\nn, m = map(int, input().split())\n\n# Initialize distance matrix with a large value (infinity equivalent)\nINF = 1001\nd = np.full((n, n), INF, dtype=int)\n\n# Set diagonal elements to 0 (distance to self is zero)\nnp.fill_diagonal(d, 0)\n\n# Read edges and update the distance matrix\nfor _ in range(m):\n    i, j, w = map(int, input().split())\n    d[i - 1][j - 1] = w\n    d[j - 1][i - 1] = w\n\n# Floyd-Warshall Algorithm to compute all-pairs shortest paths\nfor k in range(n):\n    for i in range(n):\n        # Avoid unnecessary inner loop if d[i][k] is infinity\n        if d[i][k] < INF:\n            for j in range(n):\n                # Update shortest path if a better path is found\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n\n# Count edges that are not part of the shortest paths\nc = 0\nfor _ in range(m):\n    i, j, w = map(int, input().split())\n    if d[i - 1][j - 1] < w:\n        c += 1\n\nprint(c)"}
{"problem_id":"p03371","slow_code_col":"A,B,C,X,Y = list(map(int,input().split()))\n\nl = []\n\nfor i in range(max(X,Y)+1):\n\n    T = i * C * 2\n\n    if i < X: \n\n        T += (X-i)*A\n\n    if i < Y:\n\n        T += (Y-i)*B\n\n    l.append(T)\n\nl.sort()\n\nprint((l[0]))","reference_code_col":"A,B,C,X,Y = list(map(int,input().split()))\n\nans = 0\n\nif 2*C <= A+B:\n\n    Z = min(X,Y)\n\n    ans = 2*C*Z\n\n    X -= Z\n\n    Y -= Z\n\nans += min(2*C*X,A*X)\n\nans += min(2*C*Y,B*Y)\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Input parsing\nA, B, C, X, Y = map(int, input().split())\n\n# Precompute constants\ntwo_C = 2 * C\nmin_T = float('inf')  # Initialize with infinity to find the minimum\n\n# Iterate over the range [0, max(X, Y)]\nfor i in range(max(X, Y) + 1):\n    T = i * two_C  # Base cost for pairing A and B\n\n    if i < X:\n        T += (X - i) * A  # Add remaining A's cost\n    if i < Y:\n        T += (Y - i) * B  # Add remaining B's cost\n\n    # Update the minimum value\n    if T < min_T:\n        min_T = T\n\n# Output the minimum value\nprint(min_T)"}
{"problem_id":"p02983","slow_code_col":"# \u53c2\u8003 https:\/\/atcoder.jp\/contests\/abc133\/submissions\/7966658\n\n\n\nimport numpy as np\n\n\n\ndef abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    if R - L > 673: return 0\n\n    x = np.arange(L, R+1, dtype=np.int64)\n\n    #y = x[:, None] * x[None, :] % 2019\n\n    y = x.reshape(-1, 1) * x.reshape(1, -1)  # \u533a\u9593\u5185\u306e\u3059\u3079\u3066\u306e\u7d44\u5408\u305b\u306e\u7a4d\n\n    y %= 2019\n\n    np.fill_diagonal(y, 2019)  # \u5bfe\u89d2\u6210\u5206\u306f\u7121\u8996\u3059\u308b (\u540c\u3058\u6570\u30922\u56de\u9078\u3079\u306a\u3044) \u306e\u3067inf\u5024\u3067\u57cb\u3081\u308b\n\n    return y.min()\n\n\n\nprint((abc133_c()))","reference_code_col":"def abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    # \u533a\u9593\u306e\u5e45\u304c673\u3042\u308c\u3070\u3001673\u306e\u500d\u6570\u30683\u306e\u500d\u6570\u304c\u542b\u307e\u308c\u3066\u30012019\u306e\u500d\u6570\u304c\u4f5c\u308c\u308b\n\n    if R - L > 673: return 0\n\n    # \u305d\u308c\u4ee5\u5916\u306f\u8a66\u3059\n\n    ans = 2019\n\n    for i in range(L, R+1):\n\n        for j in range(L, i):\n\n            m = i * j % 2019\n\n            ans = min(m, ans)\n\n    return ans\n\n\n\nprint((abc133_c()))","model_generated_potentially_faster_code_col":"def abc133_c():\n    L, R = map(int, input().split())\n\n    # Early termination if the range is too large\n    if R - L > 673:\n        return 0\n\n    # Reduce the range [L, R] to unique residues modulo 2019\n    residues = list(range(L % 2019, R % 2019 + 1))\n    if L \/\/ 2019 != R \/\/ 2019:  # Handle wrap-around cases\n        residues += list(range(0, 2019))\n\n    # Remove duplicates and sort residues\n    residues = sorted(set(residues))\n\n    # Compute the minimum product modulo 2019\n    min_product_mod = 2019\n    for i in range(len(residues)):\n        for j in range(i + 1, len(residues)):\n            product_mod = (residues[i] * residues[j]) % 2019\n            if product_mod < min_product_mod:\n                min_product_mod = product_mod\n                if min_product_mod == 0:  # Early termination if minimum is 0\n                    return 0\n\n    return min_product_mod\n\n\nprint(abc133_c())"}
{"problem_id":"p03835","slow_code_col":"#ABC951B\/Sum_of_Three_Integers\n\n\n\nK, S = list(map(int, input().split()))\n\nans = 0\n\nfor x in range(0, K+1):\n\n    for y in range(0, K+1):\n\n        z = S - x - y\n\n        if 0 <= z and z <= K:\n\n            ans += 1\n\nprint(ans)","reference_code_col":"K, S = list(map(int, input().split()))\n\nans = 0\n\nfor X in range(K+1):\n\n    for Y in range(K+1):\n\n        Z = S - X - Y\n\n        if Z >= 0 and Z <= K:\n\n            ans += 1\n\nprint(ans)       ","model_generated_potentially_faster_code_col":"K, S = map(int, input().split())\n\nans = 0\n\nfor x in range(0, K + 1):\n    # Calculate the valid range for y\n    y_min = max(0, S - x - K)\n    y_max = min(K, S - x)\n    \n    # Count the number of valid y values\n    if y_min <= y_max:\n        ans += y_max - y_min + 1\n\nprint(ans)"}
{"problem_id":"p02276","slow_code_col":"n=int(eval(input()))-1\n\nA=list(map(int,input().split()))\n\ni=0\n\nfor j in range(n):\n\n if A[j]<=A[-1]:A[i],A[j]=A[j],A[i];i+=1\n\nA[i],A[n]=A[n],A[i]\n\nprint((\" \".join(map(str,A[:i]))+\" [\"+str(A[i])+\"] \"+\" \".join(map(str,A[i+1:]))))\n","reference_code_col":"def s():\n\n n=int(eval(input()))-1\n\n A=list(map(int,input().split()))\n\n i=0\n\n for j in range(n):\n\n  if A[j]<=A[-1]:A[i],A[j]=A[j],A[i];i+=1\n\n A[i],A[n]=A[n],A[i]\n\n print((\" \".join(map(str,A[:i]))+\" [\"+str(A[i])+\"] \"+\" \".join(map(str,A[i+1:]))))\n\nif'__main__'==__name__:s()\n","model_generated_potentially_faster_code_col":"n = int(input()) - 1  # Directly read input as integer instead of using eval\n\n# Read the array\nA = list(map(int, input().split()))\n\ni = 0\n\n# Partitioning step\nfor j in range(n):\n    if A[j] <= A[-1]:\n        A[i], A[j] = A[j], A[i]\n        i += 1\n\n# Place the pivot (last element) in its correct position\nA[i], A[n] = A[n], A[i]\n\n# Prepare the output string efficiently\noutput = \" \".join(map(str, A[:i])) + f\" [{A[i]}] \" + \" \".join(map(str, A[i+1:]))\nprint(output)"}
{"problem_id":"p02792","slow_code_col":"N = int(eval(input()))\n\nmem = [[0]*10 for _ in range(10)]\n\n\n\nfor i in range(1,N+1):\n\n    a = int(str(i)[0])\n\n    b = int(str(i)[-1])\n\n    mem[a][b] += 1\n\n\n\nans = 0\n\nfor i in range(1,N+1):\n\n    a = int(str(i)[0])\n\n    b = int(str(i)[-1])\n\n    ans += mem[b][a]\n\nprint(ans)\n","reference_code_col":"N = int(eval(input()))\n\nmem=[[0] * 10 for _ in range(10)]\n\n\n\nfor i in range(1, N+1):\n\n    s = str(i)\n\n    mem[int(s[0])][int(s[-1])] += 1 \n\n    \n\nans = 0\n\nfor i in range(1, 10):\n\n    for j in range(1, 10):\n\n        ans += mem[i][j] * mem[j][i]\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Initialize memory table\nmem = [[0] * 10 for _ in range(10)]\n\n# Precompute first digits for all numbers up to N\nfirst_digits = [0] * (N + 1)\nfor i in range(1, N + 1):\n    while i >= 10:\n        i \/\/= 10\n    first_digits[i] = i\n\n# Populate mem table and calculate result simultaneously\nans = 0\nfor i in range(1, N + 1):\n    a = first_digits[i]  # First digit\n    b = i % 10           # Last digit\n    ans += mem[b][a]     # Add symmetric contribution\n    mem[a][b] += 1       # Update count for current number\n\nprint(ans)"}
{"problem_id":"p03416","slow_code_col":"a, b = list(map(int, input().split()))\n\ntmp=str(a)\n\nc=0\n\nfor i in range(a,b+1):\n\n    tmp=str(i)\n\n    tmp2=\"\"\n\n    for s in range(len(tmp)):\n\n        tmp2=tmp2+tmp[len(tmp)-1-s]\n\n    if tmp==tmp2:\n\n        c=c+1\n\nprint(c)","reference_code_col":"def main():\n\n    #1. input\n\n    a, b = list(map(int, input().split()))\n\n\n\n    ans = 0\n\n\n\n    #2. from A to B\n\n    for i in range(a, b+1):\n\n        #2.1. judge if the number is palindromic\n\n        if (str(i)[0]==str(i)[4]) and (str(i)[1]==str(i)[3]):\n\n            ans = ans+1\n\n\n\n    #3. output\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"a, b = map(int, input().split())\n\ndef is_palindrome(num):\n    # Convert the number to a string and check if it's equal to its reverse\n    s = str(num)\n    return s == s[::-1]\n\ncount = 0\n\nfor num in range(a, b + 1):\n    if is_palindrome(num):\n        count += 1\n\nprint(count)"}
{"problem_id":"p03835","slow_code_col":"k,s=list(map(int,input().split()))\n\nans=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        z=s-i-j\n\n        if 0<=z<=k:\n\n            ans+=1\n\nprint(ans)\n","reference_code_col":"k,s=list(map(int,input().split()))\n\nans=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        if 0<=s-i-j<=k:\n\n            ans+=1\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"k, s = map(int, input().split())\n\nans = 0\n\nfor i in range(k + 1):\n    # Compute the valid range for j\n    j_min = max(0, s - i - k)\n    j_max = min(k, s - i)\n    \n    # Count the number of valid j values\n    if j_min <= j_max:\n        ans += (j_max - j_min + 1)\n\nprint(ans)"}
{"problem_id":"p03078","slow_code_col":"import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\n\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left, insort, insort_left\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce, lru_cache\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(input())\n\ndef MAP(): return map(int, input().split())\n\ndef LIST(): return list(map(int, input().split()))\n\ndef TUPLE(): return tuple(map(int, input().split()))\n\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7 \n\n#mod = 998244353\n\nfrom decimal import *\n\n#import numpy as np\n\n#decimal.getcontext().prec = 10\n\n\n\nX, Y, Z, K = MAP()\n\nA = sorted(LIST(), reverse = True)\n\nB = sorted(LIST(), reverse = True)\n\nC = sorted(LIST(), reverse = True)\n\n\n\nAB = []\n\nfor i in range(X):\n\n\tfor j in range(Y):\n\n\t\tAB.append(A[i]+B[j])\n\n\n\nAB.sort(reverse = True)\n\nAB = AB[:3000]\n\nABC = sorted([C[0]+AB[i] for i in range(min(3000, X*Y))], reverse = True)\n\n\n\nfor j in range(1, Z):\n\n\tABC_tmp = sorted([C[j]+AB[i] for i in range(min(3000, X*Y))])\n\n\tABC += ABC_tmp\n\n\tABC.sort(reverse = True)\n\n\tABC = ABC[:3000]\n\n\n\nprint(*ABC[:K], sep= \"\\n\")\n\n\n","reference_code_col":"import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\n\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left, insort, insort_left\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce, lru_cache\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef TUPLE(): return tuple(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7 \n\n#mod = 998244353\n\nfrom decimal import *\n\n#import numpy as np\n\n#decimal.getcontext().prec = 10\n\n\n\nX, Y, Z, K = MAP()\n\nA = sorted(LIST(), reverse = True)\n\nB = sorted(LIST(), reverse = True)\n\nC = sorted(LIST(), reverse = True)\n\n\n\nans = []\n\nfor i in range(X):\n\n\tfor j in range(Y):\n\n\t\tfor k in range(Z):\n\n\t\t\tif (i+1)*(j+1)*(k+1) <= K:\n\n\t\t\t\tans.append(A[i]+B[j]+C[k])\n\n\t\t\telse:\n\n\t\t\t\tbreak\n\n\n\nfor a in sorted(ans)[::-1][:K]:\n\n\tprint(a)\n","model_generated_potentially_faster_code_col":"import sys\nfrom heapq import heappush, heappop\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(input())\n\ndef LIST(): return list(map(int, input().split()))\n\n# Input\nX, Y, Z, K = LIST()\nA = sorted(LIST(), reverse=True)\nB = sorted(LIST(), reverse=True)\nC = sorted(LIST(), reverse=True)\n\n# Step 1: Generate initial heap with A and B\nheap = []\nfor i in range(min(X, K)):  # Only consider top K elements of A\n    for j in range(min(Y, K)):  # Only consider top K elements of B\n        heappush(heap, -(A[i] + B[j]))  # Use negative for max-heap behavior\n\n# Step 2: Combine with C and maintain top K sums\nresult_heap = []\nfor c in C:\n    temp_heap = []\n    while heap:\n        ab_sum = -heappop(heap)  # Get the largest sum\n        heappush(result_heap, -(ab_sum + c))  # Add to result heap\n        heappush(temp_heap, -ab_sum)  # Save for reuse\n        if len(result_heap) > K:\n            heappop(result_heap)  # Keep only top K elements\n    heap = temp_heap  # Restore heap for next iteration\n\n# Step 3: Extract and print top K results\nresult = []\nwhile result_heap:\n    result.append(-heappop(result_heap))\n\nprint(*sorted(result, reverse=True)[:K], sep=\"\\n\")"}
{"problem_id":"p00174","slow_code_col":"while True:\n\n    try:\n\n        for i in range(3):\n\n            line = input().strip()\n\n            if line == '0':\n\n                raise Exception\n\n\n\n            a = b = 0\n\n            for i, s in enumerate(line):\n\n                if i != 0:\n\n                    if s == 'A':\n\n                        a += 1\n\n                    else:\n\n                        b += 1\n\n            if a > b:\n\n                a += 1\n\n            else:\n\n                b += 1\n\n            print(a, b)\n\n\n\n    except:\n\n        break","reference_code_col":"while True:\n\n    try:\n\n        for i in range(3):\n\n            line = input().strip()\n\n            if line == '0':\n\n                raise Exception\n\n\n\n            if line[0] == 'A':\n\n                a = -1\n\n                b = 0\n\n            else:\n\n                a = 0\n\n                b = -1\n\n            for i, s in enumerate(line):\n\n                if s == 'A':\n\n                    a += 1\n\n                else:\n\n                    b += 1\n\n            if a > b:\n\n                a += 1\n\n            else:\n\n                b += 1\n\n            print(a, b)\n\n\n\n    except:\n\n        break","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    for line in sys.stdin:\n        line = line.strip()\n        if line == '0':\n            break\n\n        a = b = 0\n        for s in line[1:]:  # Start from the second character\n            if s == 'A':\n                a += 1\n            else:\n                b += 1\n\n        if a > b:\n            a += 1\n        else:\n            b += 1\n\n        print(a, b)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03559","slow_code_col":"from bisect import *\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\nb = list(map(int,input().split()))\n\nc = list(map(int,input().split()))\n\n\n\na = sorted(a)\n\nc = sorted(c)\n\n\n\nrec = 0\n\nfor i in range(n):\n\n    temp = b[i]\n\n    l = bisect_left(a, temp)\n\n    r = bisect_right(c, temp)\n\n    rec += l * (n - r)\n\nprint(rec)","reference_code_col":"from bisect import *\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\nb = list(map(int,input().split()))\n\nc = list(map(int,input().split()))\n\n\n\na.sort()\n\nc.sort()\n\nres = 0\n\nfor i in b:\n\n    temp_a = bisect_left(a, i)\n\n    temp_c = n - bisect_right(c, i)\n\n    res += temp_a*temp_c\n\nprint(res)","model_generated_potentially_faster_code_col":"from bisect import bisect_left, bisect_right\n\n# Input parsing\nn = int(input())\na = sorted(map(int, input().split()))\nb = list(map(int, input().split()))\nc = sorted(map(int, input().split()))\n\n# Precompute cumulative counts for a and c\na_counts = [bisect_left(a, x) for x in range(min(b), max(b) + 2)]\nc_counts = [n - bisect_right(c, x) for x in range(min(b), max(b) + 2)]\n\n# Adjust b values to match the precomputed range\nb_min = min(b)\nrec = 0\nfor val in b:\n    idx = val - b_min\n    rec += a_counts[idx] * c_counts[idx]\n\nprint(rec)"}
{"problem_id":"p02837","slow_code_col":"N=int(eval(input()))\n\n\n\nS=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  A=int(eval(input()))\n\n  for _ in range(A):\n\n    x, y=list(map(int, input().split()))\n\n    S[i][x-1]=y\n\nans=0   \n\nfor s in range(2**N):\n\n  ok=True\n\n  for i in range(N):\n\n    #\u6b63\u76f4\u8005\u306b\u3064\u3044\u3066\u898b\u3066\u3044\u304f\n\n    if (s>>i&1)==1:\n\n      for j in range(N):\n\n        #\u305d\u308c\u305e\u308c\u6b63\u76f4\u8005\u306e\u8a3c\u8a00\u304c\u77db\u76fe\u306a\u3044\u304b\n\n        if S[i][j]!=-1 and (s>>j&1)!=S[i][j]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(s).count(\"1\"))\n\n    \n\nprint(ans)\n","reference_code_col":"N=int(eval(input()))\n\n\n\nA=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  a=int(eval(input()))\n\n  for j in range(a):\n\n    x,y=list(map(int, input().split()))\n\n    A[i][x-1]=y\n\n#\u6b63\u76f4\u8005\u304c\u6b63\u76f4\u8005\u306b\u4e0d\u89aa\u5207\u3068\u8a00\u308f\u308c\u3066\u3044\u306a\u3044\n\n#\u2192\u6b63\u76f4\u3082\u306e\u304c\u4e0d\u89aa\u5207\u3092\u6b63\u76f4\u8005\u3068\u8a00\u3063\u3066\u3044\u306a\u3044\u304b\n\nans=0\n\nfor i in range(2**N):\n\n  ok=True\n\n  for j in range(N):\n\n    if (i>>j&1)==1:\n\n      for k in range(N):\n\n        if A[j][k]!=-1 and (i>>k&1)!=A[j][k]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(i).count(\"1\"))\n\n  \n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Initialize the testimony matrix\nS = [[-1] * N for _ in range(N)]\n\n# Read input data\nfor i in range(N):\n    A = int(input())\n    for _ in range(A):\n        x, y = map(int, input().split())\n        S[i][x - 1] = y\n\n# Precompute powers of 2 for faster bitmask operations\npowers_of_2 = [1 << i for i in range(N)]\n\n# Function to count set bits (population count)\ndef count_set_bits(s):\n    count = 0\n    while s:\n        s &= s - 1  # Remove the lowest set bit\n        count += 1\n    return count\n\n# Iterate over all possible subsets of people\nans = 0\nfor s in range(2 ** N):\n    ok = True\n    for i in range(N):\n        # Check only if person i is honest in this subset\n        if s & powers_of_2[i]:\n            for j in range(N):\n                # If there's a testimony from i about j, check for consistency\n                if S[i][j] != -1 and ((s & powers_of_2[j]) >> j) != S[i][j]:\n                    ok = False\n                    break\n        if not ok:\n            break\n    if ok:\n        ans = max(ans, count_set_bits(s))\n\nprint(ans)"}
{"problem_id":"p02899","slow_code_col":"import numpy as np\n\nfrom copy import deepcopy\n\n\n\nN = int(eval(input()))\n\nA = []\n\nA.append(list(map(int, input().split())))\n\na = deepcopy(A[0])\n\na.sort()\n\nA.append(a)\n\nA_t = np.array(A).T.tolist()\n\nA_t.sort()\n\n\n\nout = []\n\nfor i in range(N):\n\n    out.append(str(A_t[i][1]))\n\nprint((\" \".join(out)))\n","reference_code_col":"N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nrev = [\"\"] * N\n\nfor i in range(N):\n\n    rev[A[i]-1] = str(i+1)\n\nprint((\" \".join(rev)))\n","model_generated_potentially_faster_code_col":"N = int(input())  # Read the size of the array\nA = list(map(int, input().split()))  # Read the array elements\n\n# Pair each element with its index and sort based on the values\nsorted_pairs = sorted(enumerate(A), key=lambda x: x[1])\n\n# Extract the indices of the sorted elements and construct the output\noutput = \" \".join(str(index) for index, _ in sorted_pairs)\n\nprint(output)"}
{"problem_id":"p03592","slow_code_col":"N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        t = i*M + j*N - i*j*2\n\n        if t==K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')","reference_code_col":"N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        if i*(M-j) + j*(N-i) == K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')","model_generated_potentially_faster_code_col":"N, M, K = map(int, input().split())\n\n# Precompute constants to avoid recalculating them repeatedly\nfor i in range(N + 1):\n    # Rearrange the equation: K = i * M + j * (N - 2 * i)\n    # Solve for j: j = (K - i * M) \/ (N - 2 * i), if (N - 2 * i) != 0\n    numerator = K - i * M\n    denominator = N - 2 * i\n\n    if denominator != 0:  # Avoid division by zero\n        if numerator % denominator == 0:  # Check if j is an integer\n            j = numerator \/\/ denominator\n            if 0 <= j <= M:  # Ensure j is within valid range\n                print('Yes')\n                exit()\n\nprint('No')"}
{"problem_id":"p00542","slow_code_col":"a,b,c,d,e,f=[int(eval(input())) for _ in range(6)]\n\nprint((sum([a,b,c,d,max(e,f)])-min([a,b,c,d])))","reference_code_col":"print((sum(sorted(int(eval(input())) for _ in range(4))[1:])+max([int(eval(input())) for _ in range(2)])))","model_generated_potentially_faster_code_col":"a, b, c, d, e, f = [int(eval(input())) for _ in range(6)]"}
{"problem_id":"p03371","slow_code_col":"# AtCoder Beginner Contest 095 C - Half and Half\n\nimport sys\n\n\n\nA, B, C, X, Y = list(map(int, sys.stdin.readline().strip().split()))\n\n\n\nans = A * X + B * Y\n\nfor z in range(2, 2 * 10 ** 5 + 1, 2):\n\n    x = max(X - int(z \/ 2), 0)\n\n    y = max(Y - int(z \/ 2), 0)\n\n\n\n    price = A * x + B * y + C * z\n\n    ans = min(price, ans)\n\n\n\nprint(ans)\n","reference_code_col":"# AtCoder Beginner Contest 095 C - Half and Half\n\nimport sys\n\n\n\nA, B, C, X, Y = list(map(int, sys.stdin.readline().strip().split()))\n\n\n\n\"\"\"\n\nans = A * X + B * Y\n\nfor z in range(2, 2 * 10 ** 5 + 1, 2):\n\n    x = max(X - int(z \/ 2), 0)\n\n    y = max(Y - int(z \/ 2), 0)\n\n\n\n    price = A * x + B * y + C * z\n\n    ans = min(price, ans)\n\n\n\nprint(ans)\n\n\"\"\"\n\n\n\nprice1 = A * X + B * Y\n\nprice2 = C * 2 * X + B * max(Y - X, 0)\n\nprice3 = A * max(X - Y, 0) + C * 2 * Y\n\nprint((min(price1, price2, price3)))\n\n\n","model_generated_potentially_faster_code_col":"import sys\n\n# Read input values\nA, B, C, X, Y = map(int, sys.stdin.readline().strip().split())\n\n# Initialize the answer with the cost of buying all individual pizzas\nans = A * X + B * Y\n\n# Iterate over possible values of z (number of half-and-half pizzas)\nfor z in range(0, 2 * max(X, Y) + 1, 2):\n    # Calculate remaining individual pizzas needed\n    x = max(X - z \/\/ 2, 0)\n    y = max(Y - z \/\/ 2, 0)\n    \n    # Calculate total cost for this configuration\n    price = A * x + B * y + C * z\n    \n    # Update the minimum cost\n    ans = min(price, ans)\n\n# Output the result\nprint(ans)"}
{"problem_id":"p03037","slow_code_col":"N,M = list(map(int,input().split()))\n\nL,R = [],[]\n\nfor i in range(M):\n\n    l,r = list(map(int,input().split()))\n\n    L.append(l)\n\n    R.append(r)\n\nans = min(R)-max(L)+1\n\nprint((ans if ans >= 0 else 0))","reference_code_col":"# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, M = lr()\n\nL = 0; R = 10 ** 6\n\nfor _ in range(M):\n\n    l, r = lr()\n\n    if l > L:\n\n        L = l\n\n    if r < R:\n\n        R = r\n\n\n\nanswer = max(0, R - L + 1)\n\nprint(answer)\n","model_generated_potentially_faster_code_col":"# Read N and M\nN, M = map(int, input().split())\n\n# Initialize variables to track min(R) and max(L)\nmin_R = float('inf')\nmax_L = float('-inf')\n\n# Process each pair (l, r) in one pass\nfor _ in range(M):\n    l, r = map(int, input().split())\n    max_L = max(max_L, l)  # Update the running maximum of L\n    min_R = min(min_R, r)  # Update the running minimum of R\n\n# Compute the answer\nans = min_R - max_L + 1\nprint(ans if ans >= 0 else 0)"}
{"problem_id":"p02555","slow_code_col":"MOD = 1000000007\n\n\n\n\n\nS = int(eval(input()))\n\n\n\n#dp[i]:=i\u6841\u306e\u6570\u5217\u3067\u6761\u4ef6\u3092\u6e80\u305f\u3059\u3082\u306e\u306e\u6570\n\ndp = [0]*(S+1)\n\n\n\nfor i in range(3,S+1):\n\n    #dp[i]=sum(dp[0],..,dp[i-3])+1\n\n    for j in range(i-3+1):\n\n        dp[i] = (dp[i]+dp[j])%MOD\n\n    dp[i] = (dp[i]+1)%MOD\n\n\n\nprint((dp[S]))","reference_code_col":"MOD = 1000000007\n\n\n\n\n\nS = int(eval(input()))\n\n\n\n#dp[i]:=i\u6841\u306e\u6570\u5217\u3067\u6761\u4ef6\u3092\u6e80\u305f\u3059\u3082\u306e\u306e\u6570\n\ndp = [0]*(S+1)\n\ndp_sum = [0]*(S+1)\n\n\n\nfor i in range(3,S+1):\n\n    #dp[i]=sum(dp[0],..,dp[i-3])+1\n\n    \n\n    dp[i] = (dp_sum[i-3]+1)%MOD\n\n    dp_sum[i] = (dp[i]+dp_sum[i-1])%MOD\n\n\n\nprint((dp[S]))","model_generated_potentially_faster_code_col":"MOD = 1000000007\n\n# Read input\nS = int(eval(input()))\n\n# dp[i] := i\u6841\u306e\u6570\u5217\u3067\u6761\u4ef6\u3092\u6e80\u305f\u3059\u3082\u306e\u306e\u6570\ndp = [0] * (S + 1)\ncumulative_sum = 0  # To store the cumulative sum of dp[0] to dp[i-3]\n\nfor i in range(3, S + 1):\n    # Update cumulative_sum to include dp[i-3]\n    if i - 3 >= 0:\n        cumulative_sum = (cumulative_sum + dp[i - 3]) % MOD\n    \n    # Calculate dp[i] using the cumulative sum\n    dp[i] = (cumulative_sum + 1) % MOD\n\nprint(dp[S])"}
{"problem_id":"p02881","slow_code_col":"n = int(eval(input()))\n\nl = []\n\nfor i in range(1,1000001):\n\n    a = n \/ i\n\n    if a.is_integer():\n\n        l.append(i+n\/i)\n\nprint((int(min(l)-2)))","reference_code_col":"n = int(eval(input()))\n\na = 10**20\n\nfor i in range(1,int(n**0.5)+1):\n\n    if n%i==0:\n\n        a = min(a,i+n\/\/i)\n\nprint((a-2))","model_generated_potentially_faster_code_col":"n = int(eval(input()))\n\n# Initialize the minimum value to a large number\nmin_value = float('inf')\n\n# Iterate only up to the square root of n\nfor i in range(1, int(n**0.5) + 1):\n    if n % i == 0:  # Check if i is a divisor of n\n        # Compute the pair of divisors\n        a = i\n        b = n \/\/ i\n\n        # Update the minimum value for both divisors\n        min_value = min(min_value, a + b)\n\n# Output the result\nprint(int(min_value - 2))"}
{"problem_id":"p02881","slow_code_col":"n = int(eval(input()))\n\nimport math\n\nm = int(math.sqrt(n))+1\n\nanss = []\n\nfor x in range(1, m+1):\n\n  y = n\/\/x\n\n  z = n%x\n\n  if z == 0:\n\n    anss.append(abs(x-1)+abs(y-1))\n\nprint((min(anss)))\n","reference_code_col":"n = int(eval(input()))\n\ndef make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append(i)\n\n            if i != n \/\/ i:\n\n                divisors.append(n\/\/i)\n\n\n\n    #divisors.sort(reverse=True)\n\n    return divisors\n\n\n\nl = make_divisors(n)\n\nmin_ = float('inf')\n\nfor i in range(len(l)):\n\n    min_ = min(min_, l[i]-1+n\/\/l[i]-1)\n\nprint(min_)\n","model_generated_potentially_faster_code_col":"import math\n\n# Read input\nn = int(input())\n\n# Initialize variables\nmin_value = float('inf')  # Start with infinity as the initial minimum\nsqrt_n = int(math.sqrt(n))\n\n# Iterate through potential divisors up to sqrt(n)\nfor x in range(1, sqrt_n + 1):\n    if n % x == 0:  # Check if x is a divisor\n        y = n \/\/ x  # Compute the corresponding divisor\n        # Calculate the result for both x and y\n        min_value = min(min_value, abs(x - 1) + abs(y - 1))\n        if x != y:  # Avoid double-counting when x == y (perfect square case)\n            min_value = min(min_value, abs(y - 1) + abs(x - 1))\n\n# Output the minimum value\nprint(min_value)"}
{"problem_id":"p02994","slow_code_col":"import numpy as np\n\nN,L = list(map(int,input().split()))\n\napple = np.array(list(range(N))) + 1\n\ntaste = apple + L - 1\n\ntaste_applepie = sum(taste)\n\nif L <= 0 and abs(N) > abs(L):\n\n    print(taste_applepie)\n\nelif L > 0:\n\n    print((taste_applepie - L))\n\nelse:\n\n    print((taste_applepie - (N+L-1)))","reference_code_col":"N,L = list(map(int,input().split()))\n\nt = [L+i-1 for i in range(1,N+1)]\n\nabst = list(map(abs,t))\n\nminind = abst.index(min(abst))\n\nprint((sum(t)-t[minind]))","model_generated_potentially_faster_code_col":"# Read input values\nN, L = map(int, input().split())\n\n# Calculate the sum of the arithmetic sequence directly\nfirst_term = L\nlast_term = N + L - 1\ntaste_applepie = (N * (first_term + last_term)) \/\/ 2\n\n# Determine the output based on the conditions\nif L <= 0 and abs(N) > abs(L):\n    print(taste_applepie)\nelif L > 0:\n    print(taste_applepie - L)\nelse:\n    print(taste_applepie - (N + L - 1))"}
{"problem_id":"p03774","slow_code_col":"import numpy as np\n\nN,M=list(map(int, input().split()))\n\nhuman=[]\n\nfor i in range(N):\n\n  a,b=list(map(int, input().split()))\n\n  human.append((a,b))\n\nC=[]\n\nfor i in range(M):\n\n  c,d=list(map(int, input().split()))\n\n  C.append((c,d))\n\n  \n\nfor h in human:\n\n  a,b=h\n\n  now=0\n\n  mini=np.inf\n\n  for i,ch in enumerate(C):\n\n    c,d=ch\n\n    L=abs(a-c)+abs(b-d)\n\n    if mini>L:\n\n      mini=L\n\n      now=i+1\n\n  print(now)","reference_code_col":"N,M=list(map(int, input().split()))\n\nS=[]\n\nfor i in range(N):\n\n    a,b=list(map(int, input().split()))\n\n    S.append((a,b))\n\n\n\nC=[]\n\nfor i in range(M):\n\n    c,d=list(map(int, input().split()))\n\n    C.append((c,d,i+1))\n\n#print(C)\n\nfor s in S:\n\n    a,b=s\n\n    now=0\n\n    dis=10**9\n\n\n\n    for t in C:\n\n        c,d,n=t\n\n        D=abs(c-a)+abs(d-b)\n\n        \n\n        if D<dis:\n\n            dis=D\n\n            now=n\n\n    print(now)","model_generated_potentially_faster_code_col":"import numpy as np\nfrom scipy.spatial import KDTree\n\n# Read input values\nN, M = map(int, input().split())\n\n# Read human coordinates\nhuman = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Read checkpoint coordinates\ncheckpoints = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Build a k-d tree for the checkpoints\ntree = KDTree(checkpoints)\n\n# Query the nearest checkpoint for each human\nfor h in human:\n    # Query the tree for the nearest checkpoint\n    dist, idx = tree.query(h)\n    print(idx + 1)  # Add 1 because indices in Python are 0-based"}
{"problem_id":"p03455","slow_code_col":"a, b = list(map(int, input().split()))\n\nif a*b%2 == 1:\n\n    print(\"Odd\")\n\nelse:\n\n    print(\"Even\")","reference_code_col":"a, b = list(map(int, input().split()))\n\nprint(('Odd'if a&b&1 else 'Even'))","model_generated_potentially_faster_code_col":"a, b = map(int, input().split())\n\nif a % 2 == 1 and b % 2 == 1:\n    print(\"Odd\")\nelse:\n    print(\"Even\")"}
{"problem_id":"p02555","slow_code_col":"import sys, os, math, bisect, itertools, collections, heapq, queue, copy, array\n\n\n\n# from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n# from decimal import Decimal\n\n# from collections import defaultdict, deque\n\n\n\nsys.setrecursionlimit(10000000)\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\nfl = lambda: list(map(float, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nsl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\nlcm = lambda x, y: (x * y) \/\/ math.gcd(x, y)\n\n\n\nMOD = 10 ** 9 + 7\n\nINF = float('inf')\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    S = ii()\n\n    dp = [0] * (S + 1)\n\n\n\n    dp[0] = 1\n\n    # 0 <= i <= S\u306e\u7bc4\u56f2\u3092\u63a2\u7d22\n\n    for i in range(1, S + 1):\n\n        # 0 <= j <= i - 3\u306e\u7bc4\u56f2\u3067\u3001\n\n        # \u9593\u4ed5\u5207\u308a\u3092\u7f6e\u304f\u3053\u3068\u304c\u3067\u304d\u308b\u500b\u6570\u306e\u5408\u8a08\u3092\u96c6\u8a08\n\n        for j in range(0, i - 3 + 1):\n\n            dp[i] += dp[j]\n\n            dp[i] %= MOD\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"import sys, os, math, bisect, itertools, collections, heapq, queue, copy, array\n\n\n\n# from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n# from decimal import Decimal\n\n# from collections import defaultdict, deque\n\n\n\nsys.setrecursionlimit(10000000)\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\nfl = lambda: list(map(float, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nsl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\nlcm = lambda x, y: (x * y) \/\/ math.gcd(x, y)\n\n\n\nMOD = 10 ** 9 + 7\n\nINF = float('inf')\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    S = ii()\n\n    dp = [0] * (S + 1)\n\n\n\n    dp[0] = 1\n\n    # 0 <= i <= S\u306e\u7bc4\u56f2\u3092\u63a2\u7d22\n\n    for i in range(1, S + 1):\n\n        # 0 <= j <= i - 3\u306e\u7bc4\u56f2\u3067\u3001\n\n        # \u9593\u4ed5\u5207\u308a\u3092\u7f6e\u304f\u3053\u3068\u304c\u3067\u304d\u308b\u500b\u6570\u306e\u5408\u8a08\u3092\u96c6\u8a08\n\n        if i > 2:\n\n            dp[i] = sum(dp[0:i - 2])\n\n            dp[i] %= MOD\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys, os, math\n\n# Constants\nMOD = 10**9 + 7\n\ndef main():\n    if os.getenv(\"LOCAL\"):\n        sys.stdin = open(\"input.txt\", \"r\")\n\n    S = int(sys.stdin.buffer.readline().rstrip())\n    dp = [0] * (S + 1)\n    dp[0] = 1\n\n    # Cumulative sum of dp values\n    prefix_sum = 0\n\n    for i in range(1, S + 1):\n        if i >= 3:\n            prefix_sum += dp[i - 3]\n            prefix_sum %= MOD\n        dp[i] = prefix_sum\n\n    print(dp[S])\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02555","slow_code_col":"n = int(eval(input()))\n\nm = 10**9 + 7\n\n# ans = [0] * (n + 1)\n\nans = [0] * 2200\n\nans[0] = 1\n\n# ans[3] = 1\n\n# ans[4] = 1\n\n# ans[5] = 1\n\nfor i in range(3, n + 1):\n\n    for j in range(i - 2):\n\n        ans[i] += ans[j]\n\n        ans[i] %= m\n\nprint((ans[n]))\n\n# print(ans[:10])\n","reference_code_col":"n = int(eval(input()))\n\nm = 10**9 + 7\n\n# ans = [0] * (n + 1)\n\nans = [0] * 2200\n\nans[0] = 1\n\n# ans[3] = 1\n\n# ans[4] = 1\n\n# ans[5] = 1\n\nfor i in range(3, n + 1):\n\n    ans[i] = ans[i - 1] + ans[i - 3]\n\n    ans[i] %= m\n\n    # for j in range(i - 2):\n\n    #     ans[i] += ans[j]\n\n    #     ans[i] %= m\n\nprint((ans[n]))\n\n# print(ans[:10])\n","model_generated_potentially_faster_code_col":"n = int(input())  # Removed eval for safety and performance\n\nm = 10**9 + 7\n\n# Initialize the array with zeros\nans = [0] * max(2200, n + 1)\nans[0] = 1  # Base case\n\n# Cumulative sum array\ncum_sum = [0] * max(2200, n + 1)\ncum_sum[0] = 1  # Initial cumulative sum\n\nfor i in range(3, n + 1):\n    if i - 3 >= 0:\n        ans[i] = cum_sum[i - 3] % m  # Use cumulative sum to calculate ans[i]\n    else:\n        ans[i] = 0  # For i < 3, there are no valid j values\n    \n    # Update the cumulative sum\n    cum_sum[i] = (cum_sum[i - 1] + ans[i]) % m\n\nprint(ans[n])"}
{"problem_id":"p03608","slow_code_col":"N, M, R = list(map(int, input().split()))\n\nr = list(map(int, input().split()))\n\nd = [[float('inf')]*N for _ in range(N)]\n\nfor i in range(M): #\u3072\u3068\u307e\u305a\u679d\u304c\u3042\u308b\u30da\u30a2\u306f\u679d\u306e\u9577\u3055\u3092\u30bb\u30c3\u30c8\n\n  a,b,t = list(map(int, input().split()))\n\n  d[a-1][b-1] = t\n\n  d[b-1][a-1] = t\n\n\n\nfor i in range(N):\n\n  d[i][i] = 0 #\u81ea\u8eab\u3078\u306e\u6700\u77ed\u7d4c\u8def\u306f0\n\n#\u4e09\u91cd\u30eb\u30fc\u30d7\n\nfor k in range(N):\n\n  for i in range(N):\n\n    for j in range(N):\n\n      d[i][j] = min(d[i][j], d[i][k]+d[k][j])\n\n\n\nfrom itertools import groupby, accumulate, product, permutations, combinations\n\n\n\nans = float('inf')\n\nfor p in permutations(r,R):\n\n  cnt = 0\n\n  for i in range(1,R):\n\n    cnt += d[p[i-1]-1][p[i]-1]\n\n  ans = min(ans,cnt)\n\nprint(ans)","reference_code_col":"N, M, r = list(map(int, input().split()))\n\nR = list([int(x)-1 for x in input().split()])\n\nd = [[1<<30]*N for _ in range(N)]\n\nfor i in range(M): #\u3072\u3068\u307e\u305a\u679d\u304c\u3042\u308b\u30da\u30a2\u306f\u679d\u306e\u9577\u3055\u3092\u30bb\u30c3\u30c8\n\n  a,b,t = list(map(int, input().split()))\n\n  d[a-1][b-1] = t\n\n  d[b-1][a-1] = t\n\n\n\nfor i in range(N):\n\n  d[i][i] = 0 #\u81ea\u8eab\u3078\u306e\u6700\u77ed\u7d4c\u8def\u306f0\n\n#\u4e09\u91cd\u30eb\u30fc\u30d7\n\nfor k in range(N):\n\n  for i in range(N):\n\n    for j in range(N):\n\n      d[i][j] = min(d[i][j], d[i][k]+d[k][j])\n\nfrom itertools import groupby, accumulate, product, permutations, combinations\n\nans = 1<<30\n\nfor per in permutations(R,r):\n\n  cnt = 0\n\n  for i in range(r-1):\n\n    cnt += d[per[i]][per[i+1]]\n\n  ans = min(ans, cnt)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\nfrom itertools import combinations\nfrom math import inf\n\n# Fast input reading\ndef read_ints():\n    return list(map(int, sys.stdin.readline().split()))\n\n# Input reading\nN, M, R = read_ints()\nr = read_ints()\ngraph = [[inf] * N for _ in range(N)]\n\n# Initialize adjacency matrix\nfor i in range(N):\n    graph[i][i] = 0\n\n# Read edges and populate the adjacency matrix\nfor _ in range(M):\n    a, b, t = read_ints()\n    graph[a - 1][b - 1] = t\n    graph[b - 1][a - 1] = t\n\n# Floyd-Warshall algorithm for all-pairs shortest paths\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            if graph[i][k] + graph[k][j] < graph[i][j]:\n                graph[i][j] = graph[i][k] + graph[k][j]\n\n# Convert r to zero-based indices\nr = [x - 1 for x in r]\n\n# Solve TSP using dynamic programming with bitmasking\ndp = [[inf] * R for _ in range(1 << R)]\nfor i in range(R):\n    dp[1 << i][i] = 0\n\nfor mask in range(1 << R):\n    for i in range(R):\n        if not (mask & (1 << i)):\n            continue\n        for j in range(R):\n            if mask & (1 << j):\n                continue\n            new_mask = mask | (1 << j)\n            dp[new_mask][j] = min(dp[new_mask][j], dp[mask][i] + graph[r[i]][r[j]])\n\n# Find the minimum cost to visit all nodes in r\nans = inf\nfinal_mask = (1 << R) - 1\nfor i in range(R):\n    ans = min(ans, dp[final_mask][i])\n\nprint(ans)"}
{"problem_id":"p02615","slow_code_col":"import numpy as np\n\nimport heapq\n\n\n\nN = int(eval(input()))\n\nA =  np.sort([int(x) for x in input().split(\" \")])[::-1]\n\n\n\nq = [(-A[1], (0, 1)), (-A[1], (0, 1))]\n\nconfort = A[0]\n\nheapq.heapify(q)\n\n\n\ni = 2\n\nwhile N > i:\n\n    m = heapq.heappop(q)\n\n    # print(f\"{m[1][0]}\u3068{m[1][1]}\u306e\u9593\u306b\u5272\u308a\u8fbc\u3080. \u6c17\u6301\u3061\u826f\u3055 {-m[0]}\")\n\n    confort -= m[0]\n\n    heapq.heappush(q, (-A[i], (i, m[1][0])))\n\n    heapq.heappush(q, (-A[i], (i, m[1][1])))\n\n    i += 1\n\nprint(confort)\n","reference_code_col":"N = int(eval(input()))\n\nA = sorted([int(x) for x in input().split(\" \")])[::-1]\n\n\n\nN -= 2\n\nS = A[0]\n\n\n\ni = 1\n\nwhile 1:\n\n    if N == 0:\n\n        break \n\n    if N == 1:\n\n        S += A[i]\n\n        break\n\n    S += 2 * A[i]\n\n    N -= 2\n\n    i += 1\n\nprint(S)","model_generated_potentially_faster_code_col":"A = sorted([int(x) for x in input().split()], reverse=True)"}
{"problem_id":"p04021","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nread = sys.stdin.read\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, read().split()))\n\nL = sorted([(j, i) for i, j in enumerate(A)])\n\ncount = 0\n\nfor i in range(n):\n\n  if (L[i][1]-i)%2:\n\n    count += 1\n\nans = (count+1) \/\/ 2\n\nprint(ans)","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\nread = sys.stdin.read\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, read().split()))\n\nL = sorted([(j, i) for i, j in enumerate(A)])\n\ncount = 0\n\nfor i in range(n):\n\n  count += (L[i][1]-i)%2\n\nans = (count+1) \/\/ 2\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import sys\n\n# Faster input reading\ninput = sys.stdin.readline\n\n# Read input\nn = int(input())\nA = list(map(int, input().split()))\n\n# Create a list of indices sorted by the values in A\nsorted_indices = sorted(range(n), key=lambda x: A[x])\n\n# Count the number of indices where (original_index - sorted_position) is odd\ncount = sum(1 for i in range(n) if (sorted_indices[i] - i) % 2)\n\n# Compute the final answer\nans = (count + 1) \/\/ 2\n\n# Output the result\nprint(ans)"}
{"problem_id":"p02378","slow_code_col":"# Acceptance of input\n\n\n\nimport sys\n\n\n\nfile_input = sys.stdin\n\n\n\nX, Y, E = list(map(int, file_input.readline().split()))\n\n\n\nv_num = X + Y + 2\n\n\n\nadj_mat = [[0] * (v_num) for i in range(v_num)]\n\n\n\nfor line in file_input:\n\n    x, y = list(map(int, line.split()))\n\n    adj_mat[x][X + y] = 1\n\n\n\ns = X + Y\n\nt = s + 1\n\n\n\nfor i in range(X):\n\n    adj_mat[s][i] = 1\n\n\n\nfor i in range(X, s):\n\n    adj_mat[i][t] = 1\n\n\n\n# Dinic's algorithm\n\n\n\nimport collections\n\n\n\n# BFS for residual capacity network to construct level graph\n\ndef bfs(start, goal, parent):\n\n    unvisited = [True] * v_num\n\n    queue = collections.deque()\n\n    queue.append(start)\n\n    unvisited[start] = False\n\n    while queue:\n\n        u = queue.popleft()\n\n        for v, r_capacity in enumerate(adj_mat[u]):\n\n            if unvisited[v] and (r_capacity > 0):\n\n                parent[v].append(u)\n\n                queue.append(v)\n\n                unvisited[v] = False\n\n    return unvisited[goal]\n\n\n\n# DFS for level graph and construct blocking flow\n\ndef dfs(goal, path, parent, blocking_flow):\n\n    v = path[-1]\n\n    if v == goal:\n\n        aug_path_flow = 10000\n\n        for x, y in zip(path[1:], path[:-1]):\n\n            aug_path_flow = min(aug_path_flow, adj_mat[x][y])\n\n        for x, y in zip(path[1:], path[:-1]):\n\n            adj_mat[x][y] -= aug_path_flow\n\n            adj_mat[y][x] += aug_path_flow\n\n        blocking_flow[0] += aug_path_flow\n\n    else:\n\n        for u in parent[v]:\n\n            path.append(u)\n\n            dfs(goal, path, parent, blocking_flow)\n\n            path.pop()\n\n\n\ndef dinic(source, sink):\n\n    max_flow = 0\n\n    parent = [[] for i in range(v_num)]\n\n    while not bfs(source, sink, parent):\n\n        blocking_flow = [0]\n\n        path = [sink]\n\n        # search in reverse direction from sink\n\n        dfs(source, path, parent, blocking_flow)\n\n        max_flow += blocking_flow[0]\n\n        parent = [[] for i in range(v_num)]\n\n    return max_flow\n\n\n\n# output\n\nprint((dinic(s, t)))","reference_code_col":"# Acceptance of input\n\n\n\nimport sys\n\n\n\nfile_input = sys.stdin\n\n\n\nX, Y, E = list(map(int, file_input.readline().split()))\n\n\n\nv_num = X + Y + 2\n\n\n\nadj_mat = [[0] * (v_num) for i in range(v_num)]\n\n\n\nfor line in file_input:\n\n    x, y = list(map(int, line.split()))\n\n    adj_mat[x][X + y] = 1\n\n\n\ns = X + Y\n\nt = s + 1\n\n\n\nfor i in range(X):\n\n    adj_mat[s][i] = 1\n\n\n\nfor i in range(X, s):\n\n    adj_mat[i][t] = 1\n\n\n\n# Dinic's algorithm\n\n\n\nimport collections\n\n\n\n# BFS for residual capacity network to construct level graph\n\ndef bfs(start, goal, parent):\n\n    level = [v_num] * v_num\n\n    unvisited = [True] * v_num\n\n    queue = collections.deque()\n\n    queue.append(start)\n\n    level[start] = 0\n\n    unvisited[start] = False\n\n    while queue:\n\n        u = queue.popleft()\n\n        next_level = level[u] + 1\n\n        for v, r_capacity in enumerate(adj_mat[u]):\n\n            if (level[v] >= next_level) and (r_capacity > 0):\n\n                level[v] = next_level\n\n                parent[v].append(u)\n\n                if unvisited[v]:\n\n                    queue.append(v)\n\n                    unvisited[v] = False\n\n    return level[goal]\n\n\n\n# DFS for level graph and construct blocking flow\n\ndef dfs(goal, path, parent, blocking_flow):\n\n    v = path[-1]\n\n    if v == goal:\n\n        aug_path_flow = 10000\n\n        for x, y in zip(path[1:], path[:-1]):\n\n            aug_path_flow = min(aug_path_flow, adj_mat[x][y])\n\n        for x, y in zip(path[1:], path[:-1]):\n\n            adj_mat[x][y] -= aug_path_flow\n\n            adj_mat[y][x] += aug_path_flow\n\n        blocking_flow[0] += aug_path_flow\n\n    else:\n\n        for u in parent[v]:\n\n            path.append(u)\n\n            dfs(goal, path, parent, blocking_flow)\n\n            path.pop()\n\n\n\ndef dinic(source, sink):\n\n    max_flow = 0\n\n    parent = [[] for i in range(v_num)]\n\n    while bfs(source, sink, parent) != v_num:\n\n        blocking_flow = [0]\n\n        path = [sink]\n\n        # search in reverse direction from sink\n\n        dfs(source, path, parent, blocking_flow)\n\n        max_flow += blocking_flow[0]\n\n        parent = [[] for i in range(v_num)]\n\n    return max_flow\n\n\n\n# output\n\nprint((dinic(s, t)))","model_generated_potentially_faster_code_col":"def bfs(start, goal):\n    level = [-1] * v_num  # Initialize all levels to -1 (unreachable)\n    queue = collections.deque()\n    queue.append(start)\n    level[start] = 0  # Start node is at level 0\n\n    while queue:\n        u = queue.popleft()\n        for v, r_capacity in enumerate(adj_mat[u]):\n            if level[v] == -1 and r_capacity > 0:  # Unvisited and residual capacity > 0\n                level[v] = level[u] + 1\n                queue.append(v)\n                if v == goal:  # Early termination if sink is reached\n                    return True\n    return level[goal] != -1  # Return whether the sink is reachable"}
{"problem_id":"p03752","slow_code_col":"import numpy as np\n\nfrom itertools import combinations \n\nINF = int(1e9)*15\n\ndef main():\n\n    n, k = list(map(int, input().split())) \n\n    a = np.array(input().split(), np.int32)\n\n    c = np.array([int(i) for i in range(1, n)])\n\n    ans = INF\n\n    for comb in combinations(c, k-1):\n\n        s = set(comb)\n\n        mx = a[0]\n\n        cost = 0\n\n        for i in range(n):\n\n            if i in s:\n\n                if a[i] > mx:\n\n                    mx = a[i]\n\n                    continue\n\n                else:\n\n                    mx += 1\n\n                    cost += mx-a[i] \n\n                    continue\n\n            mx = max(mx, a[i])\n\n        ans = min(cost, ans)\n\n    print(ans)\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"from itertools import combinations \n\nINF = int(1e9)*15\n\ndef main():\n\n    n, k = list(map(int, input().split())) \n\n    a = [int(i) for i in input().split()]\n\n    c = [int(i) for i in range(1, n)]\n\n    ans = INF\n\n    for comb in combinations(c, k-1):\n\n        s = set(comb)\n\n        mx = a[0]\n\n        cost = 0\n\n        for i in range(n):\n\n            if i in s:\n\n                if a[i] > mx:\n\n                    mx = a[i]\n\n                    continue\n\n                else:\n\n                    mx += 1\n\n                    cost += mx-a[i] \n\n                    continue\n\n            mx = max(mx, a[i])\n\n        ans = min(cost, ans)\n\n    print(ans)\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import numpy as np\n\nINF = int(1e18)\n\ndef compute_cost(a, start, end):\n    \"\"\"Compute the cost of making the subarray a[start:end+1] valid.\"\"\"\n    mx = a[start]\n    cost = 0\n    for i in range(start + 1, end + 1):\n        if a[i] > mx:\n            mx = a[i]\n        else:\n            mx += 1\n            cost += mx - a[i]\n    return cost\n\ndef main():\n    n, k = map(int, input().split())\n    a = np.array(list(map(int, input().split())), dtype=np.int32)\n\n    # DP table: dp[i][j] = min cost to partition first i elements into j subarrays\n    dp = np.full((n + 1, k + 1), INF, dtype=np.int64)\n    dp[0][0] = 0\n\n    for j in range(1, k + 1):  # Iterate over number of subarrays\n        for i in range(1, n + 1):  # Iterate over array length\n            for t in range(j - 1, i):  # Possible split points\n                cost = compute_cost(a, t, i - 1)\n                dp[i][j] = min(dp[i][j], dp[t][j - 1] + cost)\n\n    print(dp[n][k])\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02772","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nA = np.array(lr())\n\nA = A[A%2==0].tolist()\n\nbool = True\n\nfor a in A:\n\n    if a%3 != 0 and a%5 != 0:\n\n        bool = False\n\n\n\nprint(('APPROVED' if bool else 'DENIED'))\n","reference_code_col":"# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nA = lr()\n\nbl = all(x % 3 == 0 or x % 5 == 0 for x in A if x % 2 == 0)\n\nprint(('APPROVED' if bl else 'DENIED'))\n","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Efficient input functions\nsr = sys.stdin.readline\nir = lambda: int(sr())\nlr = lambda: np.fromstring(sr(), dtype=int, sep=' ')\n\n# Read input\nN = ir()\nA = lr()\n\n# Filter even numbers using NumPy (vectorized operation)\nA = A[A % 2 == 0]\n\n# Check condition using vectorized operations\nresult = 'APPROVED' if np.all((A % 3 == 0) | (A % 5 == 0)) else 'DENIED'\n\n# Output the result\nprint(result)"}
{"problem_id":"p02851","slow_code_col":"from collections import defaultdict\n\n\n\nN, K, *A = list(map(int, open(0).read().split()))\n\n\n\nS = [0] * (N + 1)\n\nfor i in range(N):\n\n    S[i + 1] = S[i] + A[i]\n\n\n\nd = defaultdict(int)\n\nans = 0\n\nfor j in range(N + 1):\n\n    v = (S[j] - j) % K\n\n    ans += d[v]\n\n    d[v] += 1\n\n    if j >= K - 1:\n\n        d[(S[j - K + 1] - (j - K + 1)) % K] -= 1\n\n        \n\nprint(ans)\n","reference_code_col":"from collections import defaultdict\n\n\n\nN, K, *A = list(map(int, open(0).read().split()))\n\n\n\nx = [0] * (N + 1)\n\nfor i in range(N):\n\n    x[i + 1] = x[i] + A[i]\n\n    \n\ny = [(x[i] - i) % K for i in range(N + 1)]\n\n\n\nctr = defaultdict(int)\n\nans = 0\n\nfor j in range(N + 1):\n\n    ans += ctr[y[j]]\n\n    ctr[y[j]] += 1\n\n    if j - K + 1 >= 0:\n\n        ctr[y[j - K + 1]] -= 1\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"from collections import defaultdict\n\n# Read input efficiently\ninput_data = list(map(int, open(0).read().split()))\nN, K = input_data[0], input_data[1]\nA = input_data[2:]\n\n# Compute prefix sums\nS = [0] * (N + 1)\nfor i in range(N):\n    S[i + 1] = S[i] + A[i]\n\n# Use a dictionary to track frequencies of (S[j] - j) % K\nfreq = defaultdict(int)\nans = 0\n\nfor j in range(N + 1):\n    # Compute the key for the current index\n    key = (S[j] - j) % K\n    \n    # Update the answer using the frequency of the current key\n    ans += freq[key]\n    \n    # Increment the frequency of the current key\n    freq[key] += 1\n    \n    # Remove the contribution of the oldest element in the sliding window\n    if j >= K - 1:\n        old_key = (S[j - K + 1] - (j - K + 1)) % K\n        freq[old_key] -= 1\n\n# Output the result\nprint(ans)"}
{"problem_id":"p02767","slow_code_col":"n=int(eval(input()))\n\nx=list(map(int,input().split()))\n\n\n\nx.sort()\n\n\n\nfor p in range(x[0],x[len(x)-1]+1):\n\n    psum=0\n\n    for i in range(len(x)):\n\n        psum=psum+(x[0]-x[i])**2\n\n#    print(psum)\n\n    pmin=psum    \n\n    for j in range(x[0]+1,x[len(x)-1]):\n\n        psum=0\n\n        for i in range(len(x)):\n\n            psum=psum+(j-x[i])**2\n\n#        print(psum)\n\n        if pmin>psum:\n\n            pmin=psum\n\nprint(pmin)    ","reference_code_col":"n=int(eval(input()))\n\nx=list(map(int,input().split()))\n\n\n\nx.sort()\n\n\n\npsum=0\n\nfor i in range(len(x)):\n\n    psum=psum+(x[0]-x[i])**2\n\n#    print(psum)\n\npmin=psum    \n\nfor j in range(x[0]+1,x[len(x)-1]):\n\n    psum=0\n\n    for i in range(len(x)):\n\n        psum=psum+(j-x[i])**2\n\n#        print(psum)\n\n    if pmin>psum:\n\n        pmin=psum\n\nprint(pmin)            \n","model_generated_potentially_faster_code_col":"# Read input\nn = int(eval(input()))\nx = list(map(int, input().split()))\n\n# Sort the array (still required for correctness)\nx.sort()\n\n# Compute the mean of the array\nmean = sum(x) \/ n\n\n# Calculate the minimum sum of squared differences\npmin = sum((xi - mean) ** 2 for xi in x)\n\n# Output the result\nprint(pmin)"}
{"problem_id":"p02880","slow_code_col":"N = int(eval(input()))\n\n# N>81\u306e\u3068\u304d\u306fn*n\u3067\u8868\u305b\u306a\u3044\u306e\u3067\u4e0d\u6575\n\nif N>81:\n\n    print('No')\n\nelse:\n\n    import numpy as np\n\n    n=np.array([1,2,3,4,5,6,7,8,9])\n\n    amari=N%n\n\n    shou=N\/\/n\n\n    if np.any((amari==0)*(shou<=9)):\n\n        print('Yes')\n\n    else:\n\n        print('No')\n","reference_code_col":"N = int(eval(input()))\n\nfor i in range(1,10):\n\n    if not N%i == 0:\n\n        continue\n\n    rest = N\/i\n\n    if rest<10:\n\n        print('Yes')\n\n        exit()\n\n\n\nprint('No')","model_generated_potentially_faster_code_col":"N = int(input())\n\n# If N > 81, it cannot be expressed as n * m where n, m <= 9\nif N > 81:\n    print('No')\nelse:\n    # Check if there exists two numbers n, m (both <= 9) such that n * m == N\n    found = False\n    for n in range(1, 10):  # Iterate over possible values of n\n        if N % n == 0:      # Check if n divides N\n            m = N \/\/ n      # Compute m\n            if 1 <= m <= 9: # Check if m is valid (<= 9)\n                found = True\n                break\n\n    print('Yes' if found else 'No')"}
{"problem_id":"p02880","slow_code_col":"import numpy as np\n\nimport math\n\n\n\ndef bigger_devisor(n):\n\n  s = np.sqrt(n)\n\n  i = math.ceil(s)\n\n  while(n % i != 0):\n\n    i += 1\n\n  return i\n\n\n\nn = int(eval(input()))\n\nif bigger_devisor(n) > 9:\n\n  print('No')\n\nelse:\n\n  print('Yes')","reference_code_col":"n = int(eval(input()))\n\nans = 0\n\nfor i in range(1, 10):\n\n  if n % i == 0:\n\n    if n \/ i < 10:\n\n      ans = 1\n\nif ans == 0:\n\n  print('No')\n\nelse:\n\n  print('Yes')","model_generated_potentially_faster_code_col":"def largest_divisor(n):\n    # Start from the integer square root of n and go downwards\n    sqrt_n = int(n**0.5)\n    for i in range(sqrt_n, 0, -1):\n        if n % i == 0:\n            return n \/\/ i  # Return the corresponding larger divisor\n    return n  # Fallback: n itself is the largest divisor\n\n# Input\nn = int(input())\n\n# Check if the largest divisor is greater than 9\nif largest_divisor(n) > 9:\n    print('No')\nelse:\n    print('Yes')"}
{"problem_id":"p03172","slow_code_col":"n, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\n\n\ndp = [[0] * (k + 1) for _ in range(n + 1)]\n\ndp[0][0] = 1\n\nfor i in range(n):\n\n    dp[i + 1][0] = dp[i][0]\n\n    for j in range(1, k+1):\n\n        dp[i + 1][j] = (dp[i + 1][j - 1] + dp[i][j]) % mod\n\n    for j in range(k, a[i], -1):\n\n        dp[i + 1][j] = (dp[i + 1][j] - dp[i + 1][j - a[i] - 1]) % mod\n\nprint((dp[n][-1]))","reference_code_col":"n, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\n\n\nf = [0] * (k + 1)\n\nf[0] = 1\n\nfor i in range(n):\n\n    for j in range(1, k+1):\n\n        f[j] = (f[j] + f[j - 1]) % mod # 1\/(1-x):\u7d2f\u7a4d\u548c\n\n    for j in range(k, a[i], -1): # 1-x^(a[i]+1) a[i]+1\u6b21\u3057\u305f\u306e\u9805\u3092\u5f15\u304f\n\n        f[j] = (f[j] - f[j - a[i] - 1]) % mod\n\nprint((f[-1]))","model_generated_potentially_faster_code_col":"n, k = map(int, input().split())\na = list(map(int, input().split()))\nmod = 10**9 + 7\n\n# Initialize a 1D DP array\ndp = [0] * (k + 1)\ndp[0] = 1  # Base case: one way to form sum 0 (using no elements)\n\nfor i in range(n):\n    # Create a temporary array to store updates\n    temp = dp[:]\n    \n    # Compute prefix sums for efficient updates\n    for j in range(1, k + 1):\n        dp[j] = (dp[j] + dp[j - 1]) % mod\n    \n    # Adjust values for sums greater than a[i]\n    for j in range(k, a[i], -1):\n        dp[j] = (dp[j] - temp[j - a[i] - 1]) % mod\n\nprint(dp[k])"}
{"problem_id":"p02792","slow_code_col":"import itertools\n\nN = int(eval(input()))\n\nNketa = len(str(N))\n\n\n\nrange_count = [[0 for j in range(10)]for i in range(10)]\n\n\n\n\n\nfor p in range(1,N+1):\n\n    mae = int(str(p)[0])\n\n    ato = int(str(p)[-1])\n\n    range_count[mae][ato] += 1\n\n\n\n    \n\n\n\ncount = 0\n\nfor j in range(1,N+1):\n\n    a_mae = int(str(j)[0])\n\n    a_ato = int(str(j)[-1])\n\n    \n\n    b_mae = a_ato\n\n    b_ato = a_mae\n\n    \n\n    if b_mae == 0:\n\n        continue\n\n    else:\n\n        count += range_count[b_mae][b_ato]\n\nprint(count)\n\n  ","reference_code_col":"n = int(eval(input()))\n\n\n\nall_count = 0\n\noptions = [str(i) for i in range(10)]\n\n\n\nmaeato = [[0 for i in range(10)] for j in range(10)]\n\n\n\nfor i in range(n+1):\n\n    checking = str(i)\n\n    maeato[int(checking[0])][int(checking[-1])]+=1\n\nall_count = 0\n\nfor i in range(1,10):\n\n    for j in range(1,10):\n\n        for k in range(1,10):\n\n            for p in range(1,10):\n\n                if i == p and j == k:\n\n                    all_count+=maeato[i][j]*maeato[k][p]\n\nprint(all_count)","model_generated_potentially_faster_code_col":"import sys\n\n# Read input efficiently\nN = int(sys.stdin.read())\n\n# Precompute the number of digits in N\nNketa = len(str(N))\n\n# Initialize the range_count matrix\nrange_count = [[0 for _ in range(10)] for _ in range(10)]\n\n# Efficiently calculate first and last digits for each number\nfor p in range(1, N + 1):\n    # Get the last digit\n    last_digit = p % 10\n    \n    # Get the first digit\n    first_digit = int(str(p)[0])\n    \n    # Update the range_count matrix\n    range_count[first_digit][last_digit] += 1\n\n# Count pairs efficiently\ncount = 0\nfor first_digit in range(1, 10):  # First digit cannot be 0\n    for last_digit in range(10):  # Last digit can be 0-9\n        count += range_count[first_digit][last_digit] * range_count[last_digit][first_digit]\n\nprint(count)"}
{"problem_id":"p02916","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nA = list(np.array(A) - 1)\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nsum_ = 0\n\ndiff = list(np.array(A[1:]) - np.array(A[:-1]))\n\ndiff.insert(0, -1)\n\nfor i in range(N):\n\n  sum_ += B[A[i]]\n\n  \n\n  if diff[i] == 1:\n\n    sum_ += C[A[i-1]]\n\n  \n\nprint(sum_)","reference_code_col":"N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor i in range(len(A)):\n\n  ans += B[A[i]-1]\n\n\n\n  if i != 0:\n\n    if A[i-1] + 1 == A[i]:\n\n      ans += C[A[i-1]-1]\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(input())  # Use input() instead of eval(input())\n\n# Read and preprocess A, B, C as lists\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\n\n# Precompute A[i] - 1 (as per the original code)\nA = [x - 1 for x in A]\n\n# Precompute the differences in a single pass\ndiff = [-1]  # First element is always -1\nfor i in range(1, N):\n    diff.append(A[i] - A[i - 1])\n\n# Compute the sum efficiently\nsum_ = 0\nfor i in range(N):\n    sum_ += B[A[i]]  # Add B[A[i]] to the sum\n    if diff[i] == 1:  # Check if the difference is 1\n        sum_ += C[A[i - 1]]  # Add C[A[i-1]] to the sum\n\nprint(sum_)"}
{"problem_id":"p02863","slow_code_col":"N, W = list(map(int, input().split()))\n\nitems = sorted([list(map(int, input().split())) for i in range(N)])\n\n\n\n# dp1[i][j] := \u5546\u54c10 ~ i \u304c\u5bfe\u8c61\n\ndp = [[0] * (W + 1) for i in range(N + 1)]\n\n\n\n# dp\u30c6\u30fc\u30d6\u30eb\u3092\u57cb\u3081\u308b\n\nfor i in range(N):\n\n    wi, vi = items[i]\n\n    for j in range(W + 1):\n\n        if j + wi <= W:\n\n            dp[i + 1][j + wi] = max(dp[i + 1][j + wi], dp[i][j] + vi)\n\n        dp[i + 1][j] = max(dp[i][j], dp[i + 1][j])\n\n\n\n\n\nans = 0\n\nfor i, (wi, vi) in enumerate(items):\n\n    for j in range(W):\n\n        ans = max(ans, dp[i][j] + vi)\n\n\n\nprint(ans)\n","reference_code_col":"N, W = list(map(int, input().split()))\n\nitems = sorted([list(map(int, input().split())) for i in range(N)])\n\n\n\n# dp1[i][j] := \u5546\u54c10 ~ i \u304c\u5bfe\u8c61\n\ndp = [[0] * (W + 1) for i in range(N + 1)]\n\n\n\n# dp\u30c6\u30fc\u30d6\u30eb\u3092\u57cb\u3081\u308b\n\nfor i in range(N):\n\n    wi, vi = items[i]\n\n    for j in range(W + 1):\n\n        if j + wi <= W:\n\n            dp[i + 1][j + wi] = max(dp[i + 1][j + wi], dp[i][j] + vi)\n\n        dp[i + 1][j] = max(dp[i][j], dp[i + 1][j])\n\n\n\n\n\nans = 0\n\nfor i, (wi, vi) in enumerate(items):\n\n    ans = max(ans, dp[i][W - 1] + vi)\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"# Input reading\nN, W = map(int, input().split())\nitems = [list(map(int, input().split())) for _ in range(N)]\n\n# Initialize a rolling DP array\ndp = [0] * (W + 1)\n\n# Fill the DP table\nfor wi, vi in items:\n    # Iterate over capacities in reverse to avoid overwriting\n    for j in range(W, wi - 1, -1):\n        dp[j] = max(dp[j], dp[j - wi] + vi)\n\n# The answer is the maximum value in the DP array\nprint(max(dp))"}
{"problem_id":"p03013","slow_code_col":"# https:\/\/atcoder.jp\/contests\/abc129\/tasks\/abc129_c\n\n# \u5178\u578b\u7684\u306aDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]\u3092i\u6bb5\u76ee\u307e\u3067\u306e\u901a\u308a\u306e\u6570\u3068\u3059\u308b\u3002\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False, dtype=bool)\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # \u5e8a\u304c\u629c\u3051\u3066\u3044\u308b\u3068\u3053\u308d\n\n\n\n# dp\u30c6\u30fc\u30d6\u30eb\u306e\u7528\u610f\n\ndp = np.full((N + 1), -1, dtype='int64')\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n","reference_code_col":"# https:\/\/atcoder.jp\/contests\/abc129\/tasks\/abc129_c\n\n# \u5178\u578b\u7684\u306aDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]\u3092i\u6bb5\u76ee\u307e\u3067\u306e\u901a\u308a\u306e\u6570\u3068\u3059\u308b\u3002\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False).tolist()\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # \u5e8a\u304c\u629c\u3051\u3066\u3044\u308b\u3068\u3053\u308d\n\n\n\n# dp\u30c6\u30fc\u30d6\u30eb\u306e\u7528\u610f\n\ndp = np.full((N + 1), -1).tolist()\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\n# Input reading\nN, M = map(int, input().split())\nbroken_steps = set(int(input()) for _ in range(M))\n\n# Initialize DP variables\nprev2 = 1  # dp[0]\nprev1 = 0 if 1 in broken_steps else 1  # dp[1]\n\n# DP computation\nfor i in range(2, N + 1):\n    if i in broken_steps:\n        current = 0\n    else:\n        current = (prev1 + prev2) % MOD\n    prev2, prev1 = prev1, current\n\n# Output the result\nprint(prev1)"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\neval(input())\n\nx = np.array(input().split(),dtype=np.int32)\n\n\n\nans = 0\n\nwhile (x%2 == 0).all():\n\n  x = x\/\/2\n\n  ans += 1\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nA = [int(x) for x in input().split()]\n\nresult = float('inf')\n\nfor i in range(N):\n\n  r=0\n\n  while A[i]%2==0:\n\n    A[i]=A[i]\/2\n\n    r +=1\n\n  result=min(result,r)\n\nprint(result)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Safely parse input\n_ = input()  # Ignore the first input line\nx = np.array(input().split(), dtype=np.int32)\n\n# Function to count trailing zeros (number of times divisible by 2)\ndef count_trailing_zeros(n):\n    return (n & -n).bit_length() - 1\n\n# Vectorized application of the function\ntrailing_zeros = np.vectorize(count_trailing_zeros)(x)\n\n# The answer is the minimum number of trailing zeros across all elements\nans = trailing_zeros.min()\n\nprint(ans)"}
{"problem_id":"p03416","slow_code_col":"N = {} #10000\u4ee5\u4e0akey\u4ee5\u4e0b\u306e\u56de\u6587\u6570\u306e\u500b\u6570\n\ncnt = 0\n\nfor i in range(10000, 100000):\n\n    L = list(str(i))\n\n    if L == list(reversed(L)):\n\n        cnt += 1\n\n    N[i] = cnt\n\nA, B = list(map(int, input().split()))\n\nprint((N[B]-N[A-1] if A > 10000 else N[B]))","reference_code_col":"A, B =list(map(int, input().split()))\n\nnum_palin = [0] * (B+1)\n\nfor i in range(1,B+1):\n\n    if str(i) == str(i)[::-1]:\n\n        num_palin[i] = num_palin[i-1] + 1\n\n    else:\n\n        num_palin[i] = num_palin[i-1]\n\nprint((num_palin[B]-num_palin[A-1]))\n","model_generated_potentially_faster_code_col":"from bisect import bisect_left, bisect_right\n\n# Step 1: Precompute all palindromic numbers in the range [10000, 99999]\npalindromes = []\nfor num in range(10000, 100000):\n    str_num = str(num)\n    if str_num == str_num[::-1]:  # Check if the number is a palindrome\n        palindromes.append(num)\n\n# Step 2: Input range [A, B]\nA, B = map(int, input().split())\n\n# Step 3: Use binary search to find the count of palindromes in [A, B]\nstart_index = bisect_left(palindromes, A)  # First index >= A\nend_index = bisect_right(palindromes, B)   # First index > B\n\n# Step 4: Output the result\nprint(end_index - start_index)"}
{"problem_id":"p03835","slow_code_col":"k,s=list(map(int,input().split()))\n\ncnt=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        if 0 <= s-i-j <= k:\n\n            cnt+=1\n\nprint(cnt)","reference_code_col":"k,s=list(map(int,input().split()))\n\na=0\n\nfor i in range(0,k+1):\n\n    for j in range(0,k+1):\n\n        if 0<=s-i-j<=k:\n\n            a+=1\n\nprint(a)","model_generated_potentially_faster_code_col":"k, s = map(int, input().split())\n\ncnt = 0\n\nfor i in range(k + 1):\n    # Compute the valid range for j such that 0 <= s - i - j <= k\n    low_j = max(0, s - i - k)  # Minimum value of j\n    high_j = min(k, s - i)     # Maximum value of j\n    \n    # Ensure the range is valid\n    if low_j <= high_j:\n        cnt += high_j - low_j + 1\n\nprint(cnt)"}
{"problem_id":"p03806","slow_code_col":"N,Ma,Mb = list(map(int, input().split()))\n\narr=[list(map(int,input().split())) for _ in range(N)]\n\ndp=[[[5000]*401 for _ in range(401)] for _ in range(41)]\n\ndp[0][0][0] = 0\n\nfor i in range(N):\n\n    a,b,c=arr[i]\n\n    for j in range(10*N+1):\n\n        for k in range(10*N+1):\n\n            if dp[i][j][k] == 5000:\n\n                continue\n\n            dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k])\n\n            dp[i+1][j+a][k+b]=min(dp[i+1][j+a][k+b],dp[i][j][k]+c)\n\n\n\nans=5000\n\nfor i in range(1,401):\n\n        if i*Ma>400 or i*Mb>400:\n\n            break\n\n        ans = min(ans, dp[N][i*Ma][i*Mb])\n\nif ans == 5000:\n\n    print((-1))\n\nelse:\n\n    print(ans)","reference_code_col":"def calc():\n\n    N,Ma,Mb = list(map(int, input().split()))\n\n    arr=[list(map(int,input().split())) for _ in range(N)]\n\n    dp=[[[5000]*401 for _ in range(401)] for _ in range(41)]\n\n    dp[0][0][0] = 0\n\n    for i in range(N):\n\n        a,b,c=arr[i]\n\n        for j in range(10*N+1):\n\n            for k in range(10*N+1):\n\n                if dp[i][j][k] == 5000:\n\n                    continue\n\n                dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k])\n\n                dp[i+1][j+a][k+b]=min(dp[i+1][j+a][k+b],dp[i][j][k]+c)\n\n\n\n    ans=5000\n\n    for i in range(1,401):\n\n            if i*Ma>400 or i*Mb>400:\n\n                break\n\n            ans = min(ans, dp[N][i*Ma][i*Mb])\n\n    if ans == 5000:\n\n        print((-1))\n\n    else:\n\n        print(ans)\n\n\n\ncalc()","model_generated_potentially_faster_code_col":"N, Ma, Mb = map(int, input().split())\narr = [list(map(int, input().split())) for _ in range(N)]\n\n# Initialize DP with two rows (current and previous)\nprev_dp = {0: {0: 0}}  # Sparse representation: prev_dp[j][k] = cost\nans = float('inf')\n\nfor i in range(N):\n    a, b, c = arr[i]\n    curr_dp = {}\n\n    for j, sub_dict in prev_dp.items():\n        for k, cost in sub_dict.items():\n            # Keep the current state\n            if j not in curr_dp:\n                curr_dp[j] = {}\n            curr_dp[j][k] = min(curr_dp[j].get(k, float('inf')), cost)\n\n            # Update the state with the new item\n            new_j, new_k = j + a, k + b\n            if new_j <= 400 and new_k <= 400:\n                if new_j not in curr_dp:\n                    curr_dp[new_j] = {}\n                curr_dp[new_j][new_k] = min(curr_dp[new_j].get(new_k, float('inf')), cost + c)\n\n    prev_dp = curr_dp\n\n# Find the minimum cost for valid ratios\nfor i in range(1, 401):\n    if i * Ma > 400 or i * Mb > 400:\n        break\n    target_j, target_k = i * Ma, i * Mb\n    if target_j in prev_dp and target_k in prev_dp[target_j]:\n        ans = min(ans, prev_dp[target_j][target_k])\n\nprint(-1 if ans == float('inf') else ans)"}
{"problem_id":"p03038","slow_code_col":"from heapq import *\n\n\n\n\n\nn, m = list(map(int, input().split()))\n\nPAIRS = [[-a, -1] for a in map(int, input().split())]\n\nheapify(PAIRS)\n\n\n\nfor _ in range(m):\n\n    b, c = list(map(int, input().split()))\n\n    heappush(PAIRS, [-c, -b])\n\n\n\nanswer = 0\n\nfor _ in range(n):\n\n    pair = heappop(PAIRS)\n\n    answer += -pair[0]\n\n    pair[1] += 1\n\n    if pair[1] != 0:\n\n        heappush(PAIRS, pair)\n\n\n\nprint(answer)\n","reference_code_col":"n, m = list(map(int, input().split()))\n\nPAIRS = [(a, 1) for a in map(int, input().split())]\n\n\n\nfor _ in range(m):\n\n    b, c = list(map(int, input().split()))\n\n    PAIRS.append((c, b))\n\nPAIRS.sort(reverse = True)\n\n\n\nanswer, count = 0, 0\n\nfor pair in PAIRS:\n\n    answer += pair[0] * pair[1]\n\n    count += pair[1]\n\n    if count > n:\n\n        answer -= pair[0] * (count - n)\n\n        break\n\n\n\nprint(answer)\n","model_generated_potentially_faster_code_col":"from heapq import heappush, heappop, heapify\n\n# Input parsing\nn, m = map(int, input().split())\ninitial_values = list(map(int, input().split()))\nPAIRS = [[-a, -1] for a in initial_values]\nheapify(PAIRS)\n\n# Add additional pairs to the heap\nfor _ in range(m):\n    b, c = map(int, input().split())\n    heappush(PAIRS, [-c, -b])\n\nanswer = 0\n\n# Process the top n elements\nwhile n > 0:\n    value, count = heappop(PAIRS)\n    count = -count  # Convert back to positive\n    use_count = min(count, n)  # Use as many as needed or available\n    answer += -value * use_count  # Add to the answer\n    n -= use_count  # Reduce the remaining count of elements to process\n\nprint(answer)"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nn = int(eval(input()))\n\nans = math.factorial(n) % (pow(10, 9) + 7)\n\nprint(ans)","reference_code_col":"n = int(eval(input()))\n\nans = 1\n\nmod = 10 ** 9 + 7\n\nfor i in range(1, n + 1):\n\n    ans = (ans * i % mod) % mod\n\nprint(ans)","model_generated_potentially_faster_code_col":"n = int(input())  # Avoid using eval for security reasons; use int() directly\n\nMOD = 10**9 + 7  # Define the modulo constant\n\n# Compute factorial with modulo at each step\nans = 1\nfor i in range(2, n + 1):\n    ans = (ans * i) % MOD\n\nprint(ans)"}
{"problem_id":"p02596","slow_code_col":"k = int(eval(input()))\n\nx = 1\n\n\n\nif k%7 != 0:\n\n    mod = 9*k\n\nelse:\n\n    mod = 9*k\/\/7\n\n\n\nfor i in range(10**6):\n\n    x = x*10%mod\n\n    if x == 1:\n\n        print((i + 1))\n\n        exit()\n\n\n\nprint((-1))","reference_code_col":"k = int(eval(input()))\n\na = 0\n\n\n\nfor i in range(k + 10):\n\n    a = (a*10 + 7)%k\n\n    if a == 0:\n\n        print((i + 1))\n\n        exit()\n\nprint((-1))","model_generated_potentially_faster_code_col":"k = int(input())\n\n# Calculate mod based on k\nif k % 7 != 0:\n    mod = 9 * k\nelse:\n    mod = 9 * k \/\/ 7\n\n# Edge case: If mod <= 1, no solution exists\nif mod <= 1:\n    print(-1)\n    exit()\n\n# Initialize variables\nx = 1\nseen = {}\n\nfor i in range(1, 10**6 + 1):\n    x = (x * 10) % mod\n    if x == 1:\n        print(i)\n        exit()\n    # Detect cycles using a dictionary\n    if x in seen:\n        print(-1)\n        exit()\n    seen[x] = i\n\n# If no solution is found within the range\nprint(-1)"}
{"problem_id":"p00053","slow_code_col":"import math\n\ndef pri(n):\n\n    if n < 2:\n\n        return False\n\n    elif n == 2:\n\n        return True\n\n    elif n % 2 == 0:\n\n        return False\n\n\n\n    i = 3\n\n    while i <= math.sqrt(n):\n\n        if n % i == 0:\n\n            return False\n\n        i += 2\n\n    return True\n\n\n\nl=[i for i in range(110000)if pri(i) ]\n\n\n\nwhile True:\n\n    n = int(eval(input()))\n\n    if n == 0: break\n\n    print((sum(l[:n])))","reference_code_col":"import math\n\ndef pri(n):\n\n    l =[True] * n\n\n    l[0] = l[1] = False\n\n    for i in range(2,n):\n\n        if l[i]:\n\n            for j in range(i*2, n, i):\n\n                l[j] = False\n\n    return l\n\nn=105000\n\ns=pri(n)\n\nl=[i for i in range(n) if s[i]]\n\nwhile True:\n\n    n = int(eval(input()))\n\n    if n == 0: break\n\n    print((sum(l[:n])))","model_generated_potentially_faster_code_col":"def sieve_of_eratosthenes(limit):\n    \"\"\"Generate all prime numbers up to 'limit' using the Sieve of Eratosthenes.\"\"\"\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n\n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, limit + 1, i):\n                is_prime[j] = False\n\n    return [x for x in range(limit + 1) if is_prime[x]]\n\n\n# Precompute all primes up to 110,000\nprimes = sieve_of_eratosthenes(110000)\n\n# Precompute prefix sums for faster queries\nprefix_sums = [0] * (len(primes) + 1)\nfor i in range(len(primes)):\n    prefix_sums[i + 1] = prefix_sums[i] + primes[i]\n\n# Process input queries\nwhile True:\n    try:\n        n = int(input())\n        if n == 0:\n            break\n        print(prefix_sums[n])\n    except EOFError:\n        break"}
{"problem_id":"p02988","slow_code_col":"n = int(eval(input()))\n\nl = list(map(int, input().split()))\n\nprint((sum(l[i]<l[i+1]<l[i+2] or l[i]>l[i+1]>l[i+2] for i in range(n-2))))","reference_code_col":"n=int(eval(input()))\n\nl=list(map(int,input().split()))\n\na=0\n\nfor i in range(n-2):\n\n  p,q,r=l[i:i+3]\n\n  if p<q<r or r<q<p: a+=1\n\nprint(a)","model_generated_potentially_faster_code_col":"# Read input values\nn = int(input())\nl = list(map(int, input().split()))\n\n# Count valid triplets\ncount = 0\nfor i in range(n - 2):\n    a, b, c = l[i], l[i + 1], l[i + 2]\n    if (a < b < c) or (a > b > c):\n        count += 1\n\nprint(count)"}
{"problem_id":"p02661","slow_code_col":"from numpy import*\n\na,b=median(t:=loadtxt(open(0),skiprows=1),0)\n\nprint((int((a-b)*~(~len(t)%2))+1))","reference_code_col":"from statistics import*\n\n(n,),*t=[list(map(int,t.split()))for t in open(0)]\n\na,b=list(map(median,list(zip(*t))))\n\nprint((int((b-a)*(2-n%2))+1))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input data efficiently\ndata = np.loadtxt(sys.stdin, skiprows=1)\n\n# Compute medians along axis 0\nmedians = np.median(data, axis=0)\na, b = medians[0], medians[1]\n\n# Simplify length adjustment and final computation\nlength_adjustment = len(data) % 2\nresult = int((a - b) * length_adjustment) + 1\n\n# Output the result\nprint(result)"}
{"problem_id":"p04021","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\"\"\"\n\n\u5947\u6570\u756a\u76ee\u96c6\u5408\u3001\u5076\u6570\u756a\u76ee\u96c6\u5408\u306e\u4e2d\u3067\u81ea\u7531\u306b\u3067\u304d\u308b\u306e\u304c\u64cd\u4f5c2\uff0e\n\n\u64cd\u4f5c1\u3067\u96c6\u5408\u9593\u306e\u3084\u308a\u3068\u308a\u3092\u3059\u308b\n\n\"\"\"\n\n\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.fromstring(sys.stdin.read(),dtype=np.int64,sep='\\n')\n\n\n\nB = np.sort(A)\n\n\n\nanswer = len(np.setdiff1d(A[::2],B[::2]))\n\nprint(answer)","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n\"\"\"\n\n\u30fb\u5076\u6570\u756a\u53f7\u3001\u5947\u6570\u756a\u53f7\u306e\u4e2d\u3067\u306f\u5165\u308c\u66ff\u3048\u653e\u984c\n\n\u30fb\u5076\u3001\u5947\u306e\u9593\uff1a\u4e26\u3079\u3066\u304b\u3089\u30b9\u30ef\u30c3\u30d7\u3002\u64cd\u4f5c2\u30921\u56de\u3067\u3001\u6b63\u3057\u3044\u3082\u306e\u30922\u3064\u5897\u3084\u305b\u308b\n\n\"\"\"\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nx_to_i = {x:i for i,x in enumerate(sorted(A))}\n\nrank = [x_to_i[x] for x in A]\n\n\n\nanswer = sum((x^i) & 1 for i,x in enumerate(rank)) \/\/ 2\n\nprint(answer)","model_generated_potentially_faster_code_col":"import sys\n\n# Read input efficiently\ninput = sys.stdin.readline\nN = int(input())\nA = list(map(int, sys.stdin.read().split()))\n\n# Sort the array\nB = sorted(A)\n\n# Extract odd-indexed elements from A and B\nA_odd = A[::2]\nB_odd = B[::2]\n\n# Use sets for efficient difference computation\nset_A_odd = set(A_odd)\nset_B_odd = set(B_odd)\n\n# Compute the difference: elements in A_odd but not in B_odd\nanswer = len(set_A_odd - set_B_odd)\n\n# Output the result\nprint(answer)"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\n\n\nx = int(eval(input()))\n\ny = input().split()\n\ny = [int(i) for i in y]\n\ny = np.array(y)\n\ncount = 0\n\nwhile sum([y[i] % 2 for i in range(len(y))]) == 0:\n\n    y = y\/2\n\n    count += 1\n\nprint(count)","reference_code_col":"N = int(eval(input()))\n\nA = input().split()\n\nA = [int(i) for i in A]\n\n\n\nc = 0 \n\n\n\nwhile True:\n\n  exist_odd = False\n\n  for a in A:\n\n    if a % 2 != 0:\n\n      exist_odd = True\n\n    \n\n  if exist_odd: break\n\n\n\n  for i in range(N):\n\n    A[i] = A[i] \/ 2\n\n  \n\n  c = c + 1\n\nprint(c)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input parsing\ny = np.array(list(map(int, input().split())))\n\n# Initialize counter\ncount = 0\n\n# Loop until any element in y becomes odd\nwhile np.all(y % 2 == 0):\n    y \/\/= 2  # Perform integer division\n    count += 1\n\nprint(count)"}
{"problem_id":"p03363","slow_code_col":"N = int(input())\n\nA = list(map(int, input().split()))\n\n\n\nans, s = 0, 0\n\nd = {0:1}\n\n\n\nfor i in A:\n\n    s += i\n\n    ans += d.get(s, 0)\n\n    d[s] = d.get(s, 0) + 1\n\n\n\nprint(ans)","reference_code_col":"#!\/usr\/bin\/env python3\n\n\n\nfrom collections import defaultdict\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nd = defaultdict(int)\n\nd[0] = 1\n\n\n\ns, ans = 0, 0\n\n\n\nfor a in A:\n\n    s += a\n\n    ans += d[s]\n\n    d[s] += 1\n\n\n\nprint (ans)","model_generated_potentially_faster_code_col":"from collections import defaultdict\nimport sys\n\n# Faster input reading\ndef main():\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n\n    ans, s = 0, 0\n    # Use defaultdict to avoid redundant .get() calls\n    d = defaultdict(int)\n    d[0] = 1\n\n    for i in A:\n        s += i\n        # Directly access the dictionary without .get()\n        ans += d[s]\n        d[s] += 1\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03162","slow_code_col":"import numpy as np\n\nn=int(eval(input()))\n\nABC=[list(map(int,input().split())) for _ in range(n)]\n\n\n\ndp=np.zeros((n,3),int)\n\nfor i in range(3):\n\n  dp[0][i]=ABC[0][i]\n\nfor i in range(n-1):\n\n  for j in range(3):\n\n    dp[i+1][j]=max(dp[i][(j+1)%3]+ABC[i+1][j], dp[i][(j+2)%3]+ABC[i+1][j])\n\nprint((max(dp[-1])))","reference_code_col":"import numpy as np\n\nn=int(eval(input()))\n\nABC=[list(map(int,input().split())) for _ in range(n)]\n\n\n\ndp=np.zeros((n,3),int)\n\nfor i in range(3):\n\n  dp[0,i]=ABC[0][i]\n\nfor i in range(1,n):\n\n  for j in range(3):\n\n    dp[i,j]=max(dp[i-1,(j+1)%3]+ABC[i][j],dp[i-1,(j+2)%3]+ABC[i][j])\n\nprint((max(dp[-1])))","model_generated_potentially_faster_code_col":"import numpy as np\nimport sys\n\ndef main():\n    # Read input efficiently\n    input_data = sys.stdin.read().split()\n    n = int(input_data[0])\n    ABC = [list(map(int, input_data[i:i+3])) for i in range(1, n*3+1, 3)]\n\n    # Initialize variables for the first row\n    prev_dp = np.array(ABC[0], dtype=int)\n\n    # Iterate through rows\n    for i in range(1, n):\n        curr_dp = np.zeros(3, dtype=int)\n        for j in range(3):\n            # Precompute indices for clarity\n            idx1 = (j + 1) % 3\n            idx2 = (j + 2) % 3\n            # Update current dp value\n            curr_dp[j] = max(prev_dp[idx1] + ABC[i][j], prev_dp[idx2] + ABC[i][j])\n        # Move to the next row\n        prev_dp = curr_dp\n\n    # Output the result\n    print(max(prev_dp))\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03162","slow_code_col":"N = int(eval(input()))\n\nl = [list(map(int, input().split())) for _ in range(N)]\n\n\n\ndp = [[0 for i in range(3)] for j in range(N+1)]\n\n\n\n\n\nfor i in range(1, N+1):\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j != k:\n\n                dp[i][j] = max(dp[i][j], dp[i-1][k]+l[i-1][k])\n\n\n\nprint((max(dp[N][0], dp[N][1], dp[N][2])))\n\n\n","reference_code_col":"N = int(eval(input()))\n\ndp = [[0 for i in range(3)] for j in range(N+1)]\n\n\n\nfor i in range(1, N+1):\n\n    hapiness = list(map(int, input().split()))\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j != k:\n\n                dp[i][j] = max(dp[i][j], dp[i-1][k] + hapiness[k])\n\n\n\nprint((max(dp[N][0], dp[N][1], dp[N][2])))","model_generated_potentially_faster_code_col":"N = int(eval(input()))\n\n# Read the input matrix\nl = [list(map(int, input().split())) for _ in range(N)]\n\n# Initialize the DP table\ndp = [[0] * 3 for _ in range(N + 1)]\n\n# Iterate over each row\nfor i in range(1, N + 1):\n    # Precompute the maximum values for the previous row\n    max_prev = [0] * 3\n    for j in range(3):\n        max_prev[j] = max(dp[i - 1][k] + l[i - 1][k] for k in range(3) if k != j)\n    \n    # Update the DP table using the precomputed maximums\n    for j in range(3):\n        dp[i][j] = max_prev[j]\n\n# Output the maximum value from the last row\nprint(max(dp[N]))"}
{"problem_id":"p02899","slow_code_col":"import sys\n\n\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    ans = 0\n\n    n = int(input())\n\n    o = list(map(int, input().split()))\n\n    l = [0]*n\n\n    for i in range(n):\n\n        l[o[i]-1] = i+1\n\n    for i in range(len(l)):\n\n        if  i != len(l)-1:\n\n            print(\"{} \".format(l[i]), end='')\n\n        else:\n\n            print(l[i])\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"import sys\n\n\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    ans = 0\n\n    n = int(eval(input()))\n\n    o = list(map(int, input().split()))\n\n    l = [0]*n\n\n    for i in range(n):\n\n        l[o[i]-1] = i+1\n\n    print((\" \".join(map(str,l))))\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\ndef main():\n    n = int(input())\n    o = list(map(int, input().split()))\n    \n    # Construct the array `l` in O(n) time\n    l = [0] * n\n    for i in range(n):\n        l[o[i] - 1] = i + 1\n    \n    # Print the entire array as a space-separated string in one operation\n    print(' '.join(map(str, l)))\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02994","slow_code_col":"N,L = list(map(int, input().split()))\n\ntaste = [L+i-1 for i in range(1,N+1)]\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min([abs(x) for x in taste])))\n\nelse:\n\n  print((sum(taste) - min([abs(x) for x in taste])))","reference_code_col":"N, L = list(map(int, input().split()))\n\n\n\ntaste = [L+i-1 for i in range(1, N+1)]\n\n\n\nif 0 in taste:\n\n    select = 0\n\nelse:\n\n    select_with_ind = min(enumerate(taste), key = lambda x: abs(x[1]))\n\n    select = select_with_ind[1]\n\n    \n\nprint((sum(taste) - select))","model_generated_potentially_faster_code_col":"N, L = list(map(int, input().split()))"}
{"problem_id":"p03416","slow_code_col":"# ABC090B - Palindromic Numbers\n\na, b = list(map(int, input().rstrip().split()))\n\ncount = 0\n\nfor i in range(a, b + 1):\n\n    lst = list(map(int, list(str(i))))\n\n    if lst[0] == lst[4] and lst[1] == lst[3]:\n\n        count += 1\n\nprint(count)","reference_code_col":"# ABC090B - Palindromic Numbers\n\ndef main():\n\n    a, b = list(map(int, input().rstrip().split()))\n\n    cnt = 0\n\n    for i in range(a, b + 1):\n\n        s = str(i)\n\n        if s == s[::-1]:\n\n            cnt += 1\n\n    print(cnt)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()","model_generated_potentially_faster_code_col":"# Input parsing\na, b = map(int, input().split())\n\n# Initialize count\ncount = 0\n\n# Restrict the range to 5-digit numbers\nstart = max(a, 10000)\nend = min(b, 99999)\n\n# Iterate over the restricted range\nfor num in range(start, end + 1):\n    # Extract digits using arithmetic\n    d1 = num \/\/ 10000       # First digit\n    d2 = (num \/\/ 1000) % 10  # Second digit\n    d4 = (num \/\/ 10) % 10    # Fourth digit\n    d5 = num % 10            # Fifth digit\n    \n    # Check palindrome condition\n    if d1 == d5 and d2 == d4:\n        count += 1\n\n# Output the result\nprint(count)"}
{"problem_id":"p03720","slow_code_col":"n, m = list(map(int, input().split()))\n\ndp = [0] * n\n\nfor i in range(m):\n\n    x, y = list(map(int, input().split()))\n\n    dp[x - 1] += 1\n\n    dp[y - 1] += 1\n\nfor i in range(n):\n\n    print((dp[i]))","reference_code_col":"n, m = list(map(int, input().split()))\n\nA = [0] * n\n\nfor i in range(m):\n\n    a, b = list(map(int, input().split()))\n\n    A[a - 1] += 1\n\n    A[b - 1] += 1\n\n    \n\nfor i in range(n):\n\n    print((A[i]))","model_generated_potentially_faster_code_col":"# Read n and m from the first line\nn, m = map(int, input().split())\n\n# Initialize dp array\ndp = [0] * n\n\n# Read all m pairs of inputs at once\ninputs = sys.stdin.read().split()\n\n# Process the inputs in pairs\nfor i in range(0, 2 * m, 2):\n    x = int(inputs[i]) - 1\n    y = int(inputs[i + 1]) - 1\n    dp[x] += 1\n    dp[y] += 1\n\n# Print the dp array as space-separated values\nprint(\" \".join(map(str, dp)))"}
{"problem_id":"p03558","slow_code_col":"import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\n\n\nfrom collections import deque\n\ndef resolve():\n\n    k=int(eval(input()))\n\n    E=[[] for _ in range(k)]\n\n    for i in range(k):\n\n        E[i].append(((i+1)%k,1))\n\n        E[i].append(((10*i)%k,0))\n\n\n\n    # 0-1 BFS\n\n    dist=[INF]*k\n\n    dist[1]=0\n\n    Q=deque([1])\n\n    while(Q):\n\n        v=Q.popleft()\n\n        for nv,w in E[v]:\n\n            if(dist[nv]<=dist[v]+w): continue\n\n            dist[nv]=dist[v]+w\n\n            if(w==0): Q.appendleft(nv)\n\n            else: Q.append(nv)\n\n    print((dist[0]+1))\n\nresolve()","reference_code_col":"import sys\n\nINF = 1 << 60\n\nMOD = 10**9 + 7 # 998244353\n\nsys.setrecursionlimit(2147483647)\n\ninput = lambda:sys.stdin.readline().rstrip()\n\nfrom collections import deque\n\ndef resolve():\n\n    k = int(eval(input()))\n\n    dist = [INF] * k\n\n    dist[1] = 1\n\n    queue = deque([1])\n\n\n\n    while queue:\n\n        v = queue.pop()\n\n        if dist[10 * v % k] > dist[v]:\n\n            dist[10 * v % k] = dist[v]\n\n            queue.appendleft(10 * v % k)\n\n        if dist[(v + 1) % k] > dist[v] + 1:\n\n            dist[(v + 1) % k] = dist[v] + 1\n\n            queue.append((v + 1) % k)\n\n\n\n    print((dist[0]))\n\nresolve()","model_generated_potentially_faster_code_col":"import sys\nfrom collections import deque\n\n# Set recursion limit (optional, as recursion isn't used here)\nsys.setrecursionlimit(2147483647)\n\n# Constants\nINF = float(\"inf\")\nMOD = 10**9 + 7\n\n# Input function\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef resolve():\n    # Read input\n    k = int(input())\n\n    # Precompute adjacency list\n    E = [[] for _ in range(k)]\n    for i in range(k):\n        E[i].append(((i + 1) % k, 1))  # Edge with weight 1\n        E[i].append(((10 * i) % k, 0))  # Edge with weight 0\n\n    # 0-1 BFS initialization\n    dist = [INF] * k\n    dist[1] = 0\n    Q = deque([1])\n\n    # Perform 0-1 BFS\n    while Q:\n        v = Q.popleft()\n        if v == 0:  # Early termination if target vertex is reached\n            break\n        for nv, w in E[v]:\n            if dist[nv] > dist[v] + w:\n                dist[nv] = dist[v] + w\n                if w == 0:\n                    Q.appendleft(nv)  # Add to front for weight 0\n                else:\n                    Q.append(nv)  # Add to back for weight 1\n\n    # Output result\n    print(dist[0] + 1)\n\nresolve()"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nn = int(eval(input()))\n\n\n\nprint((math.factorial(n) % (10**9 + 7)))\n","reference_code_col":"n = int(eval(input()))\n\n\n\nans = 1\n\n\n\nfor i in range(1, n+1):\n\n    ans *= i\n\n    ans %= 10**9 + 7\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"n = int(eval(input()))\nMOD = 10**9 + 7\n\n# Compute factorial iteratively with modulo\nresult = 1\nfor i in range(2, n + 1):\n    result = (result * i) % MOD\n\nprint(result)"}
{"problem_id":"p03839","slow_code_col":"N,K = list(map(int,input().split()))\n\nsrc = list(map(int,input().split()))\n\n\n\ncums = [0]\n\ncump = [0]\n\nfor a in src:\n\n    cums.append(cums[-1] + a)\n\n    cump.append(cump[-1] + max(0,a))\n\n\n\nans = 0\n\nfor i in range(N-K+1):\n\n    tmp = cump[i]\n\n    tmp += max(0, cums[i+K] - cums[i])\n\n    tmp += cump[N] - cump[i+K]\n\n    ans = max(tmp, ans)\n\nprint(ans)\n","reference_code_col":"N,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\ncums = [0]\n\ncums_p = [0]\n\nfor a in A:\n\n    cums.append(cums[-1] + a)\n\n    cums_p.append(cums_p[-1] + max(0,a))\n\n\n\nans = -float('inf')\n\nfor l in range(N-K+1):\n\n    free = cums_p[l] + cums_p[-1] - cums_p[l+K]\n\n    cont = cums[l+K] - cums[l]\n\n    ans = max(ans, free, free+cont)\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Input parsing\nN, K = map(int, input().split())\nsrc = list(map(int, input().split()))\n\n# Early exit for full window\nif K == N:\n    print(max(0, sum(src)))\n    exit()\n\n# Precompute prefix sums\ncums = [0] * (N + 1)\ncump = [0] * (N + 1)\nfor i in range(N):\n    cums[i + 1] = cums[i] + src[i]\n    cump[i + 1] = cump[i] + max(0, src[i])\n\n# Cache the total sum of positive elements\ntotal_positive = cump[N]\n\n# Sliding window calculation\nans = 0\nfor i in range(N - K + 1):\n    # Compute the score for the current window\n    tmp = cump[i]  # Positive sum before the window\n    tmp += max(0, cums[i + K] - cums[i])  # Sum of elements in the window\n    tmp += total_positive - cump[i + K]  # Positive sum after the window\n    ans = max(ans, tmp)\n\nprint(ans)"}
{"problem_id":"p03796","slow_code_col":"def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r *= n\n\n        power_r %= 10**9+7\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))","reference_code_col":"def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r = power_r*n % (10**9+7)\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\ndef factorial(N):\n    # Handle edge cases\n    if N <= 1:\n        return 1\n\n    power_r = 1\n    for n in range(2, N + 1):\n        power_r *= n\n        # Apply modulo only when necessary to prevent overflow\n        if power_r >= MOD:\n            power_r %= MOD\n\n    return power_r % MOD  # Final modulo to ensure correctness\n\nif __name__ == '__main__':\n    N = int(input())  # Safe input handling\n    print(factorial(N))"}
{"problem_id":"p02596","slow_code_col":"import sys\n\nK = int(eval(input()))\n\n\n\npower = 7\n\nSUM = 0\n\n\n\nfor i in range(1, 10 ** 6):\n\n    SUM += power\n\n    if SUM % K == 0:\n\n        print(i)\n\n        sys.exit()\n\n    power *= 10\n\n    power %= K\n\n\n\nprint((-1))","reference_code_col":"import sys\n\nK = int(eval(input()))\n\n\n\nL = 9 * K\n\n\n\nif K % 7 == 0:\n\n    L \/\/= 7\n\n\n\npower = 1\n\n\n\nfor i in range(1, 10 ** 6):\n\n    power *= 10\n\n    power %= L\n\n    if power == 1:\n\n        print(i)\n\n        sys.exit()\n\n\n\nprint((-1))","model_generated_potentially_faster_code_col":"import sys\n\nK = int(input())  # Read input directly without eval for safety\n\npower = 7 % K  # Initialize power modulo K\nSUM = 0        # Initialize SUM\nseen = {}      # Dictionary to track previously seen (power, SUM % K) states\n\nfor i in range(1, 10**6):\n    SUM += power\n    SUM %= K  # Keep SUM within bounds using modulo K\n    \n    if SUM == 0:  # Check if SUM is divisible by K\n        print(i)\n        sys.exit()\n    \n    # Detect cycles using (power, SUM % K) as a state\n    state = (power, SUM)\n    if state in seen:\n        break  # Exit loop if a cycle is detected\n    seen[state] = True\n    \n    # Update power for the next iteration\n    power = (power * 10) % K\n\nprint(-1)  # No solution found"}
{"problem_id":"p02780","slow_code_col":"import numpy as np\n\nimport sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN, K = list(map(int, readline().split()))\n\nA = np.array(readline().split(), dtype=np.int64) + 1\n\n\n\n\n\nAcum = np.zeros(N+1, np.float64)\n\nAcum[1:] = A.cumsum()\n\n\n\nx = Acum[K:] - Acum[:-K]\n\nprint((x.max()\/2))\n","reference_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 7)\n\nread = sys.stdin.buffer.read \n\ninput = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines  \n\n\n\nfrom itertools import accumulate\n\n\n\nN, K = list(map(int, input().split()))\n\nP = list(map(int, input().split()))\n\nPcum = list(accumulate([0] + [(1+p)\/2 for p in P]))\n\n\n\nans = max(right - left for left, right in zip(Pcum, Pcum[K:]))\n\nprint(ans)  ","model_generated_potentially_faster_code_col":"import numpy as np\nimport sys\n\nreadline = sys.stdin.buffer.readline\n\n# Read N and K\nN, K = map(int, readline().split())\n\n# Read A and compute cumulative sum directly\nAcum = np.frombuffer(readline(), dtype=np.int64, count=N, offset=0).cumsum()\n\n# Adjust Acum by adding 1 to each element (equivalent to A + 1)\nAcum += np.arange(1, N + 1)\n\n# Compute sliding window sums\nx = Acum[K - 1:] - np.concatenate(([0], Acum[:-K]))\n\n# Output the result\nprint(x.max() \/ 2)"}
{"problem_id":"p02982","slow_code_col":"import numpy as np\n\nn,d=list(map(int,input().split()))\n\nx=[list(map(int,input().split())) for i in range(n)]\n\ncount=0\n\nfor i in range(n-1):\n\n    for j in range(i+1,n):\n\n        a=np.array(x[i])\n\n        b=np.array(x[j])\n\n        ab=sum(np.power((a-b),2))**0.5\n\n        if ab%1==0:\n\n            count+=1\n\nprint(count)","reference_code_col":"n,d=list(map(int,input().split()))\n\nL=[list(map(int,input().split())) for i in range(n)]\n\nans=0\n\nfor i in range(n-1):\n\n    for j in range(i+1,n):\n\n        a=0\n\n        for k in range(d):\n\n            a+=(L[i][k]-L[j][k])**2\n\n        if int(a**0.5)==a**0.5:\n\n            ans+=1\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input parsing\nn, d = map(int, input().split())\nx = np.array([list(map(int, input().split())) for _ in range(n)])\n\ncount = 0\n\n# Precompute squared distances for all pairs\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        # Compute squared distance\n        squared_distance = np.sum((x[i] - x[j]) ** 2)\n        \n        # Check if squared distance is a perfect square\n        sqrt_dist = int(squared_distance ** 0.5)\n        if sqrt_dist * sqrt_dist == squared_distance:\n            count += 1\n\nprint(count)"}
{"problem_id":"p00003","slow_code_col":"for n in range(eval(input())):\n\n  a,b,c=sorted(map(int,input().split()))\n\n  s=\"YES\" if a*a+b*b==c*c else \"NO\"\n\n  print(s)","reference_code_col":"for n in range(eval(input())):\n\n  a,b,c=sorted(map(int,input().split()))\n\n  print(\"YES\" if a*a + b*b == c*c else \"NO\")","model_generated_potentially_faster_code_col":"# Read the number of test cases\nn = int(input())\n\n# Precompute \"YES\" and \"NO\" strings\nYES, NO = \"YES\", \"NO\"\n\n# Process all test cases and store results\nresults = []\nfor _ in range(n):\n    # Read three integers\n    x, y, z = map(int, input().split())\n    \n    # Determine the smallest, middle, and largest values\n    if x > y:\n        x, y = y, x\n    if y > z:\n        y, z = z, y\n    if x > y:\n        x, y = y, x\n    \n    # Check the Pythagorean theorem\n    results.append(YES if x * x + y * y == z * z else NO)\n\n# Print all results at once\nprint(\"\\n\".join(results))"}
{"problem_id":"p02821","slow_code_col":"#E\n\nfrom itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=10**10+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)\/\/2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()","reference_code_col":"from itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=2*10**5+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)\/\/2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()","model_generated_potentially_faster_code_col":"from itertools import accumulate\n\ndef main():\n    # Input reading\n    n, m = map(int, input().split())\n    A = list(map(int, input().split()))\n    A.sort()\n\n    # Optimized count function using two-pointer technique\n    def count(k):\n        cnt = 0\n        j = n - 1\n        for i in range(n):\n            while j >= 0 and A[i] + A[j] >= k:\n                j -= 1\n            if j >= i:\n                cnt += j - i + 1\n        return cnt\n\n    # Binary search for the threshold value\n    ok, ng = 0, 10**10 + 1\n    while ng - ok > 1:\n        mid = (ok + ng) \/\/ 2\n        if count(mid) < n**2 - m:\n            ok = mid\n        else:\n            ng = mid\n    border = ok\n\n    # Calculate k and prefix sums\n    k = n**2 - count(border)\n    Acc = [0] + list(accumulate(A))\n    s = Acc[-1]\n\n    # Calculate the sum of valid pairs using two-pointer technique\n    ans = 0\n    j = n - 1\n    for i in range(n):\n        while j >= 0 and A[i] + A[j] >= border:\n            j -= 1\n        if j >= i:\n            ans += A[i] * (j - i + 1) + (Acc[j + 1] - Acc[i])\n\n    # Adjust the answer based on the border value\n    ans -= border * (k - m)\n    print(ans)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03634","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nn = int(eval(input()))\n\nv = [[0]+[]*(n+1) for i in range(n+1)]\n\nfor i in range(n-1):\n\n    a,b,c = list(map(int,input().split()))\n\n    v[a].append([b,c])\n\n    v[b].append([a,c])\n\n\n\nq,k = list(map(int,input().split()))\n\nl = [k]\n\nwhile l:\n\n    now = l.pop()\n\n    for i in v[now][1:]:\n\n        if v[i[0]][0] == 0:\n\n            v[i[0]][0] = i[1]+v[now][0]\n\n            l.append(i[0])\n\n\n\nfor i in range(q):\n\n    x,y = list(map(int,input().split()))\n\n    print((v[x][0]+v[y][0]))","reference_code_col":"import sys\n\ndef main():\n\n    input = sys.stdin.readline\n\n    n = int(eval(input()))\n\n    v = [[0]+[]*(n+1) for i in range(n+1)]\n\n    for i in range(n-1):\n\n        a,b,c = list(map(int,input().split()))\n\n        v[a].append([b,c])\n\n        v[b].append([a,c])\n\n\n\n    q,k = list(map(int,input().split()))\n\n    l = [k]\n\n    while l:\n\n        now = l.pop()\n\n        for i in v[now][1:]:\n\n            if v[i[0]][0] == 0:\n\n                v[i[0]][0] = i[1]+v[now][0]\n\n                l.append(i[0])\n\n\n\n    for i in range(q):\n\n        x,y = list(map(int,input().split()))\n\n        print((v[x][0]+v[y][0]))\n\n\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"import sys\nfrom collections import deque\n\n# Use faster input method\ninput = sys.stdin.readline\n\n# Read number of nodes\nn = int(input())\n\n# Initialize adjacency list efficiently\nv = [[] for _ in range(n + 1)]\n\n# Populate adjacency list\nfor _ in range(n - 1):\n    a, b, c = map(int, input().split())\n    v[a].append((b, c))\n    v[b].append((a, c))\n\n# Read number of queries and root node\nq, k = map(int, input().split())\n\n# Perform BFS to calculate distances from node k\ndist = [0] * (n + 1)  # Distance array\nqueue = deque([k])  # Use deque for O(1) pop from front\n\nwhile queue:\n    now = queue.popleft()\n    for neighbor, weight in v[now]:\n        if dist[neighbor] == 0 and neighbor != k:  # Unvisited node\n            dist[neighbor] = dist[now] + weight\n            queue.append(neighbor)\n\n# Process queries\nfor _ in range(q):\n    x, y = map(int, input().split())\n    print(dist[x] + dist[y])"}
{"problem_id":"p02767","slow_code_col":"import numpy as np\n\n\n\nN = int(eval(input()))\n\nX = np.array(list(map(int, input().split())))\n\ncost = float(\"inf\")\n\nfor i in range(max(X) - min(X) + 1):\n\n    p = min(X) + i\n\n    cost = min(np.sum((X - p) ** 2), cost)\n\nprint(cost)","reference_code_col":"N = int(eval(input()))\n\nX = sorted(list(map(int, input().split())))\n\nif N == 1:\n\n    print((0))\n\nelse:\n\n    r = X[-1] - X[0]\n\n    ans = float(\"inf\")\n\n    for i in range(r + 1):\n\n        R = X[0] + i\n\n        hp = 0\n\n        for j in range(N):\n\n            hp = hp + (R - X[j]) ** 2\n\n\n\n        ans = min(hp, ans)\n\n\n\n    print(ans)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input reading\nN = int(eval(input()))\nX = np.array(list(map(int, input().split())))\n\n# Compute the mean of X\nmean_X = np.mean(X)\n\n# Consider the two closest integers to the mean\np1 = int(np.floor(mean_X))\np2 = int(np.ceil(mean_X))\n\n# Calculate the cost for both candidates\ncost1 = np.sum((X - p1) ** 2)\ncost2 = np.sum((X - p2) ** 2)\n\n# Output the minimum cost\nprint(min(cost1, cost2))"}
{"problem_id":"p03568","slow_code_col":"from functools import reduce\n\nfrom itertools import product\n\n\n\nN = int(eval(input()))\n\n*A, = list(map(int, input().split()))\n\nans = 0\n\nfor t in product([-1, 0, 1], repeat=N):\n\n    prod = reduce(lambda x, y: x*y, [a + t[i] for i, a in enumerate(A)])\n\n    if prod % 2 == 0: ans += 1\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\n*A, = list(map(int, input().split()))\n\nevens = 0\n\nfor a in A:\n\n    if a % 2 == 0: evens += 1\n\nans = 3**N - 2**evens\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(input())\nA = list(map(int, input().split()))\n\n# Precompute the number of ways to make each element even or odd\neven_ways = []\nodd_ways = []\n\nfor a in A:\n    # Count how many of (a-1, a, a+1) are even or odd\n    even_count = sum(1 for x in [a - 1, a, a + 1] if x % 2 == 0)\n    odd_count = 3 - even_count  # Total options are 3\n    even_ways.append(even_count)\n    odd_ways.append(odd_count)\n\n# Total combinations where at least one element is even\ntotal_combinations = 3 ** N\nall_odd_combinations = 1  # Start with 1 (product of all odds)\n\nfor odd_count in odd_ways:\n    all_odd_combinations *= odd_count\n\n# Subtract the all-odd case from total combinations\nans = total_combinations - all_odd_combinations\n\nprint(ans)"}
{"problem_id":"p02748","slow_code_col":"a, b, m = list(map(int,input().split()))\n\ndr = list(map(int,input().split()))\n\nwa = list(map(int,input().split()))\n\nxyc = [list(map(int,input().split())) for i in range(m)]\n\nlow = 200001\n\n\n\nfor i in range(m):\n\n    f = xyc[i][0] - 1\n\n    d = xyc[i][1] - 1\n\n    if low >= dr[f]+wa[d]-xyc[i][2]:\n\n        low = dr[f]+wa[d]-xyc[i][2]\n\n\n\ndr.sort()\n\nwa.sort()\n\n\n\nif low >= (dr[0] + wa[0]):\n\n    print((dr[0] + wa[0]))\n\nelse:\n\n    print(low)","reference_code_col":"a, b, m = list(map(int,input().split()))\n\nal = list(map(int,input().split()))\n\nbl = list(map(int,input().split()))\n\nlow = min(al)+min(bl)\n\nx = [0] * m\n\ny = [0] * m\n\nc = [0] * m\n\n\n\nfor i in range(m):\n\n    x[i],y[i],c[i] = list(map(int, input().split()))\n\n    x[i] -= 1\n\n    y[i] -= 1\n\n \n\nfor i in range(m):\n\n    low = min(low,al[x[i]]+bl[y[i]]-c[i])\n\n\n\nprint(low)","model_generated_potentially_faster_code_col":"# Input parsing\na, b, m = map(int, input().split())\ndr = list(map(int, input().split()))\nwa = list(map(int, input().split()))\nxyc = [list(map(int, input().split())) for _ in range(m)]\n\n# Sort dr and wa upfront\ndr.sort()\nwa.sort()\n\n# Initialize low with the smallest possible sum\nlow = dr[0] + wa[0]\n\n# Iterate through xyc to find the minimum value\nfor x, y, c in xyc:\n    f = x - 1\n    d = y - 1\n    current_value = dr[f] + wa[d] - c\n    if current_value < low:\n        low = current_value\n        # Early exit if low cannot be reduced further\n        if low == dr[0] + wa[0]:\n            break\n\n# Output the result\nprint(low)"}
{"problem_id":"p03835","slow_code_col":"K, S = [int(i) for i in input().split()]\n\n\n\nc = 0\n\nfor X in range(K + 1):\n\n    for Y in range(K + 1):\n\n        Z = S - X - Y\n\n        if 0 <= Z <= K:\n\n            c += 1\n\n\n\nprint(c)","reference_code_col":"K, S = [int(i) for i in input().split()]\n\n\n\nans = 0\n\n# X <= Y <= Z\u3068\u3057\u3066\u3082\u4e00\u822c\u6027\u3092\u5931\u308f\u306a\u3044\n\nfor x in range(K + 1):\n\n    for y in range(x, K + 1):\n\n        z = S - x - y\n\n        if z < y:\n\n            break\n\n        if z <= K:\n\n            if x == y == z:\n\n                ans += 1\n\n            elif x == y or y == z or z == x:\n\n                ans += 3\n\n            else:\n\n                ans += 6\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"K, S = map(int, input().split())\n\nc = 0\n\nfor X in range(K + 1):\n    # Calculate the valid range for Y\n    min_Y = max(0, S - X - K)  # Ensure Y >= 0 and Z <= K\n    max_Y = min(K, S - X)      # Ensure Y <= K and Z >= 0\n    \n    if min_Y <= max_Y:  # Check if there are valid Y values\n        c += max_Y - min_Y + 1\n\nprint(c)"}
{"problem_id":"p03126","slow_code_col":"import numpy as np\n\nN, M = list(map(int, input().split()))\n\nmenu = np.array([])\n\nfor i in range(N):\n\n  a = np.array(input().split())\n\n  menu = np.append(menu, a[1:])\n\nmenu = np.array(menu).astype(int).ravel()\n\ncount = 0\n\nfor i in range(1, M+1):\n\n  if np.sum(menu == i) == N:\n\n    count += 1\n\nprint(count)","reference_code_col":"# coding: utf-8\n\nn, m = list(map(int, input().split()))\n\nll = [0] * m\n\nfor i in range(n):\n\n    l = list(map(int, input().split()))\n\n    for j in range(l[0]):\n\n        ll[l[j+1] - 1] += 1\n\nprint((ll.count(max(ll)) if max(ll)==n else 0))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values N and M\nN, M = map(int, input().split())\n\n# Preallocate a list to store all menu items efficiently\nmenu_items = []\n\n# Read all rows of input and extract relevant data\nfor _ in range(N):\n    # Append all elements except the first one directly to the list\n    menu_items.extend(map(int, input().split()[1:]))\n\n# Convert the list to a NumPy array once\nmenu = np.array(menu_items)\n\n# Count the frequency of each item in the menu\nfrom collections import Counter\nfrequency = Counter(menu)\n\n# Count how many items appear exactly N times\ncount = sum(1 for freq in frequency.values() if freq == N)\n\n# Output the result\nprint(count)"}
{"problem_id":"p02983","slow_code_col":"l, r=list(map(int, input().split()))\n\nif r-l>672:\n\n\tp=0\n\nelse:\n\n\tp=2019\n\n\tfor i in range(l, r):\n\n\t\tfor j in range(i+1, r+1):\n\n\t\t\tp=min(p, (((i%2019)*(j%2019))%2019))\n\n\t\t\tif not p:\n\n\t\t\t\tbreak\n\n\t\tif not p:\n\n\t\t\tbreak\n\nprint(p)","reference_code_col":"l, r=list(map(int, input().split()))\n\nif r-l>672:\n\n\tp=0\n\nelse:\n\n\tp=2019\n\n\tfor i in range(l, r):\n\n\t\tfor j in range(i+1, r+1):\n\n\t\t\tp=min(p, (i*j%2019))\n\n\t\t\tif not p:\n\n\t\t\t\tbreak\n\n\t\tif not p:\n\n\t\t\tbreak\n\nprint(p)","model_generated_potentially_faster_code_col":"l, r = map(int, input().split())\n\nif r - l > 672:\n    print(0)\nelse:\n    # Collect unique residues modulo 2019 in the range [l, r]\n    residues = {x % 2019 for x in range(l, r + 1)}\n    residues = sorted(residues)  # Sort residues for efficient pair checking\n\n    min_product = 2019  # Initialize with the maximum possible value\n\n    # Check all pairs of residues\n    for i in residues:\n        for j in residues:\n            if i != j:  # Ensure we are considering distinct numbers\n                product_mod = (i * j) % 2019\n                min_product = min(min_product, product_mod)\n                if min_product == 0:  # Early termination if 0 is found\n                    break\n        if min_product == 0:\n            break\n\n    print(min_product)"}
{"problem_id":"p03371","slow_code_col":"a,b,c,x,y = list(map(int,input().split()))\n\nprice = 10**10\n\nfor k in range(10**5+1):\n\n    re = 2*c*k + max(0,x-k)*a + max(0,y-k)*b\n\n    price = min(re,price)\n\nprint(price)","reference_code_col":"a,b,c,x,y = list(map(int,input().split()))\n\na1 = a*x + b*y\n\na2 = max(x,y) * 2*c\n\nif y >= x:\n\n    a3 = 2*c*x + (y-x)*b\n\nelse:\n\n    a3 = 2*c*y + (x-y)*a\n\nprint((min(a1,a2,a3)))","model_generated_potentially_faster_code_col":"# Input parsing\na, b, c, x, y = map(int, input().split())\n\n# Initialize price to a very large value\nprice = float('inf')\n\n# Critical points to evaluate\ncritical_points = [0, x, y]\n\n# Evaluate the cost function at critical points and slightly beyond\nfor k in critical_points:\n    # Compute the cost at k\n    re = 2 * c * k + max(0, x - k) * a + max(0, y - k) * b\n    price = min(price, re)\n\n# Edge case: Check slightly beyond the maximum of x and y\nk = max(x, y) + 1\nre = 2 * c * k + max(0, x - k) * a + max(0, y - k) * b\nprice = min(price, re)\n\n# Output the minimum price\nprint(price)"}
{"problem_id":"p04021","slow_code_col":"import numpy as np\n\nN=int(eval(input()))\n\nA=[int(eval(input())) for i in range(N)]\n\nB=list(np.argsort(np.array(A)))\n\nX=[[0,0],[0,0]]\n\nfor i in range(N):\n\n    X[i%2][B[i]%2]+=1\n\nprint((X[0][1]))\n","reference_code_col":"N=int(eval(input()))\n\nA=[int(eval(input())) for i in range(N)]\n\nAT=[(A[i],i) for i in range(N)]\n\nAT.sort()\n\nB=[AT[i][1] for i in range(N)]\n\nX=[[0,0],[0,0]]\n\nfor i in range(N):\n\n    X[i%2][B[i]%2]+=1\n\nY=[X[0][1],X[1][0]]\n\nprint((min(Y)))\n","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Read the input values into a list\nA = [int(input()) for _ in range(N)]\n\n# Create a list of indices sorted by the values in A\nsorted_indices = sorted(range(N), key=lambda i: A[i])\n\n# Initialize the result matrix X\nX = [[0, 0], [0, 0]]\n\n# Compute the counts directly\nfor i, idx in enumerate(sorted_indices):\n    X[i % 2][idx % 2] += 1\n\n# Print the desired output\nprint(X[0][1])"}
{"problem_id":"p02996","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\nab = sorted([list(map(int, input().split()))[::-1] for _ in range(n)])\n\n\n\ncnt = 0\n\nfor b, a in ab:\n\n    cnt += a\n\n    if cnt > b:\n\n        print('No')\n\n        break\n\nelse:\n\n    print('Yes')\n","reference_code_col":"n = int(eval(input()))\n\nab = [list(map(int, input().split())) for _ in range(n)]\n\nab = sorted(ab, key=lambda x: x[1])\n\n\n\nt = 0\n\nfor a, b in ab:\n\n    t += a\n\n    if t > b:\n\n        print('No')\n\n        break\n\nelse:\n\n    print('Yes')\n","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    input = sys.stdin.read  # Read all input at once for efficiency\n    data = input().split()\n    \n    n = int(data[0])  # First element is 'n'\n    ab = []  # List to store (b, a) pairs\n    \n    # Process input data in bulk\n    index = 1\n    for _ in range(n):\n        a = int(data[index])\n        b = int(data[index + 1])\n        ab.append((b, a))  # Store as (b, a) directly\n        index += 2\n    \n    # Sort by 'b' in ascending order\n    ab.sort()\n    \n    cnt = 0\n    for b, a in ab:\n        cnt += a\n        if cnt > b:  # Early exit condition\n            print('No')\n            return\n    \n    print('Yes')  # All conditions satisfied\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03828","slow_code_col":"from collections import Counter\n\nN = int(eval(input()))\n\ndiv = []\n\nfor i in range(2,N+1):\n\n    while i != 1:\n\n        for d in range(2,i+1):\n\n            while i%d==0:\n\n                i = i\/\/d\n\n                div.append(d)\n\nC = Counter(div).most_common()\n\nAns = 1\n\nfor k,v in C:\n\n    Ans = Ans*(v+1) % (10**9+7)\n\n\n\nprint(Ans)\n","reference_code_col":"from collections import defaultdict\n\nN = int(eval(input()))\n\n\n\nF = [True]*(N+1)\n\nF[0]=F[1]=False\n\nP = []\n\n\n\nfor i in range(2,N+1):\n\n    if F[i]==True:\n\n        P.append(i)\n\n        for j in range(i*2,N+1,i):\n\n            F[j]=False\n\n\n\ndic = defaultdict(int)\n\nfor i in range(2,N+1):\n\n    for p in P:\n\n        while i%p==0:\n\n            dic[p] += 1\n\n            i = i\/\/p\n\n        if i==1:\n\n            break\n\n\n\nans = 1\n\nmodulo = 10**9+7\n\nfor v in list(dic.values()):\n\n    ans *= (v+1)\n\n    ans %= modulo\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"from collections import defaultdict\n\ndef optimized_solution():\n    # Read input\n    N = int(input())\n    \n    # Step 1: Precompute Smallest Prime Factor (SPF) using Sieve of Eratosthenes\n    spf = list(range(N + 1))  # Initialize SPF array\n    for i in range(2, int(N**0.5) + 1):\n        if spf[i] == i:  # i is a prime number\n            for j in range(i * i, N + 1, i):\n                if spf[j] == j:  # Update SPF[j] only once\n                    spf[j] = i\n    \n    # Step 2: Count prime factors using SPF\n    prime_counts = defaultdict(int)\n    for i in range(2, N + 1):\n        num = i\n        while num > 1:\n            prime_factor = spf[num]\n            while num % prime_factor == 0:\n                prime_counts[prime_factor] += 1\n                num \/\/= prime_factor\n    \n    # Step 3: Compute the modular product\n    MOD = 10**9 + 7\n    result = 1\n    for count in prime_counts.values():\n        result = result * (count + 1) % MOD\n    \n    # Output the result\n    print(result)\n\n# Call the function\noptimized_solution()"}
{"problem_id":"p02245","slow_code_col":"from collections import deque\n\nfrom copy import deepcopy, copy\n\ndy = [-1, 0, 0, 1]\n\ndx = [0, -1, 1, 0]\n\nN = 3\n\ndef g(i, j, a):\n\n    t = a \/\/ (10 ** j) % 10\n\n    return a - t * (10 ** j) + t * (10 ** i)\n\ndef MAIN():\n\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    start = 8 - MAP.find(\"0\")\n\n    MAP = int(MAP)\n\n    goal = ('1', '2', '3', '4', '5', '6', '7', '8', '0')\n\n    goal = 123456780\n\n    dp = deque([(0, start, MAP)])\n\n    LOG = {MAP}\n\n    while dp:\n\n        cnt, yx, M = dp.popleft()\n\n        if M == goal:\n\n            print(cnt)\n\n            break\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            CM = g(yx, nyx, M)\n\n            if not CM in LOG:\n\n                dp.append((cnt, nyx, CM))\n\n                LOG.add(CM)\n\nMAIN()\n\n\n","reference_code_col":"from collections import deque\n\nfrom copy import deepcopy, copy\n\nN = 3\n\ndef g(i, j, a):\n\n    if i > j:\n\n        i, j = j, i\n\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\n\ndef MAIN():\n\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    start = MAP.find(\"0\")\n\n    goal = \"123456780\"\n\n    dp = deque([(0, start, MAP)])\n\n    LOG = {MAP}\n\n    while dp:\n\n        cnt, yx, M = dp.popleft()\n\n        if M == goal:\n\n            print(cnt)\n\n            break\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            CM = g(yx, nyx, M)\n\n            if not CM in LOG:\n\n                dp.append((cnt, nyx, CM))\n\n                LOG.add(CM)\n\nMAIN()\n\n\n","model_generated_potentially_faster_code_col":"from collections import deque\n\n# Precompute powers of 10 for faster access\nPOWERS_OF_10 = [10 ** i for i in range(9)]\n\ndef swap_digits(state, i, j):\n    \"\"\"\n    Swap digits at positions i and j in the state (represented as a list of digits).\n    Return the new state as a tuple.\n    \"\"\"\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return tuple(state)\n\ndef MAIN():\n    # Define the adjacency map for each position (0-based index)\n    adjacency_map = {\n        8: {7, 5}, 7: {8, 6, 4}, 6: {7, 3}, 5: {8, 4, 2},\n        4: {7, 5, 3, 1}, 3: {6, 4, 0}, 2: {5, 1}, 1: {4, 2, 0}, 0: {3, 1}\n    }\n\n    # Read input and initialize the starting state\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(3))\n    start_zero_pos = MAP.index('0')  # Find the position of '0' (0-based index)\n    start_state = tuple(map(int, MAP))  # Convert the initial state to a tuple of integers\n\n    # Define the goal state\n    goal_state = (1, 2, 3, 4, 5, 6, 7, 8, 0)\n\n    # Initialize BFS queue and visited set\n    dp = deque([(0, start_zero_pos, start_state)])  # (moves, zero_position, current_state)\n    visited = {start_state}\n\n    while dp:\n        moves, zero_pos, current_state = dp.popleft()\n\n        # Check if the current state matches the goal state\n        if current_state == goal_state:\n            print(moves)\n            return\n\n        # Increment the move count\n        moves += 1\n\n        # Explore all possible moves from the current state\n        for neighbor_pos in adjacency_map[zero_pos]:\n            # Swap the '0' with the neighboring digit\n            new_state = swap_digits(current_state, zero_pos, neighbor_pos)\n\n            # If the new state hasn't been visited, add it to the queue\n            if new_state not in visited:\n                dp.append((moves, neighbor_pos, new_state))\n                visited.add(new_state)\n\nMAIN()"}
{"problem_id":"p03416","slow_code_col":"# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        s = str(i)\n\n        r = \"\".join(reversed(list(s)))\n\n        if s == r:\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        #     s = str(i)\n\n        #     r = \"\".join(reversed(list(s)))\n\n        #     if s == r:\n\n        #         c += 1\n\n        if (i % 10) == (i \/\/ 10000 % 10) and (i \/\/ 10 % 10) == (i \/\/ 1000 % 10):\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"def is_palindrome(num):\n    \"\"\"Check if a number is a palindrome using arithmetic operations.\"\"\"\n    original = num\n    reversed_num = 0\n    while num > 0:\n        reversed_num = reversed_num * 10 + (num % 10)\n        num \/\/= 10\n    return original == reversed_num\n\ndef count_palindromes(a, b):\n    \"\"\"Count palindromic numbers in the range [a, b].\"\"\"\n    count = 0\n    for num in range(a, b + 1):\n        if is_palindrome(num):\n            count += 1\n    return count\n\ndef main():\n    # Read input values\n    a, b = map(int, input().split())\n    \n    # Count palindromes in the range [a, b]\n    result = count_palindromes(a, b)\n    \n    # Print the result\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03371","slow_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = float('inf')\n\n\n\nfor i in range(10 ** 5 + 1):\n\n    ans = min(ans, A * max(X - i, 0) + B * max(Y - i, 0) + 2 * C * i)\n\nprint(ans)","reference_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n# ans = float('inf')\n\n\n\n# for i in range(10 ** 5 + 1):\n\n#     ans = min(ans, A * max(X - i, 0) + B * max(Y - i, 0) + 2 * C * i)\n\n# print(ans)\n\n\n\nmin_xy = min(X, Y)\n\nmax_xy = max(X, Y)\n\nans1 = 2 * C * min_xy + A * (X - min_xy) + B * (Y - min_xy)\n\nans2 = A * X + B * Y\n\nans3 = 2 * C * max_xy\n\nprint((min(ans1, ans2, ans3)))","model_generated_potentially_faster_code_col":"# Read input values\nA, B, C, X, Y = map(int, input().split())\n\n# Initialize the answer with a large value\nans = float('inf')\n\n# Evaluate the cost function at critical points: i = 0, i = X, i = Y\ncritical_points = [0, X, Y]\n\nfor i in critical_points:\n    cost = A * max(X - i, 0) + B * max(Y - i, 0) + 2 * C * i\n    ans = min(ans, cost)\n\nprint(ans)"}
{"problem_id":"p02555","slow_code_col":"def getN():\n\n    return int(eval(input()))\n\ndef getNM():\n\n    return list(map(int, input().split()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\ndef getArray(intn):\n\n    return [int(eval(input())) for i in range(intn)]\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\ndef rand_N(ran1, ran2):\n\n    return random.randint(ran1, ran2)\n\ndef rand_List(ran1, ran2, rantime):\n\n    return [random.randint(ran1, ran2) for i in range(rantime)]\n\ndef rand_ints_nodup(ran1, ran2, rantime):\n\n  ns = []\n\n  while len(ns) < rantime:\n\n    n = random.randint(ran1, ran2)\n\n    if not n in ns:\n\n      ns.append(n)\n\n  return sorted(ns)\n\n\n\ndef rand_query(ran1, ran2, rantime):\n\n  r_query = []\n\n  while len(r_query) < rantime:\n\n    n_q = rand_ints_nodup(ran1, ran2, 2)\n\n    if not n_q in r_query:\n\n      r_query.append(n_q)\n\n  return sorted(r_query)\n\n\n\nfrom collections import defaultdict, deque, Counter\n\nfrom sys import exit\n\nfrom decimal import *\n\nfrom heapq import heapify, heappop, heappush\n\nimport math\n\nimport random\n\nimport string\n\nfrom copy import deepcopy\n\nfrom itertools import combinations, permutations, product\n\nfrom operator import mul, itemgetter\n\nfrom functools import reduce\n\nfrom bisect import bisect_left, bisect_right\n\n\n\nimport sys\n\nsys.setrecursionlimit(1000000000)\n\nmod = 10 ** 9 + 7\n\n\n\n#############\n\n# Main Code #\n\n#############\n\n\n\nS = getN()\n\n\n\n# \u9006\u5143\u4e8b\u524d\u51e6\u7406ver\n\n# n\u304c\u5c0f\u3055\u3044\u5834\u5408\u306b\n\nlim = 10 ** 5 + 1\n\nfact = [1, 1]\n\nfactinv = [1, 1]\n\ninv = [0, 1]\n\n\n\nfor i in range(2, lim + 1):\n\n    fact.append((fact[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod \/\/ i)) % mod)\n\n    # \u7d2f\u8a08\n\n    factinv.append((factinv[-1] * inv[-1]) % mod)\n\n\n\ndef cmb(n, r):\n\n    if (r < 0) or (n < r):\n\n        return 0\n\n    r = min(r, n - r)\n\n    return fact[n] * factinv[r] * factinv[n - r] % mod\n\n\n\nans = 0\n\n# \u9577\u3055N\u306e\u6642\u6700\u4f4e\u3067\u30823 * N\u4f7f\u3046\n\n# \u6b8b\u308a\u306f\u5206\u914d\u3059\u308b\n\nfor i in range(1, 2001):\n\n    s = S - (3 * i)\n\n    if s < 0:\n\n        break\n\n    # s\u3092N\u500b\u306b\u5206\u914d\u3059\u308b\u901a\u308a\u304c\u3044\u304f\u3064\u3042\u308b\u304b\n\n    # \u91cd\u8907\u7d44\u307f\u5408\u308f\u305b\n\n    # \u4ed5\u5207\u308a\u306e\u6570\u306fi - 1\u500b\n\n    ans += cmb(s + i - 1, i - 1)\n\nprint((ans % mod))","reference_code_col":"def getN():\n\n    return int(eval(input()))\n\ndef getNM():\n\n    return list(map(int, input().split()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\ndef getArray(intn):\n\n    return [int(eval(input())) for i in range(intn)]\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\ndef rand_N(ran1, ran2):\n\n    return random.randint(ran1, ran2)\n\ndef rand_List(ran1, ran2, rantime):\n\n    return [random.randint(ran1, ran2) for i in range(rantime)]\n\ndef rand_ints_nodup(ran1, ran2, rantime):\n\n  ns = []\n\n  while len(ns) < rantime:\n\n    n = random.randint(ran1, ran2)\n\n    if not n in ns:\n\n      ns.append(n)\n\n  return sorted(ns)\n\n\n\ndef rand_query(ran1, ran2, rantime):\n\n  r_query = []\n\n  while len(r_query) < rantime:\n\n    n_q = rand_ints_nodup(ran1, ran2, 2)\n\n    if not n_q in r_query:\n\n      r_query.append(n_q)\n\n  return sorted(r_query)\n\n\n\nfrom collections import defaultdict, deque, Counter\n\nfrom sys import exit\n\nfrom decimal import *\n\nfrom heapq import heapify, heappop, heappush\n\nimport math\n\nimport random\n\nimport string\n\nfrom copy import deepcopy\n\nfrom itertools import combinations, permutations, product\n\nfrom operator import mul, itemgetter\n\nfrom functools import reduce\n\nfrom bisect import bisect_left, bisect_right\n\n\n\nimport sys\n\nsys.setrecursionlimit(1000000000)\n\nmod = 10 ** 9 + 7\n\n\n\n#############\n\n# Main Code #\n\n#############\n\n\n\nN = getN()\n\nlogk = N.bit_length()\n\n\n\n# \u6f38\u5316\u5f0f\u306b\u3067\u304d\u308b\u306a\u3089\u884c\u5217\u8a08\u7b97\u306b\u843d\u3068\u3057\u8fbc\u3081\u308b\n\n# A[n] = A[n - 1] + A[n - 3]\u306a\u306e\u3067\n\n# [a2, a1, a0] = [0, 0, 1]\n\n# [[1, 1, 0], [0, 0, 1], [1, 0, 0]]\u306eN\u4e57\u3092\u3059\u308c\u3070\n\n# [an+2, an+1, an] \u304c\u51fa\u308b\n\n\n\ndp = [[[0, 0, 0] for i in range(3)] for i in range(logk)]\n\ndp[0] = [\n\n[1, 1, 0],\n\n[0, 0, 1],\n\n[1, 0, 0]\n\n]\n\n\n\n# \u884c\u5217\u639b\u3051\u7b97 O(n3)\u304b\u304b\u308b\n\ndef array_cnt(ar1, ar2):\n\n    h = len(ar1)\n\n    w = len(ar2[0])\n\n    row = ar1\n\n    col = []\n\n    for j in range(w):\n\n        opt = []\n\n        for i in range(len(ar2)):\n\n            opt.append(ar2[i][j])\n\n        col.append(opt)\n\n\n\n    res = [[[0, 0] for i in range(w)] for i in range(h)]\n\n    for i in range(h):\n\n        for j in range(w):\n\n            cnt = 0\n\n            for x, y in zip(row[i], col[j]):\n\n                cnt += x * y\n\n            res[i][j] = cnt\n\n            res[i][j] %= mod\n\n    return res\n\n\n\nfor i in range(1, logk):\n\n    dp[i] = array_cnt(dp[i - 1], dp[i - 1])\n\n\n\nans = [[0, 0, 1]]\n\nfor i in range(logk):\n\n    if N & (1 << i):\n\n        ans = array_cnt(ans, dp[i])\n\nprint((ans[0][2] % mod))","model_generated_potentially_faster_code_col":"from sys import stdin, setrecursionlimit\nfrom math import comb\n\nsetrecursionlimit(10**6)\n\n# Constants\nMOD = 10**9 + 7\nLIM = 10**5 + 1\n\n# Precompute factorials and inverse factorials\nfact = [1] * (LIM + 1)\nfactinv = [1] * (LIM + 1)\ninv = [0] * (LIM + 1)\n\nfor i in range(2, LIM + 1):\n    fact[i] = fact[i - 1] * i % MOD\n    inv[i] = MOD - (MOD \/\/ i) * inv[MOD % i] % MOD\n    factinv[i] = factinv[i - 1] * inv[i] % MOD\n\n# Combination function\ndef cmb(n, r):\n    if r < 0 or n < r:\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] % MOD * factinv[n - r] % MOD\n\n# Input reading\nS = int(stdin.readline())\n\n# Main logic\nans = 0\nfor i in range(1, 2001):\n    s = S - 3 * i\n    if s < 0:\n        break\n    # Calculate combinations using precomputed values\n    ans += cmb(s + i - 1, i - 1)\n    ans %= MOD\n\nprint(ans)"}
{"problem_id":"p03037","slow_code_col":"k,m=list(map(int,input().split()))\n\nl=[0 for i in range(k+1)]\n\nfor i in range(m):\n\n  a,s=list(map(int,input().split()))\n\n  l[a-1]+=1;l[s]-=1\n\nans=0\n\nf=0\n\nfor j in range(k):\n\n  l[j]+=f\n\n  f=l[j]\n\nprint((len([1 for i in l if i==m])))","reference_code_col":"n,m=list(map(int,input().split()))\n\ntable=[0]*(n+2)\n\nfor i in range(m):\n\n    l,r=list(map(int,input().split()))\n\n    table[l]+=1\n\n    table[r+1]-=1\n\nfrom itertools import accumulate\n\nfrom collections import Counter as co\n\nvar=co((accumulate(table)))\n\n\n\nif m not in var:print((0))\n\nelse:print((var[m]))\n\n\n\n\n","model_generated_potentially_faster_code_col":"# Input parsing\nk, m = map(int, input().split())\n\n# Initialize the difference array\nl = [0] * (k + 1)\n\n# Perform range updates\nfor _ in range(m):\n    a, s = map(int, input().split())\n    l[a - 1] += 1\n    l[s] -= 1\n\n# Calculate prefix sums and count elements equal to m in one pass\nans = 0\ncurrent_sum = 0\nfor j in range(k):  # Iterate only up to k (exclude the extra element)\n    current_sum += l[j]\n    if current_sum == m:\n        ans += 1\n\n# Output the result\nprint(ans)"}
{"problem_id":"p02982","slow_code_col":"import numpy as np\n\n\n\nN, D = list(map(int, input().split()))\n\npoints = [list(map(int, input().split())) for _ in range(N)]\n\ncount = 0\n\nfor i in range(N):\n\n    for j in range(N):\n\n        if j == i:\n\n            continue\n\n        dist = np.sqrt(sum([(points[i][d] - points[j][d]) ** 2 for d in range(D)]))\n\n        if dist.is_integer():\n\n            count += 1\n\nprint((count \/\/ 2))","reference_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n\n\n\n\ndef calc_dist(x, y):\n\n    dist = 0\n\n    for xi, yi in zip(x, y):\n\n        dist += (yi - xi) ** 2\n\n    return dist ** (1\/2)\n\n\n\n\n\ndef main():\n\n    N, D = list(map(int, sys.stdin.readline().rstrip().split()))\n\n    X = [list(map(int, sys.stdin.readline().rstrip().split())) for _ in range(N)]\n\n\n\n    ans = 0\n\n    for i in range(N):\n\n        for j in range(i+1, N):\n\n            dist = calc_dist(X[i], X[j])\n\n            if dist.is_integer():\n\n                ans += 1\n\n    \n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input parsing\nN, D = map(int, input().split())\npoints = np.array([list(map(int, input().split())) for _ in range(N)])\n\ncount = 0\n\n# Iterate only over unique pairs (i, j) where i < j\nfor i in range(N):\n    for j in range(i + 1, N):\n        # Compute squared distance\n        squared_dist = np.sum((points[i] - points[j]) ** 2)\n        \n        # Check if squared distance is a perfect square\n        sqrt_dist = int(np.sqrt(squared_dist))\n        if sqrt_dist * sqrt_dist == squared_dist:\n            count += 1\n\nprint(count)"}
{"problem_id":"p02983","slow_code_col":"def abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    # \u533a\u9593\u306e\u5e45\u304c673\u3042\u308c\u3070\u3001673\u306e\u500d\u6570\u30683\u306e\u500d\u6570\u304c\u542b\u307e\u308c\u3066\u30012019\u306e\u500d\u6570\u304c\u4f5c\u308c\u308b\n\n    if R - L > 673: return 0\n\n    # \u305d\u308c\u4ee5\u5916\u306f\u8a66\u3059\n\n    ans = 2019\n\n    for i in range(L, R+1):\n\n        for j in range(L, i):\n\n            m = i * j % 2019\n\n            ans = min(m, ans)\n\n    return ans\n\n\n\nprint((abc133_c()))","reference_code_col":"def abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    # \u533a\u9593\u306e\u5e45\u304c673\u3042\u308c\u3070\u3001673\u306e\u500d\u6570\u30683\u306e\u500d\u6570\u304c\u542b\u307e\u308c\u3066\u30012019\u306e\u500d\u6570\u304c\u4f5c\u308c\u308b\n\n    if R - L > 673: return 0\n\n    # \u305d\u308c\u4ee5\u5916\u306f\u8a66\u3059\n\n    ans = 2019\n\n    for i in range(L, R+1):\n\n        for j in range(L, i):\n\n            m = i * j % 2019\n\n            ans = min(m, ans)\n\n            if ans == 1: return 1\n\n    return ans\n\n\n\nprint((abc133_c()))","model_generated_potentially_faster_code_col":"def abc133_c():\n    L, R = map(int, input().split())\n\n    # If the range is larger than 673, the result is guaranteed to be 0\n    if R - L >= 673:\n        return 0\n\n    # Otherwise, calculate the minimum modulo value\n    ans = 2019\n\n    # Reduce the range to [L % 2019, R % 2019] since only modulo matters\n    L_mod = L % 2019\n    R_mod = R % 2019\n\n    # Create a list of unique values in the range [L_mod, R_mod]\n    values = set(range(L_mod, R_mod + 1))\n\n    # Iterate over all pairs of values\n    for i in values:\n        for j in values:\n            if i != j:  # Ensure i and j are distinct\n                m = (i * j) % 2019\n                ans = min(ans, m)\n                if ans == 0:  # Early exit if minimum possible value is found\n                    return 0\n\n    return ans\n\n\nprint(abc133_c())"}
{"problem_id":"p02792","slow_code_col":"N = int(eval(input()))\n\ncount = [[0 for _ in range(9)] for _ in range(9)]\n\nfor i in range(1, N + 1):\n\n    if str(i)[0] != \"0\" and str(i)[-1] != \"0\":\n\n        count[int(str(i)[0]) - 1][int(str(i)[-1]) - 1] += 1\n\nans = 0\n\nfor i in range(0, 9):\n\n    for k in range(0, 9):\n\n        ans += count[i][k] * count[k][i]\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nnums = [0 for i in range(100)]\n\nfor i in range(1, N + 1):\n\n    i = str(i)\n\n    nums[int(i[0] + i[-1])] += 1\n\nans = 0\n\nfor i in range(1, 10):\n\n    for j in range(i, 10):\n\n        i = str(i)\n\n        j = str(j)\n\n        if i != j:\n\n            ans += nums[int(i + j)] * nums[int(j + i)] * 2\n\n        else:\n\n            n = nums[int(i + j)]\n\n            ans += n * (n - 1)\n\n            ans += n\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Initialize the 9x9 count matrix\ncount = [[0 for _ in range(9)] for _ in range(9)]\n\n# Precompute first and last digits for all numbers from 1 to N\nfor i in range(1, N + 1):\n    # Extract the last digit\n    last_digit = i % 10\n    \n    # Extract the first digit\n    first_digit = i\n    while first_digit >= 10:\n        first_digit \/\/= 10\n    \n    # Update the count matrix if both digits are non-zero\n    if first_digit != 0 and last_digit != 0:\n        count[first_digit - 1][last_digit - 1] += 1\n\n# Compute the result\nans = 0\nfor i in range(9):\n    for k in range(9):\n        ans += count[i][k] * count[k][i]\n\nprint(ans)"}
{"problem_id":"p03078","slow_code_col":"# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x \/\/ y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nMOD = 10 ** 9 + 7\n\n\n\nX,Y,Z,K=MAP()\n\nA=sorted(LIST(), reverse=True)\n\nB=sorted(LIST(), reverse=True)\n\nC=sorted(LIST(), reverse=True)\n\n\n\nABC=[]\n\nfor i in range(X):\n\n    for j in range(Y):\n\n        if (i+1)*(j+1)>K:\n\n            break\n\n        for k in range(Z):\n\n            if (i+1)*(j+1)*(k+1)>K:\n\n                break\n\n            ABC.append(A[i]+B[j]+C[k])\n\nABC.sort(reverse=True)\n\nfor i in range(K):\n\n    print((ABC[i]))\n\n\n","reference_code_col":"# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\nfrom heapq import heappush, heappop\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x \/\/ y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nMOD = 10 ** 9 + 7\n\n\n\nX,Y,Z,K=MAP()\n\nA=sorted(LIST(), reverse=True)\n\nB=sorted(LIST(), reverse=True)\n\nC=sorted(LIST(), reverse=True)\n\n\n\n\n\nque=[]\n\nheappush(que, (-(A[0]+B[0]+C[0]), 0, 0, 0))\n\nS={(0,0,0)}\n\nfor i in range(K):\n\n    ans=heappop(que)\n\n    print((-ans[0]))\n\n    a,b,c=ans[1:]\n\n    if a+1<X and (a+1,b,c) not in S:\n\n        heappush(que, (-(A[a+1]+B[b]+C[c]), a+1, b, c))\n\n        S.add((a+1,b,c))\n\n    if b+1<Y and (a,b+1,c) not in S:\n\n        heappush(que, (-(A[a]+B[b+1]+C[c]), a, b+1, c))\n\n        S.add((a,b+1,c))\n\n    if c+1<Z and (a,b,c+1) not in S:\n\n        heappush(que, (-(A[a]+B[b]+C[c+1]), a, b, c+1))\n\n        S.add((a,b,c+1))\n","model_generated_potentially_faster_code_col":"import sys\nimport heapq\n\ndef input(): return sys.stdin.readline().strip()\n\ndef MAP(): return list(map(int, input().split()))\n\n# Read input\nX, Y, Z, K = MAP()\nA = sorted(MAP(), reverse=True)\nB = sorted(MAP(), reverse=True)\nC = sorted(MAP(), reverse=True)\n\n# Min-heap to store the K largest sums\nheap = []\nvisited = set()\n\n# Push the initial combination (largest sum) into the heap\nheapq.heappush(heap, (-(A[0] + B[0] + C[0]), 0, 0, 0))\nvisited.add((0, 0, 0))\n\nresult = []\n\nwhile len(result) < K:\n    # Pop the largest sum from the heap\n    current_sum, i, j, k = heapq.heappop(heap)\n    result.append(-current_sum)  # Negate because heap stores negative values\n\n    # Explore the next possible combinations\n    if i + 1 < X and (i + 1, j, k) not in visited:\n        heapq.heappush(heap, (-(A[i + 1] + B[j] + C[k]), i + 1, j, k))\n        visited.add((i + 1, j, k))\n    \n    if j + 1 < Y and (i, j + 1, k) not in visited:\n        heapq.heappush(heap, (-(A[i] + B[j + 1] + C[k]), i, j + 1, k))\n        visited.add((i, j + 1, k))\n    \n    if k + 1 < Z and (i, j, k + 1) not in visited:\n        heapq.heappush(heap, (-(A[i] + B[j] + C[k + 1]), i, j, k + 1))\n        visited.add((i, j, k + 1))\n\n# Output the results\nfor value in result:\n    print(value)"}
{"problem_id":"p02560","slow_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nINF = 10 ** 9 + 1  # sys.maxsize # float(\"inf\")\n\nMOD = 10 ** 9 + 7\n\n\n\n\n\ndef floor_sum(n, m, a, b):\n\n    ret = 0\n\n    if a >= m:\n\n        ret += (n - 1) * n * (a \/\/ m) \/\/ 2\n\n        a %= m\n\n    if b >= m:\n\n        ret += n * (b \/\/ m)\n\n        b %= m\n\n    y_max = (a * n + b) \/\/ m\n\n    x_max = y_max * m - b\n\n    if y_max == 0:\n\n        return ret\n\n    ret += (n - (x_max + a - 1) \/\/ a) * y_max\n\n    ret += floor_sum(y_max, a, m, (a - x_max % a) % a)\n\n    return ret\n\n\n\n\n\ndef debug(*x):\n\n    print(*x, file=sys.stderr)\n\n\n\n\n\ndef solve(SOLVE_PARAMS):\n\n    pass\n\n\n\n\n\ndef main():\n\n    # parse input\n\n    T = int(input())\n\n    for _t in range(T):\n\n        N, M, A, B = map(int, input().split())\n\n        print(floor_sum(N, M, A, B))\n\n\n\n\n\n# tests\n\nT1 = \"\"\"\n\n5\n\n4 10 6 3\n\n6 5 4 3\n\n1 1 0 0\n\n31415 92653 58979 32384\n\n1000000000 1000000000 999999999 999999999\n\n\"\"\"\n\nTEST_T1 = \"\"\"\n\n>>> as_input(T1)\n\n>>> main()\n\n3\n\n13\n\n0\n\n314095480\n\n499999999500000000\n\n\"\"\"\n\n\n\n\n\ndef _test():\n\n    import doctest\n\n    doctest.testmod()\n\n    g = globals()\n\n    for k in sorted(g):\n\n        if k.startswith(\"TEST_\"):\n\n            doctest.run_docstring_examples(g[k], g, name=k)\n\n\n\n\n\ndef as_input(s):\n\n    \"use in test, use given string as input file\"\n\n    import io\n\n    f = io.StringIO(s.strip())\n\n    g = globals()\n\n    g[\"input\"] = lambda: bytes(f.readline(), \"ascii\")\n\n    g[\"read\"] = lambda: bytes(f.read(), \"ascii\")\n\n\n\n\n\ninput = sys.stdin.buffer.readline\n\nread = sys.stdin.buffer.read\n\n\n\nif sys.argv[-1] == \"-t\":\n\n    print(\"testing\")\n\n    _test()\n\n    sys.exit()\n\n\n\nmain()\n","reference_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nINF = 10 ** 9 + 1  # sys.maxsize # float(\"inf\")\n\nMOD = 10 ** 9 + 7\n\n\n\n\n\ndef floor_sum_1(n, m, a, b):\n\n    ret = 0\n\n    if a >= m:\n\n        ret += (n - 1) * n * (a \/\/ m) \/\/ 2\n\n        a %= m\n\n    if b >= m:\n\n        ret += n * (b \/\/ m)\n\n        b %= m\n\n    y_max = (a * n + b) \/\/ m\n\n    x_max = y_max * m - b\n\n    if y_max == 0:\n\n        return ret\n\n    ret += (n - (x_max + a - 1) \/\/ a) * y_max\n\n    ret += floor_sum(y_max, a, m, (a - x_max % a) % a)\n\n    return ret\n\n\n\n\n\ndef floor_sum(n, m, a, b):\n\n    ret = 0\n\n    while True:\n\n        if a >= m:\n\n            ret += (n - 1) * n * (a \/\/ m) \/\/ 2\n\n            a %= m\n\n        if b >= m:\n\n            ret += n * (b \/\/ m)\n\n            b %= m\n\n        y_max = (a * n + b) \/\/ m\n\n        x_max = y_max * m - b\n\n        if y_max == 0:\n\n            return ret\n\n        ret += (n - (x_max + a - 1) \/\/ a) * y_max\n\n        n = y_max\n\n        m, a, b = a, m, (a - x_max % a) % a\n\n\n\n\n\ndef debug(*x):\n\n    print(*x, file=sys.stderr)\n\n\n\n\n\ndef solve(SOLVE_PARAMS):\n\n    pass\n\n\n\n\n\ndef main():\n\n    # parse input\n\n    T = int(input())\n\n    for _t in range(T):\n\n        N, M, A, B = map(int, input().split())\n\n        print(floor_sum(N, M, A, B))\n\n\n\n\n\n# tests\n\nT1 = \"\"\"\n\n5\n\n4 10 6 3\n\n6 5 4 3\n\n1 1 0 0\n\n31415 92653 58979 32384\n\n1000000000 1000000000 999999999 999999999\n\n\"\"\"\n\nTEST_T1 = \"\"\"\n\n>>> as_input(T1)\n\n>>> main()\n\n3\n\n13\n\n0\n\n314095480\n\n499999999500000000\n\n\"\"\"\n\n\n\n\n\ndef _test():\n\n    import doctest\n\n    doctest.testmod()\n\n    g = globals()\n\n    for k in sorted(g):\n\n        if k.startswith(\"TEST_\"):\n\n            doctest.run_docstring_examples(g[k], g, name=k)\n\n\n\n\n\ndef as_input(s):\n\n    \"use in test, use given string as input file\"\n\n    import io\n\n    f = io.StringIO(s.strip())\n\n    g = globals()\n\n    g[\"input\"] = lambda: bytes(f.readline(), \"ascii\")\n\n    g[\"read\"] = lambda: bytes(f.read(), \"ascii\")\n\n\n\n\n\ninput = sys.stdin.buffer.readline\n\nread = sys.stdin.buffer.read\n\n\n\nif sys.argv[-1] == \"-t\":\n\n    print(\"testing\")\n\n    _test()\n\n    sys.exit()\n\n\n\nmain()\n","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\n\nINF = 10 ** 9 + 1\nMOD = 10 ** 9 + 7\n\n\ndef floor_sum(n, m, a, b):\n    \"\"\"Iterative version of floor_sum.\"\"\"\n    ret = 0\n    stack = [(n, m, a, b)]  # Stack for iterative processing\n\n    while stack:\n        n, m, a, b = stack.pop()\n\n        if a >= m:\n            ret += (n - 1) * n * (a \/\/ m) \/\/ 2\n            a %= m\n        if b >= m:\n            ret += n * (b \/\/ m)\n            b %= m\n\n        y_max = (a * n + b) \/\/ m\n        if y_max == 0:\n            continue\n\n        x_max = y_max * m - b\n        ret += (n - (x_max + a - 1) \/\/ a) * y_max\n        stack.append((y_max, a, m, (a - x_max % a) % a))\n\n    return ret\n\n\ndef main():\n    # Fast input reading\n    input_data = sys.stdin.read().split()\n    T = int(input_data[0])\n    idx = 1\n\n    for _ in range(T):\n        N, M, A, B = map(int, input_data[idx:idx + 4])\n        idx += 4\n        print(floor_sum(N, M, A, B))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03060","slow_code_col":"import numpy as np\n\nn = int(eval(input()))\n\nvalue = np.array(tuple(map(int, input().split())))\n\ncost = np.array(tuple(map(int, input().split())))\n\nxy = value - cost\n\nans = 0\n\nfor i in range(n):\n\n    if xy[i] < 0:\n\n        continue\n\n    else:\n\n        ans += xy[i]\n\nprint(ans)","reference_code_col":"n = int(eval(input()))\n\nvalue = tuple(map(int, input().split()))\n\ncost = tuple(map(int, input().split()))\n\n# i\u3053\u3081\u307e\u3067\u306ex\u30fcy\u306e\u6700\u5927\u5024\n\ninf = -100\n\ndp = [inf] * (n+1)\n\ndp[1] = max(0, value[0]-cost[0])\n\nfor i in range(2, n+1):\n\n    dp[i] = max(dp[i-1], dp[i-1]+value[i-1]-cost[i-1])\n\n\n\nprint((dp[n]))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn = int(input())  # Directly parse the integer input\nvalue = np.array(list(map(int, input().split())))  # Parse value array\ncost = np.array(list(map(int, input().split())))  # Parse cost array\n\n# Compute the difference array\nxy = value - cost\n\n# Use vectorized operations to sum non-negative values\nans = np.sum(xy[xy >= 0])\n\n# Print the result\nprint(ans)"}
{"problem_id":"p02881","slow_code_col":"import math\n\nN = int(eval(input()))\n\nans = 10**12\n\nfor i in range(1,10**6+1):\n\n  j = math.ceil(N\/(i+1))\n\n  if (1+i)*j == N:\n\n    ans = min(i+j-1,ans)\n\n  if i == 10**6 and ans == 10**12:\n\n    ans = N-1\n\n    break\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nans = 10**12\n\nfor i in range(1,10**6+1):\n\n  j = N\/\/i\n\n  if i*j == N:\n\n    ans = min(i+j-2,ans)\n\n  if i == 10**6 and ans == 10**12:\n\n    ans = N-1\n\n    break\n\nprint(ans)","model_generated_potentially_faster_code_col":"import math\n\n# Read input safely\nN = int(input())\n\n# Initialize the answer with a large value\nans = float('inf')\n\n# Iterate only up to the square root of N\nfor i in range(1, int(math.sqrt(N)) + 1):\n    if N % i == 0:  # Check if i is a divisor of N\n        j = N \/\/ i  # Compute the corresponding divisor j\n        # Update the answer with the smaller value of i + j - 1\n        ans = min(ans, i + j - 1)\n\n# Output the result\nprint(ans)"}
{"problem_id":"p03434","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nvalue = list(map(int,input().split()))\n\nvalue=np.sort(value)[::-1]\n\n#print(N,value)\n\na = np.sum(value[::2])\n\nb = np.sum(value[1::2])\n\nprint((a-b))","reference_code_col":"n = int(eval(input()))\n\na = sorted(list(map(int, input().split())), reverse=True)\n\nprint((sum(a[::2]) - sum(a[1::2])))\n","model_generated_potentially_faster_code_col":"N = int(input())  # Read the number of elements\nvalue = list(map(int, input().split()))  # Read the list of integers\n\n# Sort the list in descending order\nvalue.sort(reverse=True)\n\n# Compute the sums of elements at even and odd indices in a single pass\na, b = 0, 0\nfor i in range(N):\n    if i % 2 == 0:\n        a += value[i]\n    else:\n        b += value[i]\n\n# Print the difference between the two sums\nprint(a - b)"}
{"problem_id":"p02758","slow_code_col":"mod = 998244353\n\nN = int(eval(input()))\n\nX = []\n\nfor _ in range(N):\n\n    x, d = list(map(int, input().split()))\n\n    X.append((x, x + d))\n\n\n\nX = sorted(X, key = lambda x: x[0])\n\nL = [(0, -(10**9+1), 10**9+1)]\n\nP = [-1] * (N+1)\n\nfor i, (x, y) in enumerate(X):\n\n    while L[-1][2] <= y:\n\n        if L[-1][2] > x and P[i+1] < 0:\n\n            P[i+1] = L[-1][0]\n\n        L.pop()\n\n    if P[i+1] < 0:\n\n        P[i+1] = L[-1][0]\n\n    L.append((i+1, x, y))\n\n\n\nC = [[] for _ in range(N+1)]\n\nfor i, p in enumerate(P):\n\n    if p >= 0:\n\n        C[p].append(i)\n\n\n\nY = [1] * (N+1)\n\nfor i in range(N+1)[::-1]:\n\n    s = 1\n\n    for j in C[i]:\n\n        s = s * (Y[j] + 1) % mod\n\n    Y[i] = s\n\n\n\nprint((Y[0]))","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nmod = 998244353\n\nN = int(eval(input()))\n\nX = []\n\nfor _ in range(N):\n\n    x, d = list(map(int, input().split()))\n\n    X.append((x, x + d))\n\n\n\nX = sorted(X, key = lambda x: x[0])\n\nL = [(0, -(10**9+1), 10**9+1)]\n\nP = [-1] * (N+1)\n\nfor i, (x, y) in enumerate(X):\n\n    while L[-1][2] <= y:\n\n        if L[-1][2] > x and P[i+1] < 0:\n\n            P[i+1] = L[-1][0]\n\n        L.pop()\n\n    if P[i+1] < 0:\n\n        P[i+1] = L[-1][0]\n\n    L.append((i+1, x, y))\n\n\n\nC = [[] for _ in range(N+1)]\n\nfor i, p in enumerate(P):\n\n    if p >= 0:\n\n        C[p].append(i)\n\n\n\nY = [1] * (N+1)\n\nfor i in range(N+1)[::-1]:\n\n    s = 1\n\n    for j in C[i]:\n\n        s = s * (Y[j] + 1) % mod\n\n    Y[i] = s\n\n\n\nprint((Y[0]))","model_generated_potentially_faster_code_col":"mod = 998244353\n\n# Input reading\nN = int(input())\nX = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Sort by start time\nX.sort()\n\n# Process intervals using a stack\nL = [(0, -(10**9 + 1), 10**9 + 1)]  # (index, start, end)\nP = [-1] * (N + 1)\n\nfor i, (x, y) in enumerate(X):\n    # Remove intervals from the stack that are no longer relevant\n    while L[-1][2] <= y:\n        L.pop()\n    \n    # Assign the parent index\n    P[i + 1] = L[-1][0]\n    \n    # Add the current interval to the stack\n    L.append((i + 1, x, y))\n\n# Build the tree structure\nC = {}\nfor i, p in enumerate(P):\n    if p >= 0:\n        C.setdefault(p, []).append(i)\n\n# Compute the result using dynamic programming\nY = [1] * (N + 1)\n\nfor i in range(N, -1, -1):\n    s = 1\n    if i in C:\n        for j in C[i]:\n            s = s * (Y[j] + 1) % mod\n    Y[i] = s\n\nprint(Y[0])"}
{"problem_id":"p02994","slow_code_col":"n,a=list(map(int,input().split()))\n\n\n\nl=[a+i-1 for i in range(1,n+1)]\n\n\n\nimport numpy as np\n\nb=min(np.abs(l))\n\n\n\nif b==0:\n\n  l.remove(0)\n\nelif b in l:\n\n  l.remove(b)\n\nelif -b in l:\n\n  l.remove(-b)\n\n  \n\nprint((sum(l)))","reference_code_col":"n,a=list(map(int,input().split()))\n\n\n\napples=[a+i for i in range(n)]\n\neat=min(apples,key=lambda x:abs(x))\n\nres=sum(apples)-eat\n\n\n\nprint(res)","model_generated_potentially_faster_code_col":"n, a = map(int, input().split())\n\n# Compute the sum directly without creating the full list\ntotal_sum = 0\nsmallest_abs = float('inf')\nsmallest_pos = None\nsmallest_neg = None\n\nfor i in range(1, n + 1):\n    val = a + i - 1\n    total_sum += val\n    \n    # Track the smallest absolute value\n    abs_val = abs(val)\n    if abs_val < smallest_abs:\n        smallest_abs = abs_val\n        smallest_pos = val if val > 0 else None\n        smallest_neg = val if val < 0 else None\n    elif abs_val == smallest_abs:\n        if val > 0 and smallest_pos is None:\n            smallest_pos = val\n        if val < 0 and smallest_neg is None:\n            smallest_neg = val\n\n# Adjust the sum by subtracting the smallest absolute value\nif smallest_abs == 0:\n    total_sum -= 0  # No change needed\nelif smallest_pos is not None:\n    total_sum -= smallest_pos\nelif smallest_neg is not None:\n    total_sum -= smallest_neg\n\nprint(total_sum)"}
{"problem_id":"p02767","slow_code_col":"n = int(eval(input()))\n\nx = [int(i) for i in input().split()]\n\np = 10000000\n\nfor i in range(100):\n\n    pi = 0\n\n    for j in range(n):\n\n        pi += (x[j] - (i + 1))**2\n\n    if pi < p:\n\n        p = pi\n\n    # else:\n\n    #     break\n\n        # p[i] += (x[j]-(i+1))**2\n\nprint(p)","reference_code_col":"n = int(eval(input()))\n\nx = [int(i) for i in input().split()]\n\np = 10000000\n\nfor i in range(100):\n\n    pi = 0\n\n    for j in range(n):\n\n        pi += (x[j] - (i + 1))**2\n\n    if pi < p:\n\n        p = pi\n\n    else:\n\n        break\n\n        # p[i] += (x[j]-(i+1))**2\n\nprint(p)","model_generated_potentially_faster_code_col":"n = int(eval(input()))\nx = [int(i) for i in input().split()]\np = 10000000\n\nfor i in range(100):\n    pi = 0\n    for j in range(n):\n        pi += (x[j] - (i + 1))**2\n    if pi < p:\n        p = pi"}
{"problem_id":"p03680","slow_code_col":"N=int(eval(input()))\n\n\n\n\n\na = []\n\n\n\nfor i in range(N):\n\n    a.append(int(eval(input())))\n\n# a=[0]*N\n\n# for i in range(N):\n\n#   a[i]=int(input())\n\ncount=0\n\n\n\n#loop\u306e\u5b9a\u7fa9\u2192\u540c\u3058\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u4f7f\u7528\u3057\u305f\u3089loop\u5224\u5b9a\n\n#in \u306e\u51e6\u7406\u3092\u7206\u901f\u3067\u5b9f\u884c\u3059\u308b\u305f\u3081\u306bset\u3092\u4f7f\u7528\u3059\u308b\n\n#loop=[]\n\nloop=set()\n\n\n\ntmp=1\n\nwhile True:  \n\n  tmp=a[tmp-1]\n\n  count+=1\n\n  if tmp==2:\n\n    print(count)\n\n    exit()\n\n  if tmp-1 in loop:\n\n    print((-1))\n\n    exit()\n\n  #loop.append(tmp-1)\n\n  loop.add(tmp-1)","reference_code_col":"N=int(eval(input()))\n\n#\u8907\u6570\u884c\u306e\u5165\u529b\u3092\u9ad8\u901f\u5316\n\n#a=[0]*N\n\n#for i in range(N):\n\n#  a[i]=int(input())\n\nimport sys\n\na=[int(i) for i in sys.stdin]\n\n\n\ncount=0\n\n\n\n#loop\u306e\u5b9a\u7fa9\u2192\u540c\u3058\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u4f7f\u7528\u3057\u305f\u3089loop\u5224\u5b9a\n\n#in \u306e\u51e6\u7406\u3092\u7206\u901f\u3067\u5b9f\u884c\u3059\u308b\u305f\u3081\u306bset\u3092\u4f7f\u7528\u3059\u308b\n\n#loop=[]\n\nloop=set()\n\n\n\ntmp=1\n\nwhile True:  \n\n  tmp=a[tmp-1]\n\n  count+=1\n\n  if tmp==2:\n\n    print(count)\n\n    exit()\n\n  if tmp-1 in loop:\n\n    print((-1))\n\n    exit()\n\n  #loop.append(tmp-1)\n\n  loop.add(tmp-1)","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Read all inputs at once to avoid repeated calls to `input()`\na = [int(input()) for _ in range(N)]\n\ncount = 0\n\n# Use a set for fast membership checks\nloop = set()\n\ntmp = 1\n\nwhile True:\n    tmp = a[tmp - 1]  # Access the next element in the sequence\n    count += 1\n\n    if tmp == 2:  # If we reach the target value (2), print the count and exit\n        print(count)\n        break\n\n    if tmp - 1 in loop:  # If we detect a loop, print -1 and exit\n        print(-1)\n        break\n\n    loop.add(tmp - 1)  # Mark the current index as visited"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\nn = int(eval(input()))\n\nballs = np.array(list(map(int, input().split())))\n\ntime = 0\n\nwhile np.all(balls % 2 == 0) and np.all(balls > 0):\n\n    time += 1\n\n    balls = balls \/ 2\n\nprint(time)","reference_code_col":"import math\n\nn = eval(input())\n\na = list(map(int, input().split()))\n\nans = float(\"inf\")\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind(\"1\") - 1)\n\nprint((round(ans)))","model_generated_potentially_faster_code_col":"n = int(input())  # Read the number of balls\nballs = list(map(int, input().split()))  # Read the ball values as a list\n\ntime = 0  # Initialize the time counter\n\n# Iterate until all elements are no longer even and positive\nwhile True:\n    # Check if any ball is odd or non-positive\n    if any(ball % 2 != 0 or ball <= 0 for ball in balls):\n        break\n    \n    # Increment the time counter\n    time += 1\n    \n    # Divide all balls by 2 (equivalent to right-shifting by 1)\n    balls = [ball >> 1 for ball in balls]\n\nprint(time)"}
{"problem_id":"p03608","slow_code_col":"n, m, r = list(map(int, input().split()))\n\nrs = list(map(int, input().split()))\n\n# construct map\n\nimport numpy as np\n\ndists = np.ones((n + 1, n + 1)) * float('inf')\n\nfor _ in range(m):\n\n    a, b, c = list(map(int, input().split()))\n\n    dists[a, b] = dists[b, a] = c\n\nfor i in range(1, n + 1):\n\n    dists[i, i] = 0\n\n\n\nfrom itertools import product, permutations\n\nfor i, j in product(list(range(1, 1 + n)), repeat=2):\n\n    dists[j] = np.minimum(dists[j], dists[i] + dists[j, i])\n\n\n\nans = float('inf')\n\nfor path in permutations(rs):\n\n    val = sum(dists[i, j] for i, j in zip(path, path[1:]))\n\n    val = int(val)\n\n    if val < ans:\n\n        ans = val\n\n\n\nprint(ans)","reference_code_col":"n, m, r = list(map(int, input().split()))\n\nrs = list(map(int, input().split()))\n\n# construct map\n\nimport numpy as np\n\ndists = np.ones((n + 1, n + 1)) * float('inf')\n\nfor _ in range(m):\n\n    a, b, c = list(map(int, input().split()))\n\n    dists[a, b] = dists[b, a] = c\n\nfor i in range(1, n + 1):\n\n    dists[i, i] = 0\n\n\n\nfrom itertools import permutations\n\nfor i in range(1, 1 + n):\n\n    dists = np.minimum(dists, dists[i: i + 1] + dists[:, i: i + 1])\n\n\n\nans = float('inf')\n\nfor path in permutations(rs):\n\n    val = sum(dists[i, j] for i, j in zip(path, path[1:]))\n\n    val = int(val)\n\n    if val < ans:\n\n        ans = val\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input parsing\nn, m, r = map(int, input().split())\nrs = list(map(int, input().split()))\n\n# Construct adjacency matrix\ndists = np.full((n + 1, n + 1), float('inf'))\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    dists[a, b] = dists[b, a] = min(dists[a, b], c)\n\n# Set diagonal to 0\nfor i in range(1, n + 1):\n    dists[i, i] = 0\n\n# Floyd-Warshall algorithm for all-pairs shortest paths\nfor k in range(1, n + 1):\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            dists[i, j] = min(dists[i, j], dists[i, k] + dists[k, j])\n\n# DP-based TSP solver\ndef tsp_dp(dists, rs):\n    r = len(rs)\n    dp = [[float('inf')] * (1 << r) for _ in range(r)]\n    \n    # Base case: starting at each node\n    for i in range(r):\n        dp[i][1 << i] = 0\n    \n    # Fill DP table\n    for mask in range(1 << r):\n        for i in range(r):\n            if not (mask & (1 << i)):\n                continue\n            for j in range(r):\n                if mask & (1 << j):\n                    continue\n                dp[j][mask | (1 << j)] = min(\n                    dp[j][mask | (1 << j)],\n                    dp[i][mask] + dists[rs[i]][rs[j]]\n                )\n    \n    # Find the minimum cost to visit all nodes\n    full_mask = (1 << r) - 1\n    return min(dp[i][full_mask] for i in range(r))\n\n# Solve TSP for the subset of nodes in rs\nmin_cost = tsp_dp(dists, rs)\nprint(int(min_cost))"}
{"problem_id":"p02952","slow_code_col":"N = int(eval(input()))\n\nans = 0\n\nfor i in range(1, N + 1):\n\n    if len(str(i)) % 2 == 1:\n\n        ans += 1\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nprint((len(list([x for x in range(1, N + 1) if len(str(x)) % 2 == 1]))))","model_generated_potentially_faster_code_col":"N = int(eval(input()))\n\n# Function to calculate the count of numbers with odd digit lengths\ndef count_odd_digit_numbers(N):\n    ans = 0\n    power = 1  # Start with 1-digit numbers\n    while power <= N:\n        # Count numbers with `power` digits\n        start = 10**(power - 1)\n        end = min(10**power - 1, N)\n        if power % 2 == 1:  # Only consider odd digit lengths\n            ans += max(0, end - start + 1)\n        power += 1\n    return ans\n\nprint(count_odd_digit_numbers(N))"}
{"problem_id":"p02693","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\nK = int(eval(input()))\n\nA, B = list(map(int, input().split()))\n\n\n\nfor i in range(A, B+1):\n\n    if i%K==0:\n\n        print('OK')\n\n        exit()\n\n    \n\nprint('NG')","reference_code_col":"K = int(eval(input()))\n\nA, B = list(map(int, input().split()))\n\n\n\nif (A-1)\/\/K!=B\/\/K:\n\n    print('OK')\n\nelse:\n\n    print('NG')","model_generated_potentially_faster_code_col":"import sys\n\n# Fast input reading\ninput = sys.stdin.readline\n\n# Read inputs\nK = int(input())\nA, B = map(int, input().split())\n\n# Find the smallest multiple of K >= A\nsmallest_multiple = ((A + K - 1) \/\/ K) * K\n\n# Check if this multiple is within the range [A, B]\nif smallest_multiple <= B:\n    print('OK')\nelse:\n    print('NG')"}
{"problem_id":"p03162","slow_code_col":"# coding: utf-8\n\nimport numpy as np\n\n\n\nn = int(eval(input()))\n\ndp = np.zeros((n+10, 3))\n\n\n\ndef cmax(a,b):\n\n    if a>b:\n\n        return a\n\n    else: \n\n        return b\n\n        \n\nfor i in range(1, n+1):\n\n    a, b, c = list(map(int, input().split()))\n\n    # a\n\n    dp[i][0] = cmax(dp[i-1][1]+a, dp[i-1][2]+a)\n\n    # b\n\n    dp[i][1] = cmax(dp[i-1][0]+b, dp[i-1][2]+b)\n\n    # c\n\n    dp[i][2] = cmax(dp[i-1][0]+c, dp[i-1][1]+c)\n\n\n\nprint((int(max(dp[i,:]))))","reference_code_col":"# coding: utf-8\n\n# Your code here!\n\n\n\n\n\nN = int(eval(input()))\n\n\n\ndp = [[0]*3 for _ in range(N+1)]\n\n\n\nfor i in range(1, N+1):\n\n    a, b, c = list(map(int, input().split()))\n\n    dp[i][0] = max(dp[i-1][1], dp[i-1][2]) + a\n\n    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + b\n\n    dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + c\n\n    \n\nprint((max(dp[N])))","model_generated_potentially_faster_code_col":"# coding: utf-8\n\nimport numpy as np\n\n# Input reading\nn = int(input())\n\n# Use a smaller DP array since only the last row is needed at any time\ndp_prev = np.zeros(3)\ndp_curr = np.zeros(3)\n\nfor i in range(n):\n    # Read the input values directly\n    a, b, c = map(int, input().split())\n    \n    # Compute the new DP values using the previous row\n    dp_curr[0] = max(dp_prev[1] + a, dp_prev[2] + a)  # For activity 'a'\n    dp_curr[1] = max(dp_prev[0] + b, dp_prev[2] + b)  # For activity 'b'\n    dp_curr[2] = max(dp_prev[0] + c, dp_prev[1] + c)  # For activity 'c'\n    \n    # Update the previous row for the next iteration\n    dp_prev[:] = dp_curr\n\n# Output the maximum value from the last row\nprint(int(max(dp_prev)))"}
{"problem_id":"p03060","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nVlist = np.array(list(map(int,input().split())))\n\nClist = np.array(list(map(int,input().split())))\n\n\n\nDlist = Vlist-Clist\n\n\n\nsum_ = 0\n\nfor d in Dlist:\n\n    if d >= 0:\n\n        sum_ += d\n\n\n\nprint(sum_)\n","reference_code_col":"# \u5165\u529b\n\nN = int(eval(input()))\n\nVlist = list(map(int, input().split()))\n\nClist = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor i in range(N):\n\n    Z = Vlist[i] - Clist[i]\n\n    if Z > 0:\n\n        ans += Z\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN = int(input())  # Number of elements\nVlist = np.fromstring(input(), sep=' ', dtype=int)  # Read Vlist as a NumPy array\nClist = np.fromstring(input(), sep=' ', dtype=int)  # Read Clist as a NumPy array\n\n# Compute Dlist as the difference between Vlist and Clist\nDlist = Vlist - Clist\n\n# Use boolean indexing to sum only non-negative values in Dlist\nsum_ = np.sum(Dlist[Dlist >= 0])\n\n# Print the result\nprint(sum_)"}
{"problem_id":"p02780","slow_code_col":"import numpy as np\n\nN,K=list(map(int,input().split()))\n\nP=list(map(int,input().split()))\n\nQ=[0]\n\ndef ex(A):\n\n  return (1+A)\/2.0\n\nfor i in range(N):\n\n  Q.append(ex(P[i]))\n\nQ=np.array(Q)\n\nR=Q.cumsum()\n\nans=0\n\nfor i in range(K,N+1):\n\n  S=R[i]-R[i-K]\n\n  if ans<S:\n\n    ans=S\n\nprint(ans)","reference_code_col":"#ika tako\n\nn, k = list(map(int, input().split()))\n\nppp = list(map(int, input().split()))\n\ntot = sum(ppp[:k])#\u307e\u305a\u3001\u5148\u982dK\u500b\u306e\u5408\u8a08\u3092\u6c42\u3081\u308b\n\nans = tot#\u4eee\u306e\u7b54\u3068\u3057\u3066\u304a\u304f\n\nfor i in range(k, n):#for\u6587\u30670-index\u3067k+1\u756a\u76ee\u304b\u3089\u6700\u5f8c\u307e\u3067\u30c1\u30a7\u30c3\u30af\n\n    tot += ppp[i] - ppp[i - k]#\u65b0\u3057\u304fi\u756a\u76ee\u3092\u8db3\u3057\u3066\u3001\u4e00\u756a\u53e4\u3044\u3082\u306e\u3092\u5f15\u304f\n\n    ans = max(ans, tot)#\u65b0\u3057\u3044\u7b54\u304c\u5927\u304d\u3044\u306a\u3089\u66f4\u65b0\u3059\u308b\n\nprint(((ans + k) \/ 2))#K\u500b\u5206\u306e\u30b5\u30a4\u30b3\u30ed\u306e\u671f\u5f85\u5024\u3092\u51fa\u529b\u3059\u308b","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input reading\nN, K = map(int, input().split())\nP = np.array(list(map(int, input().split())))\n\n# Vectorized computation of Q\nQ = (1 + P) \/ 2.0\n\n# Compute cumulative sum of Q\nR = np.cumsum(Q)\n\n# Handle edge case: If K == 0, return 0\nif K == 0:\n    print(0)\nelse:\n    # Sliding window sum: R[i] - R[i-K]\n    window_sum = R[K-1:] - np.concatenate(([0], R[:N-K]))\n    \n    # Find the maximum sliding window sum\n    ans = np.max(window_sum)\n    \n    print(ans)"}
{"problem_id":"p03806","slow_code_col":"n, ma, mb = list(map(int, input().split()))\n\nU = 400\n\ndp = [[[float(\"inf\")]*(U+1) for _ in range(U+1)] for i in range(n+1)]\n\ndp[0][0][0] = 0\n\nfor i in range(n):\n\n  a, b, c = list(map(int, input().split()))\n\n  for j in range(U+1):\n\n    for k in range(U+1):\n\n      if j<a or k<b:\n\n        dp[i+1][j][k] = dp[i][j][k]\n\n      else:\n\n        dp[i+1][j][k] = min(dp[i][j][k], dp[i][j-a][k-b]+c)\n\nans = float(\"inf\")\n\nfor i in range(1, 1+U\/\/max(ma, mb)):\n\n  na, nb = i*ma, i*mb\n\n  ans = min(ans, dp[-1][na][nb])\n\nif ans == float(\"inf\"):\n\n  print((-1))\n\nelse:\n\n  print(ans)","reference_code_col":"import numpy as np\n\n\n\nn, ma, mb = list(map(int, input().split()))\n\nU = 400\n\ndp = np.full((U+1, U+1), float(\"inf\"))\n\ndp[0, 0] = 0\n\nfor i in range(n):\n\n  a, b, c = list(map(int, input().split()))\n\n  np.minimum(dp[a:, b:], dp[:-a, :-b]+c, out=dp[a:, b:])\n\nans = float(\"inf\")\n\nfor i in range(1, 1+U\/\/max(ma, mb)):\n\n  na, nb = i*ma, i*mb\n\n  ans = min(ans, dp[na, nb])\n\nif ans == float(\"inf\"):\n\n  print((-1))\n\nelse:\n\n  print((int(ans)))","model_generated_potentially_faster_code_col":"# Input parsing\nn, ma, mb = map(int, input().split())\nU = 400\n\n# Initialize dp table with infinity\ndp = [[float(\"inf\")] * (U + 1) for _ in range(U + 1)]\ndp[0][0] = 0\n\n# Process each item\nfor _ in range(n):\n    a, b, c = map(int, input().split())\n\n    # Iterate backward to avoid overwriting values prematurely\n    for j in range(U, a - 1, -1):\n        for k in range(U, b - 1, -1):\n            dp[j][k] = min(dp[j][k], dp[j - a][k - b] + c)\n\n# Find the minimum cost for valid solutions\nans = float(\"inf\")\nmax_ratio = U \/\/ max(ma, mb)\n\nfor i in range(1, max_ratio + 1):\n    na, nb = i * ma, i * mb\n    if na <= U and nb <= U:\n        ans = min(ans, dp[na][nb])\n\n# Output the result\nprint(-1 if ans == float(\"inf\") else ans)"}
{"problem_id":"p02767","slow_code_col":"n,*x=list(map(int,open(0).read().split()))\n\n\n\nimport numpy as np\n\n\n\nxar=np.array(x)\n\n\n\nans=float(\"inf\")\n\nfor p in range(0,101):\n\n    tmp=sum((xar-p)**2)\n\n    ans=min(ans,tmp)\n\n    \n\nprint((int(ans)))","reference_code_col":"n,*x=list(map(int,open(0).read().split()))\n\nans=float(\"inf\")\n\nfor p in range(0,101):\n\n  s=0\n\n  for xi in x:\n\n    s+=(xi-p)**2\n\n  ans=min(ans,s)\n\nprint((int(ans)))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input\nn, *x = map(int, open(0).read().split())\n\n# Convert to NumPy array\nxar = np.array(x)\n\n# Compute the mean of the array\nmean = np.mean(xar)\n\n# Round the mean to the nearest integer within [0, 100]\noptimal_p = max(0, min(100, round(mean)))\n\n# Compute the sum of squared differences for the optimal p\nans = np.sum((xar - optimal_p) ** 2)\n\n# Print the result\nprint(int(ans))"}
{"problem_id":"p03164","slow_code_col":"import numpy as np\n\n\n\nN, W = list(map(int, input().split()))\n\nitems = []\n\nfor _ in range(N):\n\n    items.append(tuple(map(int, input().split())))\n\nv_max = sum([i[1] for i in items])\n\nINF = 10**12\n\ndp = np.array([[INF for j in range(v_max+1)] for _ in range(N+1)])\n\ndp[0, 0] = 0\n\nfor i in range(1, N+1):\n\n    w, v = items[i-1]\n\n    dp[i, :v] = dp[i-1, :v]\n\n    dp[i, v:] = np.minimum(dp[i-1, :-v] + w, dp[i-1, v:])\n\nans = 0\n\nfor v in range(v_max, -1, -1):\n\n    if dp[N][v] <= W:\n\n        ans = v\n\n        break\n\nprint(ans)","reference_code_col":"N, W = list(map(int, input().split()))\n\nitems = []\n\nINF = 10**12\n\nfor _ in range(N):\n\n    items.append(tuple(map(int, input().split())))\n\nMAX_V = sum([v for _, v in items])\n\ndp = [[INF for j in range(MAX_V+1)] for i in range(N+1)]\n\ndp[0][0] = 0\n\nfor i in range(1, N+1):\n\n    w, v = items[i-1]\n\n    for j in range(MAX_V+1):\n\n        if j - v >= 0:\n\n            dp[i][j] = min(dp[i-1][j-v] + w, dp[i-1][j])\n\n        else:\n\n            dp[i][j] = dp[i-1][j]\n\nfor v in range(MAX_V, -1, -1):\n\n    if dp[N][v] <= W:\n\n        break\n\nprint(v)","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Fast input reading\n    N, W = map(int, sys.stdin.readline().split())\n    \n    items = [tuple(map(int, sys.stdin.readline().split())) for _ in range(N)]\n    \n    # Compute the maximum possible value (sum of all item values)\n    v_max = sum(v for _, v in items)\n    \n    # Initialize a 1D DP array with INF\n    INF = 10**18\n    dp = [INF] * (v_max + 1)\n    dp[0] = 0  # Base case: 0 value requires 0 weight\n    \n    # Fill the DP array\n    for w, v in items:\n        # Update DP in reverse to avoid overwriting\n        for value in range(v_max, v - 1, -1):\n            if dp[value - v] + w < dp[value]:\n                dp[value] = dp[value - v] + w\n    \n    # Find the maximum value <= W\n    ans = 0\n    for value in range(v_max + 1):\n        if dp[value] <= W:\n            ans = value\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02850","slow_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN = int(readline())\n\nAB = [list(map(int,readline().split())) for i in range(N-1)]\n\n\n\ngraph = [[] for _ in range(N+1)] #\u96a3\u63a5\u30ea\u30b9\u30c8\n\nfor a,b in AB:\n\n    graph[a].append(b)\n\n    graph[b].append(a)\n\n\n\n#\u89aa\u306e\u30ce\u30fc\u30c9\u306b\u5b50\u3092\u5165\u308c\u3066\u304fdfs\n\nstack = [1]\n\nparent = [0]*(N+1)\n\norder = []\n\nwhile stack:\n\n    x = stack.pop()\n\n    order.append(x)\n\n    for i in graph[x]:\n\n        if i == parent[x]:\n\n            continue\n\n        parent[i] = x\n\n        stack.append(i)\n\n\n\n#\u5404\u5b50\u306e\u8272\u3092\u6c7a\u3081\u3066\u3044\u304f\u3002\n\ncolor = [-1]*(N+1)\n\nfor x in order:\n\n    ng = color[x]\n\n    c = 1\n\n    for y in graph[x]:\n\n        if parent[x] == y:\n\n            continue\n\n        if c == ng:\n\n            c += 1\n\n        color[y] = c\n\n        c += 1\n\n\n\nans = []\n\nfor a,b in AB:\n\n    if parent[a] == b: #\u5b50\u306e\u9802\u70b9\u306e\u8272\u3092\u5165\u308c\u308b\n\n        ans.append(color[a])\n\n    else:\n\n        ans.append(color[b])\n\n\n\nprint((max(ans)))\n\nfor i in ans:\n\n    print(i)\n\n        \n","reference_code_col":"import sys\n\nfrom collections import deque\n\nreadline = sys.stdin.buffer.readline\n\ndef even(n): return 1 if n%2==0 else 0\n\nn = int(readline())\n\ng = [[] for _ in range(n)] #\u96a3\u63a5\u30ea\u30b9\u30c8\n\nab = []\n\nfor i in range(n-1):\n\n    a,b = list(map(int,readline().split()))\n\n    a,b = a-1,b-1\n\n    ab.append((a,b))\n\n    g[a].append(b)\n\n    g[b].append(a)\n\n\n\nroot = 0\n\nparent = [0]*n\n\ndeq = deque([root])\n\norder = [root]\n\n\n\ncolor = [-1]*n\n\ndeq = deque([root])\n\nwhile deq:\n\n    fr = deq.pop()\n\n    ng = color[fr]\n\n    c = 0\n\n    for go in g[fr]:\n\n        if go == parent[fr]:\n\n            continue\n\n        if c == ng:\n\n            c += 1\n\n        parent[go] = fr\n\n        color[go] = c\n\n        c += 1\n\n        deq.append(go)\n\n        order.append(go)\n\nrank = [0]*n\n\nfor i,j in enumerate(order):\n\n    rank[j] = i\n\nprint((max(color)+1))\n\nfor a,b in ab:\n\n    if rank[a] < rank[b]:\n\n        print((color[b]+1))\n\n    else:\n\n        print((color[a]+1))","model_generated_potentially_faster_code_col":"import sys\nfrom collections import deque\n\n# Fast input reading\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nAB = [tuple(map(int, data[i:i+2])) for i in range(1, 2*N-1, 2)]\n\n# Build adjacency list\ngraph = [[] for _ in range(N+1)]\nfor a, b in AB:\n    graph[a].append(b)\n    graph[b].append(a)\n\n# DFS to compute parent and traversal order\nstack = deque([1])\nparent = [0] * (N+1)\norder = []\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if parent[y] == 0 and y != 1:  # Skip visited nodes and root\n            parent[y] = x\n            stack.append(y)\n\n# Assign colors to edges\ncolor = [-1] * (N+1)\nfor x in order:\n    used_color = color[x]\n    c = 1\n    for y in graph[x]:\n        if y == parent[x]:  # Skip parent\n            continue\n        if c == used_color:  # Avoid using the same color as the parent's edge\n            c += 1\n        color[y] = c\n        c += 1\n\n# Prepare answers\nans = []\nfor a, b in AB:\n    ans.append(color[a] if parent[a] == b else color[b])\n\n# Output results efficiently\noutput = [str(max(ans))] + [str(i) for i in ans]\nsys.stdout.write(\"\\n\".join(output))"}
{"problem_id":"p03013","slow_code_col":"n, m = list(map(int, input().split()))\n\na = []\n\nfor i in range(m):\n\n  a.append(int(eval(input())))\n\nans = 0\n\nflag = 0\n\na = set(a)\n\n\n\n#\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u5217\u306e\u521d\u671f\u5024\u3092\u8abf\u7bc0\n\ndp = [0] * (n+1)\n\ndp[0] = 1\n\nif 1 in a:\n\n  dp[1] = 0\n\nelse:\n\n  dp[1] = 1\n\n  \n\nfor i in range(2, n+1):\n\n  if dp[i-2] == 0 and dp[i-1] == 0:\n\n    ans = 0\n\n    flag = 1\n\n    break\n\n  elif i in a:\n\n    continue\n\n  else:\n\n    dp[i] = dp[i-1] + dp[i-2]\n\nif flag == 0:\n\n  ans = dp[n]\n\nprint((ans%(10**9+7)))","reference_code_col":"n, m = list(map(int, input().split()))\n\na = []\n\nfor i in range(m):\n\n  a.append(int(eval(input())))\n\nans = 0\n\nflag = 0\n\na = set(a)\n\n\n\n#\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u5217\u306e\u521d\u671f\u5024\u3092\u8abf\u7bc0\n\ndp = [0] * (n+1)\n\ndp[0] = 1\n\nif 1 in a:\n\n  dp[1] = 0\n\nelse:\n\n  dp[1] = 1\n\n  \n\nfor i in range(2, n+1):\n\n  if dp[i-2] == 0 and dp[i-1] == 0:\n\n    ans = 0\n\n    flag = 1\n\n    break\n\n  elif i in a:\n\n    continue\n\n  else:\n\n    dp[i] = dp[i-1] + dp[i-2]\n\n    dp[i] = dp[i] % (10**9+7)\n\nif flag == 0:\n\n  ans = dp[n]\n\nprint(ans)","model_generated_potentially_faster_code_col":"n, m = map(int, input().split())\n\n# Directly create a set of forbidden positions\nforbidden = set()\nfor _ in range(m):\n    forbidden.add(int(input()))\n\nMOD = 10**9 + 7\n\n# Initialize Fibonacci sequence variables\nprev2, prev1 = 1, 0 if 1 in forbidden else 1\n\n# Early termination flag\nflag = False\n\nfor i in range(2, n + 1):\n    if prev2 == 0 and prev1 == 0:\n        # No valid paths exist\n        ans = 0\n        flag = True\n        break\n    if i in forbidden:\n        # Skip forbidden positions\n        prev2, prev1 = prev1, 0\n    else:\n        # Calculate current Fibonacci value with modulo\n        curr = (prev1 + prev2) % MOD\n        prev2, prev1 = prev1, curr\n\nif not flag:\n    ans = prev1\n\nprint(ans)"}
{"problem_id":"p02780","slow_code_col":"import numpy as np\n\n\n\nN, K = list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\n\n\ns = np.cumsum(p)\n\n# print(p, s)\n\n\n\nm = []\n\n\n\n\n\ndef partsum(s, x):\n\n    global K\n\n    if x == K - 1:\n\n        return s[x]\n\n    return s[x] - s[x - K]\n\n\n\n\n\nfor i in range(K - 1, N):\n\n    m.append(partsum(s, i))\n\n# print(m)\n\n\n\nidx = m.index(max(m))\n\n# print(idx)\n\n\n\nans = 0\n\nfor j in range(idx, idx + K):\n\n    ans += (p[j] + 1) \/ 2\n\nprint(ans)\n","reference_code_col":"from collections import deque\n\n\n\nN, K = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\nmx = 0\n\ns = 0\n\nq = deque()\n\n\n\nfor i in range(N):\n\n    p[i] += 1\n\n\n\nfor i in range(N):\n\n    s += p[i]\n\n    q.append(p[i])\n\n    if len(q) > K:\n\n        s -= q.popleft()\n\n    if len(q) == K:\n\n        mx = max(mx, s)\n\n\n\nprint((mx \/ 2))\n\n\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input: N (number of elements), K (window size)\nN, K = map(int, input().split())\n\n# Input array p\np = np.array(list(map(int, input().split())))\n\n# Compute cumulative sum of p\ns = np.cumsum(p)\n\n# Compute sliding window sums using NumPy slicing\nsliding_sums = s[K - 1:] - np.concatenate(([0], s[:N - K]))\n\n# Find the index of the maximum sliding window sum\nidx = np.argmax(sliding_sums)\n\n# Compute the result: sum of (p[j] + 1) \/ 2 for the identified window\nans = np.sum((p[idx:idx + K] + 1) \/ 2)\n\nprint(ans)"}
{"problem_id":"p03126","slow_code_col":"import numpy as np\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nlike_total = np.zeros(M)\n\ncnt = 0\n\nfor _ in range(N):\n\n    l = [v for v in map(int, input().split())]\n\n    #print(l)\n\n    for i in range(1, l[0]+1, 1):\n\n        like_total[l[i]-1] += 1\n\n\n\n#print(like_total, N)\n\n#print(like_total[4], like_total[9], like_total[-1])\n\nans = len(np.where(like_total==N)[0])\n\n\n\nprint(ans)\n","reference_code_col":"N, M = list(map(int, input().split()))\n\n\n\nlike_total = [0]*M\n\ncnt = 0\n\nfor _ in range(N):\n\n    l = list(map(int, input().split()))\n\n    for i in range(1, l[0]+1, 1):\n\n        like_total[l[i]-1] += 1\n\n\n\nfor v in like_total:\n\n    cnt += v==N\n\nprint(cnt)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read N (number of people) and M (number of items)\nN, M = map(int, input().split())\n\n# Initialize the array to store the total likes for each item\nlike_total = np.zeros(M, dtype=int)\n\n# Process each person's preferences\nfor _ in range(N):\n    # Read the line and split into integers\n    parts = list(map(int, input().split()))\n    k = parts[0]  # Number of liked items\n    liked_items = parts[1:k + 1]  # Extract the liked item indices\n    \n    # Increment the count for each liked item\n    for item in liked_items:\n        like_total[item - 1] += 1\n\n# Count how many items are liked by all N people\nans = np.sum(like_total == N)\n\n# Output the result\nprint(ans)"}
{"problem_id":"p03200","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nstdin = sys.stdin\n\n \n\nri = lambda: int(rs())\n\nrl = lambda: list(map(int, stdin.readline().split()))\n\nrs = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\n\n\nS = list(rs())\n\nW = [0] * len(S)\n\nfor i in range(len(S)):\n\n    if S[i] == 'W':\n\n        W[i] = 1\n\nW = np.array(W[::-1])\n\nW_cum = W.cumsum()[::-1]\n\nW_cum = W_cum.tolist()\n\nanswer = 0\n\nfor i in range(len(S)):\n\n    if S[i] == 'B':\n\n        answer += W_cum[i]\n\n\n\nprint(answer)","reference_code_col":"import sys\n\nimport numpy as np\n\n\n\nstdin = sys.stdin\n\n \n\nri = lambda: int(rs())\n\nrl = lambda: list(map(int, stdin.readline().split()))\n\nrs = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\n\n\nS = list(rs())\n\ncnt_B = 0\n\nanswer = 0\n\nfor s in S:\n\n    if s == 'B':\n\n        cnt_B += 1\n\n    else:\n\n        answer += cnt_B\n\nprint(answer)\n","model_generated_potentially_faster_code_col":"import sys\n\nstdin = sys.stdin\n\n# Input parsing functions\nri = lambda: int(rs())\nrl = lambda: list(map(int, stdin.readline().split()))\nrs = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\n# Read the input string\nS = rs()\n\n# Early exit if there are no 'B's\nif 'B' not in S:\n    print(0)\n    sys.exit()\n\n# Calculate W_cum in a single pass (no reversing needed)\nW_cum = [0] * len(S)\ncount_W = 0\nfor i in range(len(S) - 1, -1, -1):\n    if S[i] == 'W':\n        count_W += 1\n    W_cum[i] = count_W\n\n# Compute the final answer\nanswer = 0\nfor i in range(len(S)):\n    if S[i] == 'B':\n        answer += W_cum[i]\n\nprint(answer)"}
{"problem_id":"p03126","slow_code_col":"import numpy as np\n\nN,M=list(map(int,input().split()))\n\nA=np.zeros((N+1,M+1))\n\nA[0]=np.ones(M+1)\n\nfor i in range(1,N+1):\n\n    B=list(map(int,input().split()))\n\n    for m in range(1,B[0]+1):\n\n        A[i][B[m]]=A[i-1][B[m]]\n\na=sum(A[N])\n\nprint((int(a)))","reference_code_col":"N,M=list(map(int,input().split()))\n\nA = [[1 for _ in range(M)]]+[[0 for _ in range(M)] for _ in range(N)]\n\nfor i in range(1,N+1):\n\n    B=list(map(int,input().split()))\n\n    Ai=B[1:]\n\n    for m in Ai:\n\n        A[i][m-1]=A[i-1][m-1]\n\na=sum(A[N])\n\nprint((int(a)))","model_generated_potentially_faster_code_col":"import numpy as np\nimport sys\n\n# Faster input reading\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# Parse N and M\nN, M = map(int, data[0].split())\n\n# Initialize matrix A\nA = np.zeros((N + 1, M + 1), dtype=int)\nA[0, :] = 1  # Set the first row to all ones\n\n# Process each row of input\nfor i in range(1, N + 1):\n    B = list(map(int, data[i].split()))\n    indices = B[1:B[0] + 1]  # Extract relevant indices from B\n    A[i, indices] = A[i - 1, indices]  # Vectorized update\n\n# Compute the sum of the last row\nresult = np.sum(A[N])\n\nprint(result)"}
{"problem_id":"p03558","slow_code_col":"from heapq import heappush, heappop\n\nk = int(eval(input()))\n\n\n\nheap = [(1,1)]\n\ndist = [float(\"inf\")]*k\n\nwhile heap:\n\n    cost, cur = heappop(heap)\n\n    if dist[cur] <= cost:\n\n        continue\n\n    dist[cur] = cost\n\n    # +1\n\n    nxt = (cur+1)%k\n\n    heappush(heap, (cost+1, nxt))\n\n    # *10\n\n    nxt = cur*10 % k\n\n    heappush(heap, (cost, nxt))\n\n\n\nprint((dist[0]))","reference_code_col":"from collections import deque\n\nk = int(eval(input()))\n\n\n\nque = deque()\n\nque.append((1,1))\n\ndist = [float(\"inf\")]*k\n\nwhile que:\n\n    cost, cur = que.popleft()\n\n    if dist[cur] <= cost:\n\n        continue\n\n    dist[cur] = cost\n\n    # +1\n\n    nxt = (cur+1)%k\n\n    que.append((cost+1,nxt))\n\n    # *10\n\n    nxt = cur*10 % k\n\n    que.appendleft((cost, nxt))\n\nprint((dist[0]))","model_generated_potentially_faster_code_col":"from heapq import heappush, heappop\n\nk = int(input())  # Directly read input as an integer\n\n# Initialize the heap and visited array\nheap = [(1, 1)]  # (cost, current)\nvisited = [False] * k  # Track visited states to avoid redundant processing\n\nwhile heap:\n    cost, cur = heappop(heap)\n\n    # Skip if this state has already been processed\n    if visited[cur]:\n        continue\n\n    # Mark this state as visited\n    visited[cur] = True\n\n    # If we reach 0 modulo k, output the cost\n    if cur == 0:\n        print(cost)\n        break\n\n    # Operation 1: Add 1 (cost increases by 1)\n    nxt_add = (cur + 1) % k\n    if not visited[nxt_add]:\n        heappush(heap, (cost + 1, nxt_add))\n\n    # Operation 2: Multiply by 10 (no cost increase)\n    nxt_mul = (cur * 10) % k\n    if not visited[nxt_mul]:\n        heappush(heap, (cost, nxt_mul))"}
{"problem_id":"p03371","slow_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nmax_iter = max(X, Y) * 2\n\nans = float(\"inf\")\n\nfor i in range(max_iter):\n\n    a = max(X - i, 0)\n\n    b = max(Y - i, 0)\n\n    price = 2*C * i + A * a + B * b\n\n    ans = min(ans, price)\n\n\n\nprint(ans)","reference_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = float(\"inf\")\n\nfor i in range(max(X, Y)+1):\n\n    x = max(X - i, 0)\n\n    y = max(Y - i, 0)\n\n    cost = 2*C * i + A * x + B * y\n\n    ans = min(ans, cost)\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Input reading\nA, B, C, X, Y = map(int, input().split())\n\n# Initialize answer with a large value\nans = float(\"inf\")\n\n# Limit the range of i to meaningful values\nfor i in range(min(X, Y) + 1):  # Only iterate up to min(X, Y)\n    a = max(X - i, 0)  # Remaining A items\n    b = max(Y - i, 0)  # Remaining B items\n    price = 2 * C * i + A * a + B * b  # Calculate total cost\n    ans = min(ans, price)  # Update the minimum cost\n\nprint(ans)"}
{"problem_id":"p02780","slow_code_col":"import numpy as np\n\nn,k=list(map(int, input().split()))\n\nexp=list([(int(x)+1)\/2 for x in input().split()]) # \u5165\u529b\u3068\u540c\u6642\u306b\u671f\u5f85\u5024\u8a08\u7b97\n\n\n\nl=np.cumsum(exp) # \u7d2f\u7a4d\u548c\u306e\u8a08\u7b97\n\n\n\nans=l[k-1]\n\nfor i in range(n-k):\n\n    ans=max(ans,l[i+k]-l[i])\n\n    \n\nprint(ans)","reference_code_col":"n,k=list(map(int, input().split()))\n\nexp=list([(int(x)+1)\/2 for x in input().split()]) # \u5165\u529b\u3068\u540c\u6642\u306b\u671f\u5f85\u5024\u8a08\u7b97\n\n\n\nl=[0]*n\n\nsum1=0\n\nfor i in range(n):# \u7d2f\u7a4d\u548c\u306e\u8a08\u7b97\n\n    sum1+=exp[i]\n\n    l[i]=sum1 \n\n\n\nans=l[k-1]\n\nfor i in range(n-k):\n\n    ans=max(ans,l[i+k]-l[i])\n\n    \n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input parsing\nn, k = map(int, input().split())\nexp = np.fromiter(((int(x) + 1) \/ 2 for x in input().split()), dtype=float)\n\n# Compute cumulative sum\nl = np.cumsum(exp)\n\n# Initialize the answer with the sum of the first window\nans = l[k - 1]\n\n# Efficiently compute the maximum sliding window sum\nfor i in range(n - k):\n    ans = max(ans, l[i + k] - l[i])\n\nprint(ans)"}
{"problem_id":"p03309","slow_code_col":"import math\n\nimport statistics\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\na = [aa-i-1 for i, aa in enumerate(a)]\n\nanswer = n*10**20\n\nmedian_low = statistics.median_low(a)\n\nmedian_high = statistics.median_high(a)\n\n\n\nfor m in (median_low,median_high):\n\n  ans=0\n\n  for aa in a:\n\n    ans += abs(aa-m)\n\n  answer = min(ans,answer)\n\nprint(answer)\n","reference_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\n\n\n\n\n\ndef solve(N: int, A: \"List[int]\"):\n\n    difA = [0]*N\n\n\n\n    for i in range(N):\n\n        difA[i] = A[i]-(i+1)\n\n\n\n    difA.sort()\n\n    if N%2 == 0:\n\n        g1 = difA[N\/\/2]\n\n        g2 = difA[N\/\/2-1]\n\n        a1 = 0\n\n        a2 = 0\n\n        for i in range(N):\n\n            a1 += abs(difA[i]-g1)\n\n            a2 += abs(difA[i]-g2)\n\n        print((min(a1,a2)))\n\n            \n\n    else:\n\n        g = difA[N\/\/2]\n\n        a = 0\n\n        for i in range(N):\n\n            a += abs(difA[i]-g)\n\n        print(a)\n\n    return\n\n\n\n\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    N = int(next(tokens))  # type: int\n\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n\n    solve(N, A)\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"n = int(input())\na = list(map(int, input().split()))\n\n# Transform the array\na = [aa - i - 1 for i, aa in enumerate(a)]\n\n# Sort the array to find the median\na.sort()\n\n# Find the median (single value)\nmedian = a[n \/\/ 2] if n % 2 == 1 else a[(n \/\/ 2) - 1]\n\n# Compute the sum of absolute differences\nanswer = sum(abs(aa - median) for aa in a)\n\nprint(answer)"}
{"problem_id":"p03170","slow_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat Apr 25 18:20:35 2020\n\n\"\"\"\n\n\n\nimport sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 9)\n\ndef input():\n\n    return sys.stdin.readline()[:-1]\n\nmod = 10**9+7\n\n\n\n#N = int(input())\n\nN, K = list(map(int,input().split()))\n\nA = np.array(list(map(int,input().split())))\n\n#N, K, *A = map(int, open(0).read().split())\n\n\n\ndp = [True for i in range(K + A[-1] + 1)]\n\nfor i in range(K):\n\n    if dp[i]:\n\n        for a in A:\n\n            dp[i + a] = False\n\n\n\n#    print(i, dp[i],A+i,dp[A+i])\n\n#print(dp)\n\n\n\nif dp[K]:\n\n    ans = 'Second'\n\nelse:\n\n    ans = 'First'\n\nprint(ans)","reference_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat Apr 25 18:20:35 2020\n\n\"\"\"\n\n\n\nimport sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 9)\n\n#def input():\n\n#    return sys.stdin.readline()[:-1]\n\nmod = 10**9+7\n\n\n\n#N = int(input())\n\nN, K = list(map(int,input().split()))\n\n#A = np.array(list(map(int,input().split())))\n\nA = list(map(int,input().split()))\n\n\n\ndp = [True for i in range(K + A[-1] + 1)]\n\nfor i in range(K):\n\n    if dp[i]:\n\n        for a in A:\n\n            dp[i + a] = False\n\n\n\n#    print(i, dp[i],A+i,dp[A+i])\n\n#print(dp)\n\n\n\nif dp[K]:\n\n    ans = 'Second'\n\nelse:\n\n    ans = 'First'\n\nprint(ans)","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nimport sys\nimport numpy as np\n\nsys.setrecursionlimit(10 ** 9)\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\nmod = 10**9+7\n\n# Read input\nN, K = map(int, input().split())\nA = np.array(list(map(int, input().split())))\n\n# Initialize dp array\ndp = np.ones(K + 1, dtype=bool)  # True means the position is a winning state for the first player\n\n# Process the dp array\nfor i in range(K + 1):\n    if dp[i]:  # If the current position is a winning state for the first player\n        # Use vectorized operations to mark all reachable positions as losing states\n        reachable = i + A\n        valid_indices = reachable[reachable <= K]  # Only consider indices within bounds\n        dp[valid_indices] = False\n\n# Determine the result\nif dp[K]:\n    ans = 'Second'\nelse:\n    ans = 'First'\n\nprint(ans)"}
{"problem_id":"p02837","slow_code_col":"def main():\n\n    from itertools import product\n\n\n\n    N = int(eval(input()))\n\n\n\n    g = []\n\n    for _ in range(N):\n\n        a = int(eval(input()))\n\n        t = []\n\n        for _ in range(a):\n\n            x, y = list(map(int, input().split()))\n\n            x -= 1\n\n            t.append((x, y))\n\n        g.append(t)\n\n\n\n    def is_ok(prd):\n\n        for j, bl in enumerate(prd):\n\n            if bl:\n\n                for x, y in g[j]:\n\n                    if prd[x] != y:\n\n                        return False\n\n        return True\n\n\n\n    ans = 0\n\n    for prd in product([0, 1], repeat=N):\n\n        *prd, = prd  # list\u5316\n\n        if is_ok(prd):\n\n            ans = max(ans, prd.count(1))\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n\n# bit\u6f14\u7b97\u3057\u3088\u3046\u3068\u3057\u3066\u306f\u307e\u3063\u305f\n","reference_code_col":"def main():\n\n    from itertools import product\n\n\n\n    N = int(eval(input()))\n\n\n\n    g = []\n\n    for _ in range(N):\n\n        a = int(eval(input()))\n\n        t = []\n\n        for _ in range(a):\n\n            x, y = list(map(int, input().split()))\n\n            t.append((x - 1, y))\n\n        g.append(t)\n\n\n\n    def is_ok(prd):\n\n        for j, bl in enumerate(prd):\n\n            if bl:\n\n                for x, y in g[j]:\n\n                    if prd[x] != y:\n\n                        return False\n\n        return True\n\n\n\n    ans = 0\n\n    for prd in product([0, 1], repeat=N):\n\n        if is_ok(prd):\n\n            ans = max(ans, prd.count(1))\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n\n# bit\u6f14\u7b97\u3057\u3088\u3046\u3068\u3057\u3066\u306f\u307e\u3063\u305f\n","model_generated_potentially_faster_code_col":"def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n\n    g = []\n    for _ in range(N):\n        a = int(data[idx])\n        idx += 1\n        t = []\n        for _ in range(a):\n            x = int(data[idx]) - 1\n            y = int(data[idx + 1])\n            idx += 2\n            t.append((x, y))\n        g.append(t)\n\n    def is_ok(prd):\n        for j in range(N):\n            if prd & (1 << j):  # Check if person j is honest\n                for x, y in g[j]:\n                    if ((prd >> x) & 1) != y:  # Check if person x matches testimony\n                        return False\n        return True\n\n    ans = 0\n    upper_limit = 1 << N  # Equivalent to 2^N\n    for prd in range(upper_limit):\n        if is_ok(prd):\n            ans = max(ans, bin(prd).count('1'))  # Count the number of 1s in binary representation\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03371","slow_code_col":"a,b,c,x,y = list(map(int,input().split()))\n\nans = a*x + b*y\n\nfor i in range(max(x,y) + 1):\n\n\tmoney = max(0,(x-i)*a) + max(0,(y-i)*b) + 2*i*c\n\n\tif money <= ans:\n\n\t\tans = money\n\nprint(ans)","reference_code_col":"a,b,c,x,y = list(map(int,input().split()))\n\nif a + b >= 2*c:\n\n\tif x >= y:\n\n\t\tans = 2*y*c + (x-y)*min(a,2*c)\n\n\telse:\n\n\t\tans = 2*x*c + (y-x)*min(b,2*c)\n\nelse:\n\n\tans = (x*a + y*b)\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Input values\na, b, c, x, y = map(int, input().split())\n\n# Initial answer\nans = a * x + b * y\n\n# Iterate only up to min(x, y) + 1\nfor i in range(min(x, y) + 1):\n    # Calculate money for the current i\n    money = max(0, (x - i) * a) + max(0, (y - i) * b) + 2 * i * c\n    \n    # Update ans if money is smaller\n    if money < ans:\n        ans = money\n    elif money > ans:\n        break  # Early exit if money starts increasing\n\n# Output the result\nprint(ans)"}
{"problem_id":"p02680","slow_code_col":"import sys\n\n# from itertools import chain, accumulate\n\n\n\nn, m, *abcdef = list(map(int, sys.stdin.buffer.read().split()))\n\n\n\nver_lines = []\n\nhor_lines = []\n\nx_list = set()\n\ny_list = set()\n\nn3 = n * 3\n\nfor a, b, c in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n\n    y_list.add(a)\n\n    y_list.add(b)\n\n    x_list.add(c)\n\n    ver_lines.append((a, b, c))\n\n\n\nfor d, e, f in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n\n    y_list.add(d)\n\n    x_list.add(e)\n\n    x_list.add(f)\n\n    hor_lines.append((d, e, f))\n\nx_list.add(0)\n\ny_list.add(0)\n\n\n\nx_list = sorted(x_list)\n\ny_list = sorted(y_list)\n\nx_dict = {x: i for i, x in enumerate(x_list, start=1)}\n\ny_dict = {y: i for i, y in enumerate(y_list, start=1)}\n\nrow_real = len(x_list)\n\ncol_real = len(y_list)\n\nrow = row_real + 2\n\ncol = col_real + 2\n\nbanned_up_ij = [[0] * row for _ in range(col)]\n\nbanned_down_ij = [[0] * row for _ in range(col)]\n\nbanned_left_ij = [[0] * col for _ in range(row)]\n\nbanned_right_ij = [[0] * col for _ in range(row)]\n\nfor a, b, c in ver_lines:\n\n    if a > b:\n\n        a, b = b, a\n\n    ai = y_dict[a]\n\n    bi = y_dict[b]\n\n    j = x_dict[c]\n\n    banned_left_ij[j][ai] += 1\n\n    banned_left_ij[j][bi] -= 1\n\n    banned_right_ij[j - 1][ai] += 1\n\n    banned_right_ij[j - 1][bi] -= 1\n\nfor d, e, f in hor_lines:\n\n    if e > f:\n\n        e, f = f, e\n\n    i = y_dict[d]\n\n    ej = x_dict[e]\n\n    fj = x_dict[f]\n\n    banned_up_ij[i][ej] += 1\n\n    banned_up_ij[i][fj] -= 1\n\n    banned_down_ij[i - 1][ej] += 1\n\n    banned_down_ij[i - 1][fj] -= 1\n\n\n\nbanned_up = [0] * (row * col)\n\nbanned_down = [0] * (row * col)\n\nbanned_left = [0] * (row * col)\n\nbanned_right = [0] * (row * col)\n\nfor i in range(col):\n\n    ru = banned_up_ij[i]\n\n    rd = banned_down_ij[i]\n\n    ri = row * i\n\n    banned_up[ri] = ru[0]\n\n    banned_down[ri] = rd[0]\n\n    for j in range(1, row):\n\n        banned_up[ri + j] = banned_up[ri + j - 1] + ru[j]\n\n        banned_down[ri + j] = banned_down[ri + j - 1] + rd[j]\n\nfor j in range(row):\n\n    rl = banned_left_ij[j]\n\n    rr = banned_right_ij[j]\n\n    banned_left[j] = rl[0]\n\n    banned_right[j] = rr[0]\n\n    for i in range(1, col):\n\n        ri0 = (i - 1) * row\n\n        ri1 = i * row\n\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\n\n\n\n# banned_up = list(chain.from_iterable(map(accumulate, banned_up_ij)))\n\n# banned_down = list(chain.from_iterable(map(accumulate, banned_down_ij)))\n\n# banned_left = list(chain.from_iterable(zip(*map(accumulate, banned_left_ij))))\n\n# banned_right = list(chain.from_iterable(zip(*map(accumulate, banned_right_ij))))\n\n\n\n# for i in range(col):\n\n#     print(walls[i * row:(i + 1) * row])\n\n\n\ns = row * y_dict[0] + x_dict[0]\n\nenable = [-1] * row + ([-1] + [0] * (row - 2) + [-1]) * (col - 2) + [-1] * row\n\n\n\n# for i in range(col):\n\n#     print(enable[i * row:(i + 1) * row])\n\n\n\nq = [s]\n\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\n\nwhile q:\n\n    c = q.pop()\n\n    if enable[c] == 1:\n\n        continue\n\n    elif enable[c] == -1:\n\n        print('INF')\n\n        exit()\n\n    enable[c] = 1\n\n    for dc, banned in moves:\n\n        if banned[c]:\n\n            continue\n\n        nc = c + dc\n\n        if enable[nc] == 1:\n\n            continue\n\n        q.append(nc)\n\n# for i in range(col):\n\n#     print(enable[i * row:(i + 1) * row])\n\n\n\n\n\nans = 0\n\nfor i in range(col):\n\n    ri = i * row\n\n    for j in range(row):\n\n        if enable[ri + j] != 1:\n\n            continue\n\n        t = y_list[i - 1]\n\n        b = y_list[i]\n\n        l = x_list[j - 1]\n\n        r = x_list[j]\n\n        ans += (b - t) * (r - l)\n\nprint(ans)\n","reference_code_col":"import sys\n\n\n\n# from itertools import chain, accumulate\n\n\n\nn, m, *abcdef = list(map(int, sys.stdin.buffer.read().split()))\n\n\n\nver_lines = []\n\nhor_lines = []\n\nx_list = set()\n\ny_list = set()\n\nn3 = n * 3\n\nfor a, b, c in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n\n    y_list.add(a)\n\n    y_list.add(b)\n\n    x_list.add(c)\n\n    ver_lines.append((a, b, c))\n\n\n\nfor d, e, f in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n\n    y_list.add(d)\n\n    x_list.add(e)\n\n    x_list.add(f)\n\n    hor_lines.append((d, e, f))\n\nx_list.add(0)\n\ny_list.add(0)\n\n\n\nx_list = sorted(x_list)\n\ny_list = sorted(y_list)\n\nx_dict = {x: i for i, x in enumerate(x_list, start=1)}\n\ny_dict = {y: i for i, y in enumerate(y_list, start=1)}\n\nrow_real = len(x_list)\n\ncol_real = len(y_list)\n\nrow = row_real + 2\n\ncol = col_real + 2\n\n\n\nbanned_up = [0] * (row * col)\n\nbanned_down = [0] * (row * col)\n\nbanned_left = [0] * (row * col)\n\nbanned_right = [0] * (row * col)\n\nfor a, b, c in ver_lines:\n\n    if a > b:\n\n        a, b = b, a\n\n    ai = y_dict[a] * row\n\n    bi = y_dict[b] * row\n\n    j = x_dict[c]\n\n    banned_left[ai + j] += 1\n\n    banned_left[bi + j] -= 1\n\n    banned_right[ai + j - 1] += 1\n\n    banned_right[bi + j - 1] -= 1\n\nfor d, e, f in hor_lines:\n\n    if e > f:\n\n        e, f = f, e\n\n    ri = y_dict[d] * row\n\n    ej = x_dict[e]\n\n    fj = x_dict[f]\n\n    banned_up[ri + ej] += 1\n\n    banned_up[ri + fj] -= 1\n\n    banned_down[ri - row + ej] += 1\n\n    banned_down[ri - row + fj] -= 1\n\n\n\nfor i in range(1, col):\n\n    ri0 = row * (i - 1)\n\n    ri1 = row * i\n\n    for j in range(1, row):\n\n        banned_up[ri1 + j] += banned_up[ri1 + j - 1]\n\n        banned_down[ri1 + j] += banned_down[ri1 + j - 1]\n\n        banned_left[ri1 + j] += banned_left[ri0 + j]\n\n        banned_right[ri1 + j] += banned_right[ri0 + j]\n\n\n\n# banned_up = list(chain.from_iterable(map(accumulate, banned_up_ij)))\n\n# banned_down = list(chain.from_iterable(map(accumulate, banned_down_ij)))\n\n# banned_left = list(chain.from_iterable(zip(*map(accumulate, banned_left_ij))))\n\n# banned_right = list(chain.from_iterable(zip(*map(accumulate, banned_right_ij))))\n\n\n\n# for i in range(col):\n\n#     print(walls[i * row:(i + 1) * row])\n\n\n\ns = row * y_dict[0] + x_dict[0]\n\nenable = [-1] * row + ([-1] + [0] * (row - 2) + [-1]) * (col - 2) + [-1] * row\n\n\n\n# for i in range(col):\n\n#     print(enable[i * row:(i + 1) * row])\n\n\n\nq = [s]\n\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\n\nwhile q:\n\n    c = q.pop()\n\n    if enable[c] == 1:\n\n        continue\n\n    elif enable[c] == -1:\n\n        print('INF')\n\n        exit()\n\n    enable[c] = 1\n\n    for dc, banned in moves:\n\n        if banned[c]:\n\n            continue\n\n        nc = c + dc\n\n        if enable[nc] == 1:\n\n            continue\n\n        q.append(nc)\n\n# for i in range(col):\n\n#     print(enable[i * row:(i + 1) * row])\n\n\n\n\n\nans = 0\n\nfor i in range(col):\n\n    ri = i * row\n\n    for j in range(row):\n\n        if enable[ri + j] != 1:\n\n            continue\n\n        t = y_list[i - 1]\n\n        b = y_list[i]\n\n        l = x_list[j - 1]\n\n        r = x_list[j]\n\n        ans += (b - t) * (r - l)\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import numpy as np\n  banned_up = np.cumsum(banned_up_ij, axis=1).flatten()"}
{"problem_id":"p02555","slow_code_col":"def main():\n\n    s = int(eval(input()))\n\n    mod = 10**9 + 7\n\n\n\n    dp = [0] * (s+1)\n\n    dp[0] = 1\n\n    for i in range(1, s+1):\n\n        for j in range(0, (i-3)+1):\n\n            dp[i] += dp[j]\n\n            dp[i] %= mod\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"def main():\n\n    s = int(eval(input()))\n\n    mod = 10**9 + 7\n\n\n\n    dp = [0] * (s+1)\n\n    dp[0] = 1\n\n#    for i in range(1, s+1):\n\n#        for j in range(0, (i-3)+1):\n\n#            dp[i] += dp[j]\n\n#            dp[i] %= mod\n\n    for i in range(1, s+1):\n\n        if i < 3:\n\n            dp[i] = 0\n\n        else:\n\n            dp[i] = dp[i-1] + dp[i-3]\n\n            dp[i] %= mod\n\n\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    s = int(input())  # Removed eval for safety and performance\n    mod = 10**9 + 7\n\n    dp = [0] * (s + 1)\n    dp[0] = 1  # Base case: There's one way to form a sum of 0 (using no numbers)\n\n    prefix_sum = 0  # Cumulative sum of valid dp[j] values\n\n    for i in range(1, s + 1):\n        if i >= 3:\n            prefix_sum += dp[i - 3]  # Add dp[i-3] to the cumulative sum\n            prefix_sum %= mod\n\n        dp[i] = prefix_sum  # Use the cumulative sum to compute dp[i]\n\n    print(dp[-1])  # Output the result\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02792","slow_code_col":"def main():\n\n    n = int(eval(input()))\n\n    import numpy as np\n\n    ans = np.zeros((10,10))\n\n    for i in range(1,n+1):\n\n        h,t = str(i)[0],str(i)[-1]\n\n        ans[int(h)-1][int(t)-1]+=1\n\n    s = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            s += ans[i][j]*ans[j][i]\n\n\n\n    print((int(s)))\n\nif __name__ == \"__main__\":\n\n    main()","reference_code_col":"def main():\n\n    n = int(eval(input()))\n\n    dp = [[0 for i in range(10)] for i in range(10)]\n\n    for i in range(1,n+1):\n\n        h,t = int(str(i)[0]), int(str(i)[-1])\n\n        dp[h][t] += 1\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += dp[i][j] * dp[j][i]\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    # Read input\n    n = int(input())\n\n    # Initialize a 10x10 matrix to store counts of (first_digit, last_digit)\n    ans = [[0] * 10 for _ in range(10)]\n\n    # Precompute powers of 10 for efficient first-digit extraction\n    powers_of_10 = [10**i for i in range(10)]\n    \n    # Count occurrences of (first_digit, last_digit) pairs\n    for i in range(1, n + 1):\n        # Extract last digit\n        last_digit = i % 10\n        \n        # Extract first digit\n        first_digit = i\n        while first_digit >= 10:\n            first_digit \/\/= 10\n        \n        # Increment the count for the pair (first_digit, last_digit)\n        ans[first_digit][last_digit] += 1\n\n    # Compute the final result\n    result = 0\n    for i in range(10):\n        for j in range(10):\n            result += ans[i][j] * ans[j][i]\n\n    # Print the result\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03078","slow_code_col":"def slove():\n\n    import sys\n\n    import heapq\n\n    import collections\n\n    input = sys.stdin.readline\n\n    x, y, z, k = list(map(int, input().rstrip('\\n').split()))\n\n    a = list(map(int, input().rstrip('\\n').split()))\n\n    a.sort(reverse=True)\n\n    b = list(map(int, input().rstrip('\\n').split()))\n\n    b.sort(reverse=True)\n\n    c = list(map(int, input().rstrip('\\n').split()))\n\n    c.sort(reverse=True)\n\n    q = [[-(a[0] + b[0] + c[0]), 0, 0, 0]]\n\n    heapq.heapify(q)\n\n    fq = collections.defaultdict(list)\n\n    fq[(-(a[0] + b[0] + c[0]), 0, 0, 0), 1] = 1\n\n    t = 0\n\n    for _ in range(k):\n\n        if len(q) != 0:\n\n            p = heapq.heappop(q)\n\n            t = p[0]\n\n            aq = p[1]\n\n            bq = p[2]\n\n            cq = p[3]\n\n            if aq + 1 < len(a):\n\n                if (-(a[aq+1] + b[bq] + c[cq]), aq+1, bq, cq) not in fq:\n\n                    heapq.heappush(q, [-(a[aq+1] + b[bq] + c[cq]), aq+1, bq, cq])\n\n                    fq[(-(a[aq+1] + b[bq] + c[cq]), aq+1, bq, cq)] = 1\n\n            if bq + 1 < len(b):\n\n                if (-(a[aq] + b[bq+1] + c[cq]), aq, bq+1, cq) not in fq:\n\n                    heapq.heappush(q, [-(a[aq] + b[bq+1] + c[cq]), aq, bq+1, cq])\n\n                    fq[(-(a[aq] + b[bq+1] + c[cq]), aq, bq+1, cq)] = 1\n\n            if cq + 1 < len(c):\n\n                if (-(a[aq] + b[bq] + c[cq+1]), aq, bq, cq+1) not in fq:\n\n                    heapq.heappush(q, [-(a[aq] + b[bq] + c[cq+1]), aq, bq, cq+1])\n\n                    fq[(-(a[aq] + b[bq] + c[cq+1]), aq, bq, cq+1)] = 1\n\n        print((-t))\n\n\n\n\n\nif __name__ == '__main__':\n\n    slove()\n","reference_code_col":"import sys\n\nimport collections\n\nimport heapq\n\n\n\n\n\ndef solve():\n\n    input = sys.stdin.readline\n\n    mod = 10 ** 9 + 7\n\n    x, y, z, k = list(map(int, input().rstrip('\\n').split()))\n\n    a = list(map(int, input().rstrip('\\n').split()))\n\n    b = list(map(int, input().rstrip('\\n').split()))\n\n    c = list(map(int, input().rstrip('\\n').split()))\n\n    a.sort(reverse=True)\n\n    b.sort(reverse=True)\n\n    c.sort(reverse=True)\n\n    ql = [[-(a[0] + b[0] + c[0]), 0, 0, 0]]\n\n    heapq.heapify(ql)\n\n    fq = collections.defaultdict(int)\n\n    fq[0, 0, 0]\n\n    for i in range(k):\n\n        s, ap, bp, cp = heapq.heappop(ql)\n\n        for app, bpp, cpp in ([[ap+1, bp, cp], [ap, bp+1, cp], [ap, bp, cp+1]]):\n\n            if app < x and bpp < y and cpp < z:\n\n                if (app, bpp, cpp) not in fq:\n\n                    heapq.heappush(ql, [-(a[app] + b[bpp] + c[cpp]), app, bpp, cpp])\n\n                    fq[app, bpp, cpp]\n\n        print((-s))\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n","model_generated_potentially_faster_code_col":"def solve():\n    import sys\n    import heapq\n\n    input = sys.stdin.readline\n\n    # Read input\n    x, y, z, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n\n    # Sort the lists in descending order\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    c.sort(reverse=True)\n\n    # Initialize the heap and visited set\n    heap = [(-(a[0] + b[0] + c[0]), 0, 0, 0)]  # Heap stores (-sum, i, j, k)\n    visited = set()\n    visited.add((0, 0, 0))  # Track visited indices as tuples (i, j, k)\n\n    # Process the heap to extract the top k sums\n    for _ in range(k):\n        if heap:\n            current_sum, i, j, l = heapq.heappop(heap)\n            print(-current_sum)  # Output the current largest sum\n\n            # Add the next possible sums to the heap\n            if i + 1 < len(a) and (i + 1, j, l) not in visited:\n                heapq.heappush(heap, (-(a[i + 1] + b[j] + c[l]), i + 1, j, l))\n                visited.add((i + 1, j, l))\n\n            if j + 1 < len(b) and (i, j + 1, l) not in visited:\n                heapq.heappush(heap, (-(a[i] + b[j + 1] + c[l]), i, j + 1, l))\n                visited.add((i, j + 1, l))\n\n            if l + 1 < len(c) and (i, j, l + 1) not in visited:\n                heapq.heappush(heap, (-(a[i] + b[j] + c[l + 1]), i, j, l + 1))\n                visited.add((i, j, l + 1))\n\n\nif __name__ == '__main__':\n    solve()"}
{"problem_id":"p00500","slow_code_col":"N = int(input())\n\nscore = [list(map(int, input().split())) for _ in range(N)]\n\nplayers = [0 for _ in range(N)]\n\nfor play in list(zip(*score)):\n\n    for i, p in enumerate(play):\n\n        if play.count(p) == 1:\n\n            players[i] += p\n\nprint(*players, sep='\\n')\n","reference_code_col":"N = int(input())\n\nscore = [input().split() for _ in range(N)]\n\nplayers = [0]*N\n\nfor play in list(zip(*score)):\n\n    for i, p in enumerate(play):\n\n        if play.count(p) == 1:\n\n            players[i] += int(p)\n\nprint(*players, sep='\\n')\n","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Read the scores into a list of lists\nscore = [list(map(int, input().split())) for _ in range(N)]\n\n# Initialize the players' scores\nplayers = [0] * N\n\n# Process each column\nfor col in zip(*score):\n    # Count occurrences of each score in the column\n    count = {}\n    for val in col:\n        count[val] = count.get(val, 0) + 1\n\n    # Update players' scores based on uniqueness\n    for i, val in enumerate(col):\n        if count[val] == 1:  # Only add if the score is unique in the column\n            players[i] += val\n\n# Print the final scores\nprint(*players, sep='\\n')"}
{"problem_id":"p03170","slow_code_col":"n,k = list(map(int,input().split()))\n\narr = list(map(int,input().split()))\n\n\n\ndp = [False]*(k+1)\n\n\n\nfor stones in range(k+1):\n\n    for x in arr:\n\n        if stones >= x and dp[stones-x] == False:\n\n            dp[stones] = True\n\n\n\nif dp[k]:\n\n    print(\"First\")\n\nelse:\n\n    print(\"Second\")\n","reference_code_col":"N,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\ndp = [False]*(K+1)\n\n\n\nfor i in range(K+1):\n\n    for j in range(N):\n\n        if i-A[j]>=0 and dp[i-A[j]] == False:\n\n            dp[i] = True\n\n\n\n        \n\nif dp[K]:\n\n    print(\"First\")\n\nelse:\n\n    print(\"Second\")","model_generated_potentially_faster_code_col":"n, k = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Sort the array to enable early termination in the inner loop\narr.sort()\n\n# Use a bitmask for dp (each bit represents a state)\ndp = 0\n\nfor stones in range(1, k + 1):\n    for x in arr:\n        if stones < x:\n            # Early termination: No need to check larger x values\n            break\n        if not (dp & (1 << (stones - x))):\n            # If dp[stones - x] is False, set dp[stones] to True\n            dp |= (1 << stones)\n            break\n\n# Check the k-th bit in the bitmask\nif dp & (1 << k):\n    print(\"First\")\nelse:\n    print(\"Second\")"}
{"problem_id":"p02780","slow_code_col":"import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    \u6587\u5b57\u5217\u3067\u4e0e\u3048\u3089\u308c\u305f\u76e4\u9762\u3092\u8aad\u307f\u53d6\u308b\u7528\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A\u5217\u3001B\u5217\u304c\u4e0e\u3048\u3089\u308c\u308b\u3088\u3046\u306a\u3068\u304d\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) \/ 2\n\n\n\n\n\n\n\n\n\nimport numpy as np\n\nP_mean = np.array([ret_mean(p) for p in P])\n\nP_accum = np.zeros(N+1)\n\nP_accum[1:] = P_mean.cumsum()\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum[j] - P_accum[i])\n\nprint(ans)\n","reference_code_col":"import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    \u6587\u5b57\u5217\u3067\u4e0e\u3048\u3089\u308c\u305f\u76e4\u9762\u3092\u8aad\u307f\u53d6\u308b\u7528\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A\u5217\u3001B\u5217\u304c\u4e0e\u3048\u3089\u308c\u308b\u3088\u3046\u306a\u3068\u304d\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) \/ 2\n\n\n\n\n\n\n\nclass cumsum1d:\n\n    def __init__(self, ls: list):\n\n        '''\n\n        1\u6b21\u5143\u30ea\u30b9\u30c8\u3092\u53d7\u3051\u53d6\u308b\n\n        '''\n\n        from itertools import accumulate\n\n        self.ls_accum = [0] + list(accumulate(ls))\n\n\n\n    def total(self, i, j):\n\n        # \u3082\u3068\u306e\u914d\u5217ls\u306b\u304a\u3051\u308b[i,j)\u306e\u4e2d\u5408\u8a08\n\n        return self.ls_accum[j] - self.ls_accum[i]\n\n      \n\nP_mean = [ret_mean(p) for p in P]\n\nP_accum = cumsum1d(P_mean)\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum.total(i,j))\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Input reading functions (unchanged)\ndef read_ints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef read_a_int():\n    return int(sys.stdin.readline())\n\nN, K = read_ints()\nP = np.array(read_ints())  # Directly read P as a NumPy array\n\n# Compute the mean values using vectorized operations\nP_mean = (P + 1) \/ 2\n\n# Compute the cumulative sum of P_mean\nP_accum = np.zeros(N + 1)\nP_accum[1:] = P_mean.cumsum()\n\n# Compute the maximum sliding window sum of size K\n# This avoids the explicit loop by slicing\nwindow_sums = P_accum[K:] - P_accum[:-K]\nans = np.max(window_sums)\n\nprint(ans)"}
{"problem_id":"p02419","slow_code_col":"W = input().lower()\n\ns = []\n\nwhile True:\n\n    T = list(map(str, input().split()))\n\n    if(T[0] == \"END_OF_TEXT\"):\n\n        break\n\n    else:\n\n        for i in range(len(T)):\n\n            s.append(T[i].lower())\n\nans = 0\n\nfor i in range(len(s)):\n\n    if(s[i] == W):\n\n        ans += 1\n\nprint(ans)","reference_code_col":"W = input().lower()\n\ns = []\n\nans = 0\n\nwhile True:\n\n    T = list(map(str, input().split()))\n\n    if(T[0] == \"END_OF_TEXT\"):\n\n        break\n\n    else:\n\n        for i in range(len(T)):\n\n            if(W == T[i].lower()):\n\n                ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"from collections import Counter\n\n# Read the target word and convert to lowercase\nW = input().lower()\n\n# Initialize an empty list to store all words\nwords = []\n\n# Process input until \"END_OF_TEXT\" is encountered\nwhile True:\n    line = input()\n    if line == \"END_OF_TEXT\":\n        break\n    # Split the line into words, convert to lowercase, and add to the list\n    words.extend(word.lower() for word in line.split())\n\n# Count occurrences of each word using Counter\nword_count = Counter(words)\n\n# Print the count of the target word\nprint(word_count[W])"}
{"problem_id":"p02702","slow_code_col":"import numpy as np\n\n\n\ns = input()[::-1]\n\nlength = len(s)\n\na = np.zeros(length, dtype=int)\n\nd = np.zeros(length, dtype=int)\n\nans = np.zeros(2019, dtype=int)\n\nx = 10\n\n\n\na[0] = int(s[0])\n\nd[0] = a[0]\n\nans[d[0]] += 1\n\n\n\nfor i in range(1, length):\n\n    a[i] = int(s[i]) * x % 2019\n\n    d[i] = (d[i-1] + a[i]) % 2019\n\n    ans[d[i]] += 1\n\n    x = x * 10 % 2019\n\n\n\nans_c = ans[np.nonzero(ans)]\n\n\n\nprint((int(sum([ans_c[i] * (ans_c[i]-1) for i in range(ans_c.shape[0])]) \/ 2) + ans[0]))","reference_code_col":"s = input()[::-1]\n\nlength = len(s)\n\na = [0] * length\n\nd = [0] * length\n\nans = [0] * 2019\n\nx = 10\n\n\n\na[0] = int(s[0])\n\nd[0] = a[0]\n\nans[d[0]] += 1\n\n\n\nfor i in range(1, length):\n\n    a[i] = int(s[i]) * x % 2019\n\n    d[i] = (d[i-1] + a[i]) % 2019\n\n    ans[d[i]] += 1\n\n    x = x * 10 % 2019\n\n\n\nprint((int(sum([ans[i] * (ans[i]-1) for i in range(2019)]) \/ 2) + ans[0]))","model_generated_potentially_faster_code_col":"powers_of_10 = [1]  # Start with 10^0 % 2019\nfor _ in range(1, length):\n    powers_of_10.append((powers_of_10[-1] * 10) % 2019)"}
{"problem_id":"p02773","slow_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\n\nS = read().split()\n\n\n\nS = sorted(S)\n\nls = [[] for i in range(N + 1)]\n\nmax_num = 0\n\nleft = 0\n\nright = 0\n\nwhile right < N:\n\n    while right < N and S[left] == S[right]:\n\n        right += 1\n\n    if (right  - left) >= max_num:\n\n        ls[right - left].append(S[left].decode())\n\n        max_num = right - left\n\n    left = right\n\n    \n\nprint(('\\n'.join(ls[max_num])))\n","reference_code_col":"from collections import Counter\n\n\n\nimport sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\n\nS = read().split()\n\n\n\nres = []\n\nc = Counter(S)\n\nmax_num = c.most_common(1)[0][1]\n\nfor i, j in list(c.items()):\n\n    if j == max_num:\n\n        res.append(i)\n\n        \n\nres.sort()\n\n\n\n        \n\nprint(('\\n'.join(list([x.decode() for x in res]))))\n","model_generated_potentially_faster_code_col":"import sys\n\n# Efficient input reading\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\n\n# Read input\nN = int(readline())\nS = read().split()\n\n# Sort the list (O(N log N))\nS.sort()\n\n# Group elements and track the maximum frequency\nmax_num = 0\nresult = []\nleft = 0\n\nwhile left < N:\n    right = left + 1\n    while right < N and S[left] == S[right]:\n        right += 1\n    \n    # Calculate the frequency of the current group\n    freq = right - left\n    \n    if freq > max_num:\n        # New maximum frequency found; reset result\n        max_num = freq\n        result = [S[left]]\n    elif freq == max_num:\n        # Add to result if frequency matches the current maximum\n        result.append(S[left])\n    \n    # Move to the next group\n    left = right\n\n# Decode and print the result\nprint('\\n'.join(s.decode() for s in result))"}
{"problem_id":"p03164","slow_code_col":"# temp\n\nn,w = list(map(int,input().split()))\n\nwv = [tuple(map(int,input().split())) for i in range(n)]\n\n\n\ndp = [0] + [float(\"inf\")]*(10**5)\n\nfor i in range(n):\n\n    for j in range(10**5,wv[i][1]-1,-1):\n\n        dp[j] = min(dp[j],dp[j-wv[i][1]]+wv[i][0])\n\n\n\nres = 0\n\nfor v,e in enumerate(dp):\n\n    if e <= w:\n\n        res = v\n\nprint(res)","reference_code_col":"# dpE - Knapsack 2\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    n, W = tuple(map(int, input().rstrip().split()))\n\n    A = tuple(tuple(map(int, input().rstrip().split())) for _ in range(n))\n\n    _, v = list(zip(*A))\n\n    lim = sum(v)\n\n    dp = [0] + [float(\"inf\")] * lim\n\n    for i in range(n):\n\n        for j in range(lim, A[i][1] - 1, -1):\n\n            dp[j] = min(dp[j], dp[j - A[i][1]] + A[i][0])\n\n    ans = max(v for v, w in enumerate(dp) if w <= W)\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()","model_generated_potentially_faster_code_col":"# Read input values\nn, w = map(int, input().split())\nwv = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate the maximum possible value\nmax_value = sum(v for _, v in wv)\n\n# Initialize DP array\ndp = [float(\"inf\")] * (max_value + 1)\ndp[0] = 0\n\n# Fill the DP table\nfor weight, value in wv:\n    for v in range(max_value, value - 1, -1):\n        dp[v] = min(dp[v], dp[v - value] + weight)\n\n# Find the maximum value such that the weight <= w\nres = 0\nfor v in range(max_value + 1):\n    if dp[v] <= w:\n        res = v\n\nprint(res)"}
{"problem_id":"p02555","slow_code_col":"def main():\n\n  n = int(eval(input()))\n\n  \n\n  dp = [0]*(n+1)\n\n  dp[0] = 1\n\n  mod = pow(10, 9) + 7\n\n  for i in range(n+1):\n\n    for j in range(i-2):\n\n      dp[i] += dp[j]\n\n      dp[i] %= mod\n\n  \n\n  print((dp[n]))\n\n\n\nif __name__ == \"__main__\":\n\n  main()","reference_code_col":"def main():\n\n  n = int(eval(input()))\n\n  \n\n  dp = [0]*(n+1)\n\n  dp[0] = 1\n\n  mod = pow(10, 9) + 7\n\n  for i in range(3, n+1):\n\n    dp[i] = dp[i-1] + dp[i-3]\n\n    dp[i] %= mod\n\n  \n\n  print((dp[n]))\n\n\n\nif __name__ == \"__main__\":\n\n  main()","model_generated_potentially_faster_code_col":"def main():\n    n = int(input())  # Removed eval for safety and efficiency\n\n    if n < 3:\n        print(1)  # Base cases: dp[0], dp[1], dp[2] are all 1\n        return\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    mod = pow(10, 9) + 7\n\n    # Initialize prefix sum\n    prefix_sum = 1  # Represents the sum of dp[j] for j < i - 2\n\n    for i in range(1, n + 1):\n        dp[i] = prefix_sum\n        if i >= 3:\n            prefix_sum += dp[i - 2]  # Add dp[i-2] to the prefix sum\n            prefix_sum %= mod  # Ensure prefix_sum stays within modulo bounds\n\n    print(dp[n])\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03253","slow_code_col":"# -*- coding: utf-8 -*-\n\n\n\n\"\"\"\n\n\u53c2\u8003\uff1ahttp:\/\/drken1215.hatenablog.com\/entry\/2018\/09\/23\/224100\n\n\u3000\u3000\u3000http:\/\/tutuz.hateblo.jp\/entry\/2018\/09\/24\/121248\n\n\u30fb\u7d20\u56e0\u6570\u5206\u89e3\u3068\u91cd\u8907\u7d44\u307f\u5408\u308f\u305b\n\n\u30fb\u6bce\u56de\u968e\u4e57\u3084\u308b\u3068\u6b7b\u306c\u304b\u3089\u968e\u4e57\u3068\u9006\u5143\u306e\u30c6\u30fc\u30d6\u30eb\u4f5c\u308b(\u5fd8\u308c\u3066\u305f)\n\n\"\"\"\n\n\n\nfrom collections import defaultdict\n\nfrom math import sqrt\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\ndef fact_prime(num):\n\n    d = defaultdict(int)\n\n    # \u7d42\u70b9\u306f\u30eb\u30fc\u30c8\u5207\u308a\u6368\u3066+1\n\n    end = int(sqrt(num)) + 1\n\n    for i in range(2, end+1):\n\n        cnt = 0\n\n        # \u7d20\u56e0\u6570\u5206\u89e3\uff1a\u5c0f\u3055\u3044\u65b9\u304b\u3089\u5272\u308c\u308b\u3060\u3051\u5272\u3063\u3066\u7d20\u6570\u3092\u30ab\u30a6\u30f3\u30c8\n\n        while num % i == 0:\n\n            num \/\/= i\n\n            d[i] += 1\n\n        # 1\u307e\u3067\u6765\u305f\u3089\u7d42\u4e86\n\n        if num == 1:\n\n            break\n\n    # \u6700\u5f8c\u307e\u3067\u305d\u306e\u307e\u307e\u6765\u305f\u3084\u3064\u306fnum\u304c\u7d20\u6570(\u305f\u3060\u30571^1\u306f1^0\u306a\u306e\u3067\u6570\u306b\u5165\u308c\u306a\u3044)\n\n    if num != 1:\n\n        d[num] += 1\n\n    return d\n\n\n\n# \u3068\u308a\u3042\u3048\u305av+N-1\u304c\u53ce\u307e\u308c\u3070\u3044\u3044\u306f\u305a\n\nMAX = 10 ** 5 * 2\n\n# \u4e88\u3081\u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\u306b\u5fc5\u8981\u306a\u968e\u4e57\u3068\u9006\u5143\u306e\u30c6\u30fc\u30d6\u30eb\u3092\u4f5c\u3063\u3066\u304a\u304f\n\nfactorial = [1] * (MAX)\n\nfactorial[0] = factorial[1] = 1\n\nfor i in range(2, MAX):\n\n    factorial[i] = factorial[i-1] * i % MOD\n\n\n\ninverse = [1] * (MAX)\n\n# pow\u306b\u7b2c\u4e09\u5f15\u6570\u5165\u308c\u308b\u3068\u51aa\u4e57\u306emod\u4ed8\u8a08\u7b97\u3092\u9ad8\u901f\u306b\u3084\u3063\u3066\u304f\u308c\u308b\n\ninverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n\nfor i in range(MAX-2, 0, -1):\n\n    # \u6700\u5f8c\u304b\u3089\u623b\u3063\u3066\u3044\u304f\u3053\u306e\u30eb\u30fc\u30d7\u306a\u3089H+W\u56depow\u3059\u308b\u3088\u308a\u51e6\u7406\u304c\u901f\u3044\n\n    inverse[i] = inverse[i+1] * (i+1) % MOD\n\n\n\n# \u7d44\u307f\u5408\u308f\u305b\u306e\u6570\n\ndef nCr(n, r):\n\n    # 10C7 = 10C3\n\n    r = min(r, n-r)\n\n    # \u5206\u5b50\u306e\u8a08\u7b97\n\n    numerator = factorial[n]\n\n    # \u5206\u6bcd\u306e\u8a08\u7b97\n\n    denominator = inverse[r] * inverse[n-r] % MOD\n\n    return numerator * denominator % MOD\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\n# d = fact_prime(M)\n\n# print(d)\n\nans = 1\n\nfor k, v in list(fact_prime(M).items()):\n\n    # \u91cd\u8907\u7d44\u307f\u5408\u308f\u305b\n\n    # v\u500b\u306ek\u3068N-1\u500b\u306e\u4ed5\u5207\u308a\u304b\u3089\u3001v\u500b\u3092\u4e26\u3079\u308b(v+N-1\u500b\u306e\u30de\u30b9\u304b\u3089v\u500b\u3092\u9078\u3073\u51fa\u3059\u7d44\u307f\u5408\u308f\u305b)\n\n    ans = (ans * nCr(v+N-1, v)) % MOD\n\nprint(ans)\n","reference_code_col":"# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x \/\/ y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nMOD = 10 ** 9 + 7\n\n\n\ndef factorize(num: int) -> dict:\n\n    \"\"\" \u7d20\u56e0\u6570\u5206\u89e3 \"\"\"\n\n    from math import sqrt\n\n    from collections import Counter\n\n\n\n    d = Counter()\n\n    # \u7d42\u70b9\u306f\u30eb\u30fc\u30c8\u5207\u308a\u6368\u3066+1\n\n    for i in range(2, int(sqrt(num))+1):\n\n        # \u7d20\u56e0\u6570\u5206\u89e3\uff1a\u5c0f\u3055\u3044\u65b9\u304b\u3089\u5272\u308c\u308b\u3060\u3051\u5272\u3063\u3066\u7d20\u6570\u3092\u30ab\u30a6\u30f3\u30c8\n\n        while num % i == 0:\n\n            num \/\/= i\n\n            d[i] += 1\n\n        # 1\u307e\u3067\u5206\u89e3\u3057\u305f\u3089\u7d42\u4e86\n\n        if num == 1:\n\n            break\n\n    # \u6700\u5f8c\u306b\u6b8b\u3063\u305fnum\u306f\u7d20\u6570(\u305f\u3060\u30571^1\u306f1^0\u306a\u306e\u3067\u6570\u306b\u5165\u308c\u306a\u3044)\n\n    if num != 1:\n\n        d[num] += 1\n\n    return d\n\n\n\nclass FactInvMOD:\n\n    \"\"\" \u968e\u4e57\u305f\u304f\u3055\u3093\u4f7f\u3046\u6642\u7528\u306e\u30c6\u30fc\u30d6\u30eb\u6e96\u5099 \"\"\"\n\n\n\n    def __init__(self, MAX, MOD):\n\n        \"\"\" MAX\uff1a\u968e\u4e57\u306b\u4f7f\u3046\u6570\u5024\u306e\u6700\u5927\u4ee5\u4e0a\u307e\u3067\u4f5c\u308b \"\"\"\n\n        \n\n        MAX += 1\n\n        self.MAX = MAX\n\n        self.MOD = MOD\n\n        # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\n\n        factorial = [1] * MAX\n\n        factorial[0] = factorial[1] = 1\n\n        for i in range(2, MAX):\n\n            factorial[i] = factorial[i-1] * i % MOD\n\n        # \u968e\u4e57\u306e\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\n        inverse = [1] * MAX\n\n        # pow\u306b\u7b2c\u4e09\u5f15\u6570\u5165\u308c\u308b\u3068\u51aa\u4e57\u306emod\u4ed8\u8a08\u7b97\u3092\u9ad8\u901f\u306b\u3084\u3063\u3066\u304f\u308c\u308b\n\n        inverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n\n        for i in range(MAX-2, 0, -1):\n\n            # \u6700\u5f8c\u304b\u3089\u623b\u3063\u3066\u3044\u304f\u3053\u306e\u30eb\u30fc\u30d7\u306a\u3089MAX\u56depow\u3059\u308b\u3088\u308a\u51e6\u7406\u304c\u901f\u3044\n\n            inverse[i] = inverse[i+1] * (i+1) % MOD\n\n        self.fact = factorial\n\n        self.inv = inverse\n\n    \n\n    def nCr(self, n, r):\n\n        \"\"\" \u7d44\u307f\u5408\u308f\u305b\u306e\u6570 (\u5fc5\u8981\u306a\u968e\u4e57\u3068\u9006\u5143\u306e\u30c6\u30fc\u30d6\u30eb\u3092\u4e8b\u524d\u306b\u4f5c\u3063\u3066\u304a\u304f) \"\"\"\n\n\n\n        if n < r: return 0\n\n        # 10C7 = 10C3\n\n        r = min(r, n-r)\n\n        # \u5206\u5b50\u306e\u8a08\u7b97\n\n        numerator = self.fact[n]\n\n        # \u5206\u6bcd\u306e\u8a08\u7b97\n\n        denominator = self.inv[r] * self.inv[n-r] % self.MOD\n\n        return numerator * denominator % self.MOD\n\n\n\n    def nPr(self, n, r):\n\n        \"\"\" \u9806\u5217 \"\"\"\n\n\n\n        if n < r: return 0\n\n        return self.fact[n] * self.inv[n-r] % self.MOD\n\n\n\n    def nHr(self, n, r):\n\n        \"\"\" \u91cd\u8907\u7d44\u307f\u5408\u308f\u305b \"\"\"\n\n\n\n        # r\u500b\u9078\u3076\u3068\u3053\u308d\u306bN-1\u500b\u306e\u4ed5\u5207\u308a\u3092\u5165\u308c\u308b\n\n        return self.nCr(r+n-1, r)\n\n\n\nN, M = MAP()\n\n\n\nd = factorize(M)\n\n\n\n# \u4f8b\u5916\u51e6\u7406\n\nif not d:\n\n    print((1))\n\n    exit()\n\n\n\nMAX = N + max(d.values())\n\nfim = FactInvMOD(MAX, MOD)\n\nans = 1\n\nfor k, v in list(d.items()):\n\n    ans *= fim.nHr(N, v)\n\n    ans %= MOD\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"from collections import defaultdict\nfrom math import sqrt\n\nMOD = 10**9 + 7\n\n# Optimized prime factorization\ndef fact_prime(num):\n    d = defaultdict(int)\n    # Handle divisibility by 2 separately\n    while num % 2 == 0:\n        num \/\/= 2\n        d[2] += 1\n    # Check odd numbers from 3 onwards\n    i = 3\n    while i * i <= num:\n        while num % i == 0:\n            num \/\/= i\n            d[i] += 1\n        i += 2\n    # If num is still greater than 1, it's a prime number\n    if num > 1:\n        d[num] += 1\n    return d\n\n# Precompute factorials and modular inverses\nMAX = 2 * 10**5 + 10  # Slightly larger to avoid edge cases\nfactorial = [1] * MAX\ninverse = [1] * MAX\n\n# Compute factorials\nfor i in range(2, MAX):\n    factorial[i] = factorial[i - 1] * i % MOD\n\n# Compute modular inverses using Fermat's Little Theorem\ninverse[MAX - 1] = pow(factorial[MAX - 1], MOD - 2, MOD)\nfor i in range(MAX - 2, 0, -1):\n    inverse[i] = inverse[i + 1] * (i + 1) % MOD\n\n# Combination calculation\ndef nCr(n, r):\n    if r > n:\n        return 0\n    r = min(r, n - r)\n    numerator = factorial[n]\n    denominator = inverse[r] * inverse[n - r] % MOD\n    return numerator * denominator % MOD\n\n# Main logic\nN, M = map(int, input().split())\nprime_factors = fact_prime(M)\nans = 1\n\n# Calculate the result using combinations\nfor k, v in prime_factors.items():\n    ans = (ans * nCr(v + N - 1, v)) % MOD\n\nprint(ans)"}
{"problem_id":"p02264","slow_code_col":"class Queue:\n\n    def __init__(self,values):\n\n        self.values = values\n\n\n\n    def empty(self):\n\n        if len(self.values) == 0:\n\n            return True\n\n        else:\n\n            return False\n\n\n\n    def enqueue(self,v):\n\n        self.values.append(v)\n\n\n\n    def dequeue(self):\n\n        if len(self.values) <= 0:\n\n            raise\n\n        else:\n\n            v = self.values[0]\n\n            del self.values[0]\n\n            return v\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nprocesses = []\n\nfor i in range(n):\n\n    n,t = input().split(' ')\n\n    processes.append((n,int(t)))\n\n\n\nqueue = Queue(processes)\n\n\n\nclock = 0\n\ndone = []\n\nwhile not queue.empty():\n\n    p = queue.dequeue()\n\n    n = p[0]\n\n    t = p[1]\n\n    if t <= q:\n\n        clock+=t\n\n        done.append((n,clock))\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        clock+=q\n\n\n\nfor p in done:\n\n    print(p[0],p[1])","reference_code_col":"class Queue:\n\n    def __init__(self,l):\n\n        self.values = []\n\n        self.l = l\n\n        for _ in range(l):\n\n            self.values.append(None)\n\n        self.head = 0\n\n        self.tail = 0\n\n    def inc(self,n):\n\n        if n+1 >= self.l:\n\n            return 0\n\n        else:\n\n            return n+1\n\n    def enqueue(self,v):\n\n        if self.inc(self.head) == self.tail:\n\n            print('overflow')\n\n            exit()\n\n        self.values[self.head] = v\n\n        self.head = self.inc(self.head)\n\n    def dequeue(self):\n\n        if self.head == self.tail:\n\n            print('underflow')\n\n            exit()\n\n        v = self.values[self.tail]\n\n        self.tail = self.inc(self.tail)\n\n        return v\n\n    def size(self):\n\n        if self.head >= self.tail:\n\n            return self.head-self.tail\n\n        else:\n\n            self.head + (self.l-self.tail)\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nqueue = Queue(200000)\n\nfor _ in range(n):\n\n    n,t = input().split(' ')\n\n    t = int(t)\n\n    queue.enqueue((n,t))\n\n\n\nc = 0\n\nwhile queue.size()>0:\n\n    n,t = queue.dequeue()\n\n    if t <= q:\n\n        c += t\n\n        print(n,c)\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        c += q","model_generated_potentially_faster_code_col":"from collections import deque\n\nclass Queue:\n    def __init__(self, values):\n        # Use a deque for efficient append and pop operations\n        self.values = deque(values)\n\n    def empty(self):\n        # Simplified check for emptiness\n        return len(self.values) == 0\n\n    def enqueue(self, v):\n        # Append to the right end of the deque\n        self.values.append(v)\n\n    def dequeue(self):\n        # Pop from the left end of the deque in O(1) time\n        if self.empty():\n            raise IndexError(\"Queue is empty\")\n        return self.values.popleft()\n\n\n# Input parsing\nn, q = map(int, input().split())\nprocesses = [input().split() for _ in range(n)]\nprocesses = [(name, int(time)) for name, time in processes]\n\n# Initialize the queue\nqueue = Queue(processes)\n\n# Simulate the process scheduling\nclock = 0\ndone = []\n\nwhile not queue.empty():\n    name, time = queue.dequeue()\n\n    if time <= q:\n        clock += time\n        done.append((name, clock))\n    else:\n        queue.enqueue((name, time - q))\n        clock += q\n\n# Output the results\nfor name, completion_time in done:\n    print(name, completion_time)"}
{"problem_id":"p03371","slow_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n# C\u3092\u8cb7\u3063\u305f\u500b\u6570\u3068A\u3001B\u5358\u54c1\u3067\u8cb7\u3063\u305f\u5834\u5408\u306e\u30b3\u30b9\u30c8\u3092\u611a\u76f4\u306b\u8a66\u3059\n\ntotal = 1<<60\n\nfor i in range(10**5+1):\n\n  cost = 2*C*i + max(X-i, 0)*A + max(Y-i, 0)*B\n\n  total = min(cost, total)\n\n\n\nprint(total)","reference_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nif (A+B) <= 2*C: # \u5358\u54c1\u3060\u3051\u3067\u8cfc\u5165\n\n  print((X*A + Y*B))\n\nelse:\n\n  # AB\u3092\u8cb7\u3044\u6b8b\u308a\u3092\u5358\u54c1\u3067\u88dc\u3046\n\n  if X >= Y:\n\n    # AB\u3067Y\u306f\u8cc4\u3048\u308b\n\n    print((min(X*2*C, Y*2*C + A*(X-Y))))\n\n  else:\n\n    # AB\u3067X\u306f\u8cc4\u3048\u308b\n\n    print((min(Y*2*C, X*(2*C)+B*(Y-X))))","model_generated_potentially_faster_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n# Binary search to find the optimal value of i\nlow, high = 0, min(X, Y)\ntotal = float('inf')\n\nwhile low <= high:\n    mid = (low + high) \/\/ 2\n\n    # Calculate cost for mid and mid+1\n    cost_mid = 2 * C * mid + max(X - mid, 0) * A + max(Y - mid, 0) * B\n    cost_mid_plus_1 = 2 * C * (mid + 1) + max(X - (mid + 1), 0) * A + max(Y - (mid + 1), 0) * B\n\n    # Update total cost\n    total = min(total, cost_mid, cost_mid_plus_1)\n\n    # Adjust the search range\n    if cost_mid_plus_1 < cost_mid:\n        low = mid + 1  # Move right to find a lower cost\n    else:\n        high = mid - 1  # Move left to find a lower cost\n\nprint(total)"}
{"problem_id":"p02983","slow_code_col":"l,r = list(map(int,input().split()))\n\n\n\nif r - l > 2019:\n\n    print((0))\n\nelse:\n\n    tres = 2019\n\n    for i in range(l,r):\n\n        for j in range(i+1,r+1):\n\n            mod = (i % 2019) * (j % 2019) % 2019\n\n            tres = min(tres,mod)\n\n    print(tres)\n","reference_code_col":"l,r = list(map(int,input().split()))\n\n\n\nif r - l > 2019:\n\n    print((0))\n\nelse:\n\n    tres = 2019\n\n    for i in range(l,r):\n\n        for j in range(i+1,r+1):\n\n            mod = (i % 2019) * (j % 2019) % 2019\n\n            tres = min(tres,mod)\n\n            if tres == 0:\n\n                break\n\n        if tres == 0:\n\n            break\n\n    print(tres)\n","model_generated_potentially_faster_code_col":"l, r = map(int, input().split())\n\nif r - l > 2019:\n    print(0)\nelse:\n    # Compute the remainders of all numbers in [l, r] modulo 2019\n    remainders = [x % 2019 for x in range(l, r + 1)]\n    \n    # Initialize the minimum product modulo 2019 to a large value\n    min_mod = 2019\n    \n    # Iterate over all pairs of remainders to find the minimum product\n    n = len(remainders)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mod = (remainders[i] * remainders[j]) % 2019\n            min_mod = min(min_mod, mod)\n            if min_mod == 0:  # Early exit if we find the minimum possible value\n                break\n        if min_mod == 0:\n            break\n    \n    print(min_mod)"}
{"problem_id":"p03086","slow_code_col":"# 2019-11-12 22:21:08(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\nimport itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# from scipy.misc import comb # float\n\n# import numpy as np \n\n\n\ndef main():\n\n    s = sys.stdin.readline().rstrip()\n\n    \n\n    all_words = []\n\n    for i in range(1, len(s) + 1):\n\n        for letters in itertools.product('ATCG', repeat=i):\n\n            word = ''.join(letters)\n\n            all_words.append(word)\n\n    \n\n    for i in range(len(all_words)-1, 0-1, -1):\n\n        if all_words[i] in s:\n\n            print((len(all_words[i])))\n\n            sys.exit()\n\n    print((0))\n\n\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"# 2019-11-12 22:21:08(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\n# import itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# from scipy.misc import comb # float\n\n# import numpy as np \n\n\n\ndef main():\n\n    s = sys.stdin.readline().rstrip()\n\n    \n\n    permitted = 'ACGT'\n\n    continuous_count = []\n\n    count = 0\n\n\n\n    for i in range(len(s)):\n\n        char = s[i]\n\n        if char in permitted:\n\n            count += 1\n\n        else:\n\n            continuous_count.append(count)\n\n            count = 0\n\n        if i == len(s) - 1:\n\n            continuous_count.append(count)\n\n    \n\n    if not continuous_count:\n\n        print((len(s)))\n\n    else:\n\n        print((max(continuous_count)))\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n\n    # Define the allowed characters\n    allowed_chars = set('ATCG')\n\n    max_length = 0\n    current_length = 0\n\n    # Traverse the string to find the longest valid substring\n    for char in s:\n        if char in allowed_chars:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 0\n\n    print(max_length)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03425","slow_code_col":"def resolve():\n\n    '''\n\n    code here\n\n    '''\n\n    import collections\n\n    import itertools\n\n    import numpy as np\n\n    N = int(eval(input()))\n\n    Ss = [input()[0] for _ in range(N)]\n\n\n\n    march_letter = [item for item in Ss if item in ['M', 'A', 'R', 'C', 'H']]\n\n    march_cnt = collections.Counter(march_letter)\n\n\n\n    if len(march_cnt) < 3:\n\n        res = 0\n\n    else:\n\n        res_list = itertools.combinations(list(march_cnt.values()),3)\n\n\n\n        res = 0\n\n        for element in res_list:\n\n            res += np.prod(np.array(element))\n\n    print(res)\n\n\n\nif __name__ == \"__main__\":\n\n    resolve()\n","reference_code_col":"def resolve():\n\n    '''\n\n    code here\n\n    '''\n\n    import collections\n\n    import itertools\n\n    N = int(eval(input()))\n\n    Ss = [input()[0] for _ in range(N)]\n\n\n\n    march_letter = [item for item in Ss if item in ['M', 'A', 'R', 'C', 'H']]\n\n    march_cnt = collections.Counter(march_letter)\n\n\n\n    if len(march_cnt) < 3:\n\n        res = 0\n\n    else:\n\n        res_list = itertools.combinations(list(march_cnt.values()),3)\n\n\n\n        res = 0\n\n        for element in res_list:\n\n            res += element[0]*element[1]*element[2]\n\n    print(res)\n\n\n\nif __name__ == \"__main__\":\n\n    resolve()\n","model_generated_potentially_faster_code_col":"from collections import Counter\nfrom math import prod\n\ndef resolve():\n    # Read input\n    N = int(input())\n    Ss = [input()[0] for _ in range(N)]\n\n    # Filter and count relevant letters\n    march_letter = [c for c in Ss if c in {'M', 'A', 'R', 'C', 'H'}]\n    march_cnt = Counter(march_letter)\n\n    # Extract counts of valid letters\n    counts = list(march_cnt.values())\n\n    # If there are fewer than 3 distinct letters, the result is 0\n    if len(counts) < 3:\n        print(0)\n        return\n\n    # Calculate the sum of products of all combinations of 3 counts\n    result = 0\n    n = len(counts)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                result += counts[i] * counts[j] * counts[k]\n\n    print(result)\n\nif __name__ == \"__main__\":\n    resolve()"}
{"problem_id":"p03309","slow_code_col":"#                         author:  kagemeka \n\n#                         created: 2019-11-08 14:51:29(JST)\n\n## internal modules\n\nimport sys\n\n# import collections\n\n# import math\n\n# import string\n\n# import bisect\n\n# import re\n\n# import itertools\n\nimport statistics\n\n# import functools\n\n# import operator\n\n## external modules\n\n# import scipy.special   # if use comb function on AtCoder, \n\n# import scipy.misc      # select scipy.misc.comb (old version) \n\n\n\ndef main():\n\n    n, *a = (int(x) for x in sys.stdin.read().split())\n\n    \n\n    for i in range(n):\n\n        a[i] -= (i + 1)\n\n\n\n    if n % 2 != 0:\n\n        b = statistics.median(a)\n\n    else:\n\n        if a.count(statistics.median_high(a)) >= a.count(statistics.median_low(a)):\n\n            b = statistics.median_high(a)\n\n        else:\n\n            b = statistics.median_low(a)\n\n    \n\n    ans = sum([abs(a[i] - b) for i in range(n)])\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    # execute only if run as a script\n\n    main()\n\n\n\n\n","reference_code_col":"import sys\n\n\n\nn, *a = list(map(int, sys.stdin.read().split()))\n\n\n\ndef main():\n\n    for i in range(n):\n\n        a[i] -= (i + 1)\n\n    a.sort()\n\n    b = a[n \/\/ 2]\n\n    res = 0\n\n    for i in range(n):\n\n        res += abs(a[i] - b)\n\n    \n\n    return res\n\n    \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Read input\n    n, *a = (int(x) for x in sys.stdin.read().split())\n\n    # Adjust array values\n    for i in range(n):\n        a[i] -= (i + 1)\n\n    # Sort the array to compute medians efficiently\n    a_sorted = sorted(a)\n    mid = n \/\/ 2\n\n    if n % 2 != 0:\n        # Odd case: median is the middle element\n        b = a_sorted[mid]\n    else:\n        # Even case: choose between median_low and median_high\n        median_low = a_sorted[mid - 1]\n        median_high = a_sorted[mid]\n\n        # Count occurrences of median_low and median_high\n        count_low = sum(1 for x in a if x == median_low)\n        count_high = sum(1 for x in a if x == median_high)\n\n        b = median_high if count_high >= count_low else median_low\n\n    # Compute the result using a generator expression\n    ans = sum(abs(x - b) for x in a)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03416","slow_code_col":"def findSumDigit(num):\n\n    global total\n\n    total = \"\"\n\n    while num > 0:\n\n        total += str(num % 10)\n\n        num \/\/= 10\n\n    return total\n\n\n\ndef main():\n\n    a,b = list(map(int, input().split()))\n\n    ans = 0\n\n    for i in range(a,b+1):\n\n        tmp = str(findSumDigit(i))\n\n        if tmp == str(i):\n\n            ans += 1\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()","reference_code_col":"a, b = list(map(int, input().split()))\n\nans = 0\n\n\n\nfor i in range(a,b+1):\n\n    seki_gyaku = str(i)\n\n    if seki_gyaku == seki_gyaku[::-1]:\n\n        ans += 1\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"def is_palindromic_number(num):\n    # Check if the number is equal to the reverse of its digits\n    original = num\n    reversed_num = 0\n    \n    while num > 0:\n        reversed_num = reversed_num * 10 + (num % 10)\n        num \/\/= 10\n    \n    return original == reversed_num\n\n\ndef main():\n    a, b = map(int, input().split())\n    ans = 0\n\n    for i in range(a, b + 1):\n        if is_palindromic_number(i):\n            ans += 1\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03680","slow_code_col":"N = int(eval(input()))\n\na = [int(eval(input())) for i in range(N)]\n\nnow = a[0]\n\ncount = 1\n\nc = 0\n\nfor i in range(10**6):\n\n    if now != 2:\n\n        count += 1\n\n        now = a[now - 1]\n\n    else:\n\n        print(count)\n\n        c = 1\n\n        break\n\nif c == 0:\n\n    print((-1))\n","reference_code_col":"N = int(eval(input()))\n\na = [0] + [int(eval(input())) for _ in range(N)]\n\nx = 1\n\nvisited = set([1])\n\nanswer = 0\n\n\n\nwhile True:\n\n  x = a[x]\n\n  if x in visited:\n\n    answer = -1\n\n    break\n\n  visited.add(x)\n\n  answer += 1\n\n  if x == 2:\n\n    break\n\n    \n\nprint(answer)\n","model_generated_potentially_faster_code_col":"# Read input values\nN = int(input())\na = [int(input()) for _ in range(N)]\n\n# Initialize variables\nnow = a[0]\ncount = 1\nvisited = set()  # To track visited indices\n\nwhile count <= 10**6:  # Limit iterations to 10^6\n    if now == 2:\n        print(count)\n        break\n    if now in visited:  # Detect cycle\n        print(-1)\n        break\n    visited.add(now)  # Mark current index as visited\n    now = a[now - 1]  # Move to the next index\n    count += 1\nelse:\n    # If loop completes without finding `now == 2`\n    print(-1)"}
{"problem_id":"p02386","slow_code_col":"n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in([0,1,2,3,4,5],[1,5,2,0,4,3],[2,1,5,3,0,4],[3,0,2,5,4,1],[4,1,0,3,5,2],[5,1,4,3,2,0]):\n\n    f=[d[k]for k in p]\n\n    if f[0]==e[0]and f[5]==e[5]:\n\n     f=f[1:5]*2\n\n     for k in range(4):\n\n      if f[k:k+4]==e[1:5]:return'No'\n\n return'Yes'\n\nprint((f()))\n","reference_code_col":"n=int(eval(input()))\n\na=[[int(s)for s in input().split()]for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in([0,1,2,3,4,5],[1,5,2,0,4,3],[2,1,5,3,0,4],[3,0,2,5,4,1],[4,1,0,3,5,2],[5,1,4,3,2,0]):\n\n    f=[d[k]for k in p]\n\n    if f[0]==e[0]and f[5]==e[5]:\n\n     f=f[1:5]*2\n\n     for k in range(4):\n\n      if f[k:k+4]==e[1:5]:return'No'\n\n return'Yes'\n\nprint((f()))\n","model_generated_potentially_faster_code_col":"n = int(input())\n\n# Read the input efficiently\na = [list(map(int, input().split())) for _ in range(n)]\n\ndef f():\n    # Precompute all possible transformations for reuse\n    transformations = [\n        [0, 1, 2, 3, 4, 5],\n        [1, 5, 2, 0, 4, 3],\n        [2, 1, 5, 3, 0, 4],\n        [3, 0, 2, 5, 4, 1],\n        [4, 1, 0, 3, 5, 2],\n        [5, 1, 4, 3, 2, 0]\n    ]\n\n    # Iterate over all pairs of rows (i, j)\n    for i in range(n - 1):\n        d = a[i][:]\n        d[3], d[4] = d[4], d[3]  # Swap indices 3 and 4\n\n        for j in range(i + 1, n):\n            e = a[j][:]\n            e[3], e[4] = e[4], e[3]  # Swap indices 3 and 4\n\n            # Check all transformations\n            for p in transformations:\n                f_transformed = [d[k] for k in p]\n\n                # Early exit if the first and last elements don't match\n                if f_transformed[0] != e[0] or f_transformed[5] != e[5]:\n                    continue\n\n                # Compare the middle four elements in a circular manner\n                f_middle = f_transformed[1:5] * 2  # Duplicate for circular comparison\n                e_middle = e[1:5]\n\n                for k in range(4):\n                    if f_middle[k:k + 4] == e_middle:\n                        return 'No'\n\n    return 'Yes'\n\nprint(f())"}
{"problem_id":"p03568","slow_code_col":"import numpy as np\n\nfrom itertools import product\n\n\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\n\n\na = np.array(a)\n\n\n\nli = [-1,0,1]\n\ncnt = 0\n\nfor v in product(li,repeat = n):\n\n    v = np.array(v)\n\n    L =a+v\n\n    cum = L.cumprod()\n\n    if cum[-1]%2 ==0 :\n\n        cnt +=1\n\nprint(cnt)\n\n        ","reference_code_col":"n = int(eval(input()))\n\na = list(map(int,input().split()))\n\n\n\nfrom itertools import product\n\n\n\nli = [-1,0,1]\n\ncnt = 0\n\nfor v in product(li,repeat = n):\n\n    L = []\n\n    for i in range(n):\n\n        L.append(v[i]+a[i])\n\n    if any(x%2==0 for x in L):\n\n        cnt +=1\n\n\n\nprint(cnt)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input reading\nn = int(input())\na = np.array(list(map(int, input().split())))\n\n# Define the range of values for v\nli = [-1, 0, 1]\n\n# Precompute the parity (even\/odd) of each element in 'a'\na_parity = a % 2\n\n# Count the number of valid combinations\ncnt = 0\n\n# Iterate over all possible combinations of v\nfor v in np.array(np.meshgrid(*[li] * n)).T.reshape(-1, n):\n    # Compute the parity of a + v\n    L_parity = (a_parity + v) % 2\n    \n    # Check if there is at least one even number in L\n    if np.any(L_parity == 0):\n        cnt += 1\n\nprint(cnt)"}
{"problem_id":"p02952","slow_code_col":"N = int(eval(input()))\n\n\n\ncount = 0\n\nfor i in range(1, N + 1):\n\n    num_dig = 0\n\n    ii = i\n\n    while ii > 0:\n\n        ii = int(ii \/ 10)\n\n        num_dig += 1\n\n    if num_dig % 2 != 0:\n\n        count += 1\n\n\n\nprint(count)","reference_code_col":"N = int(eval(input()))\n\n\n\ncount = 0\n\nfor i in range(1, N + 1):\n\n    if len(str(i)) % 2 != 0:\n\n        count += 1\n\nprint(count)","model_generated_potentially_faster_code_col":"import math\n\n# Input N\nN = int(eval(input()))\n\n# Initialize count\ncount = 0\n\n# Determine the maximum number of digits in N\nmax_digits = int(math.log10(N)) + 1 if N > 0 else 1\n\n# Iterate over all possible odd digit counts\nfor digits in range(1, max_digits + 1, 2):\n    # Calculate the range for this digit count\n    lower_bound = 10**(digits - 1)\n    upper_bound = min(N, 10**digits - 1)\n    \n    # Add the count of numbers in this range\n    if lower_bound <= upper_bound:\n        count += (upper_bound - lower_bound + 1)\n\n# Output the result\nprint(count)"}
{"problem_id":"p03634","slow_code_col":"#!usr\/bin\/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\n\"\"\"\n\ndef gcd(a,b):\n\n    if a == 0:\n\n        return b\n\n    return gcd(b%a,a)\n\nn = I()\n\na = IR(n)\n\nl = a[0]\n\nfor i in range(1,n):\n\n    g = gcd(l,a[i])\n\n    l *= a[i]\/\/g\n\nprint(l)\n\n\"\"\"\n\n\n\n#B\n\nn = I()\n\nv = [[] for i in range(n)]\n\nfor i in range(n-1):\n\n    a,b,c = LI()\n\n    a -= 1\n\n    b -= 1\n\n    v[a].append([b,c])\n\n    v[b].append([a,c])\n\nQ,k = LI()\n\nd = [-1 for i in range(n)]\n\nd[k-1] = 0\n\nq = deque()\n\nq.append(k-1)\n\nwhile q:\n\n    x = q.pop()\n\n    for y,c in v[x]:\n\n        if d[y] == -1:\n\n            d[y] = d[x]+c\n\n            q.append(y)\n\nfor i in range(Q):\n\n    x,y = LI()\n\n    x -= 1\n\n    y -= 1\n\n    print((d[x]+d[y]))\n\n#C\n\n\n\n#D\n\n\n\n#E\n\n\n\n#F\n\n\n\n#G\n\n\n\n#H\n\n\n\n#I\n\n\n\n#J\n\n\n\n#K\n\n\n\n#L\n\n\n\n#M\n\n\n\n#N\n\n\n\n#O\n\n\n\n#P\n\n\n\n#Q\n\n\n\n#R\n\n\n\n#S\n\n\n\n#T\n","reference_code_col":"#!usr\/bin\/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\n\"\"\"\n\ndef gcd(a,b):\n\n    if a == 0:\n\n        return b\n\n    return gcd(b%a,a)\n\nn = I()\n\na = IR(n)\n\nl = a[0]\n\nfor i in range(1,n):\n\n    g = gcd(l,a[i])\n\n    l *= a[i]\/\/g\n\nprint(l)\n\n\"\"\"\n\n\n\n#B\n\nn = I()\n\nv = [[] for i in range(n)]\n\nfor i in range(n-1):\n\n    a,b,c = LI()\n\n    a -= 1\n\n    b -= 1\n\n    v[a].append([b,c])\n\n    v[b].append([a,c])\n\nQ,k = LI()\n\nd = [-1 for i in range(n)]\n\nd[k-1] = 0\n\nq = deque()\n\nq.append(k-1)\n\nwhile q:\n\n    x = q.popleft()\n\n    for y,c in v[x]:\n\n        if d[y] == -1:\n\n            d[y] = d[x]+c\n\n            q.append(y)\n\nfor i in range(Q):\n\n    x,y = LI()\n\n    x -= 1\n\n    y -= 1\n\n    print((d[x]+d[y]))\n\n#C\n\n\n\n#D\n\n\n\n#E\n\n\n\n#F\n\n\n\n#G\n\n\n\n#H\n\n\n\n#I\n\n\n\n#J\n\n\n\n#K\n\n\n\n#L\n\n\n\n#M\n\n\n\n#N\n\n\n\n#O\n\n\n\n#P\n\n\n\n#Q\n\n\n\n#R\n\n\n\n#S\n\n\n\n#T\n","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\nfrom collections import deque\n\n# Fast input parsing\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\n\n# Read all input at once\ninput_data = sys.stdin.read().splitlines()\ninput_iter = iter(input_data)\n\ndef fast_I():\n    return int(next(input_iter))\n\ndef fast_LI():\n    return list(map(int, next(input_iter).split()))\n\n# Main logic\nn = fast_I()\nv = [[] for _ in range(n)]\n\n# Build adjacency list\nfor _ in range(n - 1):\n    a, b, c = fast_LI()\n    a -= 1\n    b -= 1\n    v[a].append((b, c))\n    v[b].append((a, c))\n\nQ, k = fast_LI()\nk -= 1\n\n# BFS to compute distances from node k\nd = [-1] * n\nd[k] = 0\nq = deque([k])\n\nwhile q:\n    x = q.popleft()\n    for y, c in v[x]:\n        if d[y] == -1:\n            d[y] = d[x] + c\n            q.append(y)\n\n# Process queries\nfor _ in range(Q):\n    x, y = fast_LI()\n    x -= 1\n    y -= 1\n    print(d[x] + d[y])"}
{"problem_id":"p02837","slow_code_col":"from itertools import product\n\nN=int(eval(input()))\n\ndata=[]\n\nfor i in range(N):\n\n    for j in range(int(eval(input()))):\n\n        x,y=list(map(int,input().split()))\n\n        data.append((i,x-1,y))\n\n#print(data)\n\n\n\nans=0\n\nfor i in product([1,0],repeat=N):\n\n    #print(i)\n\n    s=True\n\n    for k in data:\n\n        if i[k[0]]==1 and i[k[1]]!=k[2]:\n\n            s=False\n\n            break\n\n    if s:\n\n        ans=max(ans,sum(i))\n\nprint(ans)\n","reference_code_col":"from itertools import product\n\n\n\nN=int(eval(input()))\n\ndata=[]\n\nfor i in range(N):\n\n    for j in range(int(eval(input()))):\n\n        x,y=list(map(int,input().split()))\n\n        data.append((i,x-1,y)) #i\u3055\u3093\u304cx-1\u3055\u3093\u306b\u5618(0)or\u6b63\u76f4(1)\n\n\n\n\n\nans=0\n\nfor i in product([0,1],repeat=N):\n\n    ok=True\n\n    for j in data:\n\n        if i[j[0]]==1 and i[j[1]]!=j[2]:\n\n            ok = False\n\n            break\n\n    if ok:\n\n        ans=max(ans,sum(i))\n\nprint(ans)","model_generated_potentially_faster_code_col":"from collections import defaultdict, deque\n\ndef main():\n    N = int(input())\n    constraints = defaultdict(list)\n    indegree = [0] * N\n\n    # Read input and build the graph\n    for i in range(N):\n        M = int(input())\n        for _ in range(M):\n            x, y = map(int, input().split())\n            x -= 1  # Convert to 0-based indexing\n            constraints[i].append((x, y))\n            indegree[x] += 1\n\n    # Topological sorting using Kahn's algorithm\n    queue = deque()\n    for i in range(N):\n        if indegree[i] == 0:\n            queue.append(i)\n\n    topo_order = []\n    while queue:\n        node = queue.popleft()\n        topo_order.append(node)\n        for neighbor, _ in constraints[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n\n    # If there's a cycle, it's impossible to satisfy all constraints\n    if len(topo_order) != N:\n        print(-1)\n        return\n\n    # Dynamic programming to maximize the number of 1s\n    dp = [[-1, -1] for _ in range(N)]  # dp[i][0] = max count if node i is 0, dp[i][1] = max count if node i is 1\n\n    for node in topo_order:\n        # Initialize dp for the current node\n        dp[node][0] = 0\n        dp[node][1] = 1\n\n        for neighbor, value in constraints[node]:\n            if value == 0:\n                # If node is 1, neighbor must be 0\n                dp[node][1] = max(dp[node][1], 1 + dp[neighbor][0])\n                dp[node][0] = max(dp[node][0], dp[neighbor][0])\n            else:\n                # If node is 1, neighbor must be 1\n                dp[node][1] = max(dp[node][1], 1 + dp[neighbor][1])\n                dp[node][0] = max(dp[node][0], dp[neighbor][1])\n\n    # The answer is the maximum of dp values for the root nodes\n    ans = max(max(dp[i]) for i in range(N))\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03013","slow_code_col":"mod = 10**9+7\n\nn, m = list(map(int, input().split()))\n\nl = [0]*n\n\nfor _ in range(m):\n\n  l[int(eval(input()))-1] = 1\n\n\n\ns = 0\n\nt = 1\n\n\n\nfor i in range(n):\n\n  if l[i] > 0:\n\n    t, s = 0, t\n\n  else:\n\n    t, s = (s+t)%mod, t\n\n\n\nprint(t)","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nmod = 10**9+7\n\nn, m = list(map(int, input().split()))\n\nl = [0]*n\n\nfor _ in range(m):\n\n  l[int(eval(input()))-1] = 1\n\n\n\nt, s = 1, 0\n\n\n\nfor i in range(n):\n\n  if l[i]:\n\n    t, s = 0, t\n\n  else:\n\n    t, s = (s+t)%mod, t\n\n\n\nprint(t)","model_generated_potentially_faster_code_col":"mod = 10**9 + 7\n\n# Read n and m\nn, m = map(int, input().split())\n\n# Precompute the positions that need to be marked as 1\nmarked_positions = set()\nfor _ in range(m):\n    marked_positions.add(int(input()) - 1)  # Convert to 0-based index\n\n# Initialize variables\ns, t = 0, 1\n\n# Iterate through the array\nfor i in range(n):\n    if i in marked_positions:\n        s, t = t, 0  # Reset t to 0 and update s\n    else:\n        s, t = t, (s + t) % mod  # Update s and t with modulo operation\n\n# Output the result\nprint(t)"}
{"problem_id":"p03774","slow_code_col":"N,M = [int(c) for c in input().split()]\n\nab = [list(map(int,input().split())) for c in range(N)]\n\ncd = [list(map(int,input().split())) for c in range(M)]\n\nfor i in range(N):\n\n    mi = 2*10**9\n\n    for j in range(M):\n\n        tmp = abs(ab[i][0]-cd[j][0])+abs(ab[i][1]-cd[j][1])\n\n        if mi > tmp:\n\n            mi = tmp\n\n            ans = j+1\n\n    print(ans)\n","reference_code_col":"N,M = [int(c) for c in input().split()]\n\nab = [list(map(int,input().split())) for c in range(N)]\n\ncd = [list(map(int,input().split())) for c in range(M)]\n\nfor i in range(N):\n\n    mi = 10**9\n\n    for j in range(M):\n\n        tmp = abs(ab[i][0]-cd[j][0])+abs(ab[i][1]-cd[j][1])\n\n        if mi > tmp:\n\n            mi = tmp\n\n            ans = j+1\n\n    print(ans)\n","model_generated_potentially_faster_code_col":"from scipy.spatial import cKDTree\n\n# Read input\nN, M = map(int, input().split())\n\n# Read points for ab and cd\nab = [list(map(int, input().split())) for _ in range(N)]\ncd = [list(map(int, input().split())) for _ in range(M)]\n\n# Build a k-d tree from the points in cd\ntree = cKDTree(cd)\n\n# For each point in ab, find the nearest neighbor in cd\nfor i in range(N):\n    # Query the k-d tree for the nearest neighbor\n    distance, index = tree.query(ab[i])\n    # Print the 1-based index of the nearest neighbor\n    print(index + 1)"}
{"problem_id":"p03416","slow_code_col":"def test():\n\n    a,b = list(map(int,input().split()))\n\n    count = 0\n\n    for i in range(a,b+1):\n\n        j = list(map(int,list(str(i))))\n\n        if j[0] == j[4] and j[1] == j[3]:\n\n            count += 1\n\n    print(count)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    test()\n","reference_code_col":"def test():\n\n    a,b = list(map(int,input().split()))\n\n    count = 0\n\n    for i in range(a,b+1):\n\n        if str(i)[0] == str(i)[4] and str(i)[1] == str(i)[3]:\n\n            count += 1\n\n    print(count)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    test()\n","model_generated_potentially_faster_code_col":"def test():\n    # Read input values\n    a, b = map(int, input().split())\n    \n    count = 0\n    \n    # Iterate through all possible 5-digit palindromes\n    for d1 in range(1, 10):  # First digit (cannot be 0)\n        for d2 in range(10):  # Second digit\n            # Construct the palindrome: d1 d2 d3 d2 d1\n            palindrome = int(f\"{d1}{d2}0{d2}{d1}\")  # Middle digit is always 0\n            \n            # Check if the palindrome is within the range [a, b]\n            if a <= palindrome <= b:\n                count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    test()"}
{"problem_id":"p02821","slow_code_col":"from bisect import bisect_left\n\nfrom bisect import bisect_right\n\n\n\nn,m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\na = sorted(a)\n\n\n\na_count = [0]*100010\n\na_sum = [0]*100010\n\n\n\nfor i in range(n):\n\n    a_count[a[i]] += 1\n\n    a_sum[a[i]] += a[i]\n\n\n\nfor i in range(100005,-1,-1):\n\n    a_count[i] += a_count[i+1]\n\n    a_sum[i] += a_sum[i+1]\n\n\n\ndef chk(x):\n\n    case = 0\n\n    for i in range(n):\n\n        if 0<= x-a[i]<= 10**5+5:\n\n            case += a_count[x-a[i]]\n\n        elif x-a[i] < 0:\n\n            case += n\n\n    if case >= m:\n\n        ch = True\n\n    else:\n\n        ch = False\n\n    return ch\n\n\n\nl = 2*a[-1]+1    #NG\n\nr = 1 #OK\n\n\n\nwhile abs(r-l) > 1:\n\n    kk = (r+l)\/\/2\n\n    if chk(kk):\n\n        r = kk\n\n    else:\n\n        l = kk\n\n\n\nans = 0\n\nsm = sum(a)\n\n\n\nl = r\n\n\n\ncase = 0\n\nfor i in range(n):\n\n    num = n-bisect_right(a,l-a[i]-1)\n\n    case += num\n\n    ans += num*a[i]*2\n\n\n\nans -= (case-m)*l\n\n\n\nprint(ans)","reference_code_col":"n, m = list(map(int, input().split()))\n\na = [int(x) for x in input().split()]\n\n\n\naa = [0]*(10**5+1)\n\naa_sum = [0]*(10**5+1)\n\n\n\nfor x in a:\n\n    aa[x] += 1\n\n    aa_sum[x] += x\n\n\n\nfor i in range(10**5)[::-1]:\n\n    aa[i] = aa[i] + aa[i+1]\n\n    aa_sum[i] = aa_sum[i] + aa_sum[i+1]\n\n\n\n\n\ndef count(x):\n\n    cnt = 0\n\n    sm = 0\n\n    for i in range(n):\n\n        if x-a[i] < 0:\n\n            cnt += n\n\n            sm += aa_sum[0]+n*a[i]\n\n        elif x-a[i] > 10**5:\n\n            continue\n\n        else:\n\n            cnt += aa[x-a[i]]\n\n            sm += aa_sum[x-a[i]]+aa[x-a[i]]*a[i]\n\n\n\n    return cnt, sm\n\n\n\n\n\nbottom = 0\n\ntop = 10**6\n\n\n\nwhile top - bottom > 1:\n\n    mid = (top+bottom) \/\/ 2\n\n    cnt, sm = count(mid)\n\n    if cnt < m:\n\n        top = mid\n\n    else:\n\n        bottom = mid\n\n\n\ncnt, sm = count(bottom)\n\nans = sm - (cnt-m)*bottom\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"from bisect import bisect_right\n\n# Input reading and sorting\nn, m = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\n\n# Precompute cumulative counts and sums\nMAX_VALUE = 10**5 + 5\na_count = [0] * (MAX_VALUE + 1)\na_sum = [0] * (MAX_VALUE + 1)\n\nfor num in a:\n    a_count[num] += 1\n    a_sum[num] += num\n\n# Compute suffix sums\nfor i in range(MAX_VALUE - 1, -1, -1):\n    a_count[i] += a_count[i + 1]\n    a_sum[i] += a_sum[i + 1]\n\n# Function to check if a given x satisfies the condition\ndef chk(x):\n    case = 0\n    for num in a:\n        if 0 <= x - num <= MAX_VALUE:\n            case += a_count[x - num]\n        elif x - num < 0:\n            case += n\n    return case >= m\n\n# Binary search for the smallest valid x\nl, r = 2 * a[-1] + 1, 1  # Initialize bounds\nwhile abs(r - l) > 1:\n    mid = (l + r) \/\/ 2\n    if chk(mid):\n        r = mid\n    else:\n        l = mid\n\n# Final computation\nans = 0\ncase = 0\nsm = sum(a)\n\nfor i in range(n):\n    # Efficiently compute the number of pairs\n    num_pairs = n - bisect_right(a, r - a[i] - 1)\n    case += num_pairs\n    ans += num_pairs * a[i] * 2\n\n# Adjust for excess cases\nans -= (case - m) * r\n\nprint(ans)"}
{"problem_id":"p03548","slow_code_col":"X, Y, Z = list(map(int, input().split()))\n\nfor n in range(10 ** 5, 0, -1):\n\n    if X >= n * (Y + Z) + Z:\n\n        break\n\nprint(n)","reference_code_col":"X, Y, Z = list(map(int, input().split()))\n\nprint(((X - Z) \/\/ (Y + Z)))","model_generated_potentially_faster_code_col":"X, Y, Z = map(int, input().split())\n\n# Calculate the maximum n directly\nif Y + Z > 0:  # Avoid division by zero or invalid cases\n    n = (X - Z) \/\/ (Y + Z)\nelse:\n    n = 0  # If Y + Z <= 0, no valid n exists\n\n# Ensure n is within the valid range [1, 10^5]\nn = max(0, min(n, 10**5))\n\nprint(n)"}
{"problem_id":"p02576","slow_code_col":"array = list(map(int, input().split()))\n\nif array[0] % array[1] > 0:\n\n    print(((array[0] \/\/ array[1] + 1) * array[2]))\n\nelse:\n\n    print(((array[0] \/\/ array[1]) * array[2]))","reference_code_col":"n, x, t = list(map(int, input().split()))\n\n\n\nprint((0--n\/\/x*t))","model_generated_potentially_faster_code_col":"# Read input values\na, b, c = map(int, input().split())\n\n# Compute the quotient\nquotient = a \/\/ b\n\n# Adjust the quotient if there is a remainder\nif a % b != 0:\n    quotient += 1\n\n# Calculate and print the result\nprint(quotient * c)"}
{"problem_id":"p02268","slow_code_col":"N = int(eval(input()))\n\nS = list(map(int, input().split()))\n\nQ = int(eval(input()))\n\nT = list(map(int, input().split()))\n\n\n\ndef binary_search(target_num, head, tail):\n\n    idx = int((head+tail)\/2)\n\n    if target_num == S[idx]:\n\n        return True\n\n    elif target_num < S[idx]:\n\n        if head == idx:\n\n            return False\n\n        return binary_search(target_num, head, idx-1)\n\n    else:\n\n        if tail == idx:\n\n            return False\n\n        return binary_search(target_num, idx+1, tail)\n\n\n\n\n\nmatch_count = 0\n\nfor target_num in T:\n\n    if binary_search(target_num, 0, len(S)-1):\n\n        match_count += 1\n\n\n\nprint((str(match_count)))\n","reference_code_col":"N = int(eval(input()))\n\nS = list(map(int, input().split()))\n\nQ = int(eval(input()))\n\nT = list(map(int, input().split()))\n\n\n\ndef binary_search(target_num, head, tail):\n\n    while head <= tail:\n\n        idx = int((head+tail)\/2)\n\n        if target_num == S[idx]:\n\n            return True\n\n        elif target_num < S[idx]:\n\n            tail = idx - 1\n\n        else:\n\n            head = idx + 1\n\n    return False\n\n\n\n\n\nmatch_count = 0\n\nfor target_num in T:\n\n    if binary_search(target_num, 0, len(S)-1):\n\n        match_count += 1\n\n\n\nprint((str(match_count)))\n","model_generated_potentially_faster_code_col":"from bisect import bisect_left\n\n# Read inputs efficiently\nN = int(input())\nS = sorted(map(int, input().split()))  # Sort S once for binary search\nQ = int(input())\nT = list(map(int, input().split()))\n\n# Use bisect_left for binary search\nmatch_count = 0\nfor target_num in T:\n    # Find the position where target_num would be inserted\n    idx = bisect_left(S, target_num)\n    # Check if the element at idx matches target_num\n    if idx < len(S) and S[idx] == target_num:\n        match_count += 1\n\n# Print the result\nprint(match_count)"}
{"problem_id":"p03796","slow_code_col":"n=eval(input())\n\nn=int(n)\n\na=1\n\nfor i in range(n):\n\n    a=a*(i+1)\n\n    if a>=pow(10,9)+7:\n\n        a=a%(pow(10,9)+7)\n\nprint(a)","reference_code_col":"n=int(eval(input()))\n\na=1\n\nfor i in range(1,n+1):\n\n    a*=i\n\n    a %= (10**9+7)\n\nprint(a)","model_generated_potentially_faster_code_col":"# Precompute the modulo constant\nMOD = 10**9 + 7\n\n# Read input and convert to integer\nn = int(input())\n\n# Initialize the result\na = 1\n\n# Compute factorial with modulo at each step\nfor i in range(1, n + 1):\n    a = (a * i) % MOD\n\n# Output the result\nprint(a)"}
{"problem_id":"p02537","slow_code_col":"class SegmentTree():\n\n    \"\"\"\n\n    update, get \u3092\u63d0\u4f9b\u3059\u308bSegmentTree\n\n\n\n    Attributes\n\n    ----------\n\n    __n : int\n\n        \u8449\u306e\u6570\u30022 ^ i - 1\n\n    __dot :\n\n        Segment function\n\n    __e: int\n\n        \u5358\u4f4d\u5143\n\n    __node: list\n\n        Segment Tree\n\n    \"\"\"\n\n    def __init__(self, A, dot, e):\n\n        \"\"\"\n\n        Parameters\n\n        ----------\n\n        A : list\n\n            \u5bfe\u8c61\u306e\u914d\u5217\n\n        dot :\n\n            Segment function\n\n        e : int\n\n            \u5358\u4f4d\u5143\n\n        \"\"\"\n\n        n = 2 ** (len(A) - 1).bit_length()\n\n        self.__n = n\n\n        self.__dot = dot\n\n        self.__e = e\n\n        self.__node = [e] * (2 * n)\n\n        for i in range(len(A)):\n\n            self.__node[i + n] = A[i]\n\n        for i in range(n - 1, 0, -1):\n\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[2 * i + 1])\n\n    \n\n    def update(self, i, c):\n\n        i += self.__n\n\n        node = self.__node\n\n        node[i] = c\n\n        while i > 1:\n\n            i \/\/= 2\n\n            node[i] = self.__dot(node[2 * i], node[2 * i + 1])\n\n\n\n    def get(self, l, r):\n\n        vl, vr = self.__e, self.__e\n\n        l += self.__n\n\n        r += self.__n\n\n        while (l < r):\n\n            if l & 1:\n\n                vl = self.__dot(vl, self.__node[l])\n\n                l += 1\n\n            l \/\/= 2\n\n            if r & 1:\n\n                r -= 1\n\n                vr = self.__dot(vr, self.__node[r])\n\n            r \/\/= 2\n\n        return self.__dot(vl, vr)\n\n\n\n\n\nN, K = list(map(int, input().split()))\n\nA = [int(eval(input())) for _ in range(N)]\n\nmax_A = max(A)\n\n\n\nst = SegmentTree([N] * (max_A + 1), min, N)\n\nedge = [set() for _ in range(N)]\n\nfor i, a in enumerate(reversed(A)):\n\n    j = N - 1 - i\n\n    p1 = st.get(a, min(max_A + 1, a + K + 1))\n\n    if p1 < N:\n\n        edge[j].add(p1)\n\n    p2 = st.get(max(0, a - K), a)\n\n    if p2 < N:\n\n        edge[j].add(p2)\n\n    p0 = st.get(a, a + 1)\n\n    if p0 < N:\n\n        edge[j].add(p0)\n\n    st.update(a, j)\n\n\n\ndp = [1] * N\n\nfor i in range(N - 1):\n\n    here = dp[i]\n\n    for ni in edge[i]:\n\n        if ni < N:\n\n            dp[ni] = max(dp[ni], dp[i] + 1)\n\n\n\nprint((max(dp)))\n","reference_code_col":"class SegmentTree():\n\n    \"\"\"\n\n    update, get \u3092\u63d0\u4f9b\u3059\u308bSegmentTree\n\n\n\n    Attributes\n\n    ----------\n\n    __n : int\n\n        \u8449\u306e\u6570\u30022 ^ i - 1\n\n    __dot :\n\n        Segment function\n\n    __e: int\n\n        \u5358\u4f4d\u5143\n\n    __node: list\n\n        Segment Tree\n\n    \"\"\"\n\n    def __init__(self, A, dot, e):\n\n        \"\"\"\n\n        Parameters\n\n        ----------\n\n        A : list\n\n            \u5bfe\u8c61\u306e\u914d\u5217\n\n        dot :\n\n            Segment function\n\n        e : int\n\n            \u5358\u4f4d\u5143\n\n        \"\"\"\n\n        n = 2 ** (len(A) - 1).bit_length()\n\n        self.__n = n\n\n        self.__dot = dot\n\n        self.__e = e\n\n        self.__node = [e] * (2 * n)\n\n        for i in range(len(A)):\n\n            self.__node[i + n] = A[i]\n\n        for i in range(n - 1, 0, -1):\n\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[2 * i + 1])\n\n    \n\n    def update(self, i, c):\n\n        i += self.__n\n\n        node = self.__node\n\n        node[i] = c\n\n        while i > 1:\n\n            i \/\/= 2\n\n            node[i] = self.__dot(node[2 * i], node[2 * i + 1])\n\n\n\n    def get(self, l, r):\n\n        vl, vr = self.__e, self.__e\n\n        l += self.__n\n\n        r += self.__n\n\n        while (l < r):\n\n            if l & 1:\n\n                vl = self.__dot(vl, self.__node[l])\n\n                l += 1\n\n            l \/\/= 2\n\n            if r & 1:\n\n                r -= 1\n\n                vr = self.__dot(vr, self.__node[r])\n\n            r \/\/= 2\n\n        return self.__dot(vl, vr)\n\n\n\n\n\nN, K = list(map(int, input().split()))\n\nA = [int(eval(input())) for _ in range(N)]\n\nmax_A = max(A)\n\n\n\nst = SegmentTree([N] * (max_A + 1), min, N)\n\nedge = [set() for _ in range(N)]\n\nfor i, a in enumerate(reversed(A)):\n\n    j = N - 1 - i\n\n    p1 = st.get(a, min(max_A + 1, a + K + 1))\n\n    if p1 < N:\n\n        edge[j].add(p1)\n\n    p2 = st.get(max(0, a - K), a)\n\n    if p2 < N:\n\n        edge[j].add(p2)\n\n    st.update(a, j)\n\n\n\ndp = [1] * N\n\nfor i in range(N - 1):\n\n    here = dp[i]\n\n    for ni in edge[i]:\n\n        if ni < N:\n\n            dp[ni] = max(dp[ni], dp[i] + 1)\n\n\n\nprint((max(dp)))\n","model_generated_potentially_faster_code_col":"from heapq import heappush, heappop\n\nclass SegmentTree:\n    def __init__(self, A, dot, e):\n        n = 2 ** (len(A) - 1).bit_length()\n        self.__n = n\n        self.__dot = dot\n        self.__e = e\n        self.__node = [e] * (2 * n)\n        for i in range(len(A)):\n            self.__node[i + n] = A[i]\n        for i in range(n - 1, 0, -1):\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[2 * i + 1])\n\n    def update(self, i, c):\n        i += self.__n\n        node = self.__node\n        node[i] = c\n        while i > 1:\n            i \/\/= 2\n            node[i] = self.__dot(node[2 * i], node[2 * i + 1])\n\n    def get(self, l, r):\n        vl, vr = self.__e, self.__e\n        l += self.__n\n        r += self.__n\n        while l < r:\n            if l & 1:\n                vl = self.__dot(vl, self.__node[l])\n                l += 1\n            l \/\/= 2\n            if r & 1:\n                r -= 1\n                vr = self.__dot(vr, self.__node[r])\n            r \/\/= 2\n        return self.__dot(vl, vr)\n\n\ndef solve():\n    N, K = map(int, input().split())\n    A = [int(eval(input())) for _ in range(N)]\n    max_A = max(A)\n\n    # Initialize Segment Tree\n    st = SegmentTree([N] * (max_A + 1), min, N)\n\n    # Build adjacency list for edges\n    edge = [[] for _ in range(N)]\n    for i, a in enumerate(reversed(A)):\n        j = N - 1 - i\n\n        # Query segment tree for potential edges\n        p1 = st.get(a, min(max_A + 1, a + K + 1))\n        if p1 < N:\n            edge[j].append(p1)\n\n        p2 = st.get(max(0, a - K), a)\n        if p2 < N:\n            edge[j].append(p2)\n\n        p0 = st.get(a, a + 1)\n        if p0 < N:\n            edge[j].append(p0)\n\n        # Update segment tree\n        st.update(a, j)\n\n    # Topological sort using Kahn's algorithm\n    in_degree = [0] * N\n    for u in range(N):\n        for v in edge[u]:\n            in_degree[v] += 1\n\n    # Initialize priority queue\n    pq = []\n    dp = [1] * N\n    for i in range(N):\n        if in_degree[i] == 0:\n            heappush(pq, i)\n\n    # Process nodes in topological order\n    while pq:\n        u = heappop(pq)\n        for v in edge[u]:\n            dp[v] = max(dp[v], dp[u] + 1)\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                heappush(pq, v)\n\n    # Output the result\n    print(max(dp))\n\n\nif __name__ == \"__main__\":\n    solve()"}
{"problem_id":"p00003","slow_code_col":"import sys\n\nr = []\n\nn = int(eval(input()))\n\nl = sys.stdin.readlines()\n\nfor i in l:\n\n  x, y, z = sorted([x*x for x in list(map(int, i.split()))])\n\n  if x + y == z:\n\n      print(\"YES\")\n\n  else:\n\n      print(\"NO\")","reference_code_col":"import sys\n\n\n\nn = int(input())\n\nl = sys.stdin.readlines()\n\ns = \"\"\n\nfor i in l:\n\n  x, y, z = sorted(map(lambda x:x*x,map(int, i.split())))\n\n  if x + y == z:\n\n      s += \"YES\\n\"\n\n  else:\n\n      s += \"NO\\n\"\n\n\n\nprint(s,end=\"\")\n","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Read the number of test cases\n    n = int(sys.stdin.readline())\n    \n    # Prepare results list\n    results = []\n    \n    # Process each test case\n    for _ in range(n):\n        # Read and process the line\n        nums = list(map(int, sys.stdin.readline().split()))\n        \n        # Compute squares of the numbers\n        x, y, z = nums[0]**2, nums[1]**2, nums[2]**2\n        \n        # Identify the largest square and check the Pythagorean condition\n        if max(x, y, z) == x + y + z - max(x, y, z):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    # Print all results at once\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03371","slow_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\nab = c * 2\n\n\n\nres = float(\"inf\")\n\nif a + b <= ab:\n\n    res = x * a + y * b\n\nelse:\n\n    if x == y:\n\n        res = x * ab\n\n    elif x > y:\n\n        for i in range(y, x + 1):\n\n            cost = i * ab + (x - i) * a\n\n            res = min(res, cost)\n\n    else:\n\n        for i in range(x, y + 1):\n\n            cost = i * ab + (y - i) * b\n\n            res = min(res, cost)\n\nprint(res)\n","reference_code_col":"import sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\ninput = sys.stdin.readline\n\nf_inf = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\n\n\ndef resolve():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    c *= 2\n\n    if a + b > c:\n\n        cost1 = max(x, y) * c\n\n        cost2 = min(x, y) * c\n\n        plus = ((y - x) * b) if x < y else (x - y) * a\n\n        res = min(cost1, cost2 + plus)\n\n    else:\n\n        res = x * a + y * b\n\n    print(res)\n\n\n\nif __name__ == '__main__':\n\n    resolve()\n","model_generated_potentially_faster_code_col":"# Input parsing\na, b, c, x, y = map(int, input().split())\nab = c * 2\n\n# Initialize result\nres = float(\"inf\")\n\n# Case 1: a + b <= ab\nif a + b <= ab:\n    res = x * a + y * b\nelse:\n    # Case 2: x == y\n    if x == y:\n        res = x * ab\n    # Case 3: x > y\n    elif x > y:\n        res = x * ab + (x - y) * a\n    # Case 4: x < y\n    else:\n        res = x * ab + (y - x) * b\n\n# Output the result\nprint(res)"}
{"problem_id":"p03371","slow_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\n\n\nans=a*x+b*y\n\nfor ci in range(max(x,y)+1):\n\n    sumc = 2*ci*c\n\n    sumc += (x-ci)*a if (x-ci)>0 else 0\n\n    sumc += (y-ci)*b if (y-ci)>0 else 0\n\n    ans=min(ans,sumc)\n\n\n\nprint(ans)","reference_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nif x==y:\n\n    ans=min(ans,2*x*c)\n\nelif x>y:\n\n    ans=min(ans,a*(x-y)+2*y*c)\n\n    ans=min(ans,2*x*c)\n\nelse:\n\n    ans=min(ans,b*(y-x)+2*x*c)\n\n    ans=min(ans,2*y*c)\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read inputs\na, b, c, x, y = map(int, input().split())\n\n# Initial cost without replacing any items\nans = a * x + b * y\n\n# Precompute maximum possible replacements\nmax_ci = min(x, y)\n\n# Iterate only up to max_ci\nfor ci in range(max_ci + 1):\n    # Calculate total cost for replacing ci items with c\n    sumc = 2 * ci * c + (x - ci) * a + (y - ci) * b\n    ans = min(ans, sumc)\n\nprint(ans)"}
{"problem_id":"p01105","slow_code_col":"a=65280; b=61680; c=52428; d=43690; e=65535\n\nfrom heapq import heappush, heappop\n\nbase = [a, b, c, d, e, 0]\n\nQ = [(1, el) for el in base]\n\nL = {el: 1 for el in base}\n\nH = []\n\nget = L.get\n\npush = H.append\n\nwhile Q:\n\n    l, p = heappop(Q)\n\n    if L[p] < l: continue\n\n    if l+1 < get(p ^ e, 17):\n\n        L[p ^ e] = l+1\n\n        if l+1 < 16: heappush(Q, (l+1, p ^ e))\n\n    if l+3 < 16:\n\n        for q, r in H:\n\n            if l+r+3 <= 16:\n\n                if l+r+3 < get(p & q, 17):\n\n                    L[p & q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p & q))\n\n                if l+r+3 < get(p ^ q, 17):\n\n                    L[p ^ q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p ^ q))\n\n            else: break\n\n    if l < 7: push((p, l))\n\nprint(*map(L.__getitem__, eval(\"e&%s\"%\",e&\".join(open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]))),sep='\\n')\n","reference_code_col":"a=65280; b=61680; c=52428; d=43690; e=65535\n\nfrom heapq import heappush, heappop\n\nQ = [(1, a), (1, b), (1, c), (1, d)]\n\nL = {a: 1, b: 1, c: 1, d: 1, e: 1, e: 1, 0: 1}\n\nH = []\n\nget = L.get\n\npush = H.append\n\nwhile Q:\n\n    l, p = heappop(Q)\n\n    if L[p] < l: continue\n\n    if l+1 < get(p ^ e, 17):\n\n        L[p ^ e] = l+1\n\n        l < 15 and heappush(Q, (l+1, p ^ e))\n\n    if l < 13:\n\n        li = 13-l; l3 = 3+l\n\n        for q, r in H:\n\n            if r <= li:\n\n                k = p & q\n\n                if r < get(k, 17)-l3:\n\n                    L[k] = l3+r\n\n                    r < li and heappush(Q, (l3+r, k))\n\n                k = p ^ q\n\n                if r < get(k, 17)-l3:\n\n                    L[k] = l3+r\n\n                    r < li and heappush(Q, (l3+r, k))\n\n            else: break\n\n    if l < 7: push((p, l))\n\nprint(*map(L.__getitem__, eval(\"e&\"+\",e&\".join(open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]))),sep='\\n')\n","model_generated_potentially_faster_code_col":"from heapq import heappush, heappop\nfrom collections import defaultdict\n\n# Constants\na, b, c, d, e = 65280, 61680, 52428, 43690, 65535\n\n# Initialize base and priority queue\nbase = [a, b, c, d, e, 0]\nQ = [(1, el) for el in base]\n\n# Use defaultdict for faster lookups\nL = defaultdict(lambda: float('inf'))\nfor el in base:\n    L[el] = 1\n\nH = []\n\nwhile Q:\n    l, p = heappop(Q)\n\n    # Skip outdated entries\n    if L[p] < l:\n        continue\n\n    # Update for XOR operation with e\n    new_val = p ^ e\n    if l + 1 < L[new_val]:\n        L[new_val] = l + 1\n        if l + 1 < 16:\n            heappush(Q, (l + 1, new_val))\n\n    # Update for AND and XOR operations with H\n    if l + 3 < 16:\n        for q, r in H:\n            if l + r + 3 > 16:\n                break\n\n            # AND operation\n            and_val = p & q\n            if l + r + 3 < L[and_val]:\n                L[and_val] = l + r + 3\n                if l + r + 3 < 16:\n                    heappush(Q, (l + r + 3, and_val))\n\n            # XOR operation\n            xor_val = p ^ q\n            if l + r + 3 < L[xor_val]:\n                L[xor_val] = l + r + 3\n                if l + r + 3 < 16:\n                    heappush(Q, (l + r + 3, xor_val))\n\n    # Add to H if length is less than 7\n    if l < 7:\n        H.append((p, l))\n\n# Read input and compute output\ninput_data = open(0).read().replace(\"-\", \"~\").replace(\"*\", \"&\").replace(\"1\", \"e\").split()[:-1]\nresults = [L[e & int(x)] for x in input_data]\nprint(*results, sep='\\n')"}
{"problem_id":"p04020","slow_code_col":"def examB():\n\n    N = I(); A = [I() for _ in range(N)]\n\n    ans = 0; cur= 0\n\n    for i in A:\n\n        if i==0:\n\n            ans += cur\/\/2\n\n            cur = 0\n\n        else:\n\n            cur += i\n\n    ans += cur \/\/ 2\n\n    print(ans)\n\n    return\n\n\n\nimport sys,copy,bisect,itertools,heapq,math\n\nfrom heapq import heappop,heappush,heapify\n\nfrom collections import Counter,defaultdict,deque\n\ndef I(): return int(sys.stdin.readline())\n\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\n\ndef LS(): return sys.stdin.readline().split()\n\ndef SI(): return sys.stdin.readline().strip()\n\nmod = 10**9 + 7\n\ninf = float('inf')\n\n\n\nif __name__ == '__main__':\n\n    examB()\n","reference_code_col":"def examA():\n\n    S = SI()\n\n    if \"W\" in S and not \"E\" in S:\n\n        print(\"No\")\n\n    elif \"E\" in S and not \"W\" in S:\n\n        print(\"No\")\n\n    elif \"N\" in S and not \"S\" in S:\n\n        print(\"No\")\n\n    elif \"S\" in S and not \"N\" in S:\n\n        print(\"No\")\n\n    else:\n\n        print(\"Yes\")\n\n    return\n\n\n\ndef examB():\n\n    N = I()\n\n    A = [I()for _ in range(N)]\n\n    ans = 0\n\n    for i in range(N-1):\n\n        ans += A[i]\/\/2\n\n        if A[i]%2 and A[i+1]>=1:\n\n            ans += 1\n\n            A[i+1] -= 1\n\n    ans += A[N-1]\/\/2\n\n    print(ans)\n\n    return\n\n\n\ndef examC():\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\ndef examD():\n\n    N = I()\n\n    S = [I()for _ in range(N)]\n\n\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\ndef examE():\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\ndef examF():\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\nimport sys,bisect,itertools,heapq,math,random\n\nfrom copy import deepcopy\n\nfrom heapq import heappop,heappush,heapify\n\nfrom collections import Counter,defaultdict,deque\n\ndef I(): return int(sys.stdin.readline())\n\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\n\ndef LS(): return sys.stdin.readline().split()\n\ndef SI(): return sys.stdin.readline().strip()\n\nglobal mod,mod2,inf,alphabet,_ep\n\nmod = 10**9 + 7\n\nmod2 = 998244353\n\ninf = 10**18\n\n_ep = 10**(-12)\n\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\n\n\nsys.setrecursionlimit(10**6)\n\n\n\nif __name__ == '__main__':\n\n    examB()\n\n\n\n\"\"\"\n\n\n\n\"\"\"","model_generated_potentially_faster_code_col":"def examB():\n    # Read input values\n    N = I()\n    A = [I() for _ in range(N)]\n\n    ans = 0\n    cur = 0\n\n    # Process the array\n    for i in A:\n        if i == 0:  # Reset when encountering zero\n            ans += cur >> 1  # Equivalent to cur \/\/ 2\n            cur = 0\n        else:\n            cur += i\n\n    # Add remaining contribution from cur\n    ans += cur >> 1\n\n    print(ans)\n\n# Helper functions for fast input\nimport sys\n\ndef I():\n    return int(sys.stdin.readline())\n\nif __name__ == '__main__':\n    examB()"}
{"problem_id":"p03544","slow_code_col":"N = int(eval(input()))\n\nL = [ 0 ] * 1000000\n\n\n\nL[0] = 2\n\nL[1] = 1\n\n\n\nfor i in range(2, N+1):\n\n  L[i] = L[i-2] + L[i-1]\n\n\n\nprint((L[N]))\n","reference_code_col":"N = int(eval(input()))\n\nL = [ 0 ] * (N+1)\n\n\n\nL[0] = 2\n\nL[1] = 1\n\n\n\nfor i in range(2, N+1):\n\n  L[i] = L[i-2] + L[i-1]\n\n\n\nprint((L[N]))\n","model_generated_potentially_faster_code_col":"# Read input safely\nN = int(input())\n\n# Base cases\nif N == 0:\n    print(2)\nelif N == 1:\n    print(1)\nelse:\n    # Initialize the first two terms\n    prev2 = 2  # L[0]\n    prev1 = 1  # L[1]\n\n    # Compute the N-th term iteratively\n    for i in range(2, N + 1):\n        current = prev2 + prev1\n        prev2 = prev1\n        prev1 = current\n\n    # Output the result\n    print(prev1)"}
{"problem_id":"p03013","slow_code_col":"import sys\n\nN,M=list(map(int,input().split()))\n\nS=set(map(int,sys.stdin))\n\n\n\na,b=0,1\n\nfor i in range(1,N+1):\n\n    if i in S:\n\n        a,b=b,0\n\n    else:\n\n        a,b=b,a+b\n\n\n\nprint((b%(10**9+7)))\n","reference_code_col":"import sys\n\n\n\nN,M=list(map(int,input().split()))\n\nbad=set(map(int,sys.stdin))\n\nMOD=10**9+7\n\n\n\na,b=0,1\n\nfor i in range(1,N+1):\n\n    if i in bad:\n\n        a,b=b,0\n\n        if a==0:\n\n            break\n\n    else:\n\n        a,b=b,(a+b)%MOD\n\n\n\nprint(b)\n","model_generated_potentially_faster_code_col":"import sys\nfrom bisect import bisect_left\n\n# Input parsing\nN, M = map(int, input().split())\nS = sorted(map(int, sys.stdin.read().split()))  # Read all indices and sort them\n\nMOD = 10**9 + 7\n\n# Initialize Fibonacci-like sequence\na, b = 0, 1\n\n# Pointer for the sorted list of indices in S\ns_ptr = 0\n\nfor i in range(1, N + 1):\n    # Check if current index i is in S using binary search\n    if s_ptr < len(S) and S[s_ptr] == i:\n        # Reset the sequence if i is in S\n        a, b = b, 0\n        s_ptr += 1  # Move to the next index in S\n    else:\n        # Update the sequence normally\n        a, b = b, (a + b) % MOD\n\n# Output the result\nprint(b)"}
{"problem_id":"p02982","slow_code_col":"import numpy as np\n\nimport itertools\n\n\n\nn, d = list(map(int, input().split()))\n\nx = [list(map(int, input().split())) for i in range(n)]\n\n\n\ncnt = 0\n\nfor i1, i2 in itertools.product(list(range(n)), list(range(n))):\n\n    if i1 == i2:\n\n        continue\n\n    x1 = np.array(x[i1])\n\n    x2 = np.array(x[i2])\n\n    d = sum(list([x ** 2 for x in list(x1 - x2)])) ** 0.5\n\n    if d == int(d):\n\n        cnt += 1\n\n\n\nprint((int(cnt \/ 2)))","reference_code_col":"n,d=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(n)]\n\n\n\ncnt=0\n\nfor i in range(n-1):\n\n for j in range(i+1,n):\n\n  l1=l[i]\n\n  l2=l[j]\n\n  sum=0\n\n  for y,z in zip(l1,l2):\n\n   sum+=(y-z)**2\n\n  dist=sum**0.5\n\n  if dist==int(dist):\n\n   cnt+=1\n\nprint(cnt)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input reading\nn, d = map(int, input().split())\nx = [list(map(int, input().split())) for _ in range(n)]\n\n# Convert the entire list of points to a NumPy array upfront\nx = np.array(x)\n\ncnt = 0\n\n# Iterate over unique pairs (i1, i2) where i1 < i2\nfor i1 in range(n):\n    for i2 in range(i1 + 1, n):\n        # Compute squared differences directly using NumPy\n        diff_squared = np.sum((x[i1] - x[i2]) ** 2)\n        \n        # Check if the square root of the sum is an integer\n        if np.sqrt(diff_squared).is_integer():\n            cnt += 1\n\n# Output the result\nprint(cnt)"}
{"problem_id":"p01138","slow_code_col":"import re\n\n\n\nwhile True:\n\n    n = int(input())\n\n    if n == 0:\n\n        break\n\n    l = [0] * (24*60*60+1)\n\n    for _ in range(n):\n\n        h1,m1,s1,h2,m2,s2 = list(map(int, re.split(':| ', input())))\n\n        l[h1*60*60 + m1*60 + s1] += 1\n\n        l[h2*60*60 + m2*60 + s2] -= 1\n\n    r = 0\n\n    for i in range(24*60*60):\n\n        l[i+1] += l[i]\n\n        r = max(r, l[i+1])\n\n    print(r)","reference_code_col":"while True:\n\n    n = int(input())\n\n    if n == 0:\n\n        break\n\n    l = []\n\n    for _ in range(n):\n\n        hms1, hms2 = input().split()\n\n        l.append((hms1, True))\n\n        l.append((hms2, False))\n\n    l.sort()\n\n    r, t = 0, 0\n\n    for i in range(len(l)):\n\n        if l[i][1]:\n\n            t += 1\n\n        else:\n\n            t -= 1\n\n        r = max(r, t)\n\n    print(r)","model_generated_potentially_faster_code_col":"while True:\n    # Read the number of events\n    n = int(input())\n    if n == 0:\n        break\n\n    # Precompute the total number of seconds in a day\n    TOTAL_SECONDS = 24 * 60 * 60\n    # Initialize the event array\n    l = [0] * (TOTAL_SECONDS + 1)\n\n    # Process each event\n    for _ in range(n):\n        # Parse input efficiently\n        parts = input().replace(':', ' ').split()\n        h1, m1, s1, h2, m2, s2 = map(int, parts)\n        \n        # Convert time to seconds and update the event array\n        start_time = h1 * 3600 + m1 * 60 + s1\n        end_time = h2 * 3600 + m2 * 60 + s2\n        l[start_time] += 1\n        l[end_time] -= 1\n\n    # Calculate the cumulative sum and find the maximum overlap\n    max_overlap = 0\n    current_overlap = 0\n    for i in range(TOTAL_SECONDS):\n        current_overlap += l[i]\n        max_overlap = max(max_overlap, current_overlap)\n\n    # Output the result\n    print(max_overlap)"}
{"problem_id":"p03038","slow_code_col":"import numpy as np\n\nn,m=list(map(int,input().split()))\n\na=np.array([int(i) for i in input().split()])\n\nbc=np.array([[int(i) for i in input().split()] for j in range(m)])\n\n\n\na.sort()\n\nb=bc[:,0]\n\nc=bc[:,1]\n\n\n\nidx=np.argsort(c)\n\nb=b[idx][::-1]\n\nc=c[idx][::-1]\n\n\n\np=0\n\nfor b,c in zip(b,c):\n\n    a[p:p+b]=np.maximum(a[p:p+b],c)\n\n    p+=b\n\n    \n\n    \n\nprint((a.sum()))","reference_code_col":"from heapq import heappop,heappush\n\nn,m=list(map(int,input().split()))\n\na=[int(i) for i in input().split()]\n\na.sort()\n\nbc=[[int(i) for i in input().split()]for j in range(m)]\n\nbc=sorted(bc, key=lambda x:x[1],reverse=True)\n\n\n\nans=[]\n\nfor b,c in bc:    \n\n    while b>0 and a: \n\n        x = heappop(a)\n\n        if x<c:\n\n            ans.append(c)\n\n            b-=1\n\n        else:\n\n            ans.append(x)\n\nprint((sum(ans)+sum(a)))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input parsing\nn, m = map(int, input().split())\na = np.fromiter(map(int, input().split()), dtype=int)\nbc = np.array([list(map(int, input().split())) for _ in range(m)])\n\n# Sort 'a' in ascending order\na.sort()\n\n# Extract 'b' and 'c', sort by 'c' in descending order\nb, c = bc[:, 0], bc[:, 1]\nsorted_indices = np.argsort(c)[::-1]\nb, c = b[sorted_indices], c[sorted_indices]\n\n# Precompute cumulative sum of 'b' to avoid repeated slicing\ncumulative_b = np.cumsum(b)\n\n# Create a mask for efficient updates\nmask = np.zeros(n, dtype=bool)\nfor start, end, value in zip(np.concatenate(([0], cumulative_b[:-1])), cumulative_b, c):\n    mask[start:end] = True\n    a[mask] = np.maximum(a[mask], value)\n    mask.fill(False)  # Reset mask for next iteration\n\n# Output the result\nprint(a.sum())"}
{"problem_id":"p03424","slow_code_col":"n=int(eval(input()))\n\ns=list(map(str,input().split()))\n\ntotal=[]\n\nfor i in range(n):\n\n    if s[i] not in total:\n\n        total.append(s[i])\n\nprint(('Three' if len(total)==3 else 'Four'))","reference_code_col":"eval(input())\n\nl=list(map(str,input().split()))\n\nprint(('Three' if len(set(l))==3 else 'Four'))","model_generated_potentially_faster_code_col":"n = int(input())  # Read the number of elements\ns = input().split()  # Read the list of strings\n\nunique_elements = set()  # Use a set to store unique elements efficiently\nresult = \"Three\"  # Default result\n\nfor i in range(n):\n    unique_elements.add(s[i])  # Add element to the set (duplicates are ignored)\n    if len(unique_elements) > 3:  # Early exit if more than 3 unique elements are found\n        result = \"Four\"\n        break\n\nprint(result)"}
{"problem_id":"p03164","slow_code_col":"import sys\n\nfrom collections import Counter, deque, defaultdict\n\nfrom itertools import accumulate, permutations, combinations, takewhile, compress, cycle\n\nfrom functools import reduce\n\nfrom math import ceil, floor, log10, log2, factorial\n\nfrom pprint import pprint\n\n\n\nsys.setrecursionlimit(1000000)\n\n# MOD = 10 ** 9 + 7\n\n# N = int(input())\n\n# A = [int(x) for x in input().split()]\n\n# V = [[0] * 100 for _ in range(100)]\n\n# A = [int(input()) for _ in range(N)]\n\n\n\nN, W = [int(x) for x in input().split()]\n\n\n\ndp = [float('inf')] * 1000 * 100*10\n\nvs = set()\n\nvs.add(0)\n\ndp[0] = 0\n\n\n\nfor i in range(N):\n\n    w, v = [int(x) for x in input().split()]\n\n\n\n    tmpDP = dp.copy()\n\n    for vv in list(vs):\n\n        if dp[vv + v] > dp[vv] + w:\n\n            tmpDP[vv + v] = dp[vv] + w\n\n            vs.add(vv + v)\n\n    dp = tmpDP\n\n\n\n\n\nans = 0\n\nfor v in list(vs):\n\n    if dp[v] <= W:\n\n        ans = max(ans, v)\n\nprint(ans)\n","reference_code_col":"import sys\n\nfrom collections import Counter, deque, defaultdict\n\nfrom itertools import accumulate, permutations, combinations, takewhile, compress, cycle\n\nfrom functools import reduce\n\nfrom math import ceil, floor, log10, log2, factorial\n\nfrom pprint import pprint\n\n\n\nsys.setrecursionlimit(1000000)\n\n# MOD = 10 ** 9 + 7\n\n# N = int(input())\n\n# A = [int(x) for x in input().split()]\n\n# V = [[0] * 100 for _ in range(100)]\n\n# A = [int(input()) for _ in range(N)]\n\n\n\nN, W = [int(x) for x in input().split()]\n\n\n\ndp = defaultdict(lambda: float('inf'))\n\ndp[0] = 0\n\n\n\nfor i in range(N):\n\n    w, v = [int(x) for x in input().split()]\n\n\n\n    add = defaultdict(lambda: float('inf'))\n\n    for vv in list(dp.keys()):\n\n        if dp[vv + v] > dp[vv] + w:\n\n            add[vv + v] = dp[vv] + w\n\n    dp.update(add)\n\n\n\nprint((max([i for i in list(dp.items()) if i[1] <= W], key=lambda x:x[0])[0]))\n","model_generated_potentially_faster_code_col":"import sys\n\n# Input reading\nN, W = map(int, sys.stdin.readline().split())\n\n# Determine the maximum possible value (v_max)\nitems = []\nv_max = 0\nfor _ in range(N):\n    w, v = map(int, sys.stdin.readline().split())\n    items.append((w, v))\n    v_max += v  # Accumulate the total value\n\n# Initialize dp array\ndp = [float('inf')] * (v_max + 1)\ndp[0] = 0  # Base case: 0 value requires 0 weight\n\n# Fill the dp array\nfor w, v in items:\n    for vv in range(v_max, v - 1, -1):  # Iterate backwards to avoid overwriting\n        if dp[vv - v] + w < dp[vv]:\n            dp[vv] = dp[vv - v] + w\n\n# Find the maximum value within the weight limit\nans = 0\nfor vv in range(v_max + 1):\n    if dp[vv] <= W:\n        ans = vv\n\nprint(ans)"}
{"problem_id":"p03796","slow_code_col":"from math import factorial\n\nN = int(eval(input()))\n\nprint((factorial(N) % (10**9 + 7)))","reference_code_col":"from math import factorial\n\nN = int(eval(input()))\n\nans = 1\n\nfor i in range(1,N+1):\n\n    ans *= i % (10**9 + 7)\n\n    ans %= 10**9 + 7\n\nprint(ans)","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7  # Precompute the modulo constant\n\n# Read input\nN = int(input())\n\n# Compute factorial with modulo optimization\nresult = 1\nfor i in range(2, N + 1):\n    result = (result * i) % MOD\n\nprint(result)"}
{"problem_id":"p03013","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\nbroken = set([int(eval(input())) for _ in range(m)]) # \u3053\u3053\u304c'list'\u3060\u3068Pypy\u3067\u3082\u901a\u3089\u306a\u3044\n\n\n\ndef ptn_num(x): # 'x'step\u307e\u3067\u306e\u30d1\u30bf\u30fc\u30f3\u6570\n\n    dp = [0] * (x+1) # DP\u67a0_including step'0'\n\n    if 1 in broken: # in case, step'1' broken \n\n        dp[:2] = 1, 0\n\n    else:\n\n        dp[:2] = 1, 1 # Usually\n\n\n\n    for i in range(2, x+1):\n\n        if i not in broken: # \u968e\u6bb5\u304c\u58ca\u308c\u3066\u306a\u3044\u5834\u5408...\n\n            dp[i] = (dp[i-1] + dp[i-2]) % (10**9+7) # -1\u6bb5\u76ee\u3068-2\u6bb5\u76ee\u306e\u5408\u8a08\n\n    print((dp[-1]))\n\n\n\nptn_num(n)\n","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\nbroken = set([int(eval(input())) for _ in range(m)]) # \u3053\u3053\u304c'list'\u3060\u3068Pypy\u3067\u3082\u901a\u3089\u306a\u3044\n\n\n\ndef ptn_num(x): # 'x'step\u307e\u3067\u306e\u30d1\u30bf\u30fc\u30f3\u6570\n\n    dp = [0] * (x+1) # DP\u67a0_including step'0'\n\n    if 1 in broken: # \u56fa\u5b9a\u90e8\u5206_in case, step'1' broken \n\n        dp[:2] = 1, 0\n\n    else:\n\n        dp[:2] = 1, 1 # \u56fa\u5b9a\u90e8\u5206_Usually\n\n\n\n    for i in range(2, x+1):\n\n        if i not in broken: # \u968e\u6bb5\u304c\u58ca\u308c\u3066\u306a\u3044\u5834\u5408...\n\n            dp[i] = (dp[i-1] + dp[i-2]) % (10**9+7) # -1\u6bb5\u76ee\u3068-2\u6bb5\u76ee\u306e\u5408\u8a08\n\n    print((dp[-1]))\n\n\n\nptn_num(n)","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\n# Constants\nMOD = 10**9 + 7\n\n# Read input\nn, m = map(int, input().split())\nbroken = set(int(input()) for _ in range(m))\n\n# Early termination if the final step is broken\nif n in broken:\n    print(0)\n    sys.exit()\n\n# Initialize DP variables\nprev2, prev1 = 1, 0  # dp[i-2], dp[i-1]\n\n# Iterate through steps\nfor i in range(1, n + 1):\n    if i in broken:  # Skip broken steps\n        prev2, prev1 = 0, prev2\n    else:\n        current = (prev1 + prev2) % MOD\n        prev2, prev1 = prev1, current\n\n# Output the result\nprint(prev1)"}
{"problem_id":"p03000","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nN, X  = list(map(int, input().split()))\n\n\n\nL = np.array(list(map(int, input().split())))\n\n\n\nx = np.zeros(N+1)\n\n\n\nfor n in range(1,N+1):\n\n    x[n] = x[n-1] + L[n-1]\n\n    if x[n] > X:\n\n        print(n)\n\n        sys.exit()\n\n\n\nprint((N+1))\n\n\n","reference_code_col":"N, X = list(map(int, input().split()))\n\nL = list(map(int, input().split()))\n\n\n\ncnt = 1\n\nsum_L = 0\n\nfor l in L:\n\n    sum_L += l\n\n    if sum_L <= X:\n\n        cnt += 1\n\n    else:\n\n        break\n\n\n\nprint(cnt)\n","model_generated_potentially_faster_code_col":"import sys\n\n# Read inputs\nN, X = map(int, input().split())\nL = list(map(int, input().split()))\n\n# Initialize cumulative sum\ncumulative_sum = 0\n\n# Iterate through the list\nfor n in range(1, N + 1):\n    cumulative_sum += L[n - 1]\n    if cumulative_sum > X:\n        print(n)\n        sys.exit()\n\n# If no exit occurred, print (N+1)\nprint(N + 1)"}
{"problem_id":"p02881","slow_code_col":"n = int(eval(input()))\n\nr = int(n**.5)\n\nfor i in range(r):\n\n  if n % (r-i) == 0:\n\n    print(( (r-i) + n\/\/(r-i) - 2 ))\n\n    break","reference_code_col":"n = int(eval(input()))\n\ns = int(n**.5)\n\nfor i in range(s):\n\n  if n % (s-i) == 0:\n\n    print(((s-i) + n \/\/ (s-i) - 2))\n\n    break","model_generated_potentially_faster_code_col":"n = int(eval(input()))\nr = int(n**0.5)\n\n# Start from r and decrement to find the largest divisor <= r\nfor d in range(r, 0, -1):\n    if n % d == 0:  # Check if d is a divisor of n\n        print(d + n \/\/ d - 2)\n        break"}
{"problem_id":"p03253","slow_code_col":"from collections import Counter\n\ndef factorization(n) -> list:\n\n\tif n==1:\n\n\t\treturn [1]\n\n\tret = []\n\n\ti = 2\n\n\twhile i*i<=n:\n\n\t\twhile n%i==0:\n\n\t\t\tn \/\/= i\n\n\t\t\tret.append(i)\n\n\t\ti += 1\n\n\tif n!=1:\n\n\t\tret.append(n)\n\n\treturn ret\n\n\n\nn,m = list(map(int,input().split()))\n\nmod = 10**9+7\n\nif m==1:\n\n\tprint((1));exit()\n\n\n\nfactors = Counter(factorization(m))\n\nmx = n+max(factors.values())\n\n\n\nfac = [1]*(mx+1)\n\ninv = [1]*(mx+1)\n\nfor i in range(1,mx+1):\n\n\tfac[i] = fac[i-1] * i % mod\n\ninv[-1] = pow(fac[-1], mod - 2, mod)\n\nfor i in range(mx-1, -1, -1):\n\n\tinv[i] = inv[i+1] * (i+1) % mod\n\ndef cmb(n,r):\n\n\tassert n >= r >= 0\n\n\treturn fac[n] * inv[n-r] * inv[r] % mod\n\n\t\n\nans=1\n\nfor v in list(factors.values()):\n\n\tans*=cmb(n+v-1,v)\n\n\tans%=mod\n\n\n\nprint(ans)","reference_code_col":"from collections import Counter\n\ndef factorization(n) -> list:\n\n\tif n==1:return [1]\n\n\tret = []\n\n\ti = 2\n\n\twhile i*i<=n:\n\n\t\twhile n%i==0:\n\n\t\t\tn \/\/= i\n\n\t\t\tret.append(i)\n\n\t\ti += 1\n\n\tif n!=1:ret.append(n)\n\n\treturn ret\n\n\t\n\nfrom operator import mul\n\nfrom functools import reduce\n\ndef cmb(n,r):\n\n\tif n < r:return 0\n\n\tr = min(n-r,r)\n\n\tif r==0:return 1\n\n\tu = reduce(mul, list(range(n, n-r, -1)))\n\n\td = reduce(mul, list(range(1,r+1)))\n\n\treturn u\/\/d\n\n\n\ndef main():\n\n\tn,m = list(map(int,input().split()))\n\n\tmod = 10**9+7\n\n\tif m==1:\n\n\t\tprint((1))\n\n\t\texit()\n\n\tans=1\n\n\tfor v in list(Counter(factorization(m)).values()):\n\n\t\tans*=cmb(n+v-1,v)\n\n\t\tans%=mod\n\n\tprint(ans)\n\n\t\n\nif __name__==\"__main__\":main()","model_generated_potentially_faster_code_col":"from collections import Counter\n\ndef factorization(n) -> list:\n    \"\"\"Efficiently factorize a number into its prime factors.\"\"\"\n    ret = []\n    i = 2\n    # Check divisibility by 2 separately\n    while n % i == 0:\n        n \/\/= i\n        ret.append(i)\n    # Check odd numbers starting from 3\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            n \/\/= i\n            ret.append(i)\n        i += 2\n    if n > 1:\n        ret.append(n)\n    return ret\n\n\ndef precompute_factorials(mx, mod):\n    \"\"\"Precompute factorials and inverses up to mx under modulo mod.\"\"\"\n    fac = [1] * (mx + 1)\n    inv = [1] * (mx + 1)\n\n    # Compute factorials\n    for i in range(2, mx + 1):\n        fac[i] = fac[i - 1] * i % mod\n\n    # Compute modular inverses using Fermat's Little Theorem\n    inv[-1] = pow(fac[-1], mod - 2, mod)\n    for i in range(mx - 1, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % mod\n\n    return fac, inv\n\n\ndef cmb(n, r, fac, inv, mod):\n    \"\"\"Compute nCr using precomputed factorials and inverses.\"\"\"\n    if n < r or r < 0:\n        return 0\n    return fac[n] * inv[r] % mod * inv[n - r] % mod\n\n\n# Input\nn, m = map(int, input().split())\nmod = 10**9 + 7\n\nif m == 1:\n    print(1)\n    exit()\n\n# Factorization\nfactors = Counter(factorization(m))\nmx = n + max(factors.values())\n\n# Precompute factorials and inverses\nfac, inv = precompute_factorials(mx, mod)\n\n# Compute the result\nans = 1\nfor v in factors.values():\n    ans *= cmb(n + v - 1, v, fac, inv, mod)\n    ans %= mod\n\nprint(ans)"}
{"problem_id":"p02725","slow_code_col":"K, N = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\n\n\ndiff = A[0] + K - A[-1]\n\nans = A[-1] - A[0]\n\nfor i in range(1, N):\n\n    dist = K - A[i] + A[i - 1]\n\n    if dist < ans:\n\n        ans = dist\n\n\n\nprint(ans)\n","reference_code_col":"import sys\n\n\n\n\n\ndef input():\n\n    return sys.stdin.readline().strip()\n\n\n\n\n\ndef main():\n\n    K, N = list(map(int, input().split()))\n\n    A = list(map(int, input().split()))\n\n\n\n    ans = [K - A[i] + A[i - 1] for i in range(1, N)]\n\n    print((min(min(ans), A[-1] - A[0])))\n\n\n\n\n\nmain()\n","model_generated_potentially_faster_code_col":"# Read inputs\nK, N = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Initialize 'ans' to a large value\nans = float('inf')\n\n# Iterate through the array to find the minimum distance\nfor i in range(1, N):\n    dist = K - A[i] + A[i - 1]\n    if dist < ans:\n        ans = dist\n        if ans == 0:  # Early exit if the smallest possible value is reached\n            break\n\nprint(ans)"}
{"problem_id":"p02837","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\nx = []\n\ny = []\n\nfor i in range(n):\n\n    a = int(sys.stdin.readline().rstrip())\n\n    xy = [sys.stdin.readline().split() for _ in range(a)]\n\n    if not xy:\n\n        x.append(None)\n\n        y.append(None)\n\n        continue\n\n    xi, yi = np.array(xy, np.int64).T\n\n    x.append(xi-1)\n\n    y.append(yi)\n\n\n\ndef main():\n\n\n\n    ans = 0\n\n    for comb in range(2 ** n):\n\n        cnt = 0\n\n        for i in range(n):\n\n            if not comb >> i & 1:\n\n                continue\n\n            if x[i] is None:\n\n                cnt += 1\n\n                continue\n\n            if np.count_nonzero(comb >> x[i] & 1 ^ y[i]):\n\n                break\n\n            cnt += 1\n\n        else:\n\n            ans = max(ans, cnt)\n\n    return ans\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","reference_code_col":"import sys\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\nxy = [[] for _ in range(n)]\n\nfor i in range(n):\n\n    a = int(sys.stdin.readline().rstrip())\n\n    for j in range(a):\n\n        x, y = list(map(int, sys.stdin.readline().split()))\n\n        xy[i].append((x-1, y))\n\n\n\ndef main():\n\n    ans = 0\n\n    for comb in range(2 ** n):\n\n        cnt = 0\n\n        for i in range(n):\n\n            if comb >> i & 1 ^ 1:\n\n                continue\n\n            for x, y in xy[i]:\n\n                if comb >> x & 1 ^ y:\n\n                    break\n\n            else:\n\n                cnt += 1\n\n                continue\n\n            break\n\n        else:\n\n            ans = max(ans, cnt)\n\n    return ans\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Read input efficiently\n    n = int(sys.stdin.readline())\n    constraints = []\n    \n    for _ in range(n):\n        a = int(sys.stdin.readline())\n        if a == 0:\n            constraints.append([])  # No constraints for this person\n        else:\n            xy = [tuple(map(int, sys.stdin.readline().split())) for _ in range(a)]\n            constraints.append([(xi-1, yi) for xi, yi in xy])\n    \n    # Track the maximum count of valid people\n    max_count = 0\n    \n    # Iterate over all possible combinations (2^n)\n    for comb in range(1 << n):  # Equivalent to 2^n\n        valid = True\n        count = 0\n        \n        for i in range(n):\n            if not (comb >> i & 1):  # If the i-th person is not selected\n                continue\n            \n            count += 1  # Count the selected person\n            \n            # Check constraints for the i-th person\n            for xi, yi in constraints[i]:\n                if ((comb >> xi) & 1) != yi:  # Constraint violated\n                    valid = False\n                    break\n            \n            if not valid:  # Stop checking further if invalid\n                break\n        \n        if valid:  # Update maximum count if the combination is valid\n            max_count = max(max_count, count)\n    \n    return max_count\n\nif __name__ == '__main__':\n    print(main())"}
{"problem_id":"p03371","slow_code_col":"import sys\n\ninput = lambda: sys.stdin.readline().rstrip() \n\n\n\ndef resolve():\n\n    A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n    ans = float('inf')\n\n    for i in range(0, max(X, Y)*2+1, 2):\n\n        ans = min(A*max(X-i\/\/2, 0)+B*max(Y-i\/\/2, 0)+C*i, ans)\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    resolve()\n","reference_code_col":"import sys\n\ninput = lambda: sys.stdin.readline().rstrip() \n\n\n\ndef resolve():\n\n    A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n    ans = 0\n\n    if A+B > 2*C:\n\n        ans = 2*C*min(X, Y)+min((A if X>Y else B)*abs(X-Y), 2*C*abs(X-Y))\n\n    else:\n\n        ans = A*X+B*Y\n\n    \n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    resolve()\n","model_generated_potentially_faster_code_col":"import sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef resolve():\n    # Read input values\n    A, B, C, X, Y = map(int, input().split())\n    \n    # Initialize the answer with a large value\n    ans = float('inf')\n    \n    # Determine the maximum value for i\n    max_i = 2 * max(X, Y)\n    \n    # Iterate over all valid values of i (even numbers only)\n    for i in range(0, max_i + 1, 2):\n        # Calculate the remaining quantities of A and B pizzas\n        remaining_X = max(X - i \/\/ 2, 0)\n        remaining_Y = max(Y - i \/\/ 2, 0)\n        \n        # Calculate the total cost\n        cost = A * remaining_X + B * remaining_Y + C * i\n        \n        # Update the minimum cost\n        ans = min(ans, cost)\n        \n        # Early exit if both remaining_X and remaining_Y are zero\n        if remaining_X == 0 and remaining_Y == 0:\n            break\n    \n    # Output the result\n    print(ans)\n\nif __name__ == '__main__':\n    resolve()"}
{"problem_id":"p03416","slow_code_col":"A,B = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(A,B+1):\n\n    i = str(i)\n\n    if i[0] == i[4]:\n\n        if i[1] == i[3]:\n\n            ans += 1\n\n        else:\n\n            ans += 0\n\n    else:\n\n        ans += 0\n\nprint(ans)","reference_code_col":"A,B = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(A,B+1):\n\n    k = str(i)\n\n    if k[0] == k[4] and k[1] == k[3]:\n\n        ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"A, B = map(int, input().split())\n\n# Initialize the answer counter\nans = 0\n\n# Ensure A and B are within the 5-digit range\nA = max(A, 10000)\nB = min(B, 99999)\n\n# Iterate through the valid range\nfor num in range(A, B + 1):\n    # Extract digits mathematically\n    d1 = num \/\/ 10000       # First digit\n    d2 = (num \/\/ 1000) % 10 # Second digit\n    d4 = (num \/\/ 10) % 10   # Fourth digit\n    d5 = num % 10           # Fifth digit\n\n    # Check if the number is a palindrome\n    if d1 == d5 and d2 == d4:\n        ans += 1\n\n# Output the result\nprint(ans)"}
{"problem_id":"p03568","slow_code_col":"def main():\n\n    N = int(input())\n\n    A = [int(i) for i in input().split()]\n\n    if N == 1:\n\n        return print(1 if A[0] % 2 == 0 else 2)\n\n    ans = 0\n\n    d = (-1, 0, 1)\n\n    from itertools import product\n\n    for i in product(range(3), repeat=N):\n\n        cur = 1\n\n        for j in range(N):\n\n            cur *= (A[j] + d[i[j]])\n\n        if cur % 2 == 0:\n\n            ans += 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def main():\n\n    N = int(eval(input()))\n\n    A = [int(i) for i in input().split()]\n\n    ans = 3**N\n\n    cnt = len([a for a in A if a % 2 == 0])\n\n    ans -= 2**cnt\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    N = int(input())\n    A = [int(i) for i in input().split()]\n\n    # Special case for N == 1\n    if N == 1:\n        return print(1 if A[0] % 2 == 0 else 2)\n\n    # Precompute the number of ways to make each element even or odd\n    even_ways = []\n    odd_ways = []\n\n    for num in A:\n        even_count = 0\n        odd_count = 0\n        for delta in (-1, 0, 1):\n            if (num + delta) % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n        even_ways.append(even_count)\n        odd_ways.append(odd_count)\n\n    # Total ways to modify all elements\n    total_ways = 3 ** N\n\n    # Ways to make all elements odd (product will be odd)\n    all_odd_ways = 1\n    for count in odd_ways:\n        all_odd_ways *= count\n\n    # Ways to make the product even = Total ways - All odd ways\n    even_product_ways = total_ways - all_odd_ways\n\n    print(even_product_ways)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02982","slow_code_col":"import numpy as\tnp\n\n\n\nn, d = list(map(int, input().split()))\n\nx = []\n\nfor i in range(n):\n\n    x.append(list(map(int, input().split())))\n\n\n\nx = np.array(x)\n\n\n\ncount =\t0\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        dist = np.linalg.norm(x[i] - x[j])\n\n        if dist == int(dist):\n\n            count += 1\n\n\n\nprint(count)","reference_code_col":"n, d = list(map(int, input().split()))\n\nx = [list(map(int, input().split())) for _ in range(n)]\n\n\n\n\n\ndef dist(a, b):\n\n    sm = 0\n\n    for ea, eb in zip(a, b):\n\n        sm += (ea - eb) ** 2\n\n\n\n    return sm ** 0.5\n\n\n\n\n\nans = 0\n\nfor i in range(n):\n\n    for j in range(i + 1, n):\n\n        dst = dist(x[i], x[j])\n\n        for k in range(int(16000 ** 0.5) + 1):\n\n            if k == dst:\n\n                ans += 1\n\n                break\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input reading\nn, d = map(int, input().split())\nx = [list(map(int, input().split())) for _ in range(n)]\nx = np.array(x)\n\n# Precompute squared distances to avoid repeated sqrt calculations\ncount = 0\nfor i in range(n):\n    # Compute squared differences between x[i] and all other points\n    diff = x[i+1:] - x[i]\n    squared_distances = np.sum(diff**2, axis=1)\n    \n    # Check if squared distances are perfect squares (integer distances)\n    count += np.sum(np.sqrt(squared_distances) == np.sqrt(squared_distances).astype(int))\n\nprint(count)"}
{"problem_id":"p03254","slow_code_col":"import numpy as np\n\nN,x = list(map(int,input().split()))\n\nA = np.array(input().split(), dtype = np.int64)\n\nA.sort()\n\nnp.cumsum(A, out = A)\n\nanswer = (A <= x).sum()\n\n\n\nif answer == N and A[-1] != x:\n\n  answer -= 1\n\nprint(answer)\n","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom bisect import bisect_right\n\nimport itertools\n\n\n\nN,X,*A = list(map(int,read().split()))\n\n\n\nA.sort()\n\nAcum = list(itertools.accumulate(A))\n\n\n\nanswer = bisect_right(Acum,X)\n\nif answer == N:\n\n    if Acum[-1] < X:\n\n        answer -= 1\n\nprint(answer)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN, x = map(int, input().split())\nA = np.fromstring(input(), dtype=np.int64, sep=' ')\n\n# Sort the array\nA.sort()\n\n# Compute cumulative sum and count elements <= x\ncumsum = 0\nanswer = 0\nfor num in A:\n    cumsum += num\n    if cumsum <= x:\n        answer += 1\n    else:\n        break  # Stop early if cumulative sum exceeds x\n\n# Adjust answer if the last cumulative sum is less than x\nif answer == N and cumsum < x:\n    answer -= 1\n\nprint(answer)"}
{"problem_id":"p03425","slow_code_col":"# -*- coding: utf-8 -*-\n\nfrom collections import defaultdict\n\nfrom itertools import combinations\n\nN = int(eval(input()))\n\nC = [0, 0, 0, 0, 0, 0]\n\nD = defaultdict(int)\n\nfor i, m in enumerate(\"MARCH\", start=1):\n\n    D[m] = i\n\n\n\nfor _ in range(N):\n\n    C[D[input()[0]]] += 1\n\n\n\nans = 0\n\nfor a, b, c in combinations(list(range(1, 6)), r=3):\n\n    ans += C[a]*C[b]*C[c]\n\nprint(ans)","reference_code_col":"from collections import defaultdict\n\nfrom itertools import combinations\n\ndef inpl(): return list(map(int, input().split()))\n\n\n\nC = defaultdict(int)\n\nN = int(eval(input()))\n\nfor _ in range(N):\n\n    C[input()[0]] += 1\n\n\n\nres = 0\n\nfor H in combinations(\"MARCH\", r=3):\n\n    res += C[H[0]] * C[H[1]] * C[H[2]]\n\nprint(res)","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nfrom itertools import combinations\n\n# Read input N\nN = int(input())\n\n# Initialize counts for \"MARCH\"\nC = [0] * 5\n\n# Map the first letter of each input to the corresponding index in C\nfor _ in range(N):\n    char = input()[0]\n    if char in \"MARCH\":\n        C[\"MARCH\".index(char)] += 1\n\n# Precompute all pairwise products\npairwise_products = [C[i] * C[j] for i, j in combinations(range(5), 2)]\n\n# Compute the final result\nans = sum(pairwise_products[k] * C[m] for k, m in combinations(range(5), 2))\n\nprint(ans)"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nN = int(eval(input()))\n\n\n\nprint((math.factorial(N) % (1000000000 + 7)))\n","reference_code_col":"import math\n\n\n\nN = int(eval(input()))\n\n\n\np = 1\n\nfor i in range(2, N+1):\n\n  p *= i\n\n  p = p % (1000000000 + 7)\n\n  \n\nprint(p)\n","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7  # Define the modulus as a constant\n\n# Read input and convert to integer\nN = int(input())\n\n# Compute factorial modulo MOD iteratively\nresult = 1\nfor i in range(1, N + 1):\n    result = (result * i) % MOD\n\nprint(result)"}
{"problem_id":"p03309","slow_code_col":"def main():\n\n    from statistics import median\n\n\n\n    n, *a, = list(map(int, open(0).read().split()))\n\n    a = [x - i for i, x in enumerate(a, 1)]\n\n    a.sort()\n\n    m = int(median(a))\n\n\n\n    ans = sum([abs(x - m) for x in a])\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def main():\n\n    n, *a, = list(map(int, open(0).read().split()))\n\n    a = [x - i for i, x in enumerate(a, 1)]\n\n    a.sort()\n\n    if n % 2 == 0:\n\n        ans = sum(a[n \/\/ 2:]) - sum(a[:n \/\/ 2])\n\n    else:\n\n        ans = sum(a[n \/\/ 2 + 1:]) - sum(a[:n \/\/ 2])\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Read input and parse values\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    a = [int(x) - (i + 1) for i, x in enumerate(data[1:])]\n\n    # Sort the transformed list\n    a.sort()\n\n    # Compute the median manually\n    mid = n \/\/ 2\n    m = a[mid] if n % 2 == 1 else (a[mid - 1] + a[mid]) \/\/ 2\n\n    # Compute the sum of absolute differences\n    ans = sum(abs(x - m) for x in a)\n\n    # Output the result\n    print(ans)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03037","slow_code_col":"N, M = list(map(int, input().split()))\n\nL, R = [], []\n\nlow = -float('INF')\n\nhigh = float('INF')\n\nfor i in range(M):\n\n    l, r = list(map(int, input().split()))\n\n    L.append(l)\n\n    R.append(r)\n\n    if l > low:\n\n        low = l\n\n    if r < high:\n\n        high = r\n\nprint((max(0, high - low + 1)))\n","reference_code_col":"N, M = list(map(int, input().split()))\n\nlow = -float('INF')\n\nhigh = float('INF')\n\nfor i in range(M):\n\n    l, r = list(map(int, input().split()))\n\n    if l > low:\n\n        low = l\n\n    if r < high:\n\n        high = r\n\nprint((max(0, high - low + 1)))\n","model_generated_potentially_faster_code_col":"# Read N and M\nN, M = map(int, input().split())\n\n# Initialize low and high\nlow = -float('inf')\nhigh = float('inf')\n\n# Process each pair (l, r)\nfor _ in range(M):\n    l, r = map(int, input().split())\n    if l > low:\n        low = l\n    if r < high:\n        high = r\n\n# Calculate and print the result\nprint(max(0, high - low + 1))"}
{"problem_id":"p03837","slow_code_col":"def main():\n\n    from sys import stdin\n\n    def input():\n\n        return stdin.readline().strip()\n\n\n\n    n, m = list(map(int, input().split()))\n\n    tree = [[] for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        i -= 1\n\n        j -= 1\n\n        tree[i].append((k, j))\n\n        tree[j].append((k, i))\n\n\n\n    # dijkstra\n\n    import heapq\n\n    from numpy import zeros\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in tree[i]:\n\n            seen = zeros(n)\n\n            goal = j[1]\n\n            base = j[0]\n\n            seen[i] = 1\n\n            todo = []\n\n            heapq.heapify(todo)\n\n            for k in tree[i]:\n\n                if k[0] < base and k != j:\n\n                    heapq.heappush(todo, k)\n\n            while len(todo) > 0:\n\n                k = heapq.heappop(todo)\n\n                if k[1] == goal:\n\n                    if k[0] < base:\n\n                        ans += 1\n\n                    break\n\n                seen[k[1]] = 1\n\n                for l in tree[k[1]]:\n\n                    if seen[l[1]] == 0 and k[0] + l[0] < base:\n\n                        heapq.heappush(todo, (k[0] + l[0], l[1]))\n\n\n\n    print((ans \/\/ 2))\n\n\n\nmain()","reference_code_col":"def main():\n\n    from sys import stdin\n\n    def input():\n\n        return stdin.readline().strip()\n\n\n\n    n, m = list(map(int, input().split()))\n\n    tree = [[] for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        i -= 1\n\n        j -= 1\n\n        tree[i].append((k, j))\n\n        tree[j].append((k, i))\n\n\n\n    # dijkstra\n\n    import heapq\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in tree[i]:\n\n            seen = [0] * n\n\n            goal = j[1]\n\n            base = j[0]\n\n            seen[i] = 1\n\n            todo = []\n\n            heapq.heapify(todo)\n\n            for k in tree[i]:\n\n                if k[0] < base and k != j:\n\n                    heapq.heappush(todo, k)\n\n            while len(todo) > 0:\n\n                k = heapq.heappop(todo)\n\n                if k[1] == goal:\n\n                    if k[0] < base:\n\n                        ans += 1\n\n                    break\n\n                seen[k[1]] = 1\n\n                for l in tree[k[1]]:\n\n                    if seen[l[1]] == 0 and k[0] + l[0] < base:\n\n                        heapq.heappush(todo, (k[0] + l[0], l[1]))\n\n\n\n    print((ans \/\/ 2))\n\n\n\nmain()","model_generated_potentially_faster_code_col":"from sys import stdin\nimport heapq\n\ndef main():\n    def input():\n        return stdin.readline().strip()\n\n    # Input parsing\n    n, m = map(int, input().split())\n    tree = [[] for _ in range(n)]\n    edges = []\n\n    for _ in range(m):\n        i, j, k = map(int, input().split())\n        i -= 1\n        j -= 1\n        tree[i].append((k, j))\n        tree[j].append((k, i))\n        edges.append((i, j, k))\n\n    # Precompute shortest paths using Dijkstra's algorithm for each node\n    INF = float('inf')\n    shortest_paths = [[INF] * n for _ in range(n)]\n\n    for start in range(n):\n        # Dijkstra's algorithm\n        distances = [INF] * n\n        distances[start] = 0\n        heap = [(0, start)]  # (distance, node)\n\n        while heap:\n            current_dist, u = heapq.heappop(heap)\n            if current_dist > distances[u]:\n                continue\n\n            for weight, v in tree[u]:\n                new_dist = current_dist + weight\n                if new_dist < distances[v]:\n                    distances[v] = new_dist\n                    heapq.heappush(heap, (new_dist, v))\n\n        # Store the shortest paths from 'start' to all other nodes\n        for v in range(n):\n            shortest_paths[start][v] = distances[v]\n\n    # Count valid paths\n    ans = 0\n    for i, j, k in edges:\n        if shortest_paths[i][j] < k:\n            ans += 1\n\n    print(ans \/\/ 2)\n\nmain()"}
{"problem_id":"p03197","slow_code_col":"import numpy as np\n\n \n\ndef main():\n\n    stdin = np.fromstring(open(0).read(), dtype=np.int64, sep=' ')\n\n    A = stdin[1:]\n\n    A = np.mod(A, 2)\n\n    print(\"first\") if np.count_nonzero(A) else print(\"second\")\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"import sys\n\ndef input(): return sys.stdin.readline().strip()\n\ndef main():\n\n    N = int(input())\n\n    A = (int(input()) for _ in range(N))\n\n    print(\"second\") if all(( a%2==0 for a in A)) else print(\"first\")\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import numpy as np\nimport sys\n\ndef main():\n    # Read all input from stdin at once\n    stdin = sys.stdin.read()\n    \n    # Convert input into a NumPy array of int64, skipping the first element\n    A = np.fromstring(stdin, dtype=np.int64, sep=' ')[1:]\n    \n    # Use bitwise AND to check for odd numbers (faster than modulo)\n    has_odd = np.any(A & 1)\n    \n    # Print result based on whether there are odd numbers\n    print(\"first\" if has_odd else \"second\")\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02555","slow_code_col":"a,b,c=1,0,0\n\nexec('a,b,c=b,c,(a+c)%(10**9+7);'*(int(eval(input()))-2))\n\nprint(c)","reference_code_col":"a,b,c=1,0,0\n\nexec('a,b,c=b,c,a+c;'*(int(eval(input()))-2))\n\nprint((c%(10**9+7)))","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\n# Read input\nn = int(input())\n\n# Initial values\na, b, c = 1, 0, 0\n\n# Compute the nth term iteratively\nfor _ in range(n - 2):\n    a, b, c = b, c, (a + c) % MOD\n\n# Output the result\nprint(c)"}
{"problem_id":"p02615","slow_code_col":"# -*- coding: utf-8 -*-\n\n# \u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30a4\u30f3\u30dd\u30fc\u30c8\n\nimport math\n\nimport numpy as np\n\n\n\n# \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\n# \u6c42\u89e3\u51e6\u7406\n\nA = sorted(A, reverse=True)\n\nA = np.array(A)\n\nans = 2 * np.sum(A[:(N \/\/ 2)]) - A[0] + (N % 2) * A[math.floor(N \/ 2)]\n\n\n\n# \u7d50\u679c\u51fa\u529b\n\nprint(ans)\n","reference_code_col":"# -*- coding: utf-8 -*-\n\n# \u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30a4\u30f3\u30dd\u30fc\u30c8\n\nimport math\n\n\n\n# \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\n# \u6c42\u89e3\u51e6\u7406\n\nA = sorted(A, reverse=True)\n\nans = 0\n\nfor n in range(1, N + 1):\n\n    if n == 1:\n\n        continue\n\n    ans += A[math.ceil(n \/ 2) - 1]\n\n\n\n# \u7d50\u679c\u51fa\u529b\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\n# \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97\nN = int(input())\nA = list(map(int, input().split()))\n\n# \u914d\u5217\u3092\u964d\u9806\u306b\u30bd\u30fc\u30c8\nA.sort(reverse=True)\n\n# \u4e0a\u4f4d\u534a\u5206\u306e\u8981\u7d20\u306e\u5408\u8a08\u3092\u8a08\u7b97\nhalf_sum = sum(A[:N \/\/ 2])\n\n# \u7d50\u679c\u3092\u8a08\u7b97\nif N % 2 == 0:\n    ans = 2 * half_sum - A[0]\nelse:\n    ans = 2 * half_sum - A[0] + A[N \/\/ 2]\n\n# \u7d50\u679c\u51fa\u529b\nprint(ans)"}
{"problem_id":"p03371","slow_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\n\n\nz = max(x,y) * 2\n\nmin_sum = c * z\n\n\n\nfor i in range(z):\n\n    r = max(0, y - i) * b\n\n    t = max(0, x - i) * a\n\n    sum = c * i * 2 + r + t\n\n    if sum < min_sum:\n\n        min_sum = sum\n\n\n\nprint(min_sum)","reference_code_col":"a,b,c,x,y = list(map(int, input().split()))\n\n\n\nplan_a = c * (2*x) + max(0, y-x) * b\n\nplan_b = c * (2*y) + max(0, x-y) * a\n\nplan_c = a * x + b * y\n\n\n\nprint((min(plan_a, plan_b, plan_c)))","model_generated_potentially_faster_code_col":"# Input parsing\na, b, c, x, y = map(int, input().split())\n\n# Initialize variables\nz = max(x, y) * 2\nmin_sum = c * z\n\n# Precompute constants for efficiency\nmax_x = x\nmax_y = y\n\n# Loop with reduced range and early termination\nfor i in range(min(z, max(x, y) + 1)):  # Reduce range to max(x, y) + 1\n    r = max(0, y - i) * b\n    t = max(0, x - i) * a\n    current_sum = c * i * 2 + r + t\n\n    if current_sum < min_sum:\n        min_sum = current_sum\n    else:\n        # Early termination: sum will only increase from this point\n        break\n\nprint(min_sum)"}
{"problem_id":"p03796","slow_code_col":"N = int(eval(input()))\n\na = 1\n\nfor n in range(2,N+1):\n\n    a = a*n % (10**9+7)\n\nprint(a)","reference_code_col":"def factorial(N):\n\n    a = 1\n\n    for n in range(2,N+1):\n\n        a = a*n % (10**9 + 7)\n\n    return a\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))","model_generated_potentially_faster_code_col":"N = int(eval(input()))\n\na = 1\n\nfor n in range(2, N + 1):\n    a = a * n % (10**9 + 7)\n\nprint(a)"}
{"problem_id":"p03371","slow_code_col":"# -*- coding: utf-8 -*-\n\n\n\nA, B, C, X, Y = list(map(int, input().split()))\n\n\n\ncost = int(1e10)\n\nfor num_ac in range(0, int(1e5) + 1):\n\n    num_A = max(0, X - num_ac)\n\n    num_B = max(0, Y - num_ac)\n\n    c = 2 * C * num_ac + A * num_A + B * num_B\n\n    cost = min(c, cost)\n\nprint(cost)","reference_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = 0\n\nif A + B > 2 * C:\n\n    z = min(X, Y)\n\n    X -= z\n\n    Y -= z\n\n    ans += 2 * z * C\n\n\n\n# \u504f\u308a\u5206\n\nif 2 * C < A:\n\n    k = X\n\n    X -= k\n\n    Y -= k\n\n    ans += 2 * C * k\n\nif 2 * C < B:\n\n    k = Y\n\n    X -= k\n\n    Y -= k\n\n    ans += 2 * C * k\n\n\n\n# \u3042\u307e\u308a\u5206\n\nans += A * max(0, X) + B * max(0, Y)\n\nprint(ans)","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\n# Input variables\nA, B, C, X, Y = map(int, input().split())\n\n# Initialize the minimum cost to a very large value\ncost = float('inf')\n\n# Limit the range of num_ac to max(X, Y)\nfor num_ac in range(max(X, Y) + 1):\n    # Calculate the remaining units of A and B needed\n    num_A = max(0, X - num_ac)\n    num_B = max(0, Y - num_ac)\n    \n    # Calculate the total cost for the current combination\n    c = 2 * C * num_ac + A * num_A + B * num_B\n    \n    # Update the minimum cost\n    cost = min(c, cost)\n\n# Output the minimum cost\nprint(cost)"}
{"problem_id":"p03170","slow_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom operator import xor\n\nfrom functools import reduce\n\n\n\nN,K,*A = list(map(int,read().split()))\n\n\n\na = reduce(xor,(1<<a for a in A))\n\n\n\ndp = 0 # bitset\n\nfor n in range(K):\n\n    if not(dp&(1<<n)):\n\n        dp |= (a<<n)\n\n\n\nanswer = 'First' if dp&(1<<K) else 'Second'\n\nprint(answer)","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN,K,*A = list(map(int,read().split()))\n\n\n\ndp = [0]*(K+1) # bitset\n\nfor n in range(K):\n\n    if not dp[n]:\n\n        for a in A:\n\n            if n+a>K:\n\n                break\n\n            dp[n+a]=1\n\n\n\nanswer = 'First' if dp[-1] else 'Second'\n\nprint(answer)","model_generated_potentially_faster_code_col":"import sys\n\n# Efficient input reading\nread = sys.stdin.buffer.read\n\n# Read input values\nN, K, *A = map(int, read().split())\n\n# Compute the XOR bitmask `a` using unique elements in A\nunique_A = set(A)\na = reduce(xor, (1 << x for x in unique_A), 0)\n\n# Initialize dp as 0\ndp = 0\n\n# Update dp using bitwise operations\nfor n in range(K):\n    if not (dp & (1 << n)):\n        dp |= (a << n)\n\n# Check if the K-th bit is set in dp\nanswer = 'First' if dp & (1 << K) else 'Second'\n\n# Output the result\nprint(answer)"}
{"problem_id":"p03060","slow_code_col":"import numpy as np\n\n\n\nn = int(eval(input()))\n\n\n\nv_list = np.array(list(map(int,input().split())))\n\nc_list = np.array(list(map(int,input().split())))\n\ne_list = list(v_list - c_list)\n\n\n\nans = 0\n\n\n\nfor i in range(n):\n\n    if e_list[i] > 0:\n\n        ans += e_list[i]\n\n\n\nprint(ans)\n","reference_code_col":"n = int(eval(input()))\n\n\n\nv_list = list(map(int,input().split()))\n\nc_list = list(map(int,input().split()))\n\n\n\ne_list = [v-c if (v-c > 0) else 0 for v,c in zip(v_list, c_list)]\n\n\n\nprint((sum(e_list)))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn = int(input())  # Directly use input() instead of eval(input())\nv_list = np.fromstring(input(), dtype=int, sep=' ')  # Efficiently parse input into a NumPy array\nc_list = np.fromstring(input(), dtype=int, sep=' ')  # Efficiently parse input into a NumPy array\n\n# Compute element-wise difference\ne_list = v_list - c_list\n\n# Use NumPy's vectorized operations to sum only positive values\nans = np.sum(e_list[e_list > 0])\n\n# Print the result\nprint(ans)"}
{"problem_id":"p02624","slow_code_col":"n = int(eval(input()))\n\nans = 0\n\nSQRT = int(n ** 0.5)\n\nfor m in range(1,SQRT + 1):\n\n    b = int(n\/m)\n\n    ans += m * (m + b) * (b + 1 - m)\n\nans -= SQRT * (SQRT+1) * (2*SQRT+1) \/\/ 6\n\nprint(ans)","reference_code_col":"def main():\n\n  n = int(eval(input()))\n\n  ans = 0\n\n  SQRT = int(n ** 0.5)\n\n  for m in range(1,SQRT + 1):\n\n    b = int(n\/m)\n\n    ans += m * (m + b) * (b + 1 - m)\n\n  ans -= SQRT * (SQRT+1) * (2*SQRT+1) \/\/ 6\n\n  print(ans)\n\nmain()\n","model_generated_potentially_faster_code_col":"n = int(eval(input()))\n\nans = 0\nSQRT = int(n ** 0.5)\n\n# Precompute the correction term\ncorrection = SQRT * (SQRT + 1) * (2 * SQRT + 1) \/\/ 6\n\n# Loop with reduced computations\nfor m in range(1, SQRT + 1):\n    b = n \/\/ m\n    ans += m * b * (b + 1)\n\n# Subtract the correction term\nans -= correction\n\nprint(ans)"}
{"problem_id":"p03173","slow_code_col":"import numpy as np\n\n\n\nN = int(eval(input()))\n\nA = [0] + list(map(int, input().split()))\n\n\n\nA = np.array(A, dtype = np.int64)\n\nA = np.cumsum(A)\n\n\n\ndp = np.zeros((N, N), dtype = np.int64)\n\n\n\nfor j in range(1, N):\n\n    for i in range(N - j):\n\n        # print (dp[i, i:i + j], dp[i + 1:i + j + 1, i + j])\n\n        tmp = min(dp[i, i:i + j] + dp[i + 1:i + j + 1, i + j])\n\n        dp[i][i + j] = tmp + A[i + j + 1] - A[i]\n\n\n\nprint((dp[0][N - 1]))","reference_code_col":"N = int(eval(input()))\n\nA = [0] + list(map(int, input().split()))\n\n\n\nINF = 10 ** 18\n\n\n\ndp = [[0] * (N) for _ in range(N)]\n\n\n\nfor i in range(N):\n\n    A[i + 1] += A[i]\n\n\n\nfor j in range(1, N):\n\n    for i in range(N - j):\n\n        tmp = INF\n\n        for k in range(i, i + j):\n\n            # print (i, i + j, k + 1)\n\n            tmp = min(tmp, dp[i][k] + dp[k + 1][i + j])\n\n        dp[i][i + j] = tmp + A[i + j + 1] - A[i]\n\n\n\nprint((dp[0][N - 1]))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN = int(input())\nA = [0] + list(map(int, input().split()))\n\n# Convert to NumPy array and compute cumulative sum\nA = np.array(A, dtype=np.int64)\nA = np.cumsum(A)\n\n# Initialize DP table\ndp = np.zeros((N, N), dtype=np.int64)\n\n# Fill the DP table\nfor j in range(1, N):  # Length of the interval\n    for i in range(N - j):  # Start index of the interval\n        # Compute the minimum value efficiently\n        min_val = float('inf')\n        for k in range(i, i + j):\n            min_val = min(min_val, dp[i][k] + dp[k + 1][i + j])\n        \n        # Update DP table\n        dp[i][i + j] = min_val + (A[i + j + 1] - A[i])\n\n# Output the result\nprint(dp[0][N - 1])"}
{"problem_id":"p03828","slow_code_col":"import math\n\nimport collections\n\n\n\nN = int(eval(input()))\n\na = math.factorial(N)\n\ncheck = []\n\nans = 1\n\ni = 2\n\n\n\nwhile a != 1:\n\n    if a % i == 0:\n\n        a \/\/= i\n\n        check.append(i)\n\n    else:\n\n        i += 1\n\n        \n\ncheck = list(collections.Counter(check).values())\n\nfor i in check:\n\n    ans *= (i+1)\n\n    ans %= 10**9+7\n\nprint(ans)","reference_code_col":"from math import factorial\n\n\n\nN = factorial(int(eval(input())))\n\n\n\ni = 2\n\ncheck = 1\n\nans = 1\n\nwhile N != 1:\n\n    if N % i == 0:\n\n        N \/\/= i\n\n        check += 1\n\n    else:\n\n        ans *= check\n\n        check = 1\n\n        i += 1\n\nprint(((ans*check)%(10**9+7)))","model_generated_potentially_faster_code_col":"import math\n\nMOD = 10**9 + 7\n\ndef sieve_of_eratosthenes(n):\n    \"\"\"Generate all primes up to n using the Sieve of Eratosthenes.\"\"\"\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n + 1, i):\n                is_prime[j] = False\n    return [x for x in range(n + 1) if is_prime[x]]\n\ndef count_factors_in_factorial(n, p):\n    \"\"\"Count how many times prime p divides n! using Legendre's formula.\"\"\"\n    count = 0\n    power = p\n    while power <= n:\n        count += n \/\/ power\n        power *= p\n    return count\n\n# Input\nN = int(input())\n\n# Step 1: Generate all primes up to N\nprimes = sieve_of_eratosthenes(N)\n\n# Step 2: Compute the exponents of primes in N!\nprime_exponents = [count_factors_in_factorial(N, p) for p in primes]\n\n# Step 3: Calculate the divisor count modulo 10^9 + 7\nans = 1\nfor exp in prime_exponents:\n    ans = (ans * (exp + 1)) % MOD\n\n# Output\nprint(ans)"}
{"problem_id":"p02988","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nP = np.array(lr())\n\n\n\nP_diff = np.diff(P)\n\nP_diff = P_diff > 0\n\nseries = P_diff[:-1] == P_diff[1:]\n\nanswer = series.sum()\n\nprint(answer)\n\n# 23","reference_code_col":"N = int(eval(input()))\n\nP = list(map(int, input().split()))\n\nanswer = sum(x>y>z or x<y<z for x, y, z in zip(P[:-2], P[1:-1], P[2:]))\n\nprint(answer)\n\n    ","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Input reading functions\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n# Read input\nN = ir()\nP = np.array(lr(), dtype=np.int32)\n\n# Compute the answer in a single pass\nanswer = ((P[1:-1] - P[:-2]) * (P[2:] - P[1:-1]) > 0).sum()\n\nprint(answer)"}
{"problem_id":"p02982","slow_code_col":"import numpy as np\n\nn,d=list(map(int,input().split()))\n\nnda=np.empty((0,d),int)\n\nans=0\n\nfor i in range(0,n):\n\n  a=np.array([list(map(int,input().split()))])\n\n  for j in range(i):\n\n    chklen=np.linalg.norm(a-nda[j])\n\n    if chklen==chklen\/\/1:\n\n      ans+=1\n\n  nda=np.append(nda,a,axis=0)\n\nprint(ans)","reference_code_col":"import math\n\nn,d=list(map(int,input().split()))\n\na=[0]*n\n\nfor i in range(n):\n\n  a[i]=list(map(int,input().split()))\n\nans=0\n\nfor i in range(n-1):\n\n  for j in range(i+1,n):\n\n    chklen=0\n\n    wk=0\n\n    for k in range(d):\n\n      wk+=abs(a[i][k]-a[j][k])**2\n\n    chklen=math.sqrt(wk)\n\n    if chklen==chklen\/\/1:\n\n      ans+=1\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input: n (number of points), d (dimensionality)\nn, d = map(int, input().split())\n\n# Preallocate the array to store all points\nnda = np.empty((n, d), dtype=int)\n\n# Counter for pairs with integer distances\nans = 0\n\n# Read all points and compute distances efficiently\nfor i in range(n):\n    # Read the current point\n    nda[i] = list(map(int, input().split()))\n    \n    # Compare the current point with all previous points\n    for j in range(i):\n        # Compute squared Euclidean distance\n        squared_distance = np.sum((nda[i] - nda[j]) ** 2)\n        \n        # Check if squared distance is a perfect square\n        sqrt_dist = int(squared_distance ** 0.5)\n        if sqrt_dist * sqrt_dist == squared_distance:\n            ans += 1\n\n# Output the result\nprint(ans)"}
{"problem_id":"p03371","slow_code_col":"A,B,C,X,Y=list(map(int,input().split()))\n\n\n\nK=10**9\n\nfor i in range(10**5+1):\n\n    S=i*2*C+max(0,X-i)*A+max(0,Y-i)*B\n\n    K=min(K,S)\n\nprint(K)","reference_code_col":"A,B,C,X,Y=list(map(int,input().split()))\n\n\n\na=min(X,Y)*min(A+B,2*C)\n\n\n\na+=max(0,X-Y)*min(A,2*C)\n\na+=max(0,Y-X)*min(B,2*C)\n\n\n\n\n\nprint(a)","model_generated_potentially_faster_code_col":"# Input values\nA, B, C, X, Y = list(map(int, input().split()))\n\n# Initialize K with a large value\nK = float('inf')\n\n# Evaluate S at critical points: i = 0, i = X, i = Y\nfor i in [0, X, Y]:\n    S = i * 2 * C + max(0, X - i) * A + max(0, Y - i) * B\n    K = min(K, S)\n\n# Evaluate S for i > max(X, Y), where max(0, X - i) = 0 and max(0, Y - i) = 0\ni = max(X, Y)\nS = i * 2 * C\nK = min(K, S)\n\n# Output the result\nprint(K)"}
{"problem_id":"p03032","slow_code_col":"N, K = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\nanswer = 0\n\nlimit = min(N, K)\n\nfor a in range(limit+1): #\u5de6\u304b\u3089\u53d6\u308a\u51fa\u3059\n\n    for b in range(limit-a+1): #\u53f3\u304b\u3089\u53d6\u308a\u51fa\u3059\n\n        for c in range(K-(a+b)+1):\n\n            use = V[:a] + V[N-b:]\n\n            use.sort()\n\n            s = sum(use[c:])\n\n            answer = max(answer, s)\n\n\n\nprint(answer)","reference_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 9)\n\n\n\nN, K = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\nV2 = V * 2\n\nanswer = 0\n\nfor i in range(1, min(N, K)+1): # i\u306f\u5b9d\u77f3\u3092\u53d6\u308a\u51fa\u3059\u500b\u6570\n\n    for j in range(0, min(i, K-i)+1): # j\u306f\u4f55\u500b\u306e\u5b9d\u77f3\u3092\u624b\u96e2\u3059\u304b\n\n        for k in range(max(0, N-i), N+1): # V2\u306e\u4e2d\u3067\u4f55\u756a\u76ee\u304b\u3089\u53d6\u308a\u51fa\u3059\u304b\n\n            use = V2[k:k+i]\n\n            use.sort()\n\n            s = sum(use[j:])\n\n            if s > answer:\n\n                answer = s\n\n\n\nprint(answer)\n","model_generated_potentially_faster_code_col":"import heapq\n\n# Read input\nN, K = map(int, input().split())\nV = list(map(int, input().split()))\n\nanswer = 0\nlimit = min(N, K)\n\n# Precompute prefix and suffix sums\nprefix_sums = [0] * (N + 1)\nsuffix_sums = [0] * (N + 1)\n\nfor i in range(1, N + 1):\n    prefix_sums[i] = prefix_sums[i - 1] + V[i - 1]\n    suffix_sums[N - i] = suffix_sums[N - i + 1] + V[N - i]\n\n# Iterate over all combinations of left and right elements\nfor a in range(limit + 1):  # Left elements\n    for b in range(limit - a + 1):  # Right elements\n        total_elements = a + b\n        if total_elements > K:\n            continue\n\n        # Get the combined list of elements from left and right\n        use = V[:a] + V[N - b:]\n\n        # Use a min-heap to remove the smallest elements\n        heapq.heapify(use)\n        max_discard = K - total_elements\n        for _ in range(min(max_discard, len(use))):\n            heapq.heappop(use)\n\n        # Calculate the sum of the remaining elements\n        s = sum(use)\n        answer = max(answer, s)\n\nprint(answer)"}
{"problem_id":"p02390","slow_code_col":"S = int(input())\n\n\n\nif S >= 3600:\n\n    h=S\/\/3600\n\n    m=S%3600\/\/60\n\n    s=S%60\n\nelif 3600 > S >= 60:\n\n    h=0\n\n    m=S\/\/60\n\n    s=S%60\n\nelse:\n\n    h=m=0\n\n    s=S\n\nprint(h, m, s, sep=\":\")\n","reference_code_col":"s = int(input())\n\nh = s \/\/ 3600\n\nm = (s - h * 3600) \/\/ 60\n\ns = s -  h * 3600 - m * 60\n\nprint(h, m, s, sep=\":\")\n","model_generated_potentially_faster_code_col":"S = int(input())\n\nh = S \/\/ 3600\nS %= 3600\nm = S \/\/ 60\ns = S % 60\n\nprint(h, m, s, sep=\":\")"}
{"problem_id":"p03806","slow_code_col":"def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1<<30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(400, -1, -1):\n\n\t\t\tfor j in range(400, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\nif __name__==\"__main__\":\n\n\tmain()","reference_code_col":"def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1 << 30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tua = ub = 15\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(ua, -1, -1):\n\n\t\t\tfor j in range(ub, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\t\t\t\t\tif ua < i + a:\n\n\t\t\t\t\t\tua = i + a\n\n\t\t\t\t\tif ub < j + b:\n\n\t\t\t\t\t\tub = j + b\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()\n","model_generated_potentially_faster_code_col":"def main():\n    import sys\n    from itertools import zip_longest\n\n    # Read input efficiently\n    n, ma, mb, *L = map(int, sys.stdin.read().split())\n\n    M = 1 << 30  # A large constant representing infinity\n\n    # Initialize DP table with reduced size\n    dp = [[M] * 420 for _ in range(420)]\n    dp[0][0] = 0\n\n    # Process each item (a, b, c)\n    for a, b, c in zip(*[iter(L)] * 3):\n        # Iterate backwards to avoid overwriting values prematurely\n        for i in range(400, -1, -1):\n            for j in range(400, -1, -1):\n                if dp[i][j] < M:  # Only update if the current value is valid\n                    t = dp[i][j] + c\n                    if dp[i + a][j + b] > t:\n                        dp[i + a][j + b] = t\n\n    # Find the minimum cost for the target ratio (ma:mb)\n    ans = M\n    _ma, _mb = ma, mb\n\n    # Efficiently search for the minimum cost\n    while _ma < 410 and _mb < 410:\n        ans = min(ans, dp[_ma][_mb])\n        _ma += ma\n        _mb += mb\n\n    # Output the result\n    print(ans if ans < M else -1)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\n\n\nn = int(eval(input()))\n\na = np.array(list(map(int,input().split())))\n\n\n\ncount = 0\n\nwhile np.all(a%2==0):\n\n    count+=1\n\n    a=a\/2\n\nprint(count)\n","reference_code_col":"N=int(eval(input()))\n\na = [int(i) for i in input().split()]\n\n\n\ncount=0\n\nwhile 1:\n\n    if sum([i%2 for i in a]) == 0:\n\n        a = [i\/2 for i in a]\n\n        count=count+1\n\n    else:\n\n        print(count)\n\n        break\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input\nn = int(input())\na = np.array(list(map(int, input().split())))\n\n# Function to count how many times a number can be divided by 2\ndef count_divisions(x):\n    count = 0\n    while x & 1 == 0:  # Check if x is even\n        x >>= 1        # Divide x by 2 (bitwise right shift)\n        count += 1\n    return count\n\n# Compute the minimum number of divisions across all elements\nmin_count = min(count_divisions(x) for x in a)\n\nprint(min_count)"}
{"problem_id":"p03434","slow_code_col":"_,s=open(c:=0)\n\nfor a in sorted(map(int,s.split())):c=a-c\n\nprint(c)","reference_code_col":"for a in sorted(map(int,[*open(c:=0)][1].split())):c=a-c\n\nprint(c)","model_generated_potentially_faster_code_col":"_, s = open(c := 0)\n\nfor a in map(int, s.split()):\n    c = a - c\n\nprint(c)"}
{"problem_id":"p02883","slow_code_col":"import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n \n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n \n\n    num = 0\n\n    sum_ = []\n\n    for i in range(N):\n\n      sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 90):\n\n        number = 0\n\n        mid = (left + right) \/\/ 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) \/ F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # \u6700\u5927\u5024\u3092mid\u3088\u308a\u5c0f\u3055\u304f\u3067\u304d\u306a\u3044 -> \u6700\u5927\u5024\u306f\u3082\u3063\u3068\u3067\u304b\u3044\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n        \n\n \n\n \n\n \n\nif __name__ == '__main__':\n\n    main()","reference_code_col":"import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n\n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n\n\n    num = 0\n\n    sum_ = []\n\n    for i in range(len(A)):\n\n        sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 50):\n\n        number = 0\n\n        mid = (left + right) \/\/ 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) \/ F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # \u6700\u5927\u5024\u3092mid\u3088\u308a\u5c0f\u3055\u304f\u3067\u304d\u306a\u3044 -> \u6700\u5927\u5024\u306f\u3082\u3063\u3068\u3067\u304b\u3044\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Fast input reading\n    N, K = map(int, sys.stdin.readline().split())\n    A = list(map(int, sys.stdin.readline().split()))\n    F = list(map(int, sys.stdin.readline().split()))\n    \n    # Sorting\n    A.sort()\n    F.sort(reverse=True)\n    \n    # Binary search bounds\n    left = 0\n    right = 10**12\n    \n    while left < right:\n        mid = (left + right) \/\/ 2\n        operations = 0\n        \n        # Calculate the number of operations needed\n        for i in range(N):\n            if A[i] * F[i] > mid:\n                operations += (A[i] * F[i] - mid + F[i] - 1) \/\/ F[i]\n        \n        # Adjust binary search bounds\n        if operations > K:\n            left = mid + 1\n        else:\n            right = mid\n    \n    # Output the result\n    print(left)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p00134","slow_code_col":"from statistics import mean\n\n\n\ninputCount = int(eval(input()))\n\nprices = [int(eval(input())) for lp in range(inputCount)]\n\naverage = mean(prices)\n\nprint((int(average)))\n\n\n","reference_code_col":"inputCount = int(eval(input()))\n\nprices = [int(eval(input())) for lp in range(inputCount)]\n\naverage = sum(prices) \/\/ inputCount\n\nprint(average)\n\n\n","model_generated_potentially_faster_code_col":"# Read the number of inputs\ninputCount = int(input())\n\n# Initialize sum and process inputs in a single pass\ntotal = 0\nfor _ in range(inputCount):\n    total += int(input())\n\n# Compute the average manually\naverage = total \/\/ inputCount  # Use integer division to match the original behavior\n\n# Print the result\nprint(average)"}
{"problem_id":"p03559","slow_code_col":"from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nimport sys,bisect,math,itertools,fractions,pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn = inp()\n\nA = sorted(inpl())\n\nB = sorted(inpl())\n\nC = sorted(inpl())\n\ncnt = [0] * n\n\nres = 0\n\nfor i,b in enumerate(B):\n\n    c = bisect.bisect_left(C,b+1)\n\n    cnt[i] = n-c\n\n\n\nacc = [0]\n\nfor x in cnt:\n\n    acc += [acc[-1] + x]\n\nsu = sum(cnt) \n\nfor i,a in enumerate(A):\n\n    c = bisect.bisect_left(B,a+1)\n\n    res += su - acc[c]\n\nprint(res)","reference_code_col":"from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nimport sys,bisect,math,itertools,fractions,pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn = inp()\n\na = inpl()\n\nb = inpl()\n\nc = inpl()\n\na.sort()\n\nb.sort()\n\nc.sort()\n\nlb = [0] * n\n\nres = 0\n\nfor i in range(n):\n\n    tmp = bisect.bisect_right(b,a[i])\n\n    if tmp == n: continue\n\n    lb[tmp] += 1\n\nllb = list(itertools.accumulate(lb))\n\n# print(lb,llb)\n\nrr = [0] * n\n\nfor i in range(n):\n\n    tmp = bisect.bisect_right(c,b[i])\n\n    if tmp == n: continue\n\n    rr[tmp] += llb[i]\n\nprint((sum(list(itertools.accumulate(rr)))))","model_generated_potentially_faster_code_col":"from bisect import bisect_left\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef inpl():\n    return list(map(int, sys.stdin.readline().split()))\n\nimport sys\nsys.setrecursionlimit(10**8)\n\nn = inp()\nA = sorted(inpl())\nB = sorted(inpl())\nC = sorted(inpl())\n\n# Precompute the number of elements in C greater than each element in B\ncnt = [n - bisect_left(C, b + 1) for b in B]\n\n# Compute prefix sums of cnt\nacc = [0] * (n + 1)\nfor i in range(n):\n    acc[i + 1] = acc[i] + cnt[i]\n\n# Compute the result\nres = 0\nfor a in A:\n    # Find the first index in B where b > a\n    c = bisect_left(B, a + 1)\n    res += acc[n] - acc[c]\n\nprint(res)"}
{"problem_id":"p00144","slow_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nhttp:\/\/judge.u-aizu.ac.jp\/onlinejudge\/description.jsp?id=0144\n\n\n\n\"\"\"\n\nimport sys\n\nfrom sys import stdin\n\ninput = stdin.readline\n\nfrom enum import Enum\n\n\n\n\n\nclass Graph(object):\n\n    \"\"\" single source shortest path \"\"\"\n\n    class Status(Enum):\n\n        \"\"\" ?????????????\u00a8??????\u00b6??? \"\"\"\n\n        white = 1  # ????\u00a8????\n\n        gray = 2  # ?\u00a8???????\n\n        black = 3  #?\u00a8???????\n\n\n\n    def __init__(self, n, data):\n\n        self.num_of_nodes = n+1\n\n        self.color = [Graph.Status.white] * self.num_of_nodes  # ????????????????\u00a8??????\u00b6???\n\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n\n        for i in range(self.num_of_nodes):\n\n            self.M[i][i] = 0\n\n        self._make_matrix(data)  # data????????????????????\u00a3??\\??????(?????\\?\u00b6???\u00a8???????????????????????\u00a7????????????)\n\n        self.d = [float('inf')] * self.num_of_nodes  # ?\u00a7???????????????????(?????????)\n\n        self.p = [-1] * self.num_of_nodes  # ????????????????????????????\u00a8?????????????????????????\n\n\n\n    def _make_matrix(self, data):\n\n        for d in data:\n\n            r = d[0]\n\n            for t in d[2:]:\n\n                self.M[r][t] = 1\n\n\n\n    def dijkstra(self, start):\n\n        self.d[start] = 0\n\n        self.p[start] = -1\n\n        while True:\n\n            mincost = float('inf')\n\n            # ??\\??????????????\u00a7??????????????\u00a8?????????????????????u???????????????\n\n            for i in range(len(self.d)):\n\n                if self.color[i] != Graph.Status.black and self.d[i] < mincost:  # S????\u00b1???????????????????S??\u00a8??\\?\u00b6?????????????????????????????????????????\u00b0???????????????????\n\n                    mincost = self.d[i]\n\n                    u = i  # u??????????????????ID\n\n            if mincost == float('inf'):\n\n                break\n\n            self.color[u] = Graph.Status.black  # ?????????u???S????\u00b1???????????????\u00b4???\n\n            for v in range(len(self.d)):\n\n                if self.color[v] != Graph.Status.black and self.M[u][v] != float('inf'):\n\n                    # v????????????????????????????????\u00b0??????S???????????\u00a3???u????????????????????????????????????????????\u00b0??????????????\u00b1??\u00a7??\u00b4??\u00b0??????\n\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n\n                        self.d[v] = self.d[u] + self.M[u][v]\n\n                        self.p[v] = u\n\n                        self.color[v] = Graph.Status.gray\n\n\n\n    def warshallFloyd(self):\n\n        V = self.num_of_nodes\n\n        for k in range(V):\n\n            for i in range(V):\n\n                for j in range(V):\n\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\n\n\n\n\n\n\n\ndef main(args):\n\n    n = int(eval(input()))\n\n    network = []\n\n    for _ in range(n):\n\n        network.append([int(x) for x in input().split()])\n\n\n\n    packets = []\n\n    p = int(eval(input()))\n\n    for _ in range(p):\n\n        packets.append([int(x) for x in input().split()])\n\n\n\n    g = Graph(n, network)\n\n    g.warshallFloyd()\n\n\n\n    for s, d, v in packets:\n\n        if g.M[s][d] < v:\n\n            print((g.M[s][d]+1))\n\n        else:\n\n            print('NA')\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])","reference_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nhttp:\/\/judge.u-aizu.ac.jp\/onlinejudge\/description.jsp?id=0144\n\n\n\n\"\"\"\n\nimport sys\n\nfrom sys import stdin\n\ninput = stdin.readline\n\nfrom enum import Enum\n\n\n\n\n\nclass Graph(object):\n\n    \"\"\" single source shortest path \"\"\"\n\n    class Status(Enum):\n\n        \"\"\" ?????????????\u00a8??????\u00b6??? \"\"\"\n\n        white = 1  # ????\u00a8????\n\n        gray = 2  # ?\u00a8???????\n\n        black = 3  #?\u00a8???????\n\n\n\n    def __init__(self, n, data):\n\n        self.num_of_nodes = n+1\n\n        self.color = [Graph.Status.white] * self.num_of_nodes  # ????????????????\u00a8??????\u00b6???\n\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n\n        for i in range(self.num_of_nodes):\n\n            self.M[i][i] = 0\n\n        self._make_matrix(data)  # data????????????????????\u00a3??\\??????(?????\\?\u00b6???\u00a8???????????????????????\u00a7????????????)\n\n        self.d = [float('inf')] * self.num_of_nodes  # ?\u00a7???????????????????(?????????)\n\n        self.p = [-1] * self.num_of_nodes  # ????????????????????????????\u00a8?????????????????????????\n\n\n\n    def _make_matrix(self, data):\n\n        for d in data:\n\n            r = d[0]\n\n            for t in d[2:]:\n\n                self.M[r][t] = 1\n\n\n\n    def dijkstra(self, start):\n\n        self.d[start] = 0\n\n        self.p[start] = -1\n\n        while True:\n\n            mincost = float('inf')\n\n            # ??\\??????????????\u00a7??????????????\u00a8?????????????????????u???????????????\n\n            for i in range(len(self.d)):\n\n                if self.color[i] != Graph.Status.black and self.d[i] < mincost:  # S????\u00b1???????????????????S??\u00a8??\\?\u00b6?????????????????????????????????????????\u00b0???????????????????\n\n                    mincost = self.d[i]\n\n                    u = i  # u??????????????????ID\n\n            if mincost == float('inf'):\n\n                break\n\n            self.color[u] = Graph.Status.black  # ?????????u???S????\u00b1???????????????\u00b4???\n\n            for v in range(len(self.d)):\n\n                if self.color[v] != Graph.Status.black and self.M[u][v] != float('inf'):\n\n                    # v????????????????????????????????\u00b0??????S???????????\u00a3???u????????????????????????????????????????????\u00b0??????????????\u00b1??\u00a7??\u00b4??\u00b0??????\n\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n\n                        self.d[v] = self.d[u] + self.M[u][v]\n\n                        self.p[v] = u\n\n                        self.color[v] = Graph.Status.gray\n\n\n\n    def warshallFloyd(self):\n\n        for k in range(self.num_of_nodes):\n\n            for i in range(self.num_of_nodes):\n\n                for j in range(self.num_of_nodes):\n\n                    if self.M[i][k] + self.M[k][j] < self.M[i][j]: \n\n                        self.M[i][j] = self.M[i][k] + self.M[k][j]\n\n\n\n\n\ndef main(args):\n\n    n = int(eval(input()))\n\n    network = []\n\n    for _ in range(n):\n\n        network.append([int(x) for x in input().split()])\n\n\n\n    packets = []\n\n    p = int(eval(input()))\n\n    for _ in range(p):\n\n        packets.append([int(x) for x in input().split()])\n\n\n\n    g = Graph(n, network)\n\n    g.warshallFloyd()\n\n\n\n    for s, d, v in packets:\n\n        if g.M[s][d] < v:\n\n            print((g.M[s][d]+1))\n\n        else:\n\n            print('NA')\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])","model_generated_potentially_faster_code_col":"import sys\nfrom heapq import heappop, heappush\n\nclass Graph:\n    def __init__(self, n, edges):\n        self.num_of_nodes = n + 1\n        self.adj = [[] for _ in range(self.num_of_nodes)]  # Adjacency list representation\n        self._build_graph(edges)\n\n    def _build_graph(self, edges):\n        for edge in edges:\n            src = edge[0]\n            for dest in edge[2:]:\n                self.adj[src].append((dest, 1))  # Edge weight is always 1\n\n    def dijkstra(self, start):\n        \"\"\"Single-source shortest path using Dijkstra's algorithm.\"\"\"\n        dist = [float('inf')] * self.num_of_nodes\n        dist[start] = 0\n        heap = [(0, start)]  # Priority queue: (distance, node)\n\n        while heap:\n            current_dist, u = heappop(heap)\n            if current_dist > dist[u]:  # Skip outdated entries\n                continue\n            for v, weight in self.adj[u]:\n                new_dist = current_dist + weight\n                if new_dist < dist[v]:\n                    dist[v] = new_dist\n                    heappush(heap, (new_dist, v))\n        return dist\n\n\ndef main():\n    input = sys.stdin.read().splitlines()\n    idx = 0\n\n    n = int(input[idx])  # Number of nodes\n    idx += 1\n\n    network = []\n    for _ in range(n):\n        network.append(list(map(int, input[idx].split())))\n        idx += 1\n\n    p = int(input[idx])  # Number of packets\n    idx += 1\n\n    packets = []\n    for _ in range(p):\n        packets.append(list(map(int, input[idx].split())))\n        idx += 1\n\n    g = Graph(n, network)\n\n    # Precompute shortest paths from all nodes\n    all_shortest_paths = {}\n    for i in range(1, n + 1):\n        all_shortest_paths[i] = g.dijkstra(i)\n\n    # Process each packet\n    for s, d, v in packets:\n        shortest_path = all_shortest_paths[s][d]\n        if shortest_path < v:\n            print(shortest_path + 1)\n        else:\n            print(\"NA\")\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02268","slow_code_col":"def binarySearch():\n\n    n = int(eval(input()))\n\n    S = set(map(int, input().split()))\n\n    q = int(eval(input()))\n\n    T = set(map(int, input().split()))\n\n    print((len(S.intersection(T))))\n\n    \n\n\n\nbinarySearch()","reference_code_col":"def binarySearch():\n\n    n = int(eval(input()))\n\n    S = set(input().split())\n\n    q = int(eval(input()))\n\n    T = set(input().split())\n\n    print((len(S.intersection(T))))\n\n    \n\n\n\nbinarySearch()","model_generated_potentially_faster_code_col":"def count_common_elements():\n    # Read the size of the first set (n) and the set itself\n    n = int(input())\n    S = set(map(int, input().split()))\n\n    # Read the size of the second set (q) and the set itself\n    q = int(input())\n    T = set(map(int, input().split()))\n\n    # Compute and print the size of the intersection\n    print(len(S & T))\n\n\n# Call the optimized function\ncount_common_elements()"}
{"problem_id":"p03416","slow_code_col":"a,b=list(map(int,input().split()))\n\n\n\nans=0\n\n\n\nfor i in range(a,b+1):\n\n    buf=str(i)\n\n    #print(buf[0:int(len(buf)\/2)],buf[int(len(buf)\/2+1):])\n\n    str1=buf[0:int(len(buf)\/2)]\n\n    str2=buf[int(len(buf)\/2+1):]\n\n    if str1[0]==str2[1] and str1[1]==str2[0]:\n\n        ans+=1\n\n\n\nprint(ans)\n","reference_code_col":"a,b=list(map(int,input().split()))\n\n\n\nans=0\n\n\n\nfor i in range(a,b+1):\n\n    buf=str(i)\n\n    str1=buf[::-1]\n\n    if buf==str1:\n\n        ans+=1\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"a, b = map(int, input().split())\n\nans = 0\n\n# Precompute the length of numbers to avoid repeated calculations\nfor i in range(a, b + 1):\n    buf = str(i)\n    n = len(buf)\n    \n    # Only process numbers with an odd length (since slicing depends on middle index)\n    if n % 2 == 1:\n        mid = n \/\/ 2\n        # Directly compare characters without creating substrings\n        if buf[mid - 1] == buf[mid + 1] and buf[mid - 2] == buf[mid]:\n            ans += 1\n\nprint(ans)"}
{"problem_id":"p02725","slow_code_col":"#template\n\ndef inputlist(): return [int(j) for j in input().split()]\n\n#template\n\n#issue\u304b\u3089\u59cb\u3081\u308b\n\nK,N = inputlist()\n\nA = inputlist()\n\nlia = [0]*N\n\nfor i in range(1,N):\n\n    k = A[i] - A[i-1]\n\n    lia[i] = k\n\nlia[0] = (K+A[0]-A[-1])\n\nlia.sort()\n\nans = 0\n\nfor i in range(N-1):\n\n    ans += lia[i]\n\nprint(ans)","reference_code_col":"#template\n\ndef inputlist(): return [int(j) for j in input().split()]\n\ndef listinput(): return input().split()\n\n#template\n\nK,N = inputlist()\n\nA = inputlist()\n\ndis = [0]*(N)\n\nfor i in range(N):\n\n    if i == N-1:\n\n        dis[i] = K+A[0] - A[i]\n\n        continue\n\n    dis[i] = A[i+1] - A[i]\n\ndis.sort()\n\nprint((sum(dis[:-1])))","model_generated_potentially_faster_code_col":"def inputlist():\n    return [int(j) for j in input().split()]\n\n# Input reading\nK, N = inputlist()\nA = inputlist()\n\n# Calculate differences and wrap-around difference\ntotal_sum = 0\nmax_diff = 0\n\nfor i in range(N):\n    if i == 0:\n        diff = K + A[0] - A[-1]  # Wrap-around difference\n    else:\n        diff = A[i] - A[i - 1]  # Consecutive difference\n    \n    total_sum += diff\n    max_diff = max(max_diff, diff)\n\n# Subtract the maximum difference from the total sum\nans = total_sum - max_diff\n\nprint(ans)"}
{"problem_id":"p03000","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, X = lr()\n\nL = np.array([0] + lr())\n\nLcum = L.cumsum()\n\ni = np.searchsorted(Lcum, X, side='right')\n\nprint(i)\n\n# ","reference_code_col":"# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, X = lr()\n\nL = lr()\n\ncnt = 1\n\ncur = 0\n\nfor l in L:   \n\n    cur += l\n\n    if cur > X:\n\n        break\n\n    cnt += 1\n\n\n\nanswer = cnt\n\nprint(answer)\n","model_generated_potentially_faster_code_col":"import sys\n\n# Efficient input reading\ndef read_ints():\n    return list(map(int, sys.stdin.readline().split()))\n\n# Read N and X\nN, X = map(int, sys.stdin.readline().split())\n\n# Read L and compute cumulative sum directly\nL = [0]  # Start with 0\nL.extend(read_ints())  # Extend with input values\n\n# Compute cumulative sum manually\nLcum = [0] * (N + 1)\nfor i in range(1, N + 1):\n    Lcum[i] = Lcum[i - 1] + L[i]\n\n# Binary search to find the position\nlow, high = 0, N\nwhile low < high:\n    mid = (low + high) \/\/ 2\n    if Lcum[mid] <= X:\n        low = mid + 1\n    else:\n        high = mid\n\nprint(low)"}
{"problem_id":"p02767","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tN = II()\n\n\tX = LI()\n\n\tX = np.array(X)\n\n\tm = round(np.sum(X) \/ N)\n\n\tprint(int(np.sum((X-m)**2)))\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n","reference_code_col":"import sys\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tN = II()\n\n\tX = LI()\n\n\tm = round(sum(X) \/ N)\n\n\tans = 0\n\n\tfor x in X:\n\n\t\tans += ((x-m)**2)\n\n\tprint(ans)\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Set recursion limit (not used in this specific code, but kept if needed elsewhere)\nsys.setrecursionlimit(10 ** 6)\n\n# Lambda functions for input reading\nint1 = lambda x: int(x) - 1\nprintV = lambda x: print(*x, sep=\"\\n\")\nprintH = lambda x: print(\" \".join(map(str, x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\ndef LII(rows_number): return [II() for _ in range(rows_number)]\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\ndef main():\n    # Read input\n    N = II()\n    X = np.array(LI(), dtype=np.int64)  # Directly convert to NumPy array with int64 type\n    \n    # Compute mean efficiently\n    mean_X = np.round(np.mean(X))  # Use np.mean instead of np.sum \/ N for clarity and efficiency\n    \n    # Compute sum of squared differences\n    result = np.sum((X - mean_X) ** 2)\n    \n    # Print result as integer\n    print(int(result))\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03720","slow_code_col":"n, m = list(map(int, input().split()))\n\nRD = list(list(map(int, input().split())) for _ in range(m))\n\nfor i in range(1, n + 1):\n\n    ans = 0\n\n    for j in RD:\n\n        ans += j.count(i)\n\n    print(ans)","reference_code_col":"n, m = list(map(int, input().split()))\n\nNRD = list(0 for i in range(n))\n\nfor i in range(m):\n\n    r1, r2 = list(map(int, input().split()))\n\n    NRD[r1 - 1] += 1\n\n    NRD[r2 - 1] += 1\n\nfor i in range(n):\n\n    print((NRD[i]))","model_generated_potentially_faster_code_col":"# Read input values\nn, m = map(int, input().split())\n\n# Read RD and preprocess frequencies\nfrequency = {}\nfor _ in range(m):\n    row = list(map(int, input().split()))\n    for num in row:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n\n# Output the frequency for each number from 1 to n\nfor i in range(1, n + 1):\n    print(frequency.get(i, 0))"}
{"problem_id":"p03371","slow_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nfor HaH in range(0,2*max(x,y)+1,2):\n\n    ans = min(ans, c*HaH+max(0, a*(x-HaH\/\/2))+max(0, b*(y-HaH\/\/2)))\n\nprint(ans)","reference_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\nans=0\n\nm=min(x,y)\n\nif a+b>=2*c: #Half and Half\u8cfc\u5165\u3067\u5b89\u304f\u306a\u308b\u53ef\u80fd\u6027\u3042\u308b\u30d1\u30bf\u30fc\u30f3\n\n    # HaH\u3092m\u679a\u8cb7\u3063\u3066\u6b8b\u308aHaH\u8cfc\u5165,\u307e\u305f\u306f\u5168\u90e8HaH\u8cfc\u5165,\u3053\u306e\u3044\u305a\u308c\u304b\u3057\u304b\u3042\u308a\u5f97\u306a\u3044\n\n    ans = min(2*c*m+a*(x-m)+b*(y-m), 2*c*max(x,y))\n\nelse:\n\n    ans = a*x+b*y\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read inputs efficiently\na, b, c, x, y = map(int, input().split())\n\n# Initialize the answer with the base case\nans = a * x + b * y\n\n# Precompute constants\nmax_x_y = 2 * max(x, y) + 1\n\n# Loop through HaH with step size 2\nfor HaH in range(0, max_x_y, 2):\n    half_HaH = HaH \/\/ 2  # Compute HaH \/\/ 2 once per iteration\n    \n    # Compute the updated terms\n    term1 = max(0, a * (x - half_HaH))\n    term2 = max(0, b * (y - half_HaH))\n    \n    # Update the answer\n    ans = min(ans, c * HaH + term1 + term2)\n\n    # Early exit if HaH exceeds both 2*x and 2*y\n    if HaH >= 2 * x and HaH >= 2 * y:\n        break\n\n# Output the result\nprint(ans)"}
{"problem_id":"p02994","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, L = lr()\n\nA = np.arange(1, N+1)\n\nA += (L - 1)\n\nanswer = A.sum() - A[np.argmin(np.abs(A))]\n\nprint(answer)","reference_code_col":"import sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, L = lr()\n\ntotal = sum(range(L, L+N))\n\nsub = min(list(range(L, L+N)), key=abs)\n\nprint((total-sub))\n","model_generated_potentially_faster_code_col":"import sys\n\n# Input parsing\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n# Read inputs\nN, L = lr()\n\n# Compute the sum of the sequence [L, L+1, ..., L+N-1]\ntotal_sum = (N * (2 * L + N - 1)) \/\/ 2\n\n# Find the element with the minimum absolute value\nif L >= 0:\n    min_abs_value = L\nelif L + N - 1 < 0:\n    min_abs_value = L + N - 1\nelse:\n    min_abs_value = 0\n\n# Compute the final answer\nanswer = total_sum - min_abs_value\n\nprint(answer)"}
{"problem_id":"p03078","slow_code_col":"import numpy as np\n\n\n\n\n\ndef main():\n\n    X, Y, Z, K = list(map(int, input().split(' ')))\n\n    A = np.array(list(map(int, input().split(' '))))\n\n    B = np.array(list(map(int, input().split(' '))))\n\n    C = np.array(list(map(int, input().split(' '))))\n\n    AB = np.array(np.meshgrid(A, B)).T.reshape(-1, 2).sum(axis=1)\n\n    AB[::-1].sort()\n\n    AB = AB[:min([K, X * Y])]\n\n    ABC = np.array(np.meshgrid(AB, C)).T.reshape(-1, 2).sum(axis=1)\n\n    ABC[::-1].sort()\n\n    for ans in ABC[:K]:\n\n        print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()","reference_code_col":"from heapq import heappush, heappop\n\nfrom collections import defaultdict\n\n\n\n\n\ndef main():\n\n    X, Y, Z, K = list(map(int, input().split(' ')))\n\n    A = list(map(int, input().split(' ')))\n\n    B = list(map(int, input().split(' ')))\n\n    C = list(map(int, input().split(' ')))\n\n    A.sort(reverse=True)\n\n    B.sort(reverse=True)\n\n    C.sort(reverse=True)\n\n    que = [(- A[0] - B[0] - C[0], 0, 0, 0)]  # multiply -1 to change min to max\n\n    already_inserted = defaultdict(int)\n\n    answer = list()\n\n    for _ in range(K):\n\n        q, i, j, k = heappop(que)\n\n        answer.append(-q)\n\n        if i + 1 < X:\n\n            item_a = (- A[i + 1] - B[j] - C[k], i + 1, j, k)\n\n            if already_inserted[item_a] == 0:\n\n                heappush(que, item_a)\n\n                already_inserted[item_a] = 1\n\n        if j + 1 < Y:\n\n            item_b = (- A[i] - B[j + 1] - C[k], i, j + 1, k)\n\n            if already_inserted[item_b] == 0:\n\n                heappush(que, item_b)\n\n                already_inserted[item_b] = 1\n\n        if k + 1 < Z:\n\n            item_c = (- A[i] - B[j] - C[k + 1], i, j, k + 1)\n\n            if already_inserted[item_c] == 0:\n\n                heappush(que, item_c)\n\n                already_inserted[item_c] = 1\n\n    for ans in answer:\n\n        print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"import sys\nimport heapq\n\ndef main():\n    # Read input values\n    X, Y, Z, K = map(int, sys.stdin.readline().split())\n    A = list(map(int, sys.stdin.readline().split()))\n    B = list(map(int, sys.stdin.readline().split()))\n    C = list(map(int, sys.stdin.readline().split()))\n\n    # Sort arrays in descending order\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n\n    # Function to compute top K sums using a heap\n    def top_k_sums(arr1, arr2, k):\n        heap = []\n        result = []\n\n        # Initialize heap with the largest pair\n        heapq.heappush(heap, (-(arr1[0] + arr2[0]), 0, 0))\n\n        while len(result) < k and heap:\n            # Pop the largest sum\n            s, i, j = heapq.heappop(heap)\n            result.append(-s)\n\n            # Push next candidates into the heap\n            if i + 1 < len(arr1):\n                heapq.heappush(heap, (-(arr1[i + 1] + arr2[j]), i + 1, j))\n            if j + 1 < len(arr2) and i == 0:  # Avoid duplicate entries\n                heapq.heappush(heap, (-(arr1[i] + arr2[j + 1]), i, j + 1))\n\n        return result\n\n    # Compute top K sums for AB\n    AB = top_k_sums(A, B, K)\n\n    # Compute top K sums for ABC\n    ABC = top_k_sums(AB, C, K)\n\n    # Print the results\n    for ans in ABC:\n        print(ans)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03325","slow_code_col":"N = int(eval(input()))\n\nx = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in x:\n\n  while i % 2 == 0:\n\n    cnt += 1\n\n    i \/= 2\n\nprint(cnt)","reference_code_col":"n = int(eval(input()))\n\nans = 0\n\nfor i in map(int, input().split()):\n\n    cnt = 0\n\n    while i % 2 == 0:\n\n        i >>= 1\n\n        cnt += 1\n\n    ans += cnt\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read input\nN = int(input())\nx = list(map(int, input().split()))\n\n# Initialize counter\ncnt = 0\n\n# Iterate through each number in the list\nfor i in x:\n    # Count trailing zeros in binary representation of i (equivalent to counting divisions by 2)\n    while i > 0 and (i & 1) == 0:  # Check if the least significant bit is 0\n        cnt += 1\n        i >>= 1  # Right shift to divide by 2\n\nprint(cnt)"}
{"problem_id":"p02649","slow_code_col":"def popcount(x):\n\n    x = x - ((x >> 1) & 0x55555555)\n\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n\n    x = x + (x >> 8)\n\n    x = x + (x >> 16)\n\n    return x & 0x0000007f\n\n\n\ncmb=[[0 for i in range(51)] for j in range(51)]\n\ncmb[0][0]=1\n\nfor i in range(51):\n\n    for j in range(51):\n\n        if i!=50 and j!=50:\n\n            cmb[i+1][j+1]+=cmb[i][j]\n\n        if i!=50:\n\n            cmb[i+1][j]+=cmb[i][j]\n\n\n\nfor i in range(1,51):\n\n    for j in range(2,51):\n\n        cmb[i][j]+=cmb[i][j-1]\n\n\n\nN,K,T,S=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\n\n\nmust0=[i for i in range(18) if S>>i &1==0]\n\nmust1=[i for i in range(18) if T>>i &1==1]\n\n\n\nA=[]\n\nfor val in a:\n\n    check=True\n\n    for j in must0:\n\n        check=check&(val>>j &1==0)\n\n    for j in must1:\n\n        check=check&(val>>j &1==1)\n\n    if check:\n\n        A.append(val)\n\n\n\nif not A:\n\n    print((0))\n\n    exit()\n\n\n\nbit=[]\n\nfor i in range(18):\n\n    if i not in must0 and i not in must1:\n\n        bit.append(i)\n\n\n\nfor i in range(len(A)):\n\n    temp=0\n\n    for j in range(len(bit)):\n\n        temp+=(A[i]>>bit[j] &1==1)*2**j\n\n    A[i]=temp\n\n\n\nans=0\n\nn=len(bit)\n\ndata=[0]*(2**n)\n\nfor i in range(2**n):\n\n    t=set([])\n\n    for a in A:\n\n        data[a&i]+=1\n\n        t.add(a&i)\n\n    temp=0\n\n    for val in t:\n\n        temp+=cmb[data[val]][min(K,data[val])]\n\n    ans+=temp*(-1)**popcount(i)\n\n    for val in t:\n\n        data[val]=0\n\n\n\nprint(ans)\n","reference_code_col":"def popcount(x):\n\n    x = x - ((x >> 1) & 0x55555555)\n\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n\n    x = x + (x >> 8)\n\n    x = x + (x >> 16)\n\n    return x & 0x0000007f\n\n\n\ncmb=[[0 for i in range(51)] for j in range(51)]\n\ncmb[0][0]=1\n\nfor i in range(51):\n\n    for j in range(51):\n\n        if i!=50:\n\n            cmb[i+1][j]+=cmb[i][j]\n\n        if j!=50 and i!=50:\n\n            cmb[i+1][j+1]+=cmb[i][j]\n\n\n\n\n\nfor i in range(1,51):\n\n    for j in range(2,51):\n\n        cmb[i][j]+=cmb[i][j-1]\n\n\n\nimport random\n\nN,K,T,S=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\n\n\nmust0=[i for i in range(18) if S>>i &1==0]\n\nmust1=[i for i in range(18) if T>>i &1==1]\n\n\n\nA=[]\n\nfor val in a:\n\n    check=True\n\n    for j in must0:\n\n        check=check&(val>>j &1==0)\n\n    for j in must1:\n\n        check=check&(val>>j &1==1)\n\n    if check:\n\n        A.append(val)\n\n\n\nif not A:\n\n    print((0))\n\n    exit()\n\n\n\nbit=[]\n\nfor i in range(18):\n\n    if i not in must0 and i not in must1:\n\n        bit.append(i)\n\n\n\nfor i in range(len(A)):\n\n    temp=0\n\n    for j in range(len(bit)):\n\n        temp+=(A[i]>>bit[j] &1==1)*2**j\n\n    A[i]=temp\n\n\n\nans=0\n\nn=len(bit)\n\ndata=[0]*(2**n)\n\npc=[popcount(i) for i in range(2**n)]\n\nfor i in range(2**n):\n\n    for a in A:\n\n        data[a&i]+=1\n\n    for a in A:\n\n        if data[a&i]:\n\n            ans+=cmb[data[a&i]][min(K,data[a&i])]*(-1)**pc[i]\n\n            data[a&i]=0\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"def popcount(x):\n    return bin(x).count('1')"}
{"problem_id":"p03078","slow_code_col":"import sys\n\n#import numpy as np\n\n\n\ns2nn = lambda s: [int(c) for c in s.split(' ')]\n\nss2nn = lambda ss: [int(s) for s in ss]\n\nss2nnn = lambda ss: [s2nn(s) for s in ss]\n\ni2s = lambda: sys.stdin.readline().rstrip()\n\ni2n = lambda: int(i2s())\n\ni2nn = lambda: s2nn(i2s())\n\nii2ss = lambda n: [sys.stdin.readline().rstrip() for _ in range(n)]\n\nii2nn = lambda n: ss2nn(ii2ss(n))\n\nii2nnn = lambda n: ss2nnn(ii2ss(n))\n\n\n\nN = 10000\n\ndef tokey(i, j, k):\n\n    return i*N*N + j*N + k\n\ndef dekey(n):\n\n    i = int(n \/ N \/ N)\n\n    j = int(n \/ N) % N\n\n    k = n % N\n\n    return i, j, k\n\n\n\ndef main():\n\n    X, Y, Z, K = i2nn()\n\n    A = i2nn()\n\n    B = i2nn()\n\n    C = i2nn()\n\n    A.sort()\n\n    A.reverse()\n\n    B.sort()\n\n    B.reverse()\n\n    C.sort()\n\n    C.reverse()\n\n    Q = [(A[0] + B[0] + C[0], 0, 0, 0)]\n\n    loop = 0\n\n    stored = set()\n\n    def next(i, j, k):\n\n        if i >= X or j >= Y or k >= Z:\n\n            return\n\n        key = tokey(i, j, k)\n\n        if key not in stored:\n\n            stored.add(key)\n\n            n = A[i] + B[j] + C[k]\n\n            Q.append((n, i, j, k))\n\n    while True:\n\n        v = max(Q, key=lambda v: v[0])\n\n        Q.remove(v)\n\n        print((v[0]))\n\n        loop += 1\n\n        if loop >= K:\n\n            break\n\n        next(v[1]+1, v[2], v[3])\n\n        next(v[1], v[2]+1, v[3])\n\n        next(v[1], v[2], v[3]+1)\n\n\n\nmain()\n","reference_code_col":"import sys\n\nfrom collections import deque  # \u53cc\u65b9\u5411\u30ad\u30e5\u30fc\n\nfrom collections import defaultdict  # \u521d\u671f\u5316\u6e08\u307f\u8f9e\u66f8\n\nfrom heapq import heapify, heappush, heappop, heappushpop  # \u30d7\u30e9\u30a4\u30aa\u30ea\u30c6\u30a3\u30ad\u30e5\u30fc\n\nfrom bisect import bisect_left, bisect_right  # \u4e8c\u5206\u63a2\u7d22\n\n#import numpy as np  # 1.8.2\n\n#import scipy  # 0.13.3\n\n#sys.setrecursionlimit(int(1e+6))\n\ns2nn = lambda s: [int(c) for c in s.split(' ')]\n\nss2nn = lambda ss: [int(s) for s in ss]\n\nss2nnn = lambda ss: [s2nn(s) for s in ss]\n\ni2s = lambda: sys.stdin.readline().rstrip()\n\ni2n = lambda: int(i2s())\n\ni2nn = lambda: s2nn(i2s())\n\nii2ss = lambda n: [sys.stdin.readline().rstrip() for _ in range(n)]\n\nii2sss = lambda n: [list(sys.stdin.readline().rstrip()) for _ in range(n)]\n\nii2nn = lambda n: ss2nn(ii2ss(n))\n\nii2nnn = lambda n: ss2nnn(ii2ss(n))\n\nMOD = int(1e+9) + 7\n\n\n\ndef main():\n\n    X, Y, Z, K = i2nn()\n\n    A = i2nn()\n\n    B = i2nn()\n\n    C = i2nn()\n\n    A.sort()\n\n    A.reverse()\n\n    B.sort()\n\n    B.reverse()\n\n    C.sort()\n\n    C.reverse()\n\n    s = set()\n\n    hq = []\n\n    n = 0\n\n    heappush(hq, ((A[0] + B[0] + C[0]) * -1, (0, 0, 0)))\n\n    while n < K:\n\n        t, abc = heappop(hq)\n\n        if abc in s:\n\n            continue\n\n        s.add(abc)\n\n        (a, b, c) = abc\n\n        if a+1 < X:\n\n            heappush(hq, ((A[a+1] + B[b] + C[c]) * -1, (a+1, b, c)))\n\n        if b+1 < Y:\n\n            heappush(hq, ((A[a] + B[b+1] + C[c]) * -1, (a, b+1, c)))\n\n        if c+1 < Z:\n\n            heappush(hq, ((A[a] + B[b] + C[c+1]) * -1, (a, b, c+1)))\n\n        print((-t))\n\n        n += 1\n\n\n\nmain()\n","model_generated_potentially_faster_code_col":"import sys\nimport heapq\n\n# Input helper functions\ni2s = lambda: sys.stdin.readline().rstrip()\ni2n = lambda: int(i2s())\ni2nn = lambda: [int(c) for c in i2s().split()]\n\ndef main():\n    # Read input\n    X, Y, Z, K = i2nn()\n    A = i2nn()\n    B = i2nn()\n    C = i2nn()\n\n    # Sort arrays in descending order\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n\n    # Priority queue to store (sum, i, j, k)\n    pq = [(-(A[0] + B[0] + C[0]), 0, 0, 0)]  # Use negative for max-heap behavior\n    visited = set((0, 0, 0))  # Track visited indices to avoid duplicates\n\n    # Process the top K sums\n    for _ in range(K):\n        # Extract the largest sum\n        s, i, j, k = heapq.heappop(pq)\n        print(-s)  # Negate back to get the original sum\n\n        # Generate next candidates\n        if i + 1 < X and (i + 1, j, k) not in visited:\n            heapq.heappush(pq, (-(A[i + 1] + B[j] + C[k]), i + 1, j, k))\n            visited.add((i + 1, j, k))\n\n        if j + 1 < Y and (i, j + 1, k) not in visited:\n            heapq.heappush(pq, (-(A[i] + B[j + 1] + C[k]), i, j + 1, k))\n            visited.add((i, j + 1, k))\n\n        if k + 1 < Z and (i, j, k + 1) not in visited:\n            heapq.heappush(pq, (-(A[i] + B[j] + C[k + 1]), i, j, k + 1))\n            visited.add((i, j, k + 1))\n\nmain()"}
{"problem_id":"p02761","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nN, M = [int(_) for _ in input().split()]\n\n\n\nif M == 0:\n\n    if N == 1:\n\n        print(\"0\")\n\n    else:\n\n        ans = [0] * N\n\n        ans[0] = 1\n\n        print((\"\".join(map(str, ans))))\n\n    sys.exit()\n\n\n\nS, C = np.array([[int(_) for _ in input().split()] for i in range(M)]).T\n\n\n\nans = [-1] * N\n\n\n\nfor i in range(M):\n\n    j = int(S[i]) - 1\n\n    if ans[j] == -1 or ans[j] == C[i]:\n\n        ans[j] = C[i]\n\n    else:\n\n        print(\"-1\")\n\n        sys.exit()\n\n\n\nif N >= 2 and ans[0] == 0:\n\n    print(\"-1\")\n\n    sys.exit()\n\n\n\nif N >= 2 and ans[0] == -1:\n\n    ans[0] = 1\n\n\n\nfor i in range(1, N):\n\n    if ans[i] == -1:\n\n        ans[i] = 0\n\n\n\ns = \"\".join(map(str, ans))\n\nprint(s)\n","reference_code_col":"import sys\n\n\n\nN, M = [int(_) for _ in input().split()]\n\nSC = [[int(_) for _ in input().split()] for i in range(M)]\n\n\n\nif N == 1:\n\n    start = 0\n\n    end = 10\n\nelse:\n\n    start = 10 ** (N - 1)\n\n    end = 10 ** N\n\n\n\nfor i in range(start, end):\n\n    ans = list(map(int, str(i)))\n\n    valid = True\n\n    for s, c in SC:\n\n        if ans[s-1] != c:\n\n            valid = False\n\n            break\n\n    if valid:\n\n        print(i)\n\n        sys.exit()\n\n\n\nprint((-1))\n","model_generated_potentially_faster_code_col":"import sys\n\n# Input parsing\nN, M = map(int, input().split())\n\n# Handle the case where M == 0\nif M == 0:\n    if N == 1:\n        print(\"0\")\n    else:\n        print(\"1\" + \"0\" * (N - 1))\n    sys.exit()\n\n# Parse constraints into two lists instead of a NumPy array\nS = []\nC = []\nfor _ in range(M):\n    s, c = map(int, input().split())\n    S.append(s - 1)  # Convert to 0-based index\n    C.append(c)\n\n# Initialize answer array\nans = [-1] * N\n\n# Process constraints\nfor i in range(M):\n    j = S[i]\n    if ans[j] == -1 or ans[j] == C[i]:\n        ans[j] = C[i]\n    else:\n        print(\"-1\")\n        sys.exit()\n\n# Check leading digit constraint\nif N >= 2:\n    if ans[0] == 0:\n        print(\"-1\")\n        sys.exit()\n    elif ans[0] == -1:\n        ans[0] = 1\n\n# Fill remaining unknown digits with 0\nfor i in range(1, N):\n    if ans[i] == -1:\n        ans[i] = 0\n\n# Construct and print the result\nprint(\"\".join(map(str, ans)))"}
{"problem_id":"p03363","slow_code_col":"import numpy\n\nN=int(eval(input()))\n\nA=list(map(int,input().split()))\n\nB=list(numpy.cumsum(A))+[0]\n\nC=sorted(B)\n\nd=C[0]\n\ncnt=1\n\nans=0\n\nfor i in range(N):\n\n  if C[i+1]==d:\n\n    cnt+=1\n\n  else:\n\n    ans+=cnt*(cnt-1)\/\/2\n\n    cnt=1\n\n    d=C[i+1]\n\nans+=cnt*(cnt-1)\/\/2\n\nprint(ans)    ","reference_code_col":"N=int(eval(input()))\n\nA=list(map(int, input().split()))\n\nD=[0]\n\nd=0\n\nfor i in A:\n\n  d+=i\n\n  D.append(d)\n\nD=sorted(D)\n\nans=0\n\nd=-10**9+1\n\nD.append(10**9+1)\n\ncnt=0\n\nfor i in range(N+2):\n\n  if D[i]==d:\n\n    cnt+=1\n\n  else:\n\n    if cnt>1:\n\n      ans+=cnt*(cnt-1)\/\/2\n\n      cnt=1\n\n    else:\n\n      cnt=1\n\n    d=D[i]\n\nprint(ans)","model_generated_potentially_faster_code_col":"def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Read N and A\n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    \n    # Compute cumulative sum (native Python)\n    B = [0]  # Start with 0\n    cumsum = 0\n    for num in A:\n        cumsum += num\n        B.append(cumsum)\n    \n    # Sort the cumulative sums\n    C = sorted(B)\n    \n    # Count consecutive equal elements\n    ans = 0\n    cnt = 1\n    for i in range(1, len(C)):\n        if C[i] == C[i - 1]:\n            cnt += 1\n        else:\n            ans += cnt * (cnt - 1) \/\/ 2\n            cnt = 1\n    ans += cnt * (cnt - 1) \/\/ 2  # Add the last group\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03634","slow_code_col":"import sys\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(v,p,d):\n\n    for i, j in tree[v]:\n\n        if i != p:\n\n            depth[i] = d + j\n\n            dfs(i,v,d+j)\n\n\n\nN = int(eval(input()))\n\n\n\ntree = [[] for _ in range(N)]\n\n\n\nfor i in range(N-1):\n\n    a, b, c = list(map(int, input().split()))\n\n    a -= 1\n\n    b -= 1\n\n    tree[a].append((b,c))\n\n    tree[b].append((a,c))\n\n\n\nQ, K = list(map(int, input().split()))\n\n\n\ndepth = [0 for i in range(N)]\n\ndepth[K-1] = 0\n\n\n\ndfs(K-1,-1,0)\n\n\n\nfor _ in range(Q):\n\n    x, y = list(map(int, input().split()))\n\n    print((depth[x-1] + depth[y-1]))","reference_code_col":"import heapq\n\nimport sys\n\n\n\ninput = sys.stdin.readline\n\n\n\ndef dijkstra(s, edge, N):\n\n    d = [float('inf')] * N\n\n    used = [True] * N\n\n    d[s] = 0\n\n    used[s] = False\n\n    edgelist = []\n\n    for a, b in edge[s]:\n\n        heapq.heappush(edgelist, a * (10 ** 6) + b)\n\n    while len(edgelist):\n\n        minedge = heapq.heappop(edgelist)\n\n\n\n        if not used[minedge%(10 ** 6)]:\n\n            continue\n\n        v = minedge % (10 ** 6)\n\n        d[v] = minedge \/\/ (10 ** 6)\n\n        used[v] = False\n\n        for e in edge[v]:\n\n            if used[e[1]]:\n\n                heapq.heappush(edgelist, (e[0] + d[v]) * (10 ** 6) + e[1])\n\n    return d\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    edge = [[] for _ in range(N)]\n\n    for _ in range(N-1):\n\n        a, b, c = list(map(int, input().split()))\n\n        a -= 1\n\n        b -= 1\n\n        edge[a].append([c,b])\n\n        edge[b].append([c,a])\n\n    Q, K = list(map(int, input().split()))\n\n    K -= 1\n\n    d = dijkstra(K, edge, N)\n\n    for _ in range(Q):\n\n        x, y = list(map(int, input().split()))\n\n        x -= 1\n\n        y -= 1\n\n        print((d[x] + d[y]))\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()","model_generated_potentially_faster_code_col":"import sys\nfrom collections import deque\n\ndef iterative_dfs(start, tree, depth):\n    stack = [(start, -1, 0)]  # (current node, parent, current depth)\n    \n    while stack:\n        v, p, d = stack.pop()\n        for neighbor, weight in tree[v]:\n            if neighbor != p:\n                depth[neighbor] = d + weight\n                stack.append((neighbor, v, d + weight))\n\n# Read number of nodes\nN = int(input())\n\n# Build the tree as an adjacency list\ntree = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    tree[a].append((b, c))\n    tree[b].append((a, c))\n\n# Read number of queries and starting node\nQ, K = map(int, input().split())\nK -= 1\n\n# Calculate depth from node K using iterative DFS\ndepth = [0] * N\niterative_dfs(K, tree, depth)\n\n# Process queries\nfor _ in range(Q):\n    x, y = map(int, input().split())\n    print(depth[x - 1] + depth[y - 1])"}
{"problem_id":"p03796","slow_code_col":"import math\n\nn = int(eval(input()))\n\n\n\npower = math.factorial(n)\n\n\n\nprint((power % (10**9 + 7)))\n","reference_code_col":"import math\n\nn = int(eval(input()))\n\n\n\npower = 1\n\n\n\nfor i in range(1, n+1):\n\n    power = i * power % (10**9 + 7)\n\n\n\nprint(power)\n","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7  # Define the modulo constant\n\n# Input reading without eval\nn = int(input())\n\n# Compute factorial with modulo optimization\nresult = 1\nfor i in range(1, n + 1):\n    result = (result * i) % MOD\n\nprint(result)"}
{"problem_id":"p03575","slow_code_col":"'''\n\n\u7121\u5411\u30b0\u30e9\u30d5\u306e\u6a4b\u306e\u6570\u3092\u8abf\u3079\u308b\n\n\u30eb\u30fc\u30d7\u7121\u3057\/2\u91cd\u8fba\u7121\u3057\n\n'''\n\n\n\ndef main():\n\n    import sys\n\n    #input = sys.stdin.readline\n\n    sys.setrecursionlimit(10000000)\n\n    from collections import Counter, deque\n\n    #from collections import defaultdict\n\n    from itertools import combinations\n\n    #from itertools import accumulate, product, permutations\n\n    from math import floor, ceil\n\n\n\n    #mod = 1000000007\n\n\n\n    node,m =list(map(int, input().split()))\n\n    edge = [list(map(int, input().split())) for _ in range(m)]\n\n    res = 0\n\n\n\n    def dfs(num):\n\n        flag[num-1] = 1\n\n        for x, y in edge:\n\n            if x==num:\n\n                if not flag[y-1]:\n\n                    dfs(y)\n\n            if y==num:\n\n                if not flag[x-1]:\n\n                    dfs(x)\n\n    \n\n    for i in range(m):\n\n        bridge = edge.pop(i)\n\n        flag = [0]*node\n\n        s = edge[0][0]\n\n        dfs(s)\n\n        if not all(flag):\n\n            res += 1\n\n        edge.insert(i, bridge)\n\n    print(res)\n\n\n\nif __name__ == '__main__':\n\n    main()","reference_code_col":"'''\n\nhttps:\/\/atcoder.jp\/contests\/abc075\/tasks\/abc075_c?lang=ja\n\n\u6df1\u3055\u512a\u5148\u63a2\u7d22\u3067\u3082\u89e3\u3051\u308b\n\n'''\n\ndef main():\n\n    import sys\n\n    #input = sys.stdin.readline\n\n    sys.setrecursionlimit(10000000)\n\n    from collections import Counter, deque\n\n    #from collections import defaultdict\n\n    from itertools import combinations, permutations\n\n    #from itertools import accumulate, product\n\n    from bisect import bisect_left,bisect_right\n\n    from math import floor, ceil\n\n    #from operator import itemgetter\n\n\n\n    #mod = 1000000007\n\n\n\n    class UnionFind():\n\n        #n\u500b\u306e\u8981\u7d20\u3092\u756a\u53f70~n-1\u3067\u7ba1\u7406\u3059\u308b\n\n        #parents:\u8981\u7d20\u306e\u89aa(1\u3064\u4e0a), \u8981\u7d20\u304c\u6839\u306e\u5834\u5408\u30b5\u30a4\u30ba\u3092\u8868\u3059\n\n        def __init__(self, n):\n\n            self.n = n\n\n            self.parents = [-1] * n\n\n    \n\n        #\u8981\u7d20x\u306e\u6839\u3092\u8fd4\u3059, \u305d\u306e\u904e\u7a0b\u3067\u7d4c\u8def\u5727\u7e2e\u3082\u884c\u3046\n\n        def find(self, x):\n\n            if self.parents[x] < 0:\n\n                return x\n\n            else:\n\n                self.parents[x] = self.find(self.parents[x])\n\n                return self.parents[x]\n\n    \n\n        def union(self, x, y):\n\n            x = self.find(x)\n\n            y = self.find(y)\n\n            if x == y:\n\n                return\n\n            #\u305d\u308c\u305e\u308c\u306esize\u3067\u6bd4\u3079\u308b\n\n            if self.parents[x] > self.parents[y]:\n\n                x, y = y, x\n\n            self.parents[x] += self.parents[y]\n\n            self.parents[y] = x #\u6839\u3092\u304f\u3063\u3064\u3051\u308b(\u7247\u65b9\u3092\u89aa\u306b\u3059\u308b)\n\n    \n\n        #x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306esize\n\n        def size(self, x):\n\n            return -self.parents[self.find(x)]\n\n    \n\n        #x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u304b\u3069\u3046\u304b\n\n        def same(self, x, y):\n\n            return self.find(x) == self.find(y)\n\n    \n\n        #x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u5168\u3066\u3092\u8fd4\u3059\n\n        def members(self, x):\n\n            root = self.find(x)\n\n            return [i for i in range(self.n) if self.find(i) == root]\n\n    \n\n        #\u5168\u3066\u306e\u6839\u306e\u8981\u7d20\u3092\u8fd4\u3059\n\n        def roots(self):\n\n            return [i for i, x in enumerate(self.parents) if x < 0]\n\n    \n\n        #\u5404\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u3092\u8f9e\u66f8\u3067\u8fd4\u3059\n\n        def all_group_members(self):\n\n            return {r: self.members(r) for r in self.roots()}\n\n    \n\n        #print(uf)\n\n        def __str__(self):\n\n            return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n    n,m = list(map(int, input().split()))\n\n    edge = [list(map(int, input().split())) for _ in range(m)]\n\n    res = 0\n\n    for i in range(m):\n\n        uf = UnionFind(n)\n\n        for j in range(m):\n\n            if i==j:\n\n                continue\n\n            a,b = edge[j]\n\n            uf.union(a-1,b-1)\n\n        if uf.size(0)!=n:\n\n            res += 1\n\n    print(res)\n\n\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"def main():\n    import sys\n    sys.setrecursionlimit(10**7)\n\n    # Input reading\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [list(map(int, sys.stdin.readline().split())) for _ in range(m)]\n\n    # Build adjacency list\n    adj = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Variables for Tarjan's algorithm\n    visited = [False] * (n + 1)\n    disc = [float('inf')] * (n + 1)  # Discovery time\n    low = [float('inf')] * (n + 1)   # Low-link value\n    parent = [-1] * (n + 1)          # Parent array to avoid backtracking\n    bridges = []                     # List to store bridges\n    time = [0]                       # Global timer\n\n    def dfs(u):\n        visited[u] = True\n        disc[u] = low[u] = time[0]\n        time[0] += 1\n\n        for v in adj[u]:\n            if not visited[v]:  # Tree edge\n                parent[v] = u\n                dfs(v)\n                low[u] = min(low[u], low[v])\n\n                # Check if (u, v) is a bridge\n                if low[v] > disc[u]:\n                    bridges.append((min(u, v), max(u, v)))\n\n            elif v != parent[u]:  # Back edge\n                low[u] = min(low[u], disc[v])\n\n    # Perform DFS from all unvisited nodes\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i)\n\n    # Output the number of bridges\n    print(len(bridges))\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03634","slow_code_col":"import heapq\n\n\n\nN = int(eval(input()))\n\nabc = [list(map(int,input().split())) for _ in range(N-1)]\n\nQ,K = list(map(int,input().split()))\n\nxy = [list(map(int,input().split())) for _ in range(Q)]\n\n\n\nconnect = [[] for _ in range(N)]\n\nINFTY = 10**15\n\nfor a,b,c in abc:\n\n    connect[a-1].append([b-1,c])\n\n    connect[b-1].append([a-1,c])\n\n\n\ncost = [[INFTY,False] for _  in range(N)]\n\ncost[K-1][0] = 0\n\nq = [(0,K-1)]\n\nwhile q:\n\n    _,i = heapq.heappop(q)\n\n    if cost[i][1]:\n\n        continue\n\n    cost[i][1] = True\n\n    ci0 = cost[i][0]\n\n    for j,c in connect[i]:\n\n        if cost[j][1]:\n\n            continue\n\n        tmp_cost = ci0+c\n\n        if tmp_cost < cost[j][0]:\n\n            cost[j][0] = tmp_cost\n\n            heapq.heappush(q,(tmp_cost,j))\n\n\n\nfor x,y in xy:\n\n    print((cost[x-1][0] + cost[y-1][0]))","reference_code_col":"N = int(eval(input()))\n\nABC = [list(map(int,input().split())) for _ in [0]*(N-1)]\n\nQ,K = list(map(int,input().split()))\n\nXY = [list(map(int,input().split())) for _ in [0]*Q]\n\n\n\nE = [{} for _ in [0]*N]\n\nfor a,b,c in ABC:\n\n    E[a-1][b-1] = c\n\n    E[b-1][a-1] = c\n\n\n\ndef dist_dfs_tree(N,E,start):\n\n    d = [-1]*N\n\n    d[start] = 0\n\n    q = [start]\n\n    while q:\n\n        i = q.pop()\n\n        ci = d[i]\n\n        for j,cj in list(E[i].items()):\n\n            if d[j] !=-1:continue\n\n            d[j] = ci+cj\n\n            q.append(j)\n\n    return d\n\n\n\nd = dist_dfs_tree(N,E,K-1)\n\nfor x,y in XY:\n\n    print((d[x-1]+d[y-1]))","model_generated_potentially_faster_code_col":"import heapq\nimport math\n\n# Input parsing\nN = int(input())\nabc = [list(map(int, input().split())) for _ in range(N - 1)]\nQ, K = map(int, input().split())\nxy = [list(map(int, input().split())) for _ in range(Q)]\n\n# Build adjacency list\nconnect = [[] for _ in range(N)]\nfor a, b, c in abc:\n    connect[a - 1].append((b - 1, c))\n    connect[b - 1].append((a - 1, c))\n\n# Dijkstra's algorithm\ndef dijkstra(start):\n    dist = [math.inf] * N\n    dist[start] = 0\n    visited = set()\n    heap = [(0, start)]  # (current_distance, node)\n\n    while heap:\n        current_dist, node = heapq.heappop(heap)\n\n        if node in visited:\n            continue\n        visited.add(node)\n\n        # Update neighbors\n        for neighbor, weight in connect[node]:\n            if neighbor in visited:\n                continue\n            new_dist = current_dist + weight\n            if new_dist < dist[neighbor]:\n                dist[neighbor] = new_dist\n                heapq.heappush(heap, (new_dist, neighbor))\n\n    return dist\n\n# Compute shortest distances from node K-1\ndistances = dijkstra(K - 1)\n\n# Answer queries\nfor x, y in xy:\n    print(distances[x - 1] + distances[y - 1])"}
{"problem_id":"p03416","slow_code_col":"A,B = list(map(int,input().split()))\n\n\n\n\n\ndef kaibun(n):\n\n\tkey = 0\n\n\tfor i in range(1,n+1):\n\n\t\tif str(i) == str(i)[::-1]:\n\n\t\t\tkey += 1\n\n\treturn key\n\n\n\nprint((kaibun(B)-kaibun(A-1)))","reference_code_col":"A,B = list(map(int,input().split()))\n\n\n\n\n\ndef kaibun(m, n):\n\n\tkey = 0\n\n\tfor i in range(m,n+1):\n\n\t\tif str(i) == str(i)[::-1]:\n\n\t\t\tkey += 1\n\n\treturn key\n\n\n\nprint((kaibun(A,B)))","model_generated_potentially_faster_code_col":"def generate_palindromes(limit):\n    \"\"\"Generate all palindromic numbers <= limit.\"\"\"\n    palindromes = []\n    \n    # Generate single-digit palindromes\n    for i in range(10):\n        if i <= limit:\n            palindromes.append(i)\n    \n    # Generate multi-digit palindromes\n    for length in range(2, 10):  # Limit to reasonable lengths (adjust as needed)\n        # Odd-length palindromes\n        base_len = (length + 1) \/\/ 2\n        for base in range(10**(base_len - 1), 10**base_len):\n            base_str = str(base)\n            palindrome = int(base_str + base_str[-2::-1])  # Mirror the base\n            if palindrome > limit:\n                break\n            palindromes.append(palindrome)\n        \n        # Even-length palindromes\n        base_len = length \/\/ 2\n        for base in range(10**(base_len - 1), 10**base_len):\n            base_str = str(base)\n            palindrome = int(base_str + base_str[::-1])  # Mirror the base\n            if palindrome > limit:\n                break\n            palindromes.append(palindrome)\n    \n    return sorted(palindromes)\n\n\n# Read input\nA, B = map(int, input().split())\n\n# Generate all palindromes up to B\npalindromes = generate_palindromes(B)\n\n# Count palindromes in the range [A, B]\ncount = sum(1 for p in palindromes if A <= p <= B)\n\nprint(count)"}
{"problem_id":"p02555","slow_code_col":"from sys import stdin\n\ndef solve():\n\n    s = int(stdin.readline())\n\n    mod = 10**9+7\n\n    if s < 3: return 0\n\n    dp = [0]*(s+1)\n\n    dp[0] = 1\n\n    for i in range(3,s+1):\n\n        for x in range(3,i+1):\n\n            if x in [i-1,i-2]:\n\n                continue\n\n            dp[i] += dp[i-x]\n\n    return dp[s]%mod\n\nprint((solve()))","reference_code_col":"from sys import stdin\n\ndef solve():\n\n    s = int(stdin.readline())\n\n    mod = 10**9+7\n\n    if s < 3: return 0\n\n    dp = [0]*(s+1)\n\n    dp[0] = 1\n\n    for i in range(3,s+1):\n\n        dp[i] = dp[i-1] + dp[i-3]\n\n    return dp[s]%mod\n\nprint((solve()))","model_generated_potentially_faster_code_col":"from sys import stdin\n\ndef solve():\n    s = int(stdin.readline())\n    mod = 10**9 + 7\n\n    if s < 3:\n        return 0\n\n    # Initialize dp array\n    dp = [0] * (s + 1)\n    dp[0] = 1  # Base case: one way to partition 0\n\n    # Use a running sum to track contributions efficiently\n    running_sum = 0\n\n    for i in range(3, s + 1):\n        # Update running_sum by adding dp[i-3]\n        running_sum = (running_sum + dp[i - 3]) % mod\n\n        # Subtract dp[i-1] and dp[i-2] to exclude invalid partitions\n        if i - 1 >= 3:\n            running_sum = (running_sum - dp[i - 1]) % mod\n        if i - 2 >= 3:\n            running_sum = (running_sum - dp[i - 2]) % mod\n\n        # Update dp[i] with the current running_sum\n        dp[i] = running_sum\n\n    return dp[s]\n\nprint(solve())"}
{"problem_id":"p02780","slow_code_col":"import numpy as np\n\nn, k = list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\np += 1\n\nsum_E = np.cumsum(p)\n\nsum_e = np.append([0], sum_E)\n\nans = -1\n\nfor i in range(n-k+1):\n\n    ans = max(ans, sum_e[i+k] - sum_e[i])\n\nprint((ans\/2))","reference_code_col":"n, k = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\ndef calc(x):\n\n    return (x + 1) \/ 2\n\n\n\n\n\nw = 0\n\n\n\nfor i in range(k):\n\n    w += calc(p[i])\n\n\n\nans = w\n\nfor i in range(k, n):\n\n    w += calc(p[i]) - calc(p[i - k])\n\n    ans = max(ans, w)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input parsing\nn, k = map(int, input().split())\np = np.fromstring(input(), dtype=int, sep=' ') + 1\n\n# Compute cumulative sum\nsum_E = np.cumsum(p)\n\n# Compute the maximum subarray sum of length k using slicing\nans = np.max(sum_E[k:] - sum_E[:n-k])\n\n# Output the result\nprint(ans \/ 2)"}
{"problem_id":"p03013","slow_code_col":"import numpy as np\n\n\n\n\n\ndef main(n, m, a):\n\n    dp = np.zeros(n + 1, dtype=int)\n\n    dp[0] = 1\n\n    dp[1] = 1 if 1 not in a else 0\n\n\n\n    for i in range(2, len(dp)):\n\n        dp[i] = dp[i - 1] + dp[i - 2] if i not in a else 0\n\n        dp[i] %= 1000000007\n\n\n\n    return dp[-1]\n\n\n\n\n\nif __name__ == '__main__':\n\n    N, M = list(map(int, input().split()))\n\n    A = set()\n\n    for _ in range(M):\n\n        A.add(int(eval(input())))\n\n\n\n    print((main(N, M, A)))\n","reference_code_col":"import math\n\n\n\nMOD = int(math.pow(10, 9)) + 7\n\nN, M = list(map(int, input().split(' ')))\n\nbroken_steps = {int(eval(input())) for _ in range(M)}\n\n\n\ndp = [0] * (N + 1)\n\n\n\ndp[0] = 1\n\nif 1 not in broken_steps:\n\n    dp[1] = 1\n\n\n\nfor step in range(2, N + 1):\n\n    if step not in broken_steps:\n\n        dp[step] = (dp[step - 1] + dp[step - 2]) % MOD\n\n\n\nprint((dp[N]))\n","model_generated_potentially_faster_code_col":"def main(n, m, a):\n    # Use a Python list instead of numpy array for dp\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: 1 way to stay at step 0\n    dp[1] = 1 if 1 not in a else 0  # Base case: 1 way to reach step 1 unless it's blocked\n\n    # Iterate from step 2 to n\n    for i in range(2, n + 1):\n        if i not in a:  # If step i is not blocked\n            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007\n        else:\n            dp[i] = 0  # Step i is blocked, so no ways to reach it\n\n    return dp[n]\n\n\nif __name__ == '__main__':\n    # Read input values\n    N, M = map(int, input().split())\n    A = {int(input()) for _ in range(M)}  # Use set comprehension for blocked steps\n\n    # Compute and print the result\n    print(main(N, M, A))"}
{"problem_id":"p03038","slow_code_col":"n,m = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nA.sort()\n\nbc = [list(map(int,input().split())) for _ in range(m)]\n\n\n\nbc.sort(key=lambda x:x[1],reverse=1)\n\n\n\ni = 0#bc\u306e\u6dfb\u3048\u5b57\n\nj = 0#A\u306e\u6dfb\u3048\u5b57\n\nwhile 1:\n\n\tif i >= m or j >= n:\n\n\t\t#print('i\u304bj\u304c\u8d85\u3048\u305f\uff01')\n\n\t\tbreak\n\n\tif bc[i][1] < A[j]:\n\n\t\t#print('A\u3067\u3063\u304b')\n\n\t\tbreak\n\n\tfor k in range(bc[i][0]):\n\n\t\t#print(i,j,k)\n\n\t\tA[j] = bc[i][1]\n\n\t\tj+=1\n\n\t\tif j >= n:\n\n\t\t\t#print('for\u6587\u5185\u3001j\u304c\u8d85\u3048\u305f')\n\n\t\t\tbreak\n\n\t\tif A[j] > bc[i][1]:\n\n\t\t\t#print('for\u6587\u5185\u3001A\u3067\u3063\u304b')\n\n\t\t\tbreak\n\n\ti+=1\n\n# print(A)\n\nprint((sum(A)))","reference_code_col":"from heapq import heapify,heappop,heappush\n\nn,m = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nheapify(A)\n\nbc = [list(map(int,input().split())) for i in range(m)]\n\nbc.sort(key=lambda x:x[1],reverse=1)\n\n\n\nflag = 0\n\n# print(A)\n\nfor b,c in bc:\n\n\tif flag:\n\n\t\tbreak\n\n\tfor i in range(b):\n\n\t\ta = heappop(A)\n\n\t\tif c <= a:\n\n\t\t\theappush(A,a)\n\n\t\t\tflag = 1\n\n\t\t\tbreak\n\n\t\telse:\n\n\t\t\theappush(A,c)\n\nprint((sum(A)))","model_generated_potentially_faster_code_col":"# Input reading\nn, m = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()  # Sort A in ascending order\n\nbc = [list(map(int, input().split())) for _ in range(m)]\nbc.sort(key=lambda x: x[1], reverse=True)  # Sort bc by c in descending order\n\n# Two-pointer approach\ni = 0  # Pointer for A\nfor b, c in bc:\n    # Replace up to b elements in A with c\n    limit = min(i + b, n)  # Ensure we don't go out of bounds\n    while i < limit and A[i] < c:\n        A[i] = c\n        i += 1\n    if i >= n:  # All elements in A have been processed\n        break\n\n# Output the sum of A\nprint(sum(A))"}
{"problem_id":"p02874","slow_code_col":"# coding: utf-8\n\nimport numpy as np\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    n = int(args[0])\n\n    LR = [tuple(map(int, a.split())) for a in args[1:]]\n\n    L, R = list(zip(*LR))\n\n\n\n    ret = 0\n\n\n\n    p, q = np.argmax(L), np.argmin(R)\n\n    lp, rq = L[p], R[q]\n\n\n\n    ret = max(0, 1+rq-lp) + max(0, max(1+r-l for l, r in LR))\n\n\n\n    AB = [[max(0, 1+r-lp), max(0, 1+rq-l)] for l, r in LR]\n\n    AB.sort(key=lambda x: (x[0], -x[1]))\n\n    A, B = list(map(list, list(zip(*AB))))\n\n\n\n    # for i in range(1, n):\n\n    #     ret = max(ret, min(A[i:]) + min(B[:i]))\n\n    b_min = 1+10**9\n\n    for i in range(n-1):\n\n        b_min = min(b_min, B[i])\n\n        ret = max(ret, b_min + A[i+1])\n\n\n\n    return str(ret)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n","reference_code_col":"# coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    n = int(args[0])\n\n    LR = [tuple(map(int, a.split())) for a in args[1:]]\n\n    L, R = list(zip(*LR))\n\n\n\n    ret = 0\n\n\n\n    # lp, rq = max(L), min(R)\n\n    lp, rq = 0, 1+10**9\n\n    for l, r in LR:\n\n        lp, rq = max(lp, l), min(rq, r)\n\n\n\n    ret = max(0, 1+rq-lp) + max(0, max(1+r-l for l, r in LR))\n\n\n\n    AB = [[max(0, 1+r-lp), max(0, 1+rq-l)] for l, r in LR]\n\n    AB.sort(key=lambda x: (x[0], -x[1]))\n\n    A, B = list(map(list, list(zip(*AB))))\n\n\n\n    # for i in range(1, n):\n\n    #     ret = max(ret, min(A[i:]) + min(B[:i]))\n\n    b_min = 1+10**9\n\n    for i in range(n-1):\n\n        b_min = min(b_min, B[i])\n\n        ret = max(ret, b_min + A[i+1])\n\n\n\n    return str(ret)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\ndef solve(*args: str) -> str:\n    # Parse input\n    n = int(args[0])\n    LR = [tuple(map(int, a.split())) for a in args[1:]]\n    L, R = zip(*LR)\n\n    # Compute initial values\n    lp, rq = max(L), min(R)\n    ret = max(0, 1 + rq - lp) + max(0, max(1 + r - l for l, r in LR))\n\n    # Precompute AB values\n    AB = [(max(0, 1 + r - lp), max(0, 1 + rq - l)) for l, r in LR]\n\n    # Sort AB by the first element, then reverse second element\n    AB.sort(key=lambda x: (x[0], -x[1]))\n\n    # Extract A and B after sorting\n    A, B = zip(*AB)\n\n    # Optimize the computation of ret using a single pass\n    b_min = float('inf')\n    for i in range(n - 1):\n        b_min = min(b_min, B[i])\n        ret = max(ret, b_min + A[i + 1])\n\n    return str(ret)\n\n\nif __name__ == \"__main__\":\n    print(solve(*(open(0).read().splitlines())))"}
{"problem_id":"p03164","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\n \n\nN,W = list(map(int, input().split()))\n\n \n\ndp = [10 ** 10] * N * (10 ** 4)\n\ndp[0] = 0\n\ndp = np.array(dp)\n\n \n\n \n\nfor i in range(N):\n\n    w,v = list(map(int, input().split()))\n\n    dp[v:] = np.minimum(dp[v:] , dp[:-v] + w)\n\n  \n\nfor i,count in enumerate(dp):\n\n    if dp[i] <= W:\n\n        ans = i\n\nprint(ans)","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\n \n\nN,W = list(map(int, input().split()))\n\n \n\ndp = [10 ** 10] * (N * (10 ** 3) + 1)\n\ndp[0] = 0\n\ndp = np.array(dp)\n\n \n\n \n\nfor i in range(N):\n\n    w,v = list(map(int, input().split()))\n\n    dp[v:] = np.minimum(dp[v:] , dp[:-v] + w)\n\n  \n\nfor i,count in enumerate(dp):\n\n    if dp[i] <= W:\n\n        ans = i\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\n# Read N (number of items) and W (maximum weight)\nN, W = map(int, input().split())\n\n# Read all items' weights and values\nitems = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Calculate the maximum possible value (sum of all values)\nmax_value = sum(v for _, v in items)\n\n# Initialize DP array: dp[i] = minimum weight required to achieve value i\ndp = [float('inf')] * (max_value + 1)\ndp[0] = 0  # Base case: 0 value requires 0 weight\n\n# Update DP array\nfor w, v in items:\n    for value in range(max_value, v - 1, -1):  # Iterate backwards to avoid overwriting\n        if dp[value - v] + w < dp[value]:\n            dp[value] = dp[value - v] + w\n\n# Find the maximum value such that the weight does not exceed W\nans = max(value for value, weight in enumerate(dp) if weight <= W)\n\nprint(ans)"}
{"problem_id":"p03796","slow_code_col":"import math\n\nx = int(eval(input()))\n\nprint((math.factorial(x) % (10**9 + 7)))","reference_code_col":"M = 1000000007\n\nn=int(eval(input()))\n\nf = 1\n\nfor i in range(1, n + 1):  \n\n    f = (f * i) % M \n\nprint(f)","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\nx = int(eval(input()))\n\n# Compute factorial modulo MOD iteratively\nresult = 1\nfor i in range(2, x + 1):\n    result = (result * i) % MOD\n\nprint(result)"}
{"problem_id":"p03416","slow_code_col":"a,b=list(map(int,input().split()))\n\nans=0\n\nfor i in range(b+1)[a:]:\n\n  if len(str(i))%2==0:\n\n    p=list(str(i))[:len(str(i))\/\/2]\n\n    q=list(reversed(list(str(i))[len(str(i))\/\/2:]))\n\n    if p==q:\n\n      ans+=1\n\n  else:\n\n    s=list(str(i))[:len(str(i))\/\/2+1]\n\n    d=list(reversed(list(str(i))[len(str(i))\/\/2:]))\n\n    if s==d:\n\n      ans += 1\n\nprint(ans)","reference_code_col":"a,s=list(map(int,input().split()))\n\nad=0\n\nfor i in range(a,s+1):\n\n  if str(i)==str(i)[::-1]:ad+=1\n\nprint(ad)","model_generated_potentially_faster_code_col":"a, b = map(int, input().split())\n\ndef is_palindrome(num):\n    \"\"\"Check if a number is a palindrome.\"\"\"\n    s = str(num)\n    return s == s[::-1]\n\nans = 0\nfor i in range(a, b + 1):\n    if is_palindrome(i):\n        ans += 1\n\nprint(ans)"}
{"problem_id":"p01093","slow_code_col":"while int(eval(input())) > 0:\n\n    s = sorted(map(int, input().split()))\n\n    print((min(abs(a - b) for (a, b) in zip(s, s[1:]))))","reference_code_col":"while True:\n\n    if int(eval(input())) == 0:\n\n        break\n\n    s = sorted(map(int, input().split()))\n\n    r = min(abs(x - y) for (x, y) in zip(s, s[1:]))\n\n    print(r)","model_generated_potentially_faster_code_col":"import sys\ninput = sys.stdin.read  # Read all input at once for efficiency\n\ndef main():\n    data = input().splitlines()  # Split input into lines\n    i = 0\n    while i < len(data):\n        n = int(data[i])  # Number of elements in the next line\n        if n <= 0:\n            break  # Exit if n is non-positive\n        i += 1\n        s = sorted(map(int, data[i].split()))  # Sort the list of integers\n        min_diff = float('inf')  # Initialize minimum difference\n        for j in range(1, len(s)):\n            diff = s[j] - s[j - 1]  # Compute difference between consecutive elements\n            if diff < min_diff:\n                min_diff = diff  # Update minimum difference\n        print(min_diff)\n        i += 1\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02412","slow_code_col":"def main():\n\n\n\n    while True:\n\n        n, x = tuple(map(int, input().split()))\n\n        pattern = 0\n\n\n\n        if n == x == 0:\n\n            break\n\n        else:\n\n            for a in range(1, n+1):\n\n                for b in range(1, a):\n\n                    for c in range(1, b):\n\n                        pattern += 1 if a + b + c == x and a > b > c else 0\n\n            print(pattern)\n\n                            \n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def divide_two(c, z):\n\n    min_b = z \/\/ 2 + 1\n\n    max_b = min(c-1, z-1)\n\n    return max(max_b-min_b+1, 0)\n\n    \n\n\n\nnum_set = []\n\ncnt = 0\n\nwhile True:\n\n    n, x = list(map(int, input().split()))\n\n    if (n, x) == (0, 0):\n\n        break\n\n    else:\n\n        num_set.append((n, x))\n\n        cnt += 1\n\n\n\nfor i in range(cnt):\n\n    num_count = 0\n\n    (n, x) = num_set[i]\n\n    for c in range(x\/\/3, n+1):\n\n        num_count += divide_two(c, x-c)\n\n    print(num_count)\n","model_generated_potentially_faster_code_col":"def main():\n    # Precompute all valid triplets (a, b, c) where a > b > c\n    max_n = 1000  # Assuming a reasonable upper limit for n\n    triplets = []\n    for a in range(1, max_n + 1):\n        for b in range(1, a):\n            for c in range(1, b):\n                triplets.append((a, b, c))\n\n    while True:\n        n, x = map(int, input().split())\n\n        if n == 0 and x == 0:\n            break\n\n        # Count valid triplets for the current n and x\n        pattern = sum(1 for a, b, c in triplets if a <= n and a + b + c == x)\n        print(pattern)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03416","slow_code_col":"A, B = list(map(int, input().split()))\n\nnumbers = list(range(A, B+1))\n\ncount = 0\n\nfor i in numbers:\n\n    m = str(i)\n\n    rm = ''.join(list(reversed(m)))\n\n    if m == rm:\n\n        count += 1\n\nprint(count)","reference_code_col":"A, B = list(map(int, input().split()))\n\nx = list(range(1,10))\n\ny = list(range(10))\n\ncount = 0\n\nfor p in x:\n\n    for q in y:\n\n        for r in y:\n\n            sakasama = int(str(p)+str(q)+str(r)+str(q)+str(p))\n\n            if A <= sakasama <= B:\n\n                count += 1\n\nprint(count)","model_generated_potentially_faster_code_col":"def count_palindromes(A, B):\n    def is_palindrome(n):\n        # Check if a number is a palindrome using arithmetic\n        original = n\n        reversed_num = 0\n        while n > 0:\n            reversed_num = reversed_num * 10 + n % 10\n            n \/\/= 10\n        return original == reversed_num\n\n    count = 0\n    for num in range(A, B + 1):\n        if is_palindrome(num):\n            count += 1\n\n    return count\n\n\n# Input\nA, B = map(int, input().split())\n\n# Output\nprint(count_palindromes(A, B))"}
{"problem_id":"p02863","slow_code_col":"import sys\n\nfrom operator import itemgetter\n\nfrom heapq import heapify, heappop, heappush\n\nMAX_INT = int(10e15)\n\nMIN_INT = -MAX_INT\n\nmod = 1000000007\n\nsys.setrecursionlimit(1000000)\n\ndef IL(): return list(map(int,input().split()))\n\ndef SL(): return input().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef S(): return eval(input())\n\n\n\nN, T = IL()\n\nab = [IL() for i in range(N)]\n\nab.sort(key=itemgetter(0))\n\n#print(ab)\n\n\n\ndp = [[0]*(T+1+3000+1) for _ in range(N+1)]\n\nans = 0\n\nfor i in range(N):\n\n  for j in range(T+1+3000+1):\n\n    time, deli = ab[i]\n\n    if 0 <= j-time < T:\n\n      dp[i + 1][j] = max(dp[i][j], dp[i][j - time] + deli)\n\n    else:\n\n      dp[i + 1][j] = dp[i][j]\n\n    ans = max(ans, dp[i + 1][j])\n\nprint(ans)\n\n\n\n#print(dp)\n","reference_code_col":"import sys\n\nfrom collections import deque\n\nMAX_INT = int(10e10)\n\nMIN_INT = -MAX_INT\n\nmod = 1000000007\n\nsys.setrecursionlimit(1000000)\n\ndef IL(): return list(map(int,input().split()))\n\ndef SL(): return input().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef S(): return eval(input())\n\n\n\nN,T = IL()\n\nab = [IL() for i in range(N)]\n\nab.sort()\n\n\n\nans = 0\n\ndp = [[0]*T for i in range(N+1)]\n\nfor i in range(1,N+1):\n\n  a,b = ab[i-1]\n\n  for j in range(T):\n\n    if 0 <= j-a < T:\n\n      dp[i][j] = max(dp[i-1][j], dp[i-1][j-a] + b)\n\n    else:\n\n      dp[i][j] = dp[i-1][j]\n\n  else:\n\n    ans = max(ans, dp[i-1][-1] + b)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\nfrom operator import itemgetter\n\ndef IL(): return list(map(int, input().split()))\ndef I(): return int(sys.stdin.readline())\n\n# Input reading\nN, T = IL()\nab = [IL() for _ in range(N)]\nab.sort(key=itemgetter(0))  # Sort by time\n\n# Initialize DP array\ndp = [0] * (T + 1)\nans = 0\n\n# Iterate over each dish\nfor i in range(N):\n    time, deli = ab[i]\n    \n    # Update DP array in reverse to avoid overwriting\n    for j in range(T, -1, -1):\n        if j + time <= T:\n            dp[j + time] = max(dp[j + time], dp[j] + deli)\n    \n    # Track the maximum value so far\n    ans = max(ans, max(dp))\n\nprint(ans)"}
{"problem_id":"p02792","slow_code_col":"from functools import lru_cache\n\nimport sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\n\n@lru_cache(maxsize=None)\n\ndef check(l, r, n, k=1):\n\n    t = l + '0' * k + r\n\n    e = l + '9' * k + r\n\n\n\n    if int(e) <= n:\n\n        return pow(10, k) + check(l, r, n, k + 1)\n\n\n\n    if int(t) <= n < int(e):\n\n        x = int(str(n)[1:-1])\n\n        if int(str(n)[-1]) < int(r):\n\n            x -= 1\n\n        return x + 1\n\n\n\n    if n < int(t):\n\n        return 0\n\n\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n\n\n    ret = 0\n\n    for x in range(1, n + 1):\n\n        if x % 10 == 0:\n\n            continue\n\n        s = str(x)\n\n        t = s[-1] + s[0]\n\n        if s[0] == s[-1]:\n\n            ret += 1\n\n        if int(t) <= n:\n\n            ret += 1\n\n        ret += check(s[-1], s[0], n, k=1)\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"# \u89e3\u8aac\u653e\u9001\n\n\n\ndef main():\n\n    from collections import defaultdict\n\n\n\n    n = int(eval(input()))\n\n\n\n    d = defaultdict(int)\n\n    for x in range(1, n + 1):\n\n        if x % 10 == 0:\n\n            continue\n\n\n\n        tail = x % 10\n\n        head = 0\n\n        while x:\n\n            head = x\n\n            x \/\/= 10\n\n\n\n        d[head, tail] += 1\n\n\n\n    ret = 0\n\n    for (head, tail), cnt in tuple(d.items()):\n\n        # RuntimeError: dictionary changed size during iteration\n\n        # defaultdict\u306e\u672a\u5b9a\u7fa9(?)\u306ekey\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u305b\u3044\u3067\u3001RE\u306b\u306a\u308b\n\n        # d.items()\u3092tuple\u5316\u3057\u3066\u56de\u907f\n\n        ret += d[head, tail] * d[tail, head]\n\n        # (head,tail)\u306e\u51fa\u73fe\u6570\u3092\u8f9e\u66f8\u3067\u7ba1\u7406\u3059\u308b\n\n        # (head,tail)*(tail,head)\u306e\u7d44\u307f\u5408\u308f\u305b\u304c\u3042\u308b\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"from functools import lru_cache\n\ndef check(l, r, n, k=1):\n    # Precompute powers of 10\n    pow_10_k = 10 ** k\n    \n    # Construct the lower and upper bounds\n    t = int(l + '0' * k + r)\n    e = int(l + '9' * k + r)\n    \n    if e <= n:\n        return pow_10_k + check(l, r, n, k + 1)\n    \n    if t <= n < e:\n        x = int(str(n)[1:-1])  # Extract middle digits\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n    \n    return 0\n\ndef main():\n    n = int(input())  # Read input directly without eval\n    \n    ret = 0\n    power_of_10 = 1  # Track powers of 10 dynamically\n    \n    while power_of_10 <= n:\n        for first_digit in range(1, 10):  # First digit cannot be zero\n            for last_digit in range(0, 10):\n                # Form the number with current first and last digits\n                base = first_digit * power_of_10 + last_digit\n                \n                # Check if the number is within bounds\n                if base > n:\n                    continue\n                \n                # Count numbers with matching first and last digits\n                if first_digit == last_digit:\n                    ret += 1\n                \n                # Add contributions from numbers formed by inserting digits\n                ret += check(str(last_digit), str(first_digit), n, k=1)\n        \n        power_of_10 *= 10  # Move to the next power of 10\n    \n    print(ret)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03325","slow_code_col":"import math\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\n\n\ndef trial_division(n):\n\n    factor = []\n\n    tmp = int(math.sqrt(n)) + 1\n\n    for _ in range(2,tmp):\n\n        while n % 2 == 0:\n\n            n \/\/= 2\n\n            factor.append(2)\n\n    if not factor:\n\n        return [n]\n\n    else:\n\n        factor.append(n)\n\n        return factor\n\n\n\n\n\ncount = 0\n\nfor i in a:\n\n    temp = trial_division(i)\n\n    count += temp.count(2)\n\n\n\nprint(count)","reference_code_col":"n = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\n\n\ndef trial_division(n):\n\n    #\uff12\u3067\u5272\u3063\u305f\u56e0\u6570\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n\n    factor = []\n\n    #2\u3067\u5272\u308c\u306a\u304f\u306a\u3063\u305f\u6642\u70b9\u3067\u30b9\u30c8\u30c3\u30d7\n\n    while n % 2 == 0:\n\n        n \/\/= 2    # \uff12\u3067\u5272\u3063\u305f\u5546\u3092\u5207\u308a\u6368\u3066\u3066\u4ee3\u5165\n\n        factor.append(2)\n\n    #n\u304c\u4e00\u5ea6\u3082\uff12\u3067\u5272\u308c\u306a\u304b\u3063\u305f\u3089\u305d\u306e\u307e\u307e\u8fd4\u3059\n\n    if not factor:\n\n        return [n]\n\n    else:\n\n        factor.append(n)\n\n        return factor\n\n\n\n\n\ncount = 0\n\nfor i in a:\n\n    temp = trial_division(i)\n\n    count += temp.count(2)\n\n\n\nprint(count)","model_generated_potentially_faster_code_col":"n = int(input())\na = list(map(int, input().split()))\n\ncount = 0\n\nfor num in a:\n    while num % 2 == 0:\n        count += 1\n        num \/\/= 2\n\nprint(count)"}
{"problem_id":"p03164","slow_code_col":"\n\n\n\n# N\u500b\u306e\u8377\u7269\u3001\u30ca\u30c3\u30d7\u30b6\u30c3\u30af\u306e\u5bb9\u91cf\u306fW\n\nN, W = list(map(int, input().split()))\n\nw = [0] * N\n\nv = [0] * N\n\n\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    w[i] = a\n\n    v[i] = b\n\n\n\n# 1 <= W <= 10^9\u306a\u306e\u3067\u6a2a\u8ef8\u3092W\u306b\u3059\u308b\u3068\u30c6\u30fc\u30d6\u30eb\u304c\u3067\u304b\u3059\u304e\u308b\n\n# \u305d\u306e\u304b\u308f\u308a\u306bV\u306e\u65b9\u3092\u6a2a\u8ef8\u306b\u3059\u308b\n\n\n\n# \u4fa1\u5024\u306e\u7dcf\u5408\u8a08\u306f\u307e\u3060\u4e0d\u660e\u306a\u306e\u3067\u3001\u9069\u5f53\u306b\u3067\u304b\u3044\u5024\u306b\u3057\u3068\u304f\n\n# \u6700\u4e0a\u90e8\u3068\u6700\u5de6\u90e8\u306b0\u304c\u5165\u308b\u306e\u3067\u3001\u305d\u306e\u5206\u3092+1\n\nV = N*1000+1\n\ndp = [ [float('inf') for _ in range(V+1)] for _ in range(N+1) ]\n\n\n\n# \u6700\u5c0f\u5024\u3092\u6c42\u3081\u308b\u306e\u3067\u3001\u4e0a\u8a18\u3067inf\u304c\u5165\u3063\u3066\u308b\u306e\u3067\u3001\u521d\u671f\u5024\u306f0\u3092\u3044\u308c\u308b\u5fc5\u8981\u304c\u3042\u308b\n\ndp[0][0] = 0\n\n\n\n# dp[i][sum_v] = \u3053\u308c\u307e\u3067(i-1)\u756a\u76ee\u307e\u3067\u306e\u54c1\u7269\u304b\u3089\u4fa1\u5024\u304csum_v\u4ee5\u4e0a\u306b\u306a\u308b\u3088\u3046\u306b\u9078\u3093\u3060\u3068\u304d\u306e\u3001\u91cd\u3055\u306e\u7dcf\u548c\u306e\u6700\u5c0f\u5024\n\nfor i in range(N):\n\n    for sum_v in range(V):\n\n        if sum_v - v[i] >= 0:\n\n            dp[i+1][sum_v] = min(dp[i+1][sum_v], dp[i][sum_v-v[i]]+w[i])\n\n\n\n        dp[i+1][sum_v] = min(dp[i+1][sum_v], dp[i][sum_v])\n\n\n\n\n\n# \u4e2d\u8eab\u304cW\u306a\u306e\u3067\u3001W\u4ee5\u4e0b\u3067\u3042\u308b\u3046\u3061\u306esum_v\u306e\u6700\u5927\u5024\u3092\u6c42\u3081\u308c\u3070\u3044\u3044\n\nfor sum_v in range(V):\n\n    # \u6700\u7d42\u884c\u3060\u3051\u898b\u308c\u3070\u3044\u3044\u306e\u3067\u3001\u7aef\u304b\u3089sum_v\u306e\u6700\u5927\u5024\u3092\u306a\u3081\u308b\u3060\u3051\n\n    if dp[N][sum_v] <= W:\n\n        ans = sum_v\n\n\n\nprint(ans)","reference_code_col":"\n\n\n\nimport sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\n# A = [ int(input()) for _ in range(N) ]\n\n##############################\n\n\n\nN, W = list(map(int, input().split()))\n\nw = []\n\nv = []\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    w.append(a)\n\n    v.append(b)\n\n\n\nV = sum(v)\n\n\n\ndp = [ [INF for _ in range(V+1)] for _ in range(N+1) ]\n\n\n\ndp[0][0] = 0\n\n\n\nfor i in range(N):\n\n    for j in range(V+1):\n\n        if j - v[i] < 0:\n\n            dp[i+1][j] = dp[i][j]\n\n        else:\n\n            dp[i+1][j] = min(dp[i][j], dp[i][j-v[i]]+w[i])\n\n\n\n#print(dp[N])\n\n\n\nans = 0\n\nfor v in range(V+1):\n\n    if dp[N][v] <= W:\n\n        ans = v\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"# Input: Number of items (N) and knapsack capacity (W)\nN, W = map(int, input().split())\n\n# Input: Weights and values of the items\nw = []\nv = []\nfor _ in range(N):\n    a, b = map(int, input().split())\n    w.append(a)\n    v.append(b)\n\n# Maximum possible value (V) is N * 1000\nV = N * 1000 + 1\n\n# Initialize the DP array with infinity\n# dp[sum_v] = minimum weight required to achieve value sum_v\ndp = [float('inf')] * V\ndp[0] = 0  # Base case: 0 value requires 0 weight\n\n# Process each item\nfor i in range(N):\n    # Update the DP array in reverse to avoid overwriting\n    for sum_v in range(V - 1, v[i] - 1, -1):\n        if dp[sum_v - v[i]] + w[i] < dp[sum_v]:\n            dp[sum_v] = dp[sum_v - v[i]] + w[i]\n\n# Find the maximum value such that the weight does not exceed W\nans = 0\nfor sum_v in range(V):\n    if dp[sum_v] <= W:\n        ans = sum_v\n\nprint(ans)"}
{"problem_id":"p02599","slow_code_col":"import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\nMOD = 1000000007\n\n\n\n# Reference: https:\/\/www.geeksforgeeks.org\/queries-number-distinct-elements-subarray\/\n\n# Python3 code to find number of\n\n# distinct numbers in a subarray\n\nMAX = 1000001\n\n\n\n# structure to store queries\n\nclass Query:\n\n    def __init__(self, l, r, idx):\n\n        self.l = l\n\n        self.r = r\n\n        self.idx = idx\n\n\n\n\n\n# updating the bit array\n\ndef update(idx, val, bit, n):\n\n    while idx <= n:\n\n        bit[idx] += val\n\n        idx += idx & -idx\n\n\n\n\n\n# querying the bit array\n\ndef query(idx, bit, n):\n\n    summ = 0\n\n    while idx:\n\n        summ += bit[idx]\n\n        idx -= idx & -idx\n\n    return summ\n\n\n\n\n\ndef answeringQueries(arr, n, queries, q):\n\n\n\n    # initialising bit array\n\n    bit = [0] * (n + 1)\n\n\n\n    # holds the rightmost index of\n\n    # any number as numbers of a[i]\n\n    # are less than or equal to 10^6\n\n    last_visit = [-1] * MAX\n\n\n\n    # answer for each query\n\n    ans = [0] * q\n\n\n\n    query_counter = 0\n\n    for i in range(n):\n\n\n\n        # If last visit is not -1 update -1 at the\n\n        # idx equal to last_visit[arr[i]]\n\n        if last_visit[arr[i]] != -1:\n\n            update(last_visit[arr[i]] + 1, -1, bit, n)\n\n\n\n        # Setting last_visit[arr[i]] as i and\n\n        # updating the bit array accordingly\n\n        last_visit[arr[i]] = i\n\n        update(i + 1, 1, bit, n)\n\n\n\n        # If i is equal to r of any query store answer\n\n        # for that query in ans[]\n\n        while query_counter < q and queries[query_counter].r == i:\n\n            ans[queries[query_counter].idx] = query(queries[query_counter].r + 1, bit, n) - query(\n\n                queries[query_counter].l, bit, n\n\n            )\n\n            query_counter += 1\n\n\n\n    # print answer for each query\n\n    for i in range(q):\n\n        print((ans[i]))\n\n\n\n\n\n# This code is contributed by\n\n# sanjeev2552\n\n\n\n\n\ndef main():\n\n    N, Q = list(map(int, readline().split()))\n\n    C = list(map(int, readline().split()))\n\n    (*LR,) = list(map(int, read().split()))\n\n\n\n    queries = [0] * Q\n\n    for i, (l, r) in enumerate(zip(*[iter(LR)] * 2)):\n\n        queries[i] = Query(l - 1, r - 1, i)\n\n\n\n    queries.sort(key=lambda x: x.r)\n\n    answeringQueries(C, N, queries, Q)\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n","reference_code_col":"import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\nMOD = 1000000007\n\n\n\n\n\nclass BIT:\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.data = [0] * (n + 1)\n\n\n\n    def add(self, i, x=1):\n\n        i += 1\n\n        while i <= self.n:\n\n            self.data[i] += x\n\n            i += i & -i\n\n\n\n    def get_sum(self, i):\n\n        i += 1\n\n        x = 0\n\n        while i > 0:\n\n            x += self.data[i]\n\n            i -= i & -i\n\n        return x\n\n\n\n    # Return sum for [l, r)\n\n    def get_sum_range(self, l, r):\n\n        return self.get_sum(r - 1) - self.get_sum(l - 1)\n\n\n\n\n\ndef main():\n\n    N, Q = map(int, readline().split())\n\n    C = list(map(int, readline().split()))\n\n    LR = map(int, read().split())\n\n\n\n    prev = [-1] * (N + 1)\n\n    ps = [[] for _ in range(N)]\n\n    for i, c in enumerate(C):\n\n        if prev[c] != -1:\n\n            ps[prev[c]].append(i)\n\n        prev[c] = i\n\n\n\n    qs = [[] for _ in range(N + 1)]\n\n    for i, (l, r) in enumerate(zip(*[iter(LR)] * 2)):\n\n        l -= 1\n\n        r -= 1\n\n        qs[l].append((r, i))\n\n\n\n    ans = [0] * Q\n\n    bit = BIT(N)\n\n\n\n    for l in range(N - 1, -1, -1):\n\n        for r in ps[l]:\n\n            bit.add(r)\n\n        for r, i in qs[l]:\n\n            ans[i] = (r - l + 1) - bit.get_sum(r)\n\n\n\n    print(*ans, sep='\\n')\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\n# Fast input reading\ninput_data = sys.stdin.read().split()\ninput_idx = 0\n\ndef read_int():\n    global input_idx\n    value = int(input_data[input_idx])\n    input_idx += 1\n    return value\n\n# Constants\nINF = 1 << 60\nMOD = 1000000007\n\n# Binary Indexed Tree (Fenwick Tree)\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def update(self, idx, val):\n        while idx <= self.n:\n            self.tree[idx] += val\n            idx += idx & -idx\n\n    def query(self, idx):\n        summ = 0\n        while idx > 0:\n            summ += self.tree[idx]\n            idx -= idx & -idx\n        return summ\n\ndef answeringQueries(arr, n, queries, q):\n    # Initialize BIT\n    bit = BIT(n)\n\n    # Dictionary to track the last visit of each element\n    last_visit = {}\n\n    # Answer array for queries\n    ans = [0] * q\n\n    query_counter = 0\n    for i in range(n):\n        # If the element was seen before, remove its previous contribution\n        if arr[i] in last_visit:\n            bit.update(last_visit[arr[i]] + 1, -1)\n\n        # Update the last visit index and add the current contribution\n        last_visit[arr[i]] = i\n        bit.update(i + 1, 1)\n\n        # Process all queries ending at the current index\n        while query_counter < q and queries[query_counter][1] == i:\n            l, r, idx = queries[query_counter]\n            ans[idx] = bit.query(r + 1) - bit.query(l)\n            query_counter += 1\n\n    # Output the results\n    sys.stdout.write(\"\\n\".join(map(str, ans)) + \"\\n\")\n\ndef main():\n    # Read input\n    N = read_int()\n    Q = read_int()\n    C = [read_int() for _ in range(N)]\n\n    # Read and sort queries\n    queries = []\n    for i in range(Q):\n        l = read_int() - 1\n        r = read_int() - 1\n        queries.append((l, r, i))\n\n    queries.sort(key=lambda x: x[1])\n\n    # Process queries\n    answeringQueries(C, N, queries, Q)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02596","slow_code_col":"k = int(eval(input()))\n\nnum = 0\n\nif not k%2:\n\n    print((-1))\n\nelse:\n\n    for i in range(k):\n\n        num = (num*10+7)%k\n\n        if num == 0:\n\n            print((i+1))\n\n            break\n\n    else:\n\n        print((-1))","reference_code_col":"K = int(eval(input()))\n\n\n\nans = 1\n\nnum = 0\n\nseven = 7\n\n\n\nif not K%2:\n\n    print((-1))\n\nelse:\n\n    for i in range(K):\n\n        num = num + seven\n\n        seven = seven*10%K\n\n        num = num%K\n\n        if num == 0:\n\n            print(ans)\n\n            break\n\n        ans += 1\n\n    else:\n\n        print((-1))","model_generated_potentially_faster_code_col":"k = int(input())\n\nif k % 2 == 0:  # Even numbers cannot divide a number made of only 7s\n    print(-1)\nelse:\n    num = 0\n    seen = set()  # To track previously seen values of num\n\n    for i in range(k):\n        num = (num * 10 + 7) % k\n\n        if num == 0:  # Found a number divisible by k\n            print(i + 1)\n            break\n\n        if num in seen:  # Cycle detected\n            print(-1)\n            break\n\n        seen.add(num)  # Mark this value as seen"}
{"problem_id":"p02886","slow_code_col":"N=int(eval(input()))\n\nd=list(map(int, input().split()))\n\n\n\nimport numpy as np\n\nd = np.array(d)\n\n\n\nprint(( ( (np.sum(d))**2 - np.sum(d**2) ) \/\/ 2 ))\n","reference_code_col":"N=int(eval(input()))\n\nd=list(map(int, input().split()))\n\n\n\ncumsum = 0\n\nfor n in range(N):\n\n    cumsum += d[n]\n\nsub_cumsum = 0\n\nans = 0\n\nfor n in range(N):\n\n    sub_cumsum += d[n]\n\n    ans += d[n] * (cumsum-sub_cumsum)\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"# Read input values\nN = int(input())\nd = list(map(int, input().split()))\n\n# Compute the required value using efficient Python operations\nsum_d = sum(d)          # Sum of all elements in d\nsum_d_squared = sum(x * x for x in d)  # Sum of squares of elements in d\n\n# Calculate the result\nresult = (sum_d**2 - sum_d_squared) \/\/ 2\n\n# Print the result\nprint(result)"}
{"problem_id":"p02596","slow_code_col":"k = int(eval(input()))\n\ncount = 1\n\nn = 0\n\nif k % 2 == 0 or k % 5 == 0:\n\n    print((-1))\n\nelse:\n\n  while 1:\n\n      n = (n * 10 + 7) % k  \n\n      if n == 0:\n\n        break \n\n      count += 1\n\n  print(count)","reference_code_col":"def main(h):\n\n  count = 1\n\n  n = 0\n\n  for i in range (k):\n\n    n = (n * 10 + 7) % k  \n\n    if n == 0: \n\n      print(count)\n\n      return 0\n\n    count += 1\n\n  print((-1))\n\n  \n\nif __name__ == '__main__':\n\n  k = int(eval(input()))\n\n  main(k)","model_generated_potentially_faster_code_col":"k = int(input())\n\nif k % 2 == 0 or k % 5 == 0:\n    print(-1)\nelse:\n    count = 1\n    n = 7 % k\n    seen_remainders = set()  # To detect cycles\n\n    while n != 0:\n        if n in seen_remainders:\n            # Cycle detected, no solution exists\n            print(-1)\n            break\n        seen_remainders.add(n)\n        n = (n * 10 + 7) % k\n        count += 1\n    else:\n        # Loop exited because n == 0\n        print(count)"}
{"problem_id":"p03250","slow_code_col":"a, b, c = sorted(map(int, input().split()))\n\n\n\nprint((c*10 + b + a))","reference_code_col":"a, b, c = list(map(int, input().split()))\n\n\n\nprint((max(a, b, c)*9 + (a + b + c)))","model_generated_potentially_faster_code_col":"# Read input and convert to integers\nnums = list(map(int, input().split()))\n\n# Manually find the smallest, middle, and largest values\na = min(nums)  # Smallest value\nc = max(nums)  # Largest value\nnums.remove(a)  # Remove the smallest value\nnums.remove(c)  # Remove the largest value\nb = nums[0]     # The remaining value is the middle one\n\n# Compute and print the result\nprint(c * 10 + b + a)"}
{"problem_id":"p03371","slow_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\nans = float('inf')\n\n\n\nfor i in range(200005):\n\n    tmp = i * 2 * c\n\n    tmp += max(0, x-i) * a\n\n    tmp += max(0, y-i) * b\n\n    ans = min(ans, tmp)\n\n\n\nprint(ans)","reference_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\nans = float('inf')\n\n\n\nfor i in range(100005):\n\n    tmp = i * 2 * c\n\n    tmp += max(0, x-i) * a\n\n    tmp += max(0, y-i) * b\n\n    ans = min(ans, tmp)\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\n\n# Initialize the answer to infinity\nans = float('inf')\n\n# Limit the range to max(x, y) + 1\nfor i in range(max(x, y) + 1):\n    # Compute the cost for the current value of i\n    tmp = i * 2 * c\n    tmp += max(0, x - i) * a\n    tmp += max(0, y - i) * b\n\n    # Update the minimum cost\n    ans = min(ans, tmp)\n\nprint(ans)"}
{"problem_id":"p02574","slow_code_col":"import sys\n\nsys.setrecursionlimit(1 << 25)\n\nreadline = sys.stdin.buffer.readline\n\nread = sys.stdin.readline  # \u6587\u5b57\u5217\u8aad\u307f\u8fbc\u3080\u6642\u306f\u3053\u3063\u3061\n\nra = range\n\nenu = enumerate\n\n\n\n\n\ndef exit(*argv, **kwarg):\n\n    print(*argv, **kwarg)\n\n    sys.exit()\n\n\n\n\n\ndef mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))\n\n# \u53d7\u3051\u6e21\u3055\u308c\u305f\u3059\u3079\u3066\u306e\u8981\u7d20\u304b\u3089sub\u3060\u3051\u5f15\u304f.\u30ea\u30b9\u30c8\u3092*\u3092\u3064\u3051\u3066\u5c55\u958b\u3057\u3066\u304a\u304f\u3053\u3068\n\n\n\n\n\ndef a_int(): return int(readline())\n\n\n\n\n\ndef ints(): return list(map(int, readline().split()))\n\n\n\n\n\ndef _make_minimum_prime(N: int):\n\n    # x\u306e\u6700\u5c0f\u306e\u7d20\u56e0\u6570\u8868\u3092\u4f5c\u6210\n\n    min_prime = [x for x in range(N + 1)]\n\n    # min_prime[0] = 0  # 0\u30681\u306f\u7d20\u6570\u3067\u306f\u306a\u3044\n\n    # min_prime[1] = 1\n\n    for i in range(2, int(N ** 0.5) + 1):\n\n        if min_prime[i] == i:  # \u7d20\u6570\u3060\u3063\u305f\u3089\u66f4\u65b0\n\n            for j in range(2 * i, N + 1, i):  # i\u306e\u500d\u6570\u306f\u7d20\u6570\u3067\u306a\u3044\n\n                if min_prime[j] == j:\n\n                    min_prime[j] = i\n\n    return min_prime\n\n\n\n\n\nmin_prime = _make_minimum_prime(10**6)\n\n\n\n\n\nfrom collections import Counter\n\n\n\n\n\ndef fast_factorization(N: int):\n\n    # -> List[Tuple[int,int]] (\u7d20\u6570,\u51aa\u6570)\u3092\u683c\u7d0d\n\n    # \u6700\u5c0f\u7d20\u6570\u914d\u5217min_prime\u3092\u4f7f\u3063\u3066O(log N)\u3067\u56e0\u6570\u5206\u89e3\n\n    if N == 1:\n\n        return Counter()  # 1\u306f\u7d20\u6570\u3067\u306f\u306a\u3044\n\n    # \u7d20\u56e0\u6570\u5206\u89e3\n\n    arr = []\n\n    tmp = N\n\n    while tmp != 1:\n\n        p = min_prime[tmp]\n\n        tmp \/\/= p\n\n        arr.append(p)\n\n\n\n    return Counter(arr)\n\n\n\n\n\nMOD = 10**9 + 7\n\nINF = 2**31  # 2147483648 > 10**9\n\n# default import\n\nfrom collections import defaultdict, Counter, deque\n\nimport random\n\nfrom math import gcd\n\n\n\n\n\nN = a_int()\n\nA = ints()\n\nrandom.shuffle(A)\n\n\n\n# set\u304b\u306f\u3059\u3050\u308f\u304b\u308b\n\n# set\u3067\u306a\u3051\u308c\u3070 not coprime\n\n# pair\u306f\u4e92\u3044\u306b\u7d20\u304b\u3092\u307f\u308c\u3070\u3044\u3044\u306e\u304b\n\n# \u3064\u307e\u308a\u56e0\u6570\u5206\u89e3\u3057\u3066\u8db3\u3057\u3066\u3063\u305f\u3068\u304d\u306b\u3059\u3079\u3066\u306e\u7d20\u6570\u306e\u3079\u304d\u6570\u304c1\u4ee5\u4e0b\u3067\u3042\u308c\u3070\u826f\u3044\n\n\n\ng_set = 0\n\ncnt = defaultdict(lambda: 0)\n\nflg = 1  # pairwise\u3067\u3042\u308b\u30d5\u30e9\u30b0\n\nfor a in A:\n\n    g_set = gcd(g_set, a)\n\n    if flg:\n\n        for p, n in fast_factorization(a).items():\n\n            if cnt[p] != 0:\n\n                flg = 0\n\n            cnt[p] += n\n\n\n\n\n\n# print(cnt)\n\n# for v in cnt.values():\n\n#     if v > 1:\n\n#         flg = 0\n\n#         break\n\n\n\nif g_set > 1:\n\n    print('not coprime')\n\nelif flg:\n\n    print('pairwise coprime')\n\nelse:\n\n    print('setwise coprime')\n","reference_code_col":"import sys\n\nsys.setrecursionlimit(1 << 25)\n\nreadline = sys.stdin.buffer.readline\n\nread = sys.stdin.readline  # \u6587\u5b57\u5217\u8aad\u307f\u8fbc\u3080\u6642\u306f\u3053\u3063\u3061\n\nra = range\n\nenu = enumerate\n\n\n\n\n\ndef exit(*argv, **kwarg):\n\n    print(*argv, **kwarg)\n\n    sys.exit()\n\n\n\n\n\ndef mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))\n\n# \u53d7\u3051\u6e21\u3055\u308c\u305f\u3059\u3079\u3066\u306e\u8981\u7d20\u304b\u3089sub\u3060\u3051\u5f15\u304f.\u30ea\u30b9\u30c8\u3092*\u3092\u3064\u3051\u3066\u5c55\u958b\u3057\u3066\u304a\u304f\u3053\u3068\n\n\n\n\n\ndef a_int(): return int(readline())\n\n\n\n\n\ndef ints(): return list(map(int, readline().split()))\n\n\n\n\n\nfrom collections import Counter\n\n\n\n\n\nclass FastFactorization:\n\n    def __init__(self, N: int):\n\n        '''\u69cb\u7bc9O(NloglogN)\u3001\u30af\u30a8\u30eaO(logN)'''\n\n        self.N = N\n\n        self.min_prime = self._make_minimum_prime()\n\n\n\n    def _make_minimum_prime(self):\n\n        # x\u306e\u6700\u5c0f\u306e\u7d20\u56e0\u6570\u8868\u3092\u4f5c\u6210\n\n        min_prime = [x for x in range(self.N + 1)]\n\n        # min_prime[0] = 0  # 0\u30681\u306f\u7d20\u6570\u3067\u306f\u306a\u3044\n\n        # min_prime[1] = 1\n\n        for i in range(2, int(self.N ** 0.5) + 1):\n\n            if min_prime[i] == i:  # \u7d20\u6570\u3060\u3063\u305f\u3089\u66f4\u65b0\n\n                for j in range(2 * i, self.N + 1, i):  # i\u306e\u500d\u6570\u306f\u7d20\u6570\u3067\u306a\u3044\n\n                    if min_prime[j] == j:\n\n                        min_prime[j] = i\n\n        return min_prime\n\n\n\n    def query(self, x: int):\n\n        # -> Counter[p,n] (\u7d20\u6570,\u51aa\u6570) \u3092\u683c\u7d0d\n\n        # \u6700\u5c0f\u7d20\u6570\u914d\u5217min_prime\u3092\u4f7f\u3063\u3066O(log N)\u3067\u56e0\u6570\u5206\u89e3\n\n        if x == 1:\n\n            return Counter()  # 1\u306f\u7d20\u6570\u3067\u306f\u306a\u3044\n\n\n\n        # \u7d20\u56e0\u6570\u5206\u89e3\n\n        arr = []\n\n        tmp = x\n\n        while tmp != 1:\n\n            p = self.min_prime[tmp]\n\n            tmp \/\/= p\n\n            arr.append(p)\n\n        return Counter(arr)\n\n\n\n\n\nMOD = 10**9 + 7\n\nINF = 2**31  # 2147483648 > 10**9\n\n# default import\n\nfrom collections import defaultdict, Counter, deque\n\nfrom math import gcd\n\n\n\n\n\nN = a_int()\n\nA = ints()\n\n\n\nfact = FastFactorization(max(A))\n\n\n\n# set\u304b\u306f\u3059\u3050\u308f\u304b\u308b\n\n# set\u3067\u306a\u3051\u308c\u3070 not coprime\n\n# pair\u306f\u4e92\u3044\u306b\u7d20\u304b\u3092\u307f\u308c\u3070\u3044\u3044\u306e\u304b\n\n# \u3064\u307e\u308a\u56e0\u6570\u5206\u89e3\u3057\u3066\u8db3\u3057\u3066\u3063\u305f\u3068\u304d\u306b\u3059\u3079\u3066\u306e\u7d20\u6570\u306e\u3079\u304d\u6570\u304c1\u4ee5\u4e0b\u3067\u3042\u308c\u3070\u826f\u3044\n\n\n\ng_set = 0\n\ncnt = defaultdict(lambda: 0)\n\nflg = 1  # pairwise\u3067\u3042\u308b\u30d5\u30e9\u30b0\n\nfor a in A:\n\n    g_set = gcd(g_set, a)\n\n    if flg:\n\n        for p, n in fact.query(a).items():\n\n            if cnt[p] != 0:\n\n                flg = 0\n\n            cnt[p] += n\n\n\n\n\n\n# print(cnt)\n\n# for v in cnt.values():\n\n#     if v > 1:\n\n#         flg = 0\n\n#         break\n\n\n\nif g_set > 1:\n\n    print('not coprime')\n\nelif flg:\n\n    print('pairwise coprime')\n\nelse:\n\n    print('setwise coprime')\n","model_generated_potentially_faster_code_col":"import sys\nfrom math import gcd\nfrom collections import defaultdict\n\n# Set recursion limit (optional, not used here)\nsys.setrecursionlimit(1 << 25)\n\n# Fast input functions\nreadline = sys.stdin.buffer.readline\na_int = lambda: int(readline())\nints = lambda: list(map(int, readline().split()))\n\n# Precompute minimum prime factors\ndef _make_minimum_prime(N):\n    min_prime = list(range(N + 1))\n    for i in range(2, int(N**0.5) + 1):\n        if min_prime[i] == i:  # i is prime\n            for j in range(i * i, N + 1, i):  # Update multiples of i\n                if min_prime[j] == j:\n                    min_prime[j] = i\n    return min_prime\n\nmin_prime = _make_minimum_prime(10**6)\n\n# Fast factorization using precomputed min_prime\ndef fast_factorization(N):\n    factors = defaultdict(int)\n    while N > 1:\n        p = min_prime[N]\n        while N % p == 0:\n            factors[p] += 1\n            N \/\/= p\n    return factors\n\n# Main logic\nN = a_int()\nA = ints()\n\n# Global GCD and pairwise coprime check\ng_set = 0\ncnt = defaultdict(int)\nflg = True  # Pairwise coprime flag\n\nfor a in A:\n    g_set = gcd(g_set, a)\n    \n    # Early termination for \"not coprime\"\n    if g_set > 1:\n        print('not coprime')\n        exit()\n    \n    # Check pairwise coprime condition\n    if flg:\n        factors = fast_factorization(a)\n        for p, n in factors.items():\n            if cnt[p] != 0:\n                flg = False  # Not pairwise coprime\n            cnt[p] += n\n\n# Final output\nif g_set > 1:\n    print('not coprime')\nelif flg:\n    print('pairwise coprime')\nelse:\n    print('setwise coprime')"}
{"problem_id":"p03844","slow_code_col":"print((eval(input())))","reference_code_col":"print(eval(input()))","model_generated_potentially_faster_code_col":"print((eval(input())))"}
{"problem_id":"p03568","slow_code_col":"N = int(eval(input()))\n\nAs = list(map(int,input().split()))\n\n\n\n\n\ndef dfs(A_s, index,Bss):\n\n    if index == N:\n\n        tmp = 1\n\n        for b in Bss:\n\n            tmp *= b\n\n        return 1 if tmp % 2 == 0 else 0\n\n    b_mi = Bss.copy()\n\n    b_mi.append(A_s[index] - 1)\n\n\n\n    b = Bss.copy()\n\n    b.append(A_s[index])\n\n\n\n    b_pl = Bss.copy()\n\n    b_pl.append(A_s[index] + 1)\n\n    return dfs(A_s,index + 1, b_mi) + dfs(A_s,index + 1,b) + dfs(A_s,index + 1,b_pl)\n\n\n\n\n\nprint((dfs(As,0,[])))\n","reference_code_col":"N = int(eval(input()))\n\nAs = list(map(int,input().split()))\n\n\n\ntmp = 1\n\nfor i in range(N):\n\n    if As[i] % 2 == 0:\n\n       tmp *= 2\n\n\n\nprint((3 ** N - tmp))","model_generated_potentially_faster_code_col":"def count_even_products(N, As):\n    total_combinations = 3 ** N\n    odd_product_combinations = 1\n\n    for x in As:\n        # Count how many of (x-1), x, (x+1) are odd\n        odd_count = sum(1 for val in [x - 1, x, x + 1] if val % 2 != 0)\n        odd_product_combinations *= odd_count\n\n    # Total even product combinations = Total combinations - Odd product combinations\n    even_product_combinations = total_combinations - odd_product_combinations\n    return even_product_combinations\n\n# Input reading\nN = int(input())\nAs = list(map(int, input().split()))\n\n# Compute and print the result\nprint(count_even_products(N, As))"}
{"problem_id":"p02767","slow_code_col":"import numpy as np\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    N = int(readline())\n\n    X = [int(i) for i in readline().split()]\n\n    X = np.array(X)\n\n\n\n    ans = np.min(np.sum((X - np.arange(1,101).reshape(100, 1))**2, axis=1))\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    N = int(readline())\n\n    X = [int(i) for i in readline().split()]\n\n\n\n    ans = float('inf')\n\n    for i in range(1,101):\n\n        tmp = 0\n\n        for x in X:\n\n            tmp += (x - i)**2\n\n        \n\n        if tmp < ans:\n\n            ans = tmp\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import numpy as np\nimport sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\n\ndef main():\n    # Read input\n    N = int(readline())\n    X = np.array(list(map(int, readline().split())))\n\n    # Compute the mean of X\n    mean_X = np.mean(X)\n\n    # Find the closest integer to the mean within the range [1, 100]\n    candidate = int(round(mean_X))\n    candidate = max(1, min(candidate, 100))  # Clamp to [1, 100]\n\n    # Compute the sum of squared differences for the candidate\n    ans = np.sum((X - candidate) ** 2)\n\n    # Check neighboring values to ensure the minimum is found\n    for c in [candidate - 1, candidate + 1]:\n        if 1 <= c <= 100:\n            ans = min(ans, np.sum((X - c) ** 2))\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03796","slow_code_col":"import math\n\nn=int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))","reference_code_col":"N=int(eval(input()))\n\ndef fact(n):\n\n    val=1\n\n    for i in range(2,n+1):\n\n        val*=i\n\n        val%=1000000007\n\n    return val\n\nprint((fact(N)))","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7  # Precompute the modulo constant\n\n# Read input safely\nn = int(input())\n\n# Compute factorial iteratively with modulo\nresult = 1\nfor i in range(1, n + 1):\n    result = (result * i) % MOD\n\nprint(result)"}
{"problem_id":"p03309","slow_code_col":"N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# \u4e2d\u592e\u5024\n\nB = []\n\nfor i in range(N):\n\n    B.append(A[i] - (i+1))\n\nb = sorted(B)[N\/\/2]\n\n\n\nans = 0\n\nfor i in range(N):\n\n    ans += abs(A[i] - (i + 1) - b)\n\n\n\nprint(ans)\n\n\n","reference_code_col":"from statistics import median_low\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nD = []\n\nfor i in range(N):\n\n    D.append(A[i] - (i+1))\n\n\n\nm = median_low(D)\n\nans = 0\n\nfor d in D:\n\n    ans += abs(d - m)\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import sys\nfrom math import floor\n\ndef quickselect(arr, k):\n    \"\"\"Find the k-th smallest element in arr using Quickselect.\"\"\"\n    if len(arr) == 1:\n        return arr[0]\n    \n    pivot = arr[len(arr) \/\/ 2]\n    lows = [x for x in arr if x < pivot]\n    highs = [x for x in arr if x > pivot]\n    pivots = [x for x in arr if x == pivot]\n    \n    if k < len(lows):\n        return quickselect(lows, k)\n    elif k < len(lows) + len(pivots):\n        return pivots[0]\n    else:\n        return quickselect(highs, k - len(lows) - len(pivots))\n\ndef main():\n    # Input parsing\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    # Compute B on-the-fly without creating a new list\n    B = [A[i] - (i + 1) for i in range(N)]\n    \n    # Find the median using Quickselect\n    median_index = N \/\/ 2\n    b = quickselect(B, median_index)\n    \n    # Compute the final answer\n    ans = sum(abs(A[i] - (i + 1) - b) for i in range(N))\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03801","slow_code_col":"n = int(input())\n\na = list(map(int, input().split()))\n\n\n\ntmp = [[e, n - i] for i, e in enumerate(a)]\n\ntmp.sort(reverse=True)\n\n\n\naa = [[e, n - i] for e, i in tmp] + [[0, -1]]\n\n\n\nv_prev, i_prev = aa[0]\n\ni = 0\n\nans = [0] * n\n\nsm = 0\n\nwhile i < n:\n\n    while aa[i][1] >= i_prev:\n\n        sm += aa[i][0]\n\n        i += 1\n\n\n\n    ans[i_prev] += sm - aa[i][0] * i\n\n    sm = aa[i][0] * i\n\n    v_prev, i_prev = aa[i]\n\n\n\nprint(*ans, sep=\"\\n\")\n","reference_code_col":"from bisect import bisect_right\n\n\n\nn = int(input())\n\na = list(map(int, input().split()))\n\n\n\nli = [[0, -1]]\n\nfor i, e in enumerate(a):\n\n    if e > li[-1][0]:\n\n        li.append([e, i])\n\n\n\nli = li[::-1]\n\n\n\na.sort()\n\nacc = [0] * (n + 1)\n\nfor i in range(n - 1, -1, -1):\n\n    acc[i] = acc[i+1] + a[i]\n\n\n\nans = [0] * n\n\nsub = 0\n\nans_prev = 0\n\nfor (ep, ip), (e, i) in zip(li, li[1:]):\n\n    j = bisect_right(a, e)\n\n    ans[ip] = acc[j] - e * (n - j)\n\n\n\ni_prev = 0\n\nfor i in range(1, n):\n\n    if ans[i]:\n\n        ans[i_prev] -= ans[i]\n\n        i_prev = i\n\n\n\nprint(*ans, sep=\"\\n\")\n","model_generated_potentially_faster_code_col":"n = int(input())\na = list(map(int, input().split()))\n\n# Pair each element with its reverse index (n - i)\nindexed_a = [(a[i], n - i) for i in range(n)]\n\n# Sort by value in descending order\nindexed_a.sort(reverse=True, key=lambda x: x[0])\n\n# Initialize result array and auxiliary variables\nans = [0] * n\nsm = 0  # Cumulative sum\nprev_index = n + 1  # Sentinel value for initial comparison\n\n# Process sorted list\nfor value, index in indexed_a:\n    if index < prev_index:\n        # Update the result for the previous group\n        ans[prev_index - 1] += sm\n        sm = 0  # Reset cumulative sum for the new group\n    sm += value\n    prev_index = index\n\n# Final update for the last group\nans[prev_index - 1] += sm\n\n# Print the result\nprint(*ans, sep=\"\\n\")"}
{"problem_id":"p03013","slow_code_col":"N, M = list(map(int, input().split()))\n\nA_ = [int(eval(input())) for _ in range(M)]\n\nA = [0] * (N+3)\n\nfor a in A_:\n\n    A[a] = 1\n\ndp = [0] * (N+3)\n\ndp[0] = 1\n\n\n\nmod = 10**9+7\n\n\n\nfor i in range(1, N+1):\n\n    if A[i-1] == 0:\n\n        dp[i] += dp[i-1]\n\n    if A[i-2] == 0:\n\n        dp[i] += dp[i-2]\n\n    dp[i] %= mod\n\nprint((dp[N]))","reference_code_col":"n,m=list(map(int,input().split()))\n\ndp=[0]*(n+3)\n\na=[int(eval(input())) for i in range(m)]\n\nmod=10**9+7\n\nfor i in range(m):\n\n    dp[a[i]]=-1\n\n\n\ndp[0]=1\n\nif dp[1]!=-1:\n\n    dp[1]+=dp[0]\n\n\n\nfor i in range(n+1):\n\n    if dp[i+2]==-1:\n\n        continue\n\n    if dp[i]!=-1:\n\n        dp[i+2]+=dp[i]\n\n    if dp[i+1]!=-1:\n\n        dp[i+2]+=dp[i+1]\n\n    dp[i+2]%=mod\n\nprint((dp[n]%mod))","model_generated_potentially_faster_code_col":"import sys\n\n# Fast input reading\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse N and M\nN, M = map(int, data[:2])\n\n# Parse A_ (blocked steps)\nA_ = set(map(int, data[2:2+M]))\n\n# Initialize dp array\ndp = [0] * (N + 1)\ndp[0] = 1  # Base case: 1 way to reach step 0\n\nmod = 10**9 + 7\n\n# Dynamic programming to calculate number of ways\nfor i in range(1, N + 1):\n    if i not in A_:  # Step i is not blocked\n        dp[i] += dp[i - 1]  # Add ways from step i-1\n    if i > 1 and (i - 1) not in A_:  # Step i-1 is not blocked\n        dp[i] += dp[i - 2]  # Add ways from step i-2\n    dp[i] %= mod  # Apply modulo\n\n# Output the result\nprint(dp[N])"}
{"problem_id":"p02635","slow_code_col":"# coding: utf-8\n\n# Your code here!\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\n\n\n#a,b,c,d = map(int,readline().split())\n\ns,k = readline().split()\n\n\n\n\n\na = [len(i) for i in s.split(\"0\")]\n\nwhile a and a[-1] == 0: a.pop()\n\n\n\nif not a:\n\n    print((1))\n\n    exit()\n\n\n\nMOD = 998244353\n\n\n\nM = sum(a)+1\n\nk = min(int(k),M)\n\n\n\n\n\ndp = [[0]*M for _ in range(k+1)] # j \u4f7f\u3063\u3066\uff08\u4e0a\u9650 k\uff09\u3001l \u4f59\u3063\u3066\u308b\n\ndp[0][0] = 1\n\n\n\n#print(a)\n\nfor ai in a[::-1]:\n\n    ndp = [[0]*M for _ in range(k+1)] # j \u4f7f\u3063\u3066\uff08\u4e0a\u9650 k\uff09\u3001l \u4f59\u3063\u3066\u308b\n\n    for j in range(k+1):\n\n        for l in range(M):\n\n            for ll in range(l):\n\n                ndp[j][ll] += dp[j][l]\n\n                ndp[j][ll] %= MOD\n\n            \n\n            V = min(M-l,k-j+1,ai+1)\n\n            for i in range(V):\n\n                #if j+i > k: break\n\n                ndp[j+i][l+i] += dp[j][l]\n\n                ndp[j+i][l+i] %= MOD\n\n    \n\n    dp = ndp\n\n    #print(dp)\n\n\n\nans = 0\n\nfor jj in range(k+1):\n\n    ans += dp[jj][0]\n\n\n\nprint((ans%MOD))\n\n\n\n\n\n\n\n\n\n\n","reference_code_col":"# coding: utf-8\n\n# Your code here!\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\n\n\n#a,b,c,d = map(int,readline().split())\n\ns,k = readline().split()\n\n\n\n\n\na = [len(i) for i in s.split(\"0\")]\n\nwhile a and a[-1] == 0: a.pop()\n\n\n\nif not a:\n\n    print((1))\n\n    exit()\n\n\n\nMOD = 998244353\n\n\n\nM = sum(a)+1\n\nk = min(int(k),M)\n\n\n\n\n\ndp = [[0]*M for _ in range(k+1)] # j \u4f7f\u3063\u3066\uff08\u4e0a\u9650 k\uff09\u3001l \u4f59\u3063\u3066\u308b\n\ndp[0][0] = 1\n\n\n\n#print(a)\n\nfor ai in a[::-1]:\n\n    ndp = [[0]*M for _ in range(k+1)] # j \u4f7f\u3063\u3066\uff08\u4e0a\u9650 k\uff09\u3001l \u4f59\u3063\u3066\u308b\n\n    for j in range(k+1):\n\n        for l in range(M):\n\n            if dp[j][l]:\n\n                for ll in range(l):\n\n                    ndp[j][ll] += dp[j][l]\n\n                    ndp[j][ll] %= MOD\n\n\n\n                V = min(M-l,k-j+1,ai+1)\n\n                for i in range(V):\n\n                    #if j+i > k: break\n\n                    ndp[j+i][l+i] += dp[j][l]\n\n                    ndp[j+i][l+i] %= MOD\n\n    \n\n    dp = ndp\n\n    #print(dp)\n\n\n\nans = 0\n\nfor jj in range(k+1):\n\n    ans += dp[jj][0]\n\n\n\nprint((ans%MOD))\n\n\n\n\n\n\n\n\n\n\n","model_generated_potentially_faster_code_col":"import sys\n\n# Input reading\nreadline = sys.stdin.readline\ns, k = readline().split()\nk = int(k)\n\n# Preprocessing: Split the string into segments based on '0'\na = [len(i) for i in s.split(\"0\") if i]\nif not a:\n    print(1)\n    exit()\n\nMOD = 998244353\nM = sum(a) + 1\nk = min(k, M)\n\n# Initialize DP table\ndp = [0] * M\ndp[0] = 1\n\n# Process each segment\nfor ai in a:\n    # Create a temporary array for the next state\n    ndp = [0] * M\n    \n    # Compute prefix sums for efficient redistribution\n    prefix_sum = [0] * (M + 1)\n    for l in range(M):\n        prefix_sum[l + 1] = (prefix_sum[l] + dp[l]) % MOD\n    \n    # Update DP table\n    for j in range(k + 1):\n        for l in range(M):\n            if dp[l] == 0:\n                continue\n            \n            # Redistribution logic using prefix sums\n            V = min(M - l, k - j + 1, ai + 1)\n            for i in range(V):\n                ndp[j + i] = (ndp[j + i] + dp[l]) % MOD\n    \n    dp = ndp\n\n# Compute the final answer\nans = sum(dp) % MOD\nprint(ans)"}
{"problem_id":"p02792","slow_code_col":"n=int(eval(input()))\n\nD={}\n\nDD={}\n\nfor i in range(1,n+1):\n\n   s=(str(i)[0],str(i)[-1])\n\n   t=(str(i)[-1],str(i)[0])\n\n   if s not in D:\n\n      D[s]=1\n\n   else:\n\n      D[s]+=1\n\n   if t not in DD:\n\n      DD[t]=1\n\n   else:\n\n      DD[t]+=1\n\nans=0\n\nfor i in D:\n\n   if i in DD:\n\n      ans+=D[i]*DD[i]\n\nprint(ans)\n\n      ","reference_code_col":"n=int(eval(input()))\n\nD={}\n\nfor i in range(1,n+1):\n\n   s=(str(i)[0],str(i)[-1])\n\n   if s in D:\n\n      D[s]+=1\n\n   else:\n\n      D[s]=1\n\n\n\nans=0\n\nfor aj,bj in D:\n\n   if (bj,aj) in D:\n\n      ans+=D[(aj,bj)]*D[(bj,aj)]\n\nprint(ans)","model_generated_potentially_faster_code_col":"from collections import defaultdict\n\n# Read input\nn = int(input())\n\n# Precompute digit pairs and their counts\nD = defaultdict(int)\nDD = defaultdict(int)\n\nfor i in range(1, n + 1):\n    s = (str(i)[0], str(i)[-1])  # First and last digit pair\n    t = (str(i)[-1], str(i)[0])  # Reverse pair\n    D[s] += 1\n    DD[t] += 1\n\n# Compute the final result\nans = sum(D[key] * DD[key] for key in D if key in DD)\n\n# Output the result\nprint(ans)"}
{"problem_id":"p03013","slow_code_col":"n,m=[int(i) for i in input().split()]\n\ndp=[1,1] ;a=set() ; mod=(10**9+7)\n\nfor i in range(m):\n\n    a.add(int(eval(input())))\n\nif 1 in a: dp[1]=0\n\nfor i in range(2,n+1):\n\n    if i not in a:\n\n        dp.append((dp[-1]+dp[-2])%mod)\n\n    else:\n\n        dp.append(0)\n\nprint((dp[-1]))\n\n    \n","reference_code_col":"import sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nn,m=[int(i) for i in input().split()]\n\ndp=[1,1] ;a=set() ; mod=(10**9+7)\n\nfor i in range(m):\n\n    a.add(int(eval(input())))\n\nif 1 in a: dp[1]=0\n\nfor i in range(2,n+1):\n\n    if i not in a:\n\n        dp.append((dp[-1]+dp[-2])%mod)\n\n    else:\n\n        dp.append(0)\n\nprint((dp[-1]))\n\n    \n","model_generated_potentially_faster_code_col":"n, m = map(int, input().split())\n\n# Read all blocked positions at once and store them in a set\nblocked_positions = set(map(int, input().split()))\n\nmod = 10**9 + 7\n\n# Initialize the first two values of the DP sequence\nprev2, prev1 = 1, 1\n\n# Handle the base case: if position 1 is blocked, no paths are possible\nif 1 in blocked_positions:\n    prev1 = 0\n\n# Compute the number of ways to reach each position\nfor i in range(2, n + 1):\n    if i in blocked_positions:\n        # If the current position is blocked, no paths are possible\n        current = 0\n    else:\n        # Otherwise, compute the number of ways to reach this position\n        current = (prev1 + prev2) % mod\n    \n    # Update the previous two values\n    prev2, prev1 = prev1, current\n\n# The result is stored in prev1 (the last computed value)\nprint(prev1)"}
{"problem_id":"p03013","slow_code_col":"from functools import lru_cache\n\n\n\ndef main():\n\n    n,m = list(map(int,input().split()))\n\n    import numpy as np\n\n    ans = np.ones(n+1,dtype=int)*-1\n\n    ans[0] = 1\n\n    mod = 10**9+7\n\n    for _ in range(m):\n\n        a = int(eval(input()))\n\n        ans[a]=0\n\n    if ans[1]!=0:\n\n        ans[1]=1\n\n    for i in range(2,n+1):\n\n        if ans[i]!=0:\n\n            ans[i] = (ans[i-1]+ans[i-2])%mod\n\n    print((ans[-1]))\n\n        \n\n\n\nif __name__ == \"__main__\":\n\n    main()","reference_code_col":"def main():\n\n    n,m = list(map(int,input().split()))\n\n    dp = [0 for i in range(n+1)]\n\n    mod = 10**9+7\n\n    for i in range(m):\n\n        a = int(eval(input()))\n\n        dp[a] = -1\n\n    dp[0] = 1\n\n    if dp[1]!=-1:\n\n        dp[1] = 1\n\n    for i in range(2,n+1):\n\n        if dp[i]==-1:\n\n            continue\n\n        if dp[i-1]!=-1 and dp[i-2]!=-1:\n\n            dp[i] = dp[i-1] + dp[i-2]\n\n            dp[i] = dp[i]%mod\n\n        elif dp[i-1]!=-1 and dp[i-2]==-1:\n\n            dp[i] = dp[i-1]\n\n        elif dp[i-1]==-1 and dp[i-2]!=-1:\n\n            dp[i] = dp[i-2]\n\n        else:\n\n            dp[i] = 0\n\n    print((dp[-1]))\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"from functools import lru_cache\n\n\ndef main():\n    # Read input values n and m\n    n, m = map(int, input().split())\n\n    # Initialize the array with -1 (unreachable states)\n    ans = [-1] * (n + 1)\n\n    # Base cases\n    ans[0] = 1\n\n    # Mark forbidden positions\n    for _ in range(m):\n        a = int(input())\n        ans[a] = 0\n\n    # Handle the first position explicitly\n    if ans[1] != 0:\n        ans[1] = 1\n\n    # Dynamic programming to compute reachable states\n    mod = 10**9 + 7\n    for i in range(2, n + 1):\n        if ans[i] != 0:  # Only compute if not forbidden\n            ans[i] = (ans[i - 1] + ans[i - 2]) % mod\n\n    # Output the result\n    print(ans[-1])\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nN = int(eval(input()))\n\nans = 0\n\n\n\nans =math.factorial(N) % (10**9 +7)\n\n\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\npower = 1\n\n\n\nfor i in range(N):\n\n    power = ((i+1) * power) % 1000000007\n\n\n\nprint(power)","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\n# Read input\nN = int(input())\n\n# Compute factorial modulo MOD iteratively\nans = 1\nfor i in range(1, N + 1):\n    ans = (ans * i) % MOD\n\n# Print the result\nprint(ans)"}
{"problem_id":"p03078","slow_code_col":"X,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nalready = [[0,0,0]]\n\nx,y,z = 0,0,0\n\nplace_sum = []\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        place_sum.append([x + 1,y,z])\n\n        check.append(asort[x + 1] + bsort[y] + csort[z])\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        place_sum.append([x,y + 1,z])\n\n        check.append(asort[x] + bsort[y + 1] + csort[z])\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        place_sum.append([x,y,z + 1])\n\n        check.append(asort[x] + bsort[y] + csort[z + 1])\n\n    print((max(check)))\n\n    x,y,z = place_sum[check.index(max(check))][0],place_sum[check.index(max(check))][1],place_sum[check.index(max(check))][2]\n\n    place_sum.pop(check.index(max(check)))\n\n    check.remove(max(check))","reference_code_col":"import heapq\n\nX,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nalready = [[0,0,0]]\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nx,y,z = 0,0,0\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        heapq.heappush(check,(-(asort[x + 1] + bsort[y] + csort[z]),x + 1,y,z))\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y + 1] + csort[z]),x,y + 1,z))\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y] + csort[z + 1]),x,y,z + 1))\n\n    maxsum = heapq.heappop(check)\n\n    print((-maxsum[0]))\n\n    x,y,z = maxsum[1],maxsum[2],maxsum[3]","model_generated_potentially_faster_code_col":"import heapq\n\n# Input reading\nX, Y, Z, K = map(int, input().split())\nA = sorted(map(int, input().split()), reverse=True)\nB = sorted(map(int, input().split()), reverse=True)\nC = sorted(map(int, input().split()), reverse=True)\n\n# Initialize a max-heap (using negative values for max-heap behavior)\nheap = []\nvisited = set()\n\n# Push the initial combination (0, 0, 0) into the heap\nheapq.heappush(heap, (-(A[0] + B[0] + C[0]), 0, 0, 0))\nvisited.add((0, 0, 0))\n\n# Process the top K sums\nfor _ in range(K):\n    # Extract the largest sum\n    current_sum, x, y, z = heapq.heappop(heap)\n    print(-current_sum)  # Negate to get the actual sum\n\n    # Generate new candidates by incrementing one index\n    if x + 1 < X and (x + 1, y, z) not in visited:\n        heapq.heappush(heap, (-(A[x + 1] + B[y] + C[z]), x + 1, y, z))\n        visited.add((x + 1, y, z))\n\n    if y + 1 < Y and (x, y + 1, z) not in visited:\n        heapq.heappush(heap, (-(A[x] + B[y + 1] + C[z]), x, y + 1, z))\n        visited.add((x, y + 1, z))\n\n    if z + 1 < Z and (x, y, z + 1) not in visited:\n        heapq.heappush(heap, (-(A[x] + B[y] + C[z + 1]), x, y, z + 1))\n        visited.add((x, y, z + 1))"}
{"problem_id":"p02725","slow_code_col":"import numpy as np\n\nk,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = np.zeros(n)\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n  \n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))","reference_code_col":"k,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = [0 for i in range(n)]\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n\n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input parsing\nk, n = map(int, input().split())\na = np.array(list(map(int, input().split())))\n\n# Compute differences using vectorized operations\nb = np.diff(a, append=a[0] + k)\n\n# Find the maximum value in b\nans = k - np.max(b)\n\n# Output the result\nprint(int(ans))"}
{"problem_id":"p02996","slow_code_col":"import numpy as np\n\n# \u7de0\u5207\u304c\u65e9\u3044\u3082\u306e\u304b\u3089\u51e6\u7406\n\nN = int(eval(input()))\n\nAB = np.array([[int(x) for x in input().split()] for _ in range(N)])\n\nA = AB[:,0]\n\nB = AB[:,1]\n\nidx = B.argsort()\n\nA = A[idx]\n\nB = B[idx]\n\nnp.cumsum(A, out = A)\n\nbl = (A <= B).all()\n\nanswer = 'Yes' if bl else 'No'\n\nprint(answer)\n","reference_code_col":"def main():\n\n    N = int(eval(input()))\n\n    A = []\n\n    for _ in range(N):\n\n        a, b = list(map(int, input().split()))\n\n        A.append((a, b))\n\n\n\n    A = sorted(A, key=lambda x: x[1])\n\n    time = 0\n\n    for a, b in A:\n\n        time += a\n\n        if time > b:\n\n            return 'No'\n\n\n\n    return 'Yes'\n\n\n\nif __name__ == '__main__':\n\n    print((main()))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input\nN = int(input())\nAB = np.array([list(map(int, input().split())) for _ in range(N)])\n\n# Sort AB by the second column (deadlines)\nAB = AB[AB[:, 1].argsort()]\n\n# Compute cumulative sum of the first column (tasks) in-place\nnp.cumsum(AB[:, 0], out=AB[:, 0])\n\n# Check if all cumulative sums are <= their respective deadlines\nanswer = 'Yes' if (AB[:, 0] <= AB[:, 1]).all() else 'No'\n\n# Print the result\nprint(answer)"}
{"problem_id":"p03371","slow_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nn=max(x,y)\n\nfor i in range(1,n+1):\n\n  ans=min(ans,2*i*c+a*max(0,x-i)+b*max(0,y-i))\n\nprint(ans)\n\n\n\n\n","reference_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\nans1=a*x+b*y\n\nans2=2*c*max(x,y)\n\nans3=2*c*min(x,y)+a*(x-min(x,y))+b*(y-min(x,y))\n\nprint((min(ans1,ans2,ans3)))","model_generated_potentially_faster_code_col":"a, b, c, x, y = list(map(int, input().split()))"}
{"problem_id":"p03325","slow_code_col":"answer = 0\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nfor i in range(N) :\n\n    while A[i] % 2 == 0 :\n\n        A[i] = A[i] \/ 2\n\n        answer += 1\n\nprint(answer)\n\n\n","reference_code_col":"N = int(eval(input()))\n\nL = list(map(int,input().split()))\n\n\n\nans = 0\n\nfor i in range(N) :\n\n    flag = 0\n\n    while flag == 0 :\n\n        if (L[i] % 2) == 0 :\n\n            ans += 1\n\n            L[i] = L[i]\/\/2\n\n        else :\n\n            flag = 1\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"# Read input\nN = int(input())\nA = list(map(int, input().split()))\n\n# Initialize answer\nanswer = 0\n\n# Process each number in A\nfor num in A:\n    # Count trailing zeros in binary representation (efficiently counts how many times num is divisible by 2)\n    if num > 0:  # Ensure num is positive to avoid issues with log2\n        answer += (num & -num).bit_length() - 1\n\n# Output the result\nprint(answer)"}
{"problem_id":"p03034","slow_code_col":"import sys\n\n\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    S = list(map(int, input().split()))\n\n\n\n    ans = 0\n\n    for C in range(1, N\/\/2):\n\n        n = N \/\/ C\n\n        point = 0\n\n        used = set([0])\n\n        for k in range(1, n):\n\n            A = N - 1 - k*C\n\n\n\n            if A in used or k*C in used or A == k*C:\n\n                break\n\n            used.add(A)\n\n            used.add(k*C)\n\n\n\n            point += S[A] + S[k*C]\n\n            ans = max(ans, point)\n\n\n\n    return ans\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((main()))\n","reference_code_col":"import sys\n\n\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    S = list(map(int, input().split()))\n\n\n\n    ans = 0\n\n    # C = A - B\n\n    for C in range(1, N\/\/2):\n\n        n = (N-1) \/\/ C\n\n        point = 0\n\n        for k in range(1, n):\n\n            A = N-1 - k*C\n\n\n\n            # Check A and B are positive integer, and S_i is not used twice.\n\n            #\n\n            # B = A - C and B >= 0, so A must be over C (A > C).\n\n            #\n\n            # If C is aliquot of N-1 (N-1 % C = 0), A is also aliquot of N-1\n\n            # (N-1 % A = 0) because A + kC = N-1. Therefore when A is less than\n\n            # or equal kC, the A's value is already used by kC.\n\n            if A < C or ((N-1) % C == 0 and A <= k*C):\n\n                break\n\n\n\n            point += S[A] + S[k*C]\n\n            ans = max(ans, point)\n\n\n\n    return ans\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((main()))\n","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    input = sys.stdin.readline\n\n    # Read input efficiently\n    N = int(input())\n    S = list(map(int, input().split()))\n\n    ans = 0\n\n    # Use a boolean array instead of a set for tracking used indices\n    for C in range(1, N \/\/ 2):\n        n = N \/\/ C\n        point = 0\n        used_array = [False] * N\n\n        for k in range(1, n):\n            A = N - 1 - k * C\n\n            # Early termination conditions\n            if A >= N or k * C >= N or used_array[A] or used_array[k * C] or A == k * C:\n                break\n\n            # Mark indices as used\n            used_array[A] = True\n            used_array[k * C] = True\n\n            # Update point and ans\n            point += S[A] + S[k * C]\n            ans = max(ans, point)\n\n    return ans\n\n\nif __name__ == '__main__':\n    print(main())"}
{"problem_id":"p03038","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N,M=MI()\n\n    A=LI()\n\n    CB=[[0,0]for _ in range(M)]\n\n    A.sort()\n\n    for i in range(M):\n\n        CB[i][1],CB[i][0]=MI()\n\n        \n\n    CB.sort(reverse=True)\n\n    now=0\n\n    \n\n    for i in range(N):\n\n        if CB[now][1]<=0:\n\n            now+=1\n\n        \n\n        if now>=M:\n\n            break    \n\n        \n\n        ch=CB[now][0]\n\n        if A[i]<ch:\n\n            A[i]=ch\n\n            CB[now][1]-=1\n\n        else:\n\n            break\n\n        \n\n    print((sum(A)))\n\n    \n\n\n\nmain()\n","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N,M=MI()\n\n    A=LI()\n\n    B=[0]*M\n\n    C=[0]*M\n\n    for i in range(M):\n\n        B[i],C[i]=MI()\n\n    \n\n    C,B=list(zip(*sorted(zip(C,B))))\n\n    B=B[::-1]\n\n    C=C[::-1]\n\n    \n\n    import heapq\n\n    heapq.heapify(A)\n\n    \n\n    for i in range(M):\n\n        b=B[i]\n\n        c=C[i]\n\n        for _ in range(b):\n\n            a=heapq.heappop(A)\n\n            if a>=c:\n\n                heapq.heappush(A,a)\n\n                break\n\n            else:\n\n                heapq.heappush(A,c)\n\n                \n\n    ans=0\n\n    for i in range(N):\n\n        a=heapq.heappop(A)\n\n        ans+=a\n\n        \n\n    print(ans)\n\n\n\nmain()\n","model_generated_potentially_faster_code_col":"import sys\nimport heapq\n\ninput = sys.stdin.readline\n\n\ndef I(): return int(input())\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\ndef main():\n    mod = 10**9 + 7\n\n    # Input reading\n    N, M = MI()\n    A = LI()\n    CB = [tuple(map(int, input().split())) for _ in range(M)]\n\n    # Sort A in ascending order\n    A.sort()\n\n    # Create a max-heap for CB (invert values for max-heap simulation)\n    heap = [(-b, c) for b, c in CB]\n    heapq.heapify(heap)\n\n    # Precompute initial sum of A\n    total_sum = sum(A)\n\n    # Main loop\n    i = 0\n    while i < N and heap:\n        # Get the largest available value from the heap\n        largest_value, count = heapq.heappop(heap)\n        largest_value = -largest_value  # Revert the sign\n\n        # Replace elements in A if they are smaller than the largest_value\n        while i < N and count > 0 and A[i] < largest_value:\n            total_sum += largest_value - A[i]\n            A[i] = largest_value\n            i += 1\n            count -= 1\n\n        # If there are remaining counts, push back to the heap\n        if count > 0:\n            heapq.heappush(heap, (-largest_value, count))\n\n    # Print the final sum\n    print(total_sum)\n\n\nmain()"}
{"problem_id":"p03828","slow_code_col":"from math import factorial\n\n\n\nn = int(eval(input()))\n\nf = factorial(n)\n\n\n\nmod = 10 ** 9 + 7\n\n\n\ndef primes(n):\n\n    is_prime = [True] * (n + 1)\n\n    is_prime[0] = False\n\n    is_prime[1] = False\n\n    for i in range(2, int(n ** 0.5) + 1):\n\n        if not is_prime[i]:\n\n            continue\n\n        for j in range(i * 2, n + 1, i):\n\n            is_prime[j] = False\n\n    return [i for i in range(n + 1) if is_prime[i]]\n\n\n\nans = 1\n\nfor p in primes(n):\n\n    temp = 1\n\n    while f % p == 0:\n\n        temp += 1\n\n        f \/\/= p\n\n    ans = (ans * temp) % mod\n\nprint(ans)\n","reference_code_col":"n=int(eval(input()))\n\nm=10**9+7\n\np=[1 for i in range(10000)]\n\np[0]=0\n\np[1]=0\n\nfor i in range(2,n+1):\n\n  if p[i]==1:\n\n    for j in range(i*i,n+1,i):\n\n        p[j]=0\n\nans=1\n\nfor i in range(2,n+1):\n\n  if p[i]:\n\n    c=0\n\n    k=i\n\n    while n\/\/k>0:\n\n      c=c+(n\/\/k)%m\n\n      k=k*i\n\n    ans=(ans*((c+1)%m))%m\n\nprint((ans%m))\n\n    \n\n    \n\n      \n\n      \n","model_generated_potentially_faster_code_col":"from math import isqrt\n\n# Input\nn = int(eval(input()))\nmod = 10**9 + 7\n\n# Sieve of Eratosthenes to find all primes up to n\ndef primes(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, isqrt(n) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n + 1, i):\n                is_prime[j] = False\n    return [i for i in range(n + 1) if is_prime[i]]\n\n# Compute the answer using Legendre's formula\nans = 1\nprime_list = primes(n)\n\nfor p in prime_list:\n    power = 0\n    x = n\n    while x > 0:\n        x \/\/= p\n        power += x\n    ans = (ans * (power + 1)) % mod\n\nprint(ans)"}
{"problem_id":"p02883","slow_code_col":"import sys\n\ninput = sys.stdin.buffer.readline\n\nimport numpy as np\n\n\n\ndef main():\n\n    N,K = list(map(int,input().split()))\n\n    a = list(map(int,input().split()))\n\n    f = list(map(int,input().split()))\n\n    a.sort()\n\n    f.sort(reverse=True)\n\n\n\n    if sum(a) <= K:\n\n        print((0))\n\n    else:\n\n        a = np.array(a)\n\n        f = np.array(f)\n\n        left,right = 0,max(a)*max(f)\n\n        while right-left > 1:\n\n            mid = (left+right)\/\/2\n\n            pra = a-mid\/\/f\n\n            pra[pra<0] = 0\n\n            if np.sum(pra) > K:\n\n                left = mid\n\n            else:\n\n                right = mid\n\n        print(right)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\ndef main():\n\n    N,K = list(map(int,input().split()))\n\n    a = list(map(int,input().split()))\n\n    f = list(map(int,input().split()))\n\n    \n\n    a.sort()\n\n    f.sort(reverse=True)\n\n    \n\n    l,r = -1,max(a)*max(f)+1\n\n    \n\n    while r-l>1:\n\n        mid = (r+l)\/\/2\n\n        count = 0\n\n        for cost,dif in zip(a,f):\n\n            if mid >= cost*dif:\n\n                continue\n\n            rest = cost*dif-mid\n\n            count += -(-rest\/\/dif)\n\n        if count <= K:\n\n            r = mid\n\n        else:\n\n            l = mid\n\n            \n\n    print(r)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\ndef main():\n    # Fast input reading\n    input = sys.stdin.buffer.readline\n    N, K = map(int, input().split())\n    a = np.array(list(map(int, input().split())))\n    f = np.array(list(map(int, input().split())))\n\n    # Sort arrays\n    a.sort()\n    f.sort()\n\n    # Early exit if total sum of 'a' is within the limit\n    if np.sum(a) <= K:\n        print(0)\n        return\n\n    # Reverse sort 'f'\n    f = f[::-1]\n\n    # Initialize binary search bounds\n    left, right = 0, a[-1] * f[0]  # max(a) * max(f)\n\n    # Binary search\n    while right - left > 1:\n        mid = (left + right) \/\/ 2\n        pra = a - mid \/\/ f\n        pra[pra < 0] = 0  # Clamp negative values to 0\n        if np.sum(pra) > K:\n            left = mid\n        else:\n            right = mid\n\n    print(right)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02996","slow_code_col":"import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\nab = [list(li()) for _ in range(n)]\n\n\n\nab.sort(key=lambda x: x[1])\n\n\n\ncur = 0\n\n\n\nans = True\n\n\n\nfor ai, bi in ab:\n\n    cur += ai\n\n    if cur > bi:\n\n        ans = False\n\n\n\nprint((\"Yes\" if ans else \"No\"))","reference_code_col":"import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\nab = [tuple(li()) for _ in range(n)]\n\n\n\nab.sort(key=lambda x: x[1])\n\ncur = 0\n\nok = True\n\n\n\nfor ai, bi in ab:\n\n    cur += ai\n\n    if cur > bi:\n\n        ok = False\n\n        break\n\n\n\nprint((\"Yes\" if ok else \"No\"))\n","model_generated_potentially_faster_code_col":"import sys\n\n# Use faster I\/O methods\nstdin = sys.stdin\nreadline = stdin.readline\n\n# Set recursion limit (if needed elsewhere)\nsys.setrecursionlimit(10**7)\n\n# Read input\nn = int(readline())\nab = [tuple(map(int, readline().split())) for _ in range(n)]\n\n# Sort by bi (second element of each pair)\nab.sort(key=lambda x: x[1])\n\n# Process the sorted list\ncur = 0\nans = True\n\nfor ai, bi in ab:\n    cur += ai\n    if cur > bi:\n        ans = False\n        break  # Early termination if condition fails\n\n# Output result\nprint(\"Yes\" if ans else \"No\")"}
{"problem_id":"p03416","slow_code_col":"n, m = list(map(int, input().split()))\n\nans = 0\n\nfor i in range(n, m+1):\n\n    if str(i)[0]+str(i)[1] == str(i)[-1]+str(i)[-2]: ans += 1\n\nprint(ans)","reference_code_col":"a, b = list(map(int, input().split()))\n\nans = 0\n\nfor n in range(a, b+1):\n\n    if str(n) == str(n)[::-1]: ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"n, m = map(int, input().split())\n\nans = 0\n\nfor i in range(max(n, 1000), m + 1):  # Start from 1000 since smaller numbers cannot satisfy the condition\n    first_two = i \/\/ 100  # Extract the first two digits\n    last_two = i % 100    # Extract the last two digits\n    if first_two == (last_two % 10) * 10 + (last_two \/\/ 10):  # Reverse the last two digits and compare\n        ans += 1\n\nprint(ans)"}
{"problem_id":"p00001","slow_code_col":"ans=[]\n\nfor i in range (0,10):\n\n    ans.append(int(eval(input())))\n\nans.sort(reverse=True)\n\nfor i in range (0,3):\n\n    print((ans[i]))","reference_code_col":"mountain=[]\n\nfor s in range(0,10):\n\n    mountain.append(int(eval(input())))\n\nmountain.sort(reverse=True)\n\nfor s in range(0,3):\n\n print((mountain[s]))","model_generated_potentially_faster_code_col":"import heapq\n\n# Use a min-heap to keep track of the top 3 largest elements\ntop_3 = []\n\nfor _ in range(10):\n    # Read input and convert to integer\n    num = int(input())\n    \n    # Push the number into the heap\n    if len(top_3) < 3:\n        heapq.heappush(top_3, num)\n    else:\n        # If the heap already has 3 elements, replace the smallest if current number is larger\n        if num > top_3[0]:\n            heapq.heapreplace(top_3, num)\n\n# Sort the top 3 elements in descending order\ntop_3.sort(reverse=True)\n\n# Print the top 3 elements\nfor num in top_3:\n    print(num)"}
{"problem_id":"p02555","slow_code_col":"# -*- coding: utf-8 -*-\n\nimport sys\n\n\n\n\n\ndef main():\n\n    S = int( sys.stdin.readline() )\n\n\n\n    dp = [0]*(S+1)\n\n    dp[0] = 1\n\n    mod = 10**9 + 7\n\n\n\n    for i in range(3, S+1):\n\n        cnt = 0\n\n\n\n        for j in range(3, i+1):\n\n            cnt += dp[i-j]\n\n            cnt %= mod\n\n        \n\n        dp[i] = cnt\n\n\n\n\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"# -*- coding: utf-8 -*-\n\nimport sys\n\n\n\n\n\ndef main():\n\n    S = int( sys.stdin.readline() )\n\n\n\n    dp = [0]*(S+1)\n\n    dp[0] = 1\n\n    mod = 10**9 + 7\n\n\n\n    for i in range(3, S+1):\n\n        dp[i] = dp[i-3] + dp[i-1]\n\n        dp[i] %= mod\n\n    \n\n\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nimport sys\n\n\ndef main():\n    # Read input\n    S = int(sys.stdin.readline())\n\n    # Initialize DP array and variables\n    dp = [0] * (S + 1)\n    dp[0] = 1  # Base case: one way to partition 0\n    mod = 10**9 + 7\n\n    # Cumulative sum to track valid partitions\n    cumulative_sum = 0\n\n    for i in range(3, S + 1):\n        # Add dp[i-3] to the cumulative sum\n        cumulative_sum += dp[i - 3]\n        cumulative_sum %= mod\n\n        # The current dp[i] is the cumulative sum\n        dp[i] = cumulative_sum\n\n    # Output the result\n    print(dp[-1])\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03363","slow_code_col":"from collections import Counter\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.array(input().split(), dtype = np.int64)\n\n\n\nc = Counter(A.cumsum())\n\nc[0] += 1\n\nanswer = sum(x*(x-1)\/\/2 for x in list(c.values()))\n\nprint(answer)","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\nfrom collections import defaultdict\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nAcum = [0] + list(itertools.accumulate(A))\n\n\n\ncounter = defaultdict(int)\n\nanswer = 0\n\nfor x in Acum:\n\n    answer += counter[x]\n\n    counter[x] += 1\n\n\n\nprint(answer)","model_generated_potentially_faster_code_col":"import numpy as np\nfrom math import comb\n\n# Read input efficiently\nA = np.array(input().split(), dtype=np.int64)\n\n# Compute cumulative sum\ncumsum = A.cumsum()\n\n# Count occurrences of cumulative sums\ncounts = {}\ncounts[0] = 1  # Initialize with 0 to handle subarrays starting from index 0\n\nfor value in cumsum:\n    counts[value] = counts.get(value, 0) + 1\n\n# Calculate the result using combinations\nanswer = sum(comb(count, 2) for count in counts.values())\n\nprint(answer)"}
{"problem_id":"p02731","slow_code_col":"import numpy as np\n\nL = np.array(int(eval(input())), dtype='float128')\n\nans = (L \/ 3)**3\n\nprint(ans)\n","reference_code_col":"import numpy as np\n\nL = int(eval(input()))\n\nans = (L \/ 3)**3\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Safely read input and convert to a NumPy array of float64\ntry:\n    # Assume input is a single number or a list of numbers\n    raw_input = input(\"Enter a number or list of numbers: \")\n    if ',' in raw_input or '[' in raw_input:\n        # Handle list-like input\n        L = np.array([float(x) for x in raw_input.strip('[]').split(',')], dtype='float64')\n    else:\n        # Handle single number input\n        L = float(raw_input)\nexcept ValueError:\n    print(\"Invalid input. Please enter a valid number or list of numbers.\")\n    exit()\n\n# Perform the computation\nans = (L \/ 3)**3\n\n# Print the result\nprint(ans)"}
{"problem_id":"p02785","slow_code_col":"def solve():\n\n  N, K = list(map(int, input().split()))\n\n  H = list(map(int, input().split()))\n\n  if K>=N:\n\n    return 0\n\n  H.sort()\n\n  ans = sum(H[:N-K])\n\n  return ans\n\nprint((solve()))","reference_code_col":"def solve():\n\n  N, K = list(map(int, input().split()))\n\n  H = list(map(int, input().split()))\n\n  H.sort()\n\n  ans = sum(H[:max(N-K,0)])\n\n  return ans\n\nprint((solve()))","model_generated_potentially_faster_code_col":"import heapq\n\ndef solve():\n    # Read input values\n    N, K = map(int, input().split())\n    H = list(map(int, input().split()))\n\n    # If K >= N, all heights can be ignored\n    if K >= N:\n        return 0\n\n    # Use heapq.nsmallest to find the smallest N-K elements efficiently\n    smallest_elements = heapq.nsmallest(N - K, H)\n\n    # Compute the sum of the smallest N-K elements\n    ans = sum(smallest_elements)\n\n    return ans\n\n# Call the function and print the result\nprint(solve())"}
{"problem_id":"p03835","slow_code_col":"k, s = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor x in range(k+1):\n\n  for y in range(k+1):\n\n    if 0<=s-x-y<=k:\n\n      ans += 1\n\n      \n\nprint(ans)","reference_code_col":"k,s=list(map(int,input().split()))\n\nans=0\n\nfor i in range(k+1):\n\n  num=s-i\n\n  for j in range(min(num+1,k+1)):\n\n    if 0<=num-j<=k:\n\n      ans+=1\n\nprint(ans)","model_generated_potentially_faster_code_col":"k, s = map(int, input().split())\n\nans = 0\n\nfor x in range(k + 1):\n    # Calculate the minimum and maximum valid values for y\n    y_min = max(0, s - x - k)  # Ensure z >= 0\n    y_max = min(k, s - x)      # Ensure z <= k\n    \n    # Count the number of valid y values in the range [y_min, y_max]\n    if y_min <= y_max:\n        ans += y_max - y_min + 1\n\nprint(ans)"}
{"problem_id":"p03680","slow_code_col":"import sys\n\n\n\nN = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\nl = 1\n\np = a[0] - 1\n\n\n\nif a[0] == 2:\n\n    print(l)\n\n    sys.exit()\n\n\n\nwhile l < int(1e6):\n\n    l += 1\n\n    if a[p] == 2:\n\n        print(l)\n\n        break\n\n    else:\n\n        p = a[p] - 1\n\nelse:\n\n    print((-1))","reference_code_col":"import sys\n\n\n\nN = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\nl = 1\n\np = a[0] - 1\n\n\n\nif a[0] == 2:\n\n    print(l)\n\n    sys.exit()\n\n\n\nwhile l < int(2e5):\n\n    l += 1\n\n    if a[p] == 2:\n\n        print(l)\n\n        break\n\n    else:\n\n        p = a[p] - 1\n\nelse:\n\n    print((-1))","model_generated_potentially_faster_code_col":"import sys\n\n# Read the number of elements\nN = int(input())\n\n# Read the array elements\na = [int(input()) for _ in range(N)]\n\n# Initialize variables\nl = 1\np = a[0] - 1\n\n# Special case: If the first element is 2, print 1 and exit\nif a[0] == 2:\n    print(l)\n    sys.exit()\n\n# Set to track visited indices for cycle detection\nvisited = set()\n\n# Iterate until the maximum limit or cycle detection\nwhile l < int(1e6):\n    if p in visited:\n        # Cycle detected, terminate with -1\n        print(-1)\n        break\n    \n    # Mark the current index as visited\n    visited.add(p)\n    \n    # Increment step count\n    l += 1\n    \n    # Check if the current element is 2\n    if a[p] == 2:\n        print(l)\n        break\n    \n    # Move to the next index\n    p = a[p] - 1\nelse:\n    # If the loop completes without finding 2, print -1\n    print(-1)"}
{"problem_id":"p03752","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\ninput = sys.stdin.buffer.readline\n\n\n\n\n\ndef RD(): return sys.stdin.read()\n\ndef II(): return int(eval(input()))\n\ndef MI(): return list(map(int,input().split()))\n\ndef LI(): return list(map(int,input().split()))\n\ndef TI(): return tuple(map(int,input().split()))\n\n\n\n# mod=10**9+7\n\n# rstrip().decode('utf-8')\n\n\n\nimport numpy as np\n\nfrom itertools import combinations\n\n\n\ndef main():\n\n\tn,k=MI()\n\n\tans=10**18\n\n\n\n\tA=LI()\n\n\tA=[A[0]-1]+A\n\n\tA=np.array(A)\n\n\n\n\tfor t in combinations(list(range(n)),k):\n\n\t\tB=A.copy()\n\n\t\ttmp=0\n\n\t\tfor i in t:\n\n\t\t\ti+=1\n\n\t\t\tB[i]=max(B[:i].max()+1,A[i])\n\n\t\t\ttmp+=B[i]-A[i]\n\n\t\tans=min(ans,tmp)\n\n\tprint(ans)\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()\n","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\ninput = sys.stdin.buffer.readline\n\n\n\n\n\ndef RD(): return sys.stdin.read()\n\ndef II(): return int(eval(input()))\n\ndef MI(): return list(map(int,input().split()))\n\ndef LI(): return list(map(int,input().split()))\n\ndef TI(): return tuple(map(int,input().split()))\n\n\n\n# mod=10**9+7\n\n# rstrip().decode('utf-8')\n\n\n\n#import numpy as np\n\nfrom itertools import combinations\n\n\n\ndef main():\n\n\tn,k=MI()\n\n\tans=10**18\n\n\n\n\tA=LI()\n\n\tA=[A[0]-1]+A\n\n\n\n\tfor t in combinations(list(range(n)),k):\n\n\t\tB=A.copy()\n\n\t\ttmp=0\n\n\t\tfor i in t:\n\n\t\t\ti+=1\n\n\t\t\tB[i]=max(max(B[:i])+1,A[i])\n\n\t\t\ttmp+=B[i]-A[i]\n\n\t\tans=min(ans,tmp)\n\n\tprint(ans)\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()\n","model_generated_potentially_faster_code_col":"import sys\n\n# Efficient input handling\ninput = sys.stdin.readline\n\ndef main():\n    # Read input\n    n, k = map(int, input().split())\n    A = list(map(int, input().split()))\n    A = [A[0] - 1] + A  # Adjust the first element\n\n    # Precompute prefix maxima\n    prefix_max = [0] * (n + 1)\n    prefix_max[0] = A[0]\n    for i in range(1, n + 1):\n        prefix_max[i] = max(prefix_max[i - 1], A[i])\n\n    # Dynamic Programming (DP) approach\n    dp = [[10**18] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + max(0, prefix_max[i] + 1 - A[i])\n            else:\n                dp[i][j] = min(\n                    dp[i - 1][j] + max(0, prefix_max[i] + 1 - A[i]),\n                    dp[i - 1][j - 1]  # Skip this element\n                )\n\n    # The answer is the minimum value in the last row of DP table\n    print(min(dp[n]))\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03434","slow_code_col":"import numpy as np\n\n\n\nn = int(eval(input()))\n\na_list = list(map(int, input().split()))\n\n\n\nalice_point = 0\n\nbob_point = 0\n\nfor i in range(n):\n\n    argmax_a = np.argmax(a_list)\n\n    max_a = np.max(a_list)\n\n    if i % 2 == 0: # If Alice takes a card\n\n        alice_point += max_a\n\n    else: # If Bob takes a card\n\n        bob_point += max_a\n\n    del a_list[argmax_a] # No confidence -> Review how to delete list element!\n\n\n\nprint((alice_point - bob_point))","reference_code_col":"n = int(eval(input()))\n\na_list = list(map(int, input().split()))\n\na_list = sorted(a_list, reverse=True)\n\n\n\nalice_point = 0\n\nbob_point = 0\n\nfor i in range(n):\n\n    if i % 2 == 0:\n\n        alice_point += a_list[i]\n\n    else:\n\n        bob_point += a_list[i]\n\n\n\nprint((alice_point - bob_point))","model_generated_potentially_faster_code_col":"n = int(input())  # Read the number of elements\na_list = list(map(int, input().split()))  # Read the list of integers\n\n# Sort the list in descending order for optimal access\na_list.sort(reverse=True)\n\nalice_point = 0\nbob_point = 0\n\n# Alternate between Alice and Bob\nfor i in range(n):\n    if i % 2 == 0:  # Alice's turn\n        alice_point += a_list[i]\n    else:  # Bob's turn\n        bob_point += a_list[i]\n\n# Output the difference between Alice's and Bob's points\nprint(alice_point - bob_point)"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    power = math.factorial(N)\n\n    print((power % (10 ** 9 + 7)))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"def main():\n\n    N = int(eval(input()))\n\n    power = 1\n\n    for i in range(1, N + 1):\n\n        power *= i\n\n        power %= 10 ** 9 + 7\n\n    print(power)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    MOD = 10**9 + 7  # Define the modulus constant\n    N = int(input())  # Read input as an integer\n\n    if N >= MOD:\n        # If N >= MOD, the factorial will include MOD as a factor, making the result 0\n        print(0)\n        return\n\n    result = 1  # Initialize the result\n    for i in range(2, N + 1):\n        result = (result * i) % MOD  # Compute factorial iteratively with modulo\n\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03078","slow_code_col":"def main():\n\n\tx, y, z, k = list(map(int, input().split()))\n\n\ta = list(map(int, input().split()))\n\n\tb = list(map(int, input().split()))\n\n\tc = list(map(int, input().split()))\n\n\td = [0]*x*y\n\n\tfor i in range(x):\n\n\t\tfor j in range(y):\n\n\t\t\td[i*y+j] = a[i]+b[j]\n\n\td.sort(reverse=True)\n\n\tc.sort(reverse=True)\n\n\n\n\tc_len = min(k, z)\n\n\td_len = min(k, x*y)\n\n\te = [0]*d_len*c_len\n\n\tfor i in range(d_len):\n\n\t\tfor j in range(c_len):\n\n\t\t\te[i*c_len+j] = d[i] + c[j]\n\n\te.sort(reverse=True)\n\n\tfor i in range(k):\n\n\t\tprint((e[i]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()","reference_code_col":"def main():\n\n\tx, y, z, k = list(map(int, input().split()))\n\n\ta = list(map(int, input().split()))\n\n\tb = list(map(int, input().split()))\n\n\tc = list(map(int, input().split()))\n\n\n\n\tsolve(a, b, c, x, y, z, k)\n\n\n\ndef solve(a, b, c, x, y, z, k):\n\n\ta.sort(reverse=True)\n\n\tb.sort(reverse=True)\n\n\tc.sort(reverse=True)\n\n\tstack = list()\n\n\tfor p in range(x):\n\n\t\tfor q in range(y):\n\n\t\t\tif (p+1)*(q+1) > k:\n\n\t\t\t\tbreak\n\n\t\t\tfor r in range(z):\n\n\t\t\t\tif (p+1)*(q+1)*(r+1) > k:\n\n\t\t\t\t\tbreak\n\n\t\t\t\tstack.append(a[p]+b[q]+c[r])\n\n\tstack.sort(reverse=True)\n\n\tfor i in range(k):\n\n\t\tprint((stack[i]))\n\n\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"import heapq\n\ndef main():\n    # Read all inputs at once\n    x, y, z, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n\n    # Step 1: Compute d as the sum of all pairs (a[i], b[j])\n    d = []\n    for i in range(x):\n        for j in range(y):\n            d.append(a[i] + b[j])\n\n    # Sort d in descending order and take only the top k elements\n    d.sort(reverse=True)\n    d = d[:min(k, len(d))]\n\n    # Step 2: Sort c in descending order and take only the top k elements\n    c.sort(reverse=True)\n    c = c[:min(k, len(c))]\n\n    # Step 3: Use a min-heap to compute the top k elements of e\n    heap = []\n    for val_d in d:\n        for val_c in c:\n            total = val_d + val_c\n            if len(heap) < k:\n                heapq.heappush(heap, total)\n            else:\n                # Push the new value and pop the smallest if heap is full\n                if total > heap[0]:\n                    heapq.heappushpop(heap, total)\n\n    # Step 4: Extract the top k elements from the heap in descending order\n    result = sorted(heap, reverse=True)\n    for val in result:\n        print(val)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p00713","slow_code_col":"from math import sqrt\n\nfrom bisect import bisect_left\n\ndef circle_center(x1, y1, x2, y2):\n\n    xd = x2 - x1; yd = y2 - y1\n\n    d = xd**2 + yd**2\n\n    k = sqrt((4.0 - d) \/ d) \/ 2.0\n\n    xc = (x1 + x2) \/ 2.0\n\n    yc = (y1 + y2) \/ 2.0\n\n    return [[xc - k*yd, yc + k*xd], [xc + k*yd, yc - k*xd]]\n\nwhile 1:\n\n    n = int(input())\n\n    if n==0: break\n\n    p = [list(map(float, input().split())) for i in range(n)]\n\n    p.sort()\n\n    prev = 0\n\n    ans = 1\n\n    for i in range(n):\n\n        bx, by = p[i]\n\n        while bx - p[prev][0] >= 2.0: prev += 1\n\n        for j in range(i+1, n):\n\n            cx, cy = p[j]\n\n            if cx - bx >= 2.0: break\n\n            if (bx - cx)**2 + (by - cy)**2 <= 4.0:\n\n                for ex, ey in circle_center(bx, by, cx, cy):\n\n                    count = 2\n\n                    for k in range(prev, n):\n\n                        if k==i or k==j: continue\n\n                        dx, dy = p[k]\n\n                        if dx - bx >= 2.0: break\n\n                        if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n\n                            count += 1\n\n                    ans = max(ans, count)\n\n    print(ans)","reference_code_col":"from math import sqrt\n\nfrom bisect import bisect_left\n\ndef circle_center(x1, y1, x2, y2):\n\n    xd = x2 - x1; yd = y2 - y1\n\n    d = xd**2 + yd**2\n\n    k = sqrt((4.0 - d) \/ d) \/ 2.0\n\n    xc = (x1 + x2) \/ 2.0; yc = (y1 + y2) \/ 2.0\n\n    xd *= k; yd *= k\n\n    return [[xc - yd, yc + xd], [xc + yd, yc - xd]]\n\nwhile 1:\n\n    n = int(input())\n\n    if n==0: break\n\n    p = sorted(list(map(float, input().split())) for i in range(n))\n\n    prev = 0\n\n    ans = 1\n\n    for i in range(n):\n\n        bx, by = p[i]\n\n        while bx - p[prev][0] >= 2.0: prev += 1\n\n        for j in range(i+1, n):\n\n            cx, cy = p[j]\n\n            if cx - bx >= 2.0: break\n\n            if (bx - cx)**2 + (by - cy)**2 <= 4.0:\n\n                for ex, ey in circle_center(bx, by, cx, cy):\n\n                    count = 2\n\n                    for k in range(prev, n):\n\n                        if k==i or k==j: continue\n\n                        dx, dy = p[k]\n\n                        if dx - ex >= 1.0: break\n\n                        if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n\n                            count += 1\n\n                    ans = max(ans, count)\n\n    print(ans)","model_generated_potentially_faster_code_col":"from math import sqrt\nfrom bisect import bisect_left\n\ndef circle_center(x1, y1, x2, y2):\n    xd = x2 - x1\n    yd = y2 - y1\n    d = xd**2 + yd**2\n    k = sqrt((4.0 - d) \/ d) \/ 2.0\n    xc = (x1 + x2) \/ 2.0\n    yc = (y1 + y2) \/ 2.0\n    return [[xc - k * yd, yc + k * xd], [xc + k * yd, yc - k * xd]]\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n\n    # Read and sort points by x-coordinate\n    p = [list(map(float, input().split())) for _ in range(n)]\n    p.sort()\n\n    # Precompute squared distances for all pairs\n    dist_sq = {}\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist_sq[(i, j)] = (p[i][0] - p[j][0])**2 + (p[i][1] - p[j][1])**2\n\n    ans = 1\n    for i in range(n):\n        bx, by = p[i]\n\n        # Find the first point within range [bx - 2, bx + 2]\n        prev = bisect_left([px for px, _ in p], bx - 2.0)\n\n        for j in range(i + 1, n):\n            cx, cy = p[j]\n\n            # Skip if the x-distance exceeds 2.0\n            if cx - bx >= 2.0:\n                break\n\n            # Check if the squared distance is <= 4.0\n            if dist_sq[(i, j)] <= 4.0:\n                # Compute circle centers\n                centers = circle_center(bx, by, cx, cy)\n\n                for ex, ey in centers:\n                    count = 2  # Start with the two points defining the circle\n\n                    # Count points within the circle\n                    for k in range(prev, n):\n                        dx, dy = p[k]\n\n                        # Skip the points defining the circle\n                        if k == i or k == j:\n                            continue\n\n                        # Stop if the x-distance exceeds 2.0\n                        if dx - bx >= 2.0:\n                            break\n\n                        # Check if the point is within the circle\n                        if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n                            count += 1\n\n                    ans = max(ans, count)\n\n    print(ans)"}
{"problem_id":"p03371","slow_code_col":"import sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef resolve():\n\n    import math\n\n    a,b,c,x,y=list(map(int, input().split()))\n\n    cmax=max(x,y)*2\n\n    l=[]\n\n    for i in range(cmax+1):\n\n        amai = max(math.ceil(x - 0.5 * i),0)\n\n        bmai = max(math.ceil(y - 0.5 * i),0)\n\n        l.append(amai*a+bmai*b+i*c)\n\n    print((min(l)))\n\nresolve()","reference_code_col":"import sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef resolve():\n\n    import math\n\n    a,b,c,x,y=list(map(int, input().split()))\n\n    # AB\u30d4\u30b6\u3092\u5947\u6570\u679a\u8cb7\u3063\u3066\u30821\u679a\u7121\u99c4\u306b\u306a\u308b\u304b\u3089\u3001AB\u30d4\u30b6\u306f2\u679a\u30921\u679a\u3060\u3068\u8003\u3048\u308b\n\n    # c\u306e\u5024\u6bb5\u30922\u500d\u306b\u3057\u3066\u679a\u6570\u3092\u534a\u5206\u306b\n\n    cmax=max(x,y) # AB\u30d4\u30b6\u306e\u6700\u5927\u679a\u6570(2\u679a\u30921\u679a\u3068\u8003\u3048\u305f\u3068\u304d)\n\n    c=2*c\n\n    l=[]\n\n    for i in range(cmax+1):\n\n        amai = max(x - i,0)\n\n        bmai = max(y - i,0)\n\n        l.append(amai*a+bmai*b+i*c)\n\n    print((min(l)))\n\nresolve()","model_generated_potentially_faster_code_col":"import sys\n\ndef input(): return sys.stdin.readline().strip()\n\ndef resolve():\n    a, b, c, x, y = map(int, input().split())\n    \n    # Limit the range of i to the smaller of 2*x and 2*y\n    cmax = min(2 * x, 2 * y)\n    \n    # Initialize the minimum cost to a large value\n    min_cost = float('inf')\n    \n    for i in range(cmax + 1):\n        # Calculate remaining slices needed for A and B\n        amai = max((2 * x - i + 1) \/\/ 2, 0)\n        bmai = max((2 * y - i + 1) \/\/ 2, 0)\n        \n        # Calculate the total cost\n        cost = amai * a + bmai * b + i * c\n        \n        # Update the minimum cost\n        min_cost = min(min_cost, cost)\n    \n    print(min_cost)\n\nresolve()"}
{"problem_id":"p03796","slow_code_col":"import math\n\nN = int(eval(input()))\n\nans = math.factorial(N) % (10 ** 9 + 7)\n\nprint(ans)","reference_code_col":"n = int(eval(input()))\n\nfrom functools import reduce\n\nprint((reduce(lambda x,y:x*y%1000000007,list(range(1,n+1)))))","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\n# Read input as an integer\nN = int(input())\n\n# Compute factorial modulo MOD iteratively\nans = 1\nfor i in range(2, N + 1):\n    ans = (ans * i) % MOD\n\nprint(ans)"}
{"problem_id":"p03371","slow_code_col":"#python3\n\nINF = int(1e9)\n\ndef main():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    ans = INF\n\n    for i in range(2*10**5+100):\n\n        t = 2*c*i + max(x-i, 0) * a + max(y-i, 0) * b\n\n        ans = min(ans, t)\n\n    print(ans)\n\nmain()","reference_code_col":"INF = int(1e5)+5\n\n\n\ndef main():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    ans = INF*INF\n\n    for i in range(INF):\n\n        tmp = 2*i*c + a*max(x-i, 0) + b*max(y-i, 0) \n\n        ans = min(tmp, ans)\n\n    print(ans)\n\nmain()\n","model_generated_potentially_faster_code_col":"INF = int(1e9)\n\ndef main():\n    # Read input\n    a, b, c, x, y = map(int, input().split())\n\n    # Initialize answer to a large value\n    ans = INF\n\n    # Case 1: Buy enough combined units to cover both x and y\n    max_combined = max(x, y)\n    cost_case1 = 2 * c * max_combined\n\n    # Case 2: Buy enough combined units to cover min(x, y), then buy remaining units individually\n    min_combined = min(x, y)\n    cost_case2 = 2 * c * min_combined + a * max(x - min_combined, 0) + b * max(y - min_combined, 0)\n\n    # Take the minimum of the two cases\n    ans = min(cost_case1, cost_case2)\n\n    # Output the result\n    print(ans)\n\nmain()"}
{"problem_id":"p03828","slow_code_col":"from functools import reduce\n\nN = int(eval(input()))\n\n\n\nprime_table = [1] * (N+1)\n\n\n\nfor x in range(2, N+1):\n\n    for t in range(2, x+1):\n\n        while x % t == 0:\n\n            prime_table[t] += 1\n\n            x \/\/= t\n\nprint((reduce(lambda x, y: x * y % (int(1e9) + 7), prime_table)))","reference_code_col":"def prime_factorize(n):\n\n    while n % 2 == 0:\n\n        a[2] += 1\n\n        n \/\/= 2\n\n    f = 3\n\n    while f * f <= n:\n\n        if n % f == 0:\n\n            a[f] += 1\n\n            n \/\/= f\n\n        else:\n\n            f += 2\n\n    if n != 1:\n\n        a[n] += 1\n\n\n\nN = int(eval(input()))\n\na = [0]*(N+1)\n\nfor i in range(2, N+1):\n\n    prime_factorize(i)\n\nans = 1\n\nfor i in a:\n\n    if i > 0:\n\n        ans *= (i+1)\n\nbig = 10**9 + 7\n\nprint((ans % big))","model_generated_potentially_faster_code_col":"from functools import reduce\n\n# Read input\nN = int(eval(input()))\n\n# Initialize prime_table to store counts of prime factors\nprime_table = [0] * (N + 1)\n\n# Sieve of Eratosthenes to compute smallest prime factor (SPF)\nspf = list(range(N + 1))  # spf[i] will hold the smallest prime factor of i\nfor i in range(2, int(N**0.5) + 1):\n    if spf[i] == i:  # i is a prime number\n        for j in range(i * i, N + 1, i):\n            if spf[j] == j:  # Update spf[j] only if it hasn't been set yet\n                spf[j] = i\n\n# Count prime factors for all numbers from 2 to N\nfor x in range(2, N + 1):\n    while x > 1:\n        prime_factor = spf[x]\n        prime_table[prime_factor] += 1\n        x \/\/= prime_factor\n\n# Compute the product of all prime counts modulo 1e9 + 7\nMOD = int(1e9) + 7\nresult = reduce(lambda x, y: x * y % MOD, prime_table[2:], 1)\n\nprint(result)"}
{"problem_id":"p03457","slow_code_col":"import numpy as np\n\nn = int(eval(input()))\n\nT = []\n\nX = []\n\nY = []\n\nt1 = 0\n\nx1 = 0\n\ny1 = 0\n\nfor i in range(n):\n\n    m = input().split()\n\n    T.append(int(m[0]) - t1)\n\n    t1 = int(m[0])\n\n    X.append(abs(int(m[1]) - x1))\n\n    x1 = int(m[1])\n\n    Y.append(abs(int(m[2]) - y1))\n\n    y1 = int(m[2])\n\nT = np.array(T)\n\nX = np.array(X)\n\nY = np.array(Y)\n\nfor i in range(n):\n\n    if X[i] + Y[i] > T[i] or (X[i] + Y[i] + T[i]) % 2 == 1:\n\n        print('No')\n\n        break\n\nelse:\n\n    print('Yes')","reference_code_col":"n = int(eval(input()))\n\nt1 = 0\n\nx1 = 0\n\ny1 = 0\n\nboolean = True\n\n\n\nfor __ in range(n):\n\n    t, x, y = [int(_) for _ in input().split()]\n\n    if boolean:\n\n        temp1 = x\n\n        temp2 = t\n\n        x = abs(x - x1) + abs(y - y1)\n\n        t -= t1\n\n        x1 = temp1\n\n        y1 = y\n\n        t1 = temp2\n\n        if x > t or (x + t) % 2 == 1:\n\n            boolean = False\n\nif boolean:\n\n    print('Yes')\n\nelse:\n\n    print('No')","model_generated_potentially_faster_code_col":"n = int(input())\n\n# Initialize previous time and coordinates\nprev_t, prev_x, prev_y = 0, 0, 0\n\nfor _ in range(n):\n    # Read and parse the current input line\n    t, x, y = map(int, input().split())\n    \n    # Calculate differences\n    delta_t = t - prev_t\n    delta_x = abs(x - prev_x)\n    delta_y = abs(y - prev_y)\n    \n    # Check conditions\n    if delta_x + delta_y > delta_t or (delta_x + delta_y + delta_t) % 2 != 0:\n        print('No')\n        break\n    \n    # Update previous values\n    prev_t, prev_x, prev_y = t, x, y\nelse:\n    # If the loop completes without breaking, print 'Yes'\n    print('Yes')"}
{"problem_id":"p03835","slow_code_col":"K,S = list(map(int,input().split(\" \")))\n\nans = 0\n\nfor i in range(K+1):\n\n\tfor j in range(K+1):\n\n\t\tif (S - i - j) <= K and (S-i-j) >= 0:\n\n\t\t\tans += 1\n\n\n\nprint(ans)\n","reference_code_col":"K, S = list(map(int,input().split(\" \")))\n\nans = 0\n\nfor X in range(K+1):\n\n    for Y in range(K+1):\n\n        if 0 <= (S - X - Y) <= K:\n\n            ans += 1\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"K, S = map(int, input().split())\n\nans = 0\n\nfor i in range(K + 1):\n    # Calculate the valid range for k\n    min_k = max(0, S - i - K)  # Ensure k >= 0 and k >= S - i - K\n    max_k = min(K, S - i)      # Ensure k <= K and k <= S - i\n    \n    if min_k <= max_k:\n        ans += (max_k - min_k + 1)\n\nprint(ans)"}
{"problem_id":"p02412","slow_code_col":"while 1:\n\n    ans=0\n\n    n,x=list(map(int,input().split()))\n\n    if n:\n\n        for i in range(1,n-1):\n\n            for j in range(i+1,n):\n\n                for k in range(j+1,n+1):\n\n                    if i+j+k==x:ans+=1\n\n    else:break\n\n    print(ans)","reference_code_col":"while 1:\n\n    a=0\n\n    n,x=list(map(int,input().split()))\n\n    if n==0:break\n\n    for i in range(1,n-1):\n\n        for j in range(i+1,n):\n\n            c=x-i-j\n\n            if c>j and c<=n:a+=1\n\n    print(a)","model_generated_potentially_faster_code_col":"while True:\n    n, x = map(int, input().split())\n    \n    if n == 0:\n        break\n    \n    ans = 0\n    # Precompute the frequency of each number in the range [1, n]\n    freq = [0] * (n + 1)\n    for i in range(1, n + 1):\n        freq[i] = 1  # Each number appears exactly once\n    \n    # Iterate over all pairs (i, j) and find the third number k\n    for i in range(1, n - 1):\n        for j in range(i + 1, n):\n            k = x - (i + j)\n            # Check if k is valid and distinct from i and j\n            if k > j and k <= n:\n                ans += 1\n    \n    print(ans)"}
{"problem_id":"p02767","slow_code_col":"def main():\n\n  from statistics import mean\n\n  from math import floor,ceil\n\n\n\n  n = int(eval(input()))\n\n  x = list(map(int, input().split()))\n\n  x_mean = mean(x) \n\n  if x_mean == 0.5:\n\n      greater_than_x = len([i for i in x if i > x_mean])\n\n      if greater_than_x * 2 >= n:\n\n          x_mean = ceil(x_mean)\n\n      else:\n\n          x_mean = floor(x_mean)\n\n  elif x_mean % 1 > 0.5:\n\n      x_mean = ceil(x_mean)\n\n  else:\n\n      x_mean = floor(x_mean)\n\n  x2 = [(num - x_mean)**2 for num in x]\n\n  print((sum(x2)))\n\n\n\nmain()","reference_code_col":"import sys\n\nread = sys.stdin.read\n\ndef main():\n\n    n, *x = list(map(int, read().split()))\n\n    r = float('inf')\n\n    for i1 in range(1, 101):\n\n        rt = 0\n\n        for xe in x:\n\n            rt += (xe - i1)**2\n\n        r = min(r, rt)\n\n    print(r)\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    # Input reading\n    n = int(input())\n    x = list(map(int, input().split()))\n    \n    # Compute mean manually\n    total_sum = sum(x)\n    x_mean = total_sum \/ n\n\n    # Adjust x_mean based on conditions\n    if x_mean == 0.5:\n        # Count elements greater than x_mean in a single pass\n        greater_than_x = sum(1 for num in x if num > x_mean)\n        x_mean = int(x_mean) + 1 if greater_than_x * 2 >= n else int(x_mean)\n    elif x_mean % 1 > 0.5:\n        x_mean = int(x_mean) + 1  # Equivalent to ceil\n    else:\n        x_mean = int(x_mean)  # Equivalent to floor\n\n    # Compute the sum of squared differences directly\n    squared_sum = sum((num - x_mean) ** 2 for num in x)\n\n    # Output the result\n    print(squared_sum)\n\n\nmain()"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\n\n\neval(input())\n\nA = np.array(list(map(int, input().split())))\n\n\n\nans = 0\n\nwhile(all(A%2==0)):\n\n    A = A\/2\n\n    ans += 1\n\n\n\nprint(ans)\n","reference_code_col":"eval(input())\n\nA = list(map(int, input().split()))\n\n\n\nans = 0\n\nwhile all(a%2==0 for a in A):\n\n    A=[a\/2 for a in A]\n\n    ans += 1\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input and create NumPy array directly\n_ = input()  # Ignore the first input (eval is removed)\nA = np.array(list(map(int, input().split())))\n\nans = 0\n\n# Use bitwise operations for faster checks and divisions\nwhile np.all((A & 1) == 0):  # Check if all elements are even using bitwise AND\n    A >>= 1  # Perform integer division by 2 using right shift\n    ans += 1\n\nprint(ans)"}
{"problem_id":"p02691","slow_code_col":"n = int(eval(input()))\n\na = list(map(int, input().split()))\n\na_index = []\n\nfor i in range(n):\n\n    a_index.append((i, a[i]))\n\ndic1 = {}\n\ndic2 = {}\n\nfor i in range(n):\n\n    one = a_index[i][0] + a_index[i][1]\n\n    two = a_index[i][0] - a_index[i][1]\n\n    if one not in dic1:\n\n        dic1[one] = 1\n\n    else:\n\n        dic1[one] += 1\n\n    if two not in dic2:\n\n        dic2[two] = 1\n\n    else:\n\n        dic2[two] += 1\n\nans = 0\n\nfor i in list(dic1.keys()):\n\n    if i in dic2:\n\n        ans += dic2[i] * dic1[i]\n\nfor i in list(dic2.keys()):\n\n    if i in dic1:\n\n        ans += dic1[i] * dic2[i]\n\n        #print(i)\n\nprint((ans \/\/ 2))\n","reference_code_col":"n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nimport collections\n\nans = 0\n\ndic = collections.defaultdict(int)\n\nfor i in range(1, n + 1):\n\n    ans += dic[i - a[i - 1]]\n\n    dic[i + a[i - 1]] += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"from collections import defaultdict\n\n# Input handling\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize dictionaries\ndic1 = defaultdict(int)\ndic2 = defaultdict(int)\n\n# Populate dictionaries\nfor i in range(n):\n    one = i + a[i]\n    two = i - a[i]\n    dic1[one] += 1\n    dic2[two] += 1\n\n# Calculate the answer using set intersection\ncommon_keys = set(dic1.keys()) & set(dic2.keys())\nans = sum(dic1[key] * dic2[key] for key in common_keys)\n\n# Output the result\nprint(ans)"}
{"problem_id":"p03835","slow_code_col":"k,s=list(map(int,input().split()))\n\nans=chk=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        if (0<=s-i-j<=k): ans+=1\n\nprint(ans)","reference_code_col":"k,s=list(map(int,input().split()))\n\nans=0\n\nx=min(k+1,s+1)\n\ny=max(0,s-k-k)\n\nfor i in range(y,x):\n\n    for j in range(y,x):\n\n        if i+j>s: break\n\n        if 0<=s-i-j<=k:\n\n            ans+=1\n\nprint(ans)","model_generated_potentially_faster_code_col":"k, s = map(int, input().split())\n\nans = 0\n\nfor i in range(k + 1):\n    # Calculate the valid range for j\n    j_min = max(0, s - i - k)  # Ensure j >= 0 and l >= 0\n    j_max = min(k, s - i)      # Ensure j <= k and l <= k\n    \n    # Count the number of valid j values\n    if j_min <= j_max:\n        ans += (j_max - j_min + 1)\n\nprint(ans)"}
{"problem_id":"p03564","slow_code_col":"N,K = int(eval(input())), int(eval(input()))\n\nnow = 1\n\nfor i in range(N):\n\n    if now*2 < now + K:\n\n        now *= 2\n\n    else:\n\n        now += K\n\nprint(now)\n","reference_code_col":"N = int(eval(input()))\n\nK = int(eval(input()))\n\nans = 1\n\nfor i in range(N):\n\n    if ans < K:\n\n        ans *= 2\n\n    else:\n\n        ans += K\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Input\nN, K = map(int, input().split())\n\n# Initialize\nnow = 1\n\n# Phase 1: Double until now >= K or N iterations are exhausted\ndoubling_steps = 0\nwhile now < K and doubling_steps < N:\n    now *= 2\n    doubling_steps += 1\n\n# Remaining iterations after doubling\nremaining_steps = N - doubling_steps\n\n# Phase 2: Add K for the remaining iterations\nif remaining_steps > 0:\n    now += K * remaining_steps\n\n# Output\nprint(now)"}
{"problem_id":"p02850","slow_code_col":"#d3\u3068\u540c\u4e00\u89e3\u6cd5\n\nn=int(eval(input()))\n\nimport sys\n\n#\u518d\u5e30\u95a2\u6570\u306e\u518d\u5e30\u56de\u6570\u3092\u5909\u66f4\n\nsys.setrecursionlimit(10**6)\n\ns=[[] for _ in range(n)]\n\n\n\nfor i in range(n-1):\n\n    a,b=list(map(int,input().split()))\n\n    s[a-1].append((b-1,i))\n\n    s[b-1].append((a-1,i))\n\n\n\nl=[0]*(n-1)\n\n\n\ndef dfs(node,pre_col,par):\n\n    col=1\n\n    for nei,i in s[node]:\n\n        if nei==par:\n\n            continue\n\n        if col==pre_col:\n\n            col+=1\n\n        l[i]=col\n\n        dfs(nei,col,node)\n\n        col+=1\n\ndfs(0,-1,-1)\n\nprint((max(l)))\n\nfor i in l:\n\n    print(i)\n","reference_code_col":"import sys\n\nsys.setrecursionlimit(500000)\n\nN = int(eval(input()))\n\nE = [[] for _ in range(N+1)]\n\nfor i in range(N-1):\n\n    a, b = list(map(int, input().split()))\n\n    E[a].append((b, i))\n\n    E[b].append((a, i))\n\nK = max(len(e) for e in E)\n\nprint(K)\n\nAns = [-1] * (N-1)\n\ndef dfs(v=1, p=0, p_col=-1):\n\n    col = 1\n\n    for u, idx in E[v]:\n\n        if u!=p: #\u6728\u69cb\u9020\u306e\u9006\u5411\u304d\u306e\u77e2\u5370\u3092\u9664\u304f\u305f\u3081\u306e\u6761\u4ef6\n\n            if col == p_col:\n\n                col += 1\n\n            Ans[idx] = col\n\n            #print(p_col)\n\n            dfs(u, v, col) #u;\u8abf\u3079\u308b\u9802\u70b9 v;\u76f4\u524d\u306b\u8abf\u3079\u305f\u8fba\u3067\u3001\u8abf\u3079\u308b\u9802\u70b9\u3068\u7d50\u3070\u308c\u3066\u3044\u308b\u9802\u70b9\u3000col;\u76f4\u524d\u306b\u8abf\u3079\u305f\u8fba\u306e\u8272\u756a\u53f7\n\n            col += 1 #\u6700\u6df1\u90e8\u307e\u3067\u8abf\u3079\u305f\u3089 \u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u8272=\u6700\u5f8c\u306b\u8abf\u3079\u305f\u8fba\u306e\u8272+1\u3068\u3059\u308b\n\n            #\u6700\u6df1\u90e8\u306b\u7e4b\u304c\u3063\u305f\u8fba\u306e\u8272+1\u3057\u3066\u3084\u308c\u3070\u3001\u6b21\u306e\u8fba\u306e\u8272\u306f\u5fc5\u305a\u6761\u4ef6\u3092\u6e80\u305f\u3057\u3066\u304f\u308c\u308b\n\n\n\ndfs()\n\nprint((\"\\n\".join(map(str, Ans))))\n","model_generated_potentially_faster_code_col":"import sys\nfrom collections import deque\n\n# Read input\nn = int(sys.stdin.readline())\n\n# Adjacency list: s[node] contains neighbors and edge indices\ns = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    a, b = map(int, sys.stdin.readline().split())\n    s[a - 1].append((b - 1, i))  # Store neighbor and edge index\n    s[b - 1].append((a - 1, i))\n\n# Edge coloring array\nl = [0] * (n - 1)\n\n# Iterative DFS using a stack\ndef dfs_iterative(root):\n    stack = deque([(root, -1, -1)])  # (current_node, parent_node, parent_edge_color)\n    max_color = 0\n\n    while stack:\n        node, par, pre_col = stack.pop()\n        col = 1\n\n        for nei, edge_idx in s[node]:\n            if nei == par:\n                continue\n\n            # Assign the smallest available color\n            if col == pre_col:\n                col += 1\n            l[edge_idx] = col\n            max_color = max(max_color, col)\n\n            # Push the neighbor onto the stack\n            stack.append((nei, node, col))\n            col += 1\n\n    return max_color\n\n# Perform DFS and compute the maximum color used\nmax_color = dfs_iterative(0)\n\n# Output results\nprint(max_color)\nprint(\"\\n\".join(map(str, l)))"}
{"problem_id":"p03494","slow_code_col":"eval(input())\n\n\n\nimport numpy as np\n\nA = np.array(list(map(int, input().split(\" \"))))\n\na = 0\n\n\n\nwhile np.sum(A%2) == 0:\n\n  A = A\/2\n\n  a = a + 1\n\n\n\nprint(a)","reference_code_col":"eval(input())\n\n\n\nA = list(map(int, input().split(\" \")))\n\nB = 0\n\n\n\nwhile all(a%2 == 0 for a in A):\n\n  A = [a\/2 for a in A]\n\n  B += 1\n\n  \n\nprint(B)\n\n    ","model_generated_potentially_faster_code_col":"# Read input as integers directly\nA = list(map(int, input().split()))\n\na = 0\n\n# Continue looping until any element in A is odd\nwhile all(x % 2 == 0 for x in A):\n    # Divide all elements by 2 using list comprehension\n    A = [x \/\/ 2 for x in A]\n    a += 1\n\nprint(a)"}
{"problem_id":"p02881","slow_code_col":"import math\n\nn=int(eval(input()))\n\nans=n\n\ni=1\n\nwhile(i<=math.sqrt(n)):\n\n    if n%i==0:\n\n        d=i+n\/i-2\n\n        ans=min(ans,d)\n\n    i+=1\n\nprint((int(ans)))","reference_code_col":"from math import floor\n\nfrom math import sqrt\n\nn=int(eval(input()))\n\nnn=floor(sqrt(n))\n\nrest=n%nn\n\nwhile rest!=0:\n\n    nn-=1\n\n    rest=n%nn\n\nnnn=n\/nn\n\nprint((int(nn+nnn-2)))","model_generated_potentially_faster_code_col":"n = int(input())  # Use direct input instead of eval\n\nans = n\nsqrt_n = int(n ** 0.5)  # Precompute square root of n once\n\nfor i in range(1, sqrt_n + 1):  # Iterate up to sqrt(n)\n    if n % i == 0:  # Check if i is a divisor of n\n        d = i + (n \/\/ i) - 2  # Compute d using integer division\n        ans = min(ans, d)  # Update the minimum value\n\nprint(ans)"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nN = int(eval(input()))\n\n\n\npower = math.factorial(N)\n\n\n\nprint((power % 1000000007))\n\n\n","reference_code_col":"n=int(eval(input()))\n\nans=1\n\nfor i in range(n):\n\n    ans=(ans*(i+1))%(10**9+7)\n\nprint(ans)","model_generated_potentially_faster_code_col":"MOD = 1000000007\n\n# Read input safely\nN = int(input())\n\n# Compute factorial modulo MOD iteratively\nresult = 1\nfor i in range(1, N + 1):\n    result = (result * i) % MOD\n\nprint(result)"}
{"problem_id":"p03170","slow_code_col":"n, k = list(map(int, input().split()))\n\na_s = list(map(int, input().split()))\n\ndp = [\"Second\"] * (k + 1)\n\nfor i in range(k + 1):\n\n    if dp[i] == \"Second\":\n\n        for a in a_s:\n\n            ii = i + a\n\n            if ii <= k:\n\n                dp[ii] = \"First\"\n\nprint((dp[-1]))\n","reference_code_col":"n, k = list(map(int, input().split()))\n\na_s = list(map(int, input().split()))\n\ndp = [\"Second\"] * (k + 1)\n\nfor i in range(k + 1):\n\n    if dp[i] == \"Second\":\n\n        for a in a_s:\n\n            ii = i + a\n\n            if ii > k:break\n\n            dp[ii] = \"First\"\n\nprint((dp[-1]))\n","model_generated_potentially_faster_code_col":"n, k = map(int, input().split())\na_s = list(map(int, input().split()))\n\n# Use a boolean array for dp: True -> \"Second\", False -> \"First\"\ndp = [False] * (k + 1)\n\n# Iterate backward to propagate updates efficiently\nfor i in range(k, -1, -1):\n    for a in a_s:\n        ii = i + a\n        if ii <= k and not dp[ii]:  # If there exists a move leading to \"First\"\n            dp[i] = True\n            break  # Early exit once a valid move is found\n\n# Convert the final result back to \"First\" or \"Second\"\nprint(\"First\" if dp[0] else \"Second\")"}
{"problem_id":"p02886","slow_code_col":"N = int(eval(input()))\n\nD = list(map(int,input().split()))\n\ncnt = 0\n\nfor i in range(N-1):\n\n    for j in range(i+1,N):\n\n        cnt += D[i]*D[j]\n\nprint(cnt)","reference_code_col":"N = int(eval(input()))\n\nD = list(map(int,input().split()))\n\ncnt = 0\n\nfor i in range(N):\n\n    cnt += D[i]**2\n\ntot = 0\n\nfor i in range(N):\n\n    tot += D[i]\n\ntot = tot**2\n\ntot -= cnt\n\nprint((tot\/\/2))","model_generated_potentially_faster_code_col":"# Input size N\nN = int(eval(input()))\n\n# Input list D\nD = list(map(int, input().split()))\n\n# Compute the sum of elements and the sum of squares of elements\nsum_D = sum(D)\nsum_D_squared = sum(x * x for x in D)\n\n# Compute the result using the formula\ncnt = (sum_D * sum_D - sum_D_squared) \/\/ 2\n\n# Output the result\nprint(cnt)"}
{"problem_id":"p02792","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nN = int(eval(input()))\n\nketa = len(str(N))\n\nif keta == 1:\n\n    print(N)\n\n    sys.exit()\n\nans = {}\n\nfor i in [1,2,3,4,5,6,7,8,9]:\n\n    for j in [1,2,3,4,5,6,7,8,9]:\n\n        ans[(i, j)] = 0\n\nfor i in range(1, N+1):\n\n    maxdigit = int(str(i)[0])\n\n    mindigit = int(str(i)[-1])\n\n    if mindigit != 0:\n\n        ans[(maxdigit, mindigit)] += 1\n\ncnt = 0\n\nfor i in range(1, 10):\n\n    for j in range(1, 10):\n\n        if i == j:\n\n            cnt += ans[(i, i)] ** 2\n\n        else:\n\n            cnt += ans[(i, j)] * ans[(j, i)] * 2\n\n            ans[(i, j)] = 0\n\n            ans[(j, i)] = 0\n\nprint(cnt)\n\n\n\n        \n\n\n\n    ","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\n\n\nfrom collections import defaultdict\n\n\n\nd = defaultdict(int) # d[(a, b)] : \u5148\u982da, \u672b\u5c3eb\n\n\n\nfor i in range(1, n + 1):\n\n    i_str = str(i)\n\n    d[(i_str[0], i_str[-1])] += 1\n\n\n\nans = 0\n\n\n\nfor i in range(1, 10):\n\n    for j in range(10):\n\n        ans += d[(str(i), str(j))] * d[(str(j), str(i))]\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Read input efficiently\n    N = int(sys.stdin.readline())\n\n    # Handle single-digit case early\n    if N < 10:\n        print(N)\n        return\n\n    # Initialize a 2D array for digit pair counts\n    ans = [[0] * 10 for _ in range(10)]\n\n    # Populate the digit pair counts\n    for i in range(1, N + 1):\n        maxdigit = i\n        while maxdigit >= 10:  # Extract the first digit\n            maxdigit \/\/= 10\n        mindigit = i % 10      # Extract the last digit\n        if mindigit != 0:\n            ans[maxdigit][mindigit] += 1\n\n    # Compute the final count efficiently\n    cnt = 0\n    for i in range(1, 10):\n        for j in range(1, 10):\n            if i == j:\n                cnt += ans[i][i] ** 2\n            else:\n                cnt += ans[i][j] * ans[j][i] * 2\n\n    # Output the result\n    print(cnt)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02555","slow_code_col":"from math import factorial\n\n\n\ns = int(eval(input()))\n\nmod = pow(10, 9) + 7\n\n\n\n\n\ndef nCr(n, r):\n\n    return int(factorial(n) \/\/ factorial(r) \/\/ factorial (n - r) % mod)\n\n\n\nans = 0\n\nseq_len = s \/\/ 3\n\n\n\nfor i in range(1, seq_len + 1):\n\n    ans += nCr(s - 3 * i + (i - 1), i - 1)\n\n\n\nprint((ans % mod))","reference_code_col":"# \u52d5\u7684\u8a08\u753b\u6cd5\u306b\u3088\u308b\u89e3\u6cd5\n\n\n\ns = int(eval(input()))\n\nmod = pow(10, 9) + 7\n\n\n\nA = [0] * (s + 1)\n\n\n\nif s >= 3:\n\n    A[3] = 1\n\n\n\nfor i in range(4, s + 1):\n\n    A[i] = (A[i - 3] + A[i - 1]) % mod\n\n\n\nprint((A[s]))","model_generated_potentially_faster_code_col":"from math import factorial\n\n# Input and constants\ns = int(input())\nmod = pow(10, 9) + 7\n\n# Precompute factorials and modular inverses\nMAX_N = 10**6  # Adjust this based on expected input size\nfactorial_precomp = [1] * (MAX_N + 1)\ninverse_precomp = [1] * (MAX_N + 1)\n\n# Compute factorials\nfor i in range(2, MAX_N + 1):\n    factorial_precomp[i] = factorial_precomp[i - 1] * i % mod\n\n# Compute modular inverses using Fermat's Little Theorem\ninverse_precomp[MAX_N] = pow(factorial_precomp[MAX_N], mod - 2, mod)\nfor i in range(MAX_N - 1, 0, -1):\n    inverse_precomp[i] = inverse_precomp[i + 1] * (i + 1) % mod\n\n# Efficient nCr function using precomputed values\ndef nCr(n, r):\n    if r > n or r < 0:\n        return 0\n    return factorial_precomp[n] * inverse_precomp[r] % mod * inverse_precomp[n - r] % mod\n\n# Main computation\nans = 0\nseq_len = s \/\/ 3\n\nfor i in range(1, seq_len + 1):\n    ans = (ans + nCr(s - 3 * i + (i - 1), i - 1)) % mod\n\nprint(ans)"}
{"problem_id":"p03370","slow_code_col":"N, X = list(map(int, input().split()))\n\n\n\nmn = [0]*N\n\nfor i in range(N):\n\n  mn[i] = int(eval(input()))\n\n  \n\nans = N\n\nx = X - sum(mn)\n\n\n\nwhile(x >= min(mn)):\n\n  if x \/\/ min(mn) == 0:\n\n    mn[mn.index(min(mn))] = 1000000\n\n  else:\n\n    if x >= min(mn):\n\n      x -= min(mn)\n\n      ans += 1\n\n      \n\nprint(ans)","reference_code_col":"N, X = list(map(int, input().split()))\n\n\n\nmn = [0]*N\n\nfor i in range(N):\n\n  mn[i] = int(eval(input()))\n\n  \n\nans = N\n\nx = X - sum(mn)\n\n\n\nwhile(x >= min(mn)):\n\n  if x \/\/ min(mn) == 0:\n\n    mn[mn.index(min(mn))] = 1000000\n\n  else:\n\n    x -= min(mn)\n\n    ans += 1\n\n      \n\nprint(ans)","model_generated_potentially_faster_code_col":"N, X = map(int, input().split())\n\n# Read all mn values at once\nmn = [int(input()) for _ in range(N)]\n\n# Calculate initial sum and remaining budget\ntotal_sum = sum(mn)\nx = X - total_sum\n\n# Sort mn in ascending order to efficiently process smallest elements first\nmn.sort()\n\nans = N\ni = 0\n\n# Use the sorted list to process elements more efficiently\nwhile i < N and x >= mn[i]:\n    x -= mn[i]\n    ans += 1\n    i += 1\n\nprint(ans)"}
{"problem_id":"p03644","slow_code_col":"import numpy as np\n\nN=int(eval(input()))\n\nprint((2**int(np.log2(N))))","reference_code_col":"import math\n\nN=int(eval(input()))\n\nprint((2**int(math.log2(N))))","model_generated_potentially_faster_code_col":"import math\n\n# Safely read input and convert to integer\nN = int(input())\n\n# Compute the largest power of 2 less than or equal to N\nlargest_power_of_2 = 2 ** int(math.log2(N))\n\n# Output the result\nprint(largest_power_of_2)"}
{"problem_id":"p02596","slow_code_col":"#! \/usr\/bin\/env python3\n\n\n\nimport sys\n\nint1 = lambda x: int(x) - 1\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(500000)\n\n\n\n\n\ndef isMultiple(s, m):\n\n    tmp = 0\n\n    for i in range(len(s)):\n\n        tmp = (tmp * 10 + int(s[i])) % m\n\n        if tmp == 0:\n\n            return i\n\n    return -1\n\n\n\n\n\nk = int(readline())\n\nacc = \"7\" * 50000000\n\nif k % 2 == 0:\n\n    ans = -1\n\nelse:\n\n\n\n    ans = isMultiple(acc, k)\n\n    if ans != -1:\n\n        ans += 1\n\n\n\nprint(ans)\n","reference_code_col":"#! \/usr\/bin\/env python3\n\n\n\nimport sys\n\nint1 = lambda x: int(x) - 1\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(500000)\n\n\n\nk = int(readline())\n\n\n\nans = -1\n\nacc = 7 % k\n\nfor n in range(1, k + 10):\n\n    if acc == 0:\n\n        ans = n\n\n        break\n\n    acc = (10 * acc + 7) % k\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\n\ndef find_smallest_multiple_of_sevens(k):\n    # Early exit for even k or k divisible by 5\n    if k % 2 == 0 or k % 5 == 0:\n        return -1\n\n    # Initialize variables\n    remainder = 0\n    for length in range(1, k + 1):  # At most k iterations due to Pigeonhole Principle\n        # Simulate appending a '7' and compute the new remainder\n        remainder = (remainder * 10 + 7) % k\n        if remainder == 0:\n            return length  # Found the smallest multiple\n\n    return -1  # No multiple found within k iterations\n\n# Read input\nk = int(sys.stdin.buffer.readline())\n\n# Compute and print the result\nprint(find_smallest_multiple_of_sevens(k))"}
{"problem_id":"p03253","slow_code_col":"from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# x\u3092\u7d20\u56e0\u6570\u5206\u89e3\u3059\u308b\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x \/\/= d\n\n\n\n    if x != 1:\n\n        ans.append(x)\n\n\n\n    return ans\n\n\n\n# x\u306en\u4e57\uff08\u4e8c\u5206\u7d2f\u4e57\u6cd5\uff09\n\ndef power(x, n):\n\n    ans = 1\n\n    while n:\n\n        if n % 2 == 1:\n\n            ans = (ans * x) % MOD\n\n        x = (x * x) % MOD\n\n        n \/\/= 2\n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nN2 = N\n\nif len(cnt):\n\n    N2 += max(cnt.values())\n\n\n\n# facts[x]: x\u306e\u968e\u4e57\n\nfacts = [1] + [0] * N2\n\nfor x in range(1, N2 + 1):\n\n    facts[x] = (facts[x - 1] * x) % MOD\n\n\n\n# invFs[x]: x\u306e\u968e\u4e57\u306e\u9006\u5143\n\ninvFs = [0] * N2 + [power(facts[N2], MOD - 2)]\n\nfor x in reversed(list(range(N2))):\n\n    invFs[x] = (invFs[x + 1] * (x + 1)) % MOD\n\n\n\ndef comb(n, k):\n\n    return ((facts[n] * invFs[k]) % MOD * invFs[n - k]) % MOD\n\n\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans = (ans * comb(N + num - 1, num)) % MOD\n\nprint(ans)\n","reference_code_col":"from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# x\u3092\u7d20\u56e0\u6570\u5206\u89e3\u3059\u308b\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x \/\/= d\n\n    if x != 1:\n\n        ans.append(x)\n\n    return ans\n\n\n\ndef comb(n, k):\n\n    k = min(k, n - k)\n\n    ans = 1\n\n    for i in range(n, n - k, -1):\n\n        ans *= i\n\n    for i in range(1, k + 1):\n\n        ans \/\/= i \n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans *= comb(N + num - 1, num)\n\nprint((ans % MOD))\n","model_generated_potentially_faster_code_col":"def sieve_of_eratosthenes(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(sqrt(limit)) + 1):\n        if is_prime[i]:\n            for j in range(i * i, limit + 1, i):\n                is_prime[j] = False\n    return [x for x in range(limit + 1) if is_prime[x]]\n\n# Precompute primes up to sqrt(10^6)\nPRIMES = sieve_of_eratosthenes(int(sqrt(10**6)))\n\ndef getPrimeFactor(x):\n    ans = []\n    for p in PRIMES:\n        if p * p > x:\n            break\n        while x % p == 0:\n            ans.append(p)\n            x \/\/= p\n    if x != 1:\n        ans.append(x)\n    return ans"}
{"problem_id":"p02615","slow_code_col":"n,*l=list(map(int,open(0).read().split()));print((sum(sorted(l*2)[-2:~n:-1])))","reference_code_col":"n,*l=list(map(int,open(0).read().split()))\n\nl.sort(reverse=1)\n\nprint((sum(l[i\/\/2] for i in range(1,n))))","model_generated_potentially_faster_code_col":"n, *l = map(int, open(0).read().split())\nmax1 = max2 = float('-inf')\n\nfor num in l:\n    if num > max1:\n        max2 = max1\n        max1 = num\n    elif num > max2 and num != max1:\n        max2 = num\n\nprint(max1 + max2)"}
{"problem_id":"p03796","slow_code_col":"import numpy as np\n\nmod=10**9+7\n\nd=np.zeros(100100,dtype=np.int64)\n\nd[0]=1\n\nfor i in range(1,10**5+1):\n\n  d[i]=d[i-1]*i%mod\n\nprint((d[int(eval(input()))]))","reference_code_col":"d,mod=[1]+[0]*100100,10**9+7\n\nfor i in range(1,10**5+1):d[i]=d[i-1]*i%mod\n\nprint((d[int(eval(input()))]))","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\n# Precompute factorials up to 10^5\ndef precompute_factorials(limit, mod):\n    factorials = [1]  # factorial[0] = 1\n    for i in range(1, limit + 1):\n        factorials.append(factorials[-1] * i % mod)\n    return factorials\n\n# Precompute once globally\nMAX_LIMIT = 10**5\nfactorials = precompute_factorials(MAX_LIMIT, MOD)\n\n# Read input and output the result\nn = int(input())\nprint(factorials[n])"}
{"problem_id":"p02881","slow_code_col":"import math\n\nN = int(eval(input()))\n\nfor i in range(int(math.sqrt(N))):\n\n    if N % (int(math.sqrt(N))-i) == 0:\n\n        print((int(N\/(int(math.sqrt(N))-i)+int(math.sqrt(N))-i-2)))\n\n        break","reference_code_col":"import math\n\nN = int(eval(input()))\n\nM = int(math.sqrt(N))\n\nfor i in range(M):\n\n    if N % (M-i) == 0:\n\n        print((int(N\/(M-i)+M-i-2)))\n\n        break\n","model_generated_potentially_faster_code_col":"import math\n\n# Input handling\nN = int(input())\n\n# Precompute the integer square root of N\nsqrt_N = int(math.sqrt(N))\n\n# Iterate over potential divisors in descending order\nfor divisor in range(sqrt_N, 0, -1):\n    if N % divisor == 0:\n        # Compute the result and print it\n        result = (N \/\/ divisor) + divisor - 2\n        print(result)\n        break"}
{"problem_id":"p02994","slow_code_col":"N, L = [int(i) for i in input().split()]\n\n\n\nmin_ = L\n\nmax_ = L + N -1\n\n\n\ndef eat_apple():\n\n    if max_<0:\n\n        return max_ \n\n    if L < 0:\n\n        return 0\n\n    return L\n\n\n\nprint(((min_+max_)*(max_-min_+1)\/\/2 - eat_apple()))","reference_code_col":"N, L = [int(i) for i in input().split()]\n\n\n\nmin_ = L\n\nmax_ = L + N -1\n\n\n\ndef eat_apple(N, L, max_):\n\n    if max_<0:\n\n        return max_ \n\n    if L < 0:\n\n        return 0\n\n    return L\n\n\n\nprint(((min_+max_)*(max_-min_+1)\/\/2 - eat_apple(N, L, max_)))","model_generated_potentially_faster_code_col":"# Input parsing\nN, L = map(int, input().split())\n\n# Precompute min_ and max_\nmin_ = L\nmax_ = L + N - 1\n\n# Determine the apple to eat\nif max_ < 0:\n    eaten = max_  # Eat the apple with the highest sweetness\nelif L < 0:\n    eaten = 0     # Eat the apple with sweetness 0\nelse:\n    eaten = L     # Eat the apple with the lowest sweetness\n\n# Compute the total sweetness of all apples\ntotal_sweetness = (min_ + max_) * N \/\/ 2\n\n# Subtract the eaten apple's sweetness\nprint(total_sweetness - eaten)"}
{"problem_id":"p03363","slow_code_col":"from collections import Counter\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\nruisekiwa = [0] * (N+1)\n\n\n\nfor i in range(N):\n\n    ruisekiwa[i+1] = ruisekiwa[i] + inputs[i]\n\n\n\nruisekiwa = ruisekiwa[1:]\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n","reference_code_col":"from collections import Counter\n\nfrom itertools import accumulate\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\n\n\nruisekiwa = list(accumulate(inputs))\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"from collections import Counter\n\n# Input reading\nN = int(input())\ninputs = list(map(int, input().split()))\n\n# Compute prefix sums (ruisukiwa)\nruisekiwa = [0] * (N + 1)\nfor i in range(N):\n    ruisekiwa[i + 1] = ruisekiwa[i] + inputs[i]\n\n# Remove the first element (initial 0) and sort the prefix sums\nruisekiwa = ruisekiwa[1:]\nruisekiwa.sort()\n\n# Count occurrences of each prefix sum using Counter\ncounter_ruiseki = Counter(ruisekiwa)\n\n# Calculate the result efficiently\nans = 0\nfor count in counter_ruiseki.values():\n    if count > 1:\n        # Add combinations of pairs for counts > 1\n        ans += count * (count - 1) \/\/ 2\n\n# Handle the special case where the prefix sum is 0\nans += counter_ruiseki.get(0, 0)\n\nprint(ans)"}
{"problem_id":"p03457","slow_code_col":"import sys\n\n_input = sys.stdin.readline\n\n\n\n\n\ndef resolve():\n\n    N = int(_input())\n\n    T = [list(map(int, _input().split())) for _ in range(N)]\n\n    t, x, y = 0, 0, 0\n\n    for next_t, next_x, next_y in T:\n\n        diff_xy = abs(x - next_x) + abs(y - next_y)\n\n        diff_t = next_t - t\n\n        if diff_xy > diff_t or (diff_xy % 2 != diff_t % 2):\n\n            print('No')\n\n            exit(0)\n\n    print('Yes')\n\n\n\n\n\nif __name__ == '__main__':\n\n    resolve()","reference_code_col":"import sys\n\n_input = sys.stdin.readline\n\n\n\n\n\ndef resolve():\n\n    N = int(_input())\n\n    t, x, y = 0, 0, 0\n\n    for _ in range(N):\n\n        next_t, next_x, next_y = list(map(int, _input().split()))\n\n        diff_xy = abs(x - next_x) + abs(y - next_y)\n\n        diff_t = next_t - t\n\n        if diff_xy > diff_t or (diff_xy % 2 != diff_t % 2):\n\n            print('No')\n\n            exit(0)\n\n    print('Yes')\n\n\n\n\n\nif __name__ == '__main__':\n\n    resolve()","model_generated_potentially_faster_code_col":"import sys\n\ndef resolve():\n    # Read the number of steps\n    N = int(sys.stdin.readline())\n\n    # Initialize starting position and time\n    t, x, y = 0, 0, 0\n\n    # Process each step directly without storing all inputs\n    for _ in range(N):\n        # Read the next step\n        next_t, next_x, next_y = map(int, sys.stdin.readline().split())\n\n        # Calculate the differences\n        diff_xy = abs(x - next_x) + abs(y - next_y)\n        diff_t = next_t - t\n\n        # Check the feasibility of the move\n        if diff_xy > diff_t or (diff_xy % 2 != diff_t % 2):\n            print('No')\n            return\n\n        # Update the current position and time\n        t, x, y = next_t, next_x, next_y\n\n    # If all steps are valid, print 'Yes'\n    print('Yes')\n\nif __name__ == '__main__':\n    resolve()"}
{"problem_id":"p02596","slow_code_col":"K = int(eval(input()))\n\n\n\nflg = [False]*K\n\n\n\ntmp = 7 % K\n\ncnt = 1\n\nif tmp == 0:\n\n    print(cnt)\n\n    exit()\n\nwhile True:\n\n    tmp = (tmp*10+7)%K\n\n    if flg[tmp]:\n\n        print((-1))\n\n        break\n\n    else:\n\n        cnt += 1\n\n        if tmp == 0:\n\n            print(cnt)\n\n            break\n\n        flg[tmp] = True\n","reference_code_col":"K = int(eval(input()))\n\nt = 7\n\nt %= K\n\n\n\nfor i in range(K+1):\n\n    if t == 0:\n\n        print((i+1))\n\n        exit()\n\n    t = (t*10+7)%K\n\nprint((-1))\n","model_generated_potentially_faster_code_col":"K = int(input())\n\n# Edge case: if K is divisible by 2 or 5, no solution exists\nif K % 2 == 0 or K % 5 == 0:\n    print(-1)\n    exit()\n\n# Initialize variables\nflg = [False] * K\ntmp = 7 % K\ncnt = 1\n\n# Check if the initial value is divisible by K\nif tmp == 0:\n    print(cnt)\n    exit()\n\n# Main loop\nwhile True:\n    tmp = (tmp * 10 + 7) % K\n    if flg[tmp]:\n        print(-1)\n        break\n    else:\n        cnt += 1\n        if tmp == 0:\n            print(cnt)\n            break\n        flg[tmp] = True"}
{"problem_id":"p03796","slow_code_col":"from math import factorial\n\nprint((factorial(int(eval(input()))) % (10**9+7)))","reference_code_col":"ans = 1\n\nfor k in range(1, int(eval(input()))+1):\n\n    ans = ans*k % (10**9+7)\n\nprint(ans)","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\ndef factorial_mod(n, mod):\n    \"\"\"Compute n! % mod using iterative approach.\"\"\"\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % mod\n    return result\n\n# Input handling\nn = int(input(\"Enter a number: \"))\n\n# Compute factorial modulo MOD\nprint(factorial_mod(n, MOD))"}
{"problem_id":"p03822","slow_code_col":"import sys\n\nsys.setrecursionlimit(202020)\n\n\n\nN = int(eval(input()))\n\nwon = [[] for i in range(N)]\n\nfor i in range(1,N):\n\n    a = int(eval(input())) - 1\n\n    won[a].append(i)\n\n\n\ndef height(v):\n\n    if not won[v]: return 0\n\n    hs = [height(op) for op in won[v]]\n\n    ret = 0\n\n    for i,h in enumerate(sorted(hs)):\n\n        ret = max(ret, h + len(hs) - i)\n\n    return ret\n\n\n\nprint((height(0)))","reference_code_col":"import sys\n\nsys.setrecursionlimit(10**8)\n\nN = int(eval(input()))\n\nA = [int(eval(input()))-1 for i in range(N-1)]\n\nwins = [[] for _ in range(N)]\n\n\n\nfor i,a in enumerate(A):\n\n    wins[a].append(i+1)\n\n\n\ndepth = [-1] * N\n\ndef dep(v):\n\n    if len(wins[v])==0: return 0\n\n    if depth[v] >= 0:\n\n        return depth[v]\n\n    ds = []\n\n    for w in wins[v]:\n\n        ds.append(dep(w))\n\n    ds.sort(reverse=True)\n\n    ret = 0\n\n    for i,d in enumerate(ds):\n\n        ret = max(ret, i+d+1)\n\n    depth[v] = ret\n\n    return ret\n\nprint((dep(0)))","model_generated_potentially_faster_code_col":"import sys\nfrom heapq import heappush, heappop\n\nsys.setrecursionlimit(202020)\n\n# Input parsing\nN = int(sys.stdin.readline())\nwon = [[] for _ in range(N)]\n\nfor i in range(1, N):\n    a = int(sys.stdin.readline()) - 1\n    won[a].append(i)\n\n# Optimized height calculation\ndef height_optimized(v):\n    stack = [(v, 0)]  # (current node, state)\n    result = [0] * N  # Store computed heights\n    while stack:\n        node, state = stack.pop()\n        \n        if state == 0:  # First visit: push children onto the stack\n            stack.append((node, 1))  # Mark as visited\n            for child in won[node]:\n                stack.append((child, 0))\n        else:  # Second visit: compute height for this node\n            max_height = 0\n            heap = []\n            \n            for child in won[node]:\n                heappush(heap, -result[child])  # Use a max-heap (negative values)\n            \n            for rank, _ in enumerate(heap):\n                h = -heappop(heap)  # Extract the largest height\n                max_height = max(max_height, h + len(heap) + 1 + rank)\n            \n            result[node] = max_height\n    \n    return result[v]\n\n# Output the result\nprint(height_optimized(0))"}
{"problem_id":"p02595","slow_code_col":"N, D = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    if (a**2 + b**2) <= D**2:\n\n        count += 1\n\nprint(count)\n","reference_code_col":"N, D = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    if (a*a + b*b) <= D*D:\n\n        count += 1\n\nprint(count)\n","model_generated_potentially_faster_code_col":"import sys\n\n# Use sys.stdin for faster input reading\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse N and D\nN, D = int(data[0]), int(data[1])\nD_squared = D ** 2  # Precompute D^2 to avoid recalculating in the loop\n\n# Initialize count\ncount = 0\n\n# Process the remaining inputs in pairs (a, b)\nfor i in range(2, 2 * N + 2, 2):\n    a, b = int(data[i]), int(data[i + 1])\n    if a * a + b * b <= D_squared:  # Compare squared distances\n        count += 1\n\n# Output the result\nprint(count)"}
{"problem_id":"p03309","slow_code_col":"# ABC102C - Linear Approximation (ARC100C)\n\nfrom statistics import median\n\n\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    A = tuple(map(int, input().rstrip().split()))\n\n    A = tuple(j - i for i, j in enumerate(A, start=1))\n\n    b = median(A)\n\n    ans = sum(abs(a - b) for a in A)\n\n    print((int(ans)))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()","reference_code_col":"# ABC102C - Linear Approximation (ARC100C)\n\ndef main():\n\n    n = int(eval(input()))\n\n    A = tuple(map(int, input().rstrip().split()))\n\n    A = sorted(j - i for i, j in enumerate(A, start=1))\n\n    b = A[n \/\/ 2]\n\n    ans = sum(abs(a - b) for a in A)\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()","model_generated_potentially_faster_code_col":"def main():\n    import sys\n    input = sys.stdin.read  # Faster input reading for large datasets\n\n    # Read all input at once\n    lines = input().splitlines()\n    n = int(lines[0])\n    A = list(map(int, lines[1].split()))\n\n    # Transform A in-place to avoid creating a new tuple\n    for i in range(n):\n        A[i] -= (i + 1)\n\n    # Sort A to calculate the median manually\n    A.sort()\n    if n % 2 == 1:  # Odd length\n        b = A[n \/\/ 2]\n    else:  # Even length\n        b = (A[n \/\/ 2 - 1] + A[n \/\/ 2]) \/\/ 2\n\n    # Calculate the sum of absolute differences\n    ans = sum(abs(a - b) for a in A)\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p01105","slow_code_col":"a=65280; b=61680; c=52428; d=43690; e=65535\n\nL = {el: 1 for el in [a, b, c, d, e, 0]}\n\nfor i in range(6):\n\n    R = sorted(L.items(), key=lambda x: x[1])\n\n    for p, l in R:\n\n        if l < 16:\n\n            L[p ^ e] = min(L.get(p ^ e, 16), l+1)\n\n            if l+3 < 16:\n\n                for q, r in R:\n\n                    if l+r+3 <= 16:\n\n                        L[p & q] = min(L.get(p & q, 16), l+r+3)\n\n                        L[p ^ q] = min(L.get(p ^ q, 16), l+r+3)\n\n                    else: break\n\n        else: break\n\nprint(*(L[e & eval(s)] for s in open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]),sep='\\n')\n","reference_code_col":"a=65280; b=61680; c=52428; d=43690; e=65535\n\nfrom heapq import heappush, heappop\n\nbase = [a, b, c, d, e, 0]\n\nQ = [(1, el) for el in base]\n\nL = {el: 1 for el in base}\n\nH = []\n\nwhile Q:\n\n    l, p = heappop(Q)\n\n    if L[p] < l: continue\n\n    if l+1 < L.get(p ^ e, 17):\n\n        L[p^e] = l+1\n\n        if l+1 < 16: heappush(Q, (l+1, p^e))\n\n    if l+3 < 16:\n\n        for q, r in H:\n\n            if l+r+3 <= 16:\n\n                if l+r+3 < L.get(p & q, 17):\n\n                    L[p & q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p & q))\n\n                if l+r+3 < L.get(p ^ q, 17):\n\n                    L[p ^ q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p ^ q))\n\n            else: break\n\n    if l < 7: H.append((p, l))\n\nprint(*(L[e & eval(s)] for s in open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]),sep='\\n')\n","model_generated_potentially_faster_code_col":"from heapq import heappush, heappop\n\n# Constants\na, b, c, d, e = 65280, 61680, 52428, 43690, 65535\n\n# Initialize L as a heap (priority queue)\nL = {}\nfor el in [a, b, c, d, e, 0]:\n    L[el] = 1\n\n# Convert L to a heap\nheap = [(v, k) for k, v in L.items()]\nL = {k: v for v, k in heap}\n\n# Process updates\nfor _ in range(6):\n    # Use a heap to efficiently retrieve elements in ascending order of their values\n    heap = [(v, k) for k, v in L.items()]\n    while heap:\n        l, p = heappop(heap)\n\n        if l >= 16:\n            break\n\n        # Update L[p ^ e]\n        new_key = p ^ e\n        L[new_key] = min(L.get(new_key, 16), l + 1)\n\n        if l + 3 < 16:\n            # Iterate over remaining elements in the heap\n            for l2, q in heap:\n                if l + l2 + 3 > 16:\n                    break\n\n                # Update L[p & q] and L[p ^ q]\n                for op in (lambda x, y: x & y, lambda x, y: x ^ y):\n                    new_key = op(p, q)\n                    L[new_key] = min(L.get(new_key, 16), l + l2 + 3)\n\n# Input processing\ninput_lines = open(0).read().replace(\"-\", \"~\").replace(\"*\", \"&\").replace(\"1\", \"e\").split()[:-1]\nprint(*(L[e & int(s)] for s in input_lines), sep='\\n')"}
{"problem_id":"p02792","slow_code_col":"#python3\n\nfrom collections import defaultdict\n\nfrom collections import namedtuple\n\n\n\nP = namedtuple('P', ['front', 'end'])\n\n\n\ndef f(x):\n\n    return P(str(x)[0], str(x)[-1]) \n\n\n\ndef main():\n\n\n\n    n = int(eval(input()))\n\n    freq = defaultdict(int)\n\n\n\n    for i in range(1, n+1):\n\n        p = f(i)\n\n        freq[p]+=1\n\n\n\n\n\n    ans = 0\n\n    for i in range(1, n + 1):\n\n        p = f(i)\n\n        q = (p.end, p.front)\n\n        ans += freq[q]\n\n\n\n    print(ans)\n\n\n\nmain()","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom collections import defaultdict\n\n\n\ndef f(x):\n\n    return (int(str(x)[0]), int(str(x)[-1])) \n\ndef main():\n\n    N = int(readline())\n\n    df = defaultdict(int)\n\n    for i in range(1, N+1):\n\n        df[f(i)] += 1\n\n    ans = 0\n\n    for i in range(1, 10):\n\n        for j in range(1, 10):\n\n            ans +=  df[(i, j)]*df[(j, i)]\n\n    print(ans)\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"from collections import defaultdict\n\ndef main():\n    # Read input safely and efficiently\n    n = int(input())\n    \n    # Precompute front and end digits for all numbers from 1 to n\n    freq = defaultdict(int)\n    front_end_pairs = []\n    \n    for i in range(1, n + 1):\n        # Compute front and end digits without string conversion\n        x = i\n        while x >= 10:  # Extract the front digit\n            x \/\/= 10\n        front = x\n        end = i % 10  # Extract the last digit\n        \n        # Store the pair (front, end) as integers\n        pair = (front, end)\n        front_end_pairs.append(pair)\n        freq[pair] += 1\n    \n    # Calculate the result\n    ans = 0\n    for p in front_end_pairs:\n        q = (p[1], p[0])  # Swap front and end\n        ans += freq[q]\n    \n    print(ans)\n\nmain()"}
{"problem_id":"p03038","slow_code_col":"n, m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nbc = [list(map(int, input().split())) for _ in range(m)]\n\n\n\nbc.sort(key=lambda x: x[1], reverse=True)\n\na.sort()\n\n\n\ni = 0\n\nfor b, c in bc:\n\n    for _ in range(b):\n\n        if i < n and a[i] < c:\n\n            a[i] = c\n\n            i += 1\n\n        else:\n\n            break\n\n\n\nans = sum(a)\n\nprint(ans)\n","reference_code_col":"n, m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nbc = [list(map(int, input().split())) for _ in range(m)]\n\n\n\nbc.sort(reverse=True, key=lambda x: x[1])\n\n\n\nli = []\n\nl = 0\n\ni = 0\n\nwhile i < m and l < n:\n\n    b, c = bc[i]\n\n    li += [c] * b\n\n    i += 1\n\n    l += b\n\n\n\na += li\n\na.sort(reverse=True)\n\nans = sum(a[:n])\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"n, m = map(int, input().split())\na = list(map(int, input().split()))\nbc = [list(map(int, input().split())) for _ in range(m)]\n\n# Sort `a` in ascending order and `bc` in descending order of `c`\na.sort()\nbc.sort(key=lambda x: x[1], reverse=True)\n\n# Use a pointer to track the current position in `a`\ni = 0\n\n# Iterate through each `(b, c)` pair in `bc`\nfor b, c in bc:\n    # Replace up to `b` elements in `a` with `c`, if beneficial\n    while b > 0 and i < n and a[i] < c:\n        a[i] = c\n        i += 1\n        b -= 1\n    # If we've replaced all elements in `a`, break early\n    if i == n:\n        break\n\n# Compute the final sum of `a`\nans = sum(a)\nprint(ans)"}
{"problem_id":"p02837","slow_code_col":"import itertools\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nstl = []\n\nfor i in range(N):\n\n    a = int(eval(input()))\n\n    for _ in range(a):\n\n        x, y = list(map(int, input().split()))\n\n        stl.append((i, x-1, y))\n\ndl = np.array(list(itertools.product([0, 1], repeat=N)), np.bool)\n\nfor i, x, y in stl:\n\n    bl = (dl[:, i] == False) | (dl[:, x] == bool(y))\n\n    dl = dl[bl]\n\nres = dl.sum(axis=1).max()\n\nprint(res)\n","reference_code_col":"import sys\n\nimport itertools\n\nimport collections\n\n\n\n\n\ndef solve():\n\n    readline = sys.stdin.buffer.readline\n\n    mod = 10 ** 9 + 7\n\n    n = int(readline())\n\n    xy = []\n\n    for i in range(n):\n\n        a = int(readline())\n\n        for j in range(a):\n\n            x, y = list(map(int, readline().split()))\n\n            xy.append([i, x-1, y])\n\n    ls = collections.deque([v for v in itertools.product([True, False], repeat=n)])\n\n    for i, x, y in xy:\n\n        for j in range(len(ls)):\n\n            lsv = ls.pop()\n\n            if not lsv[i] or lsv[x] == bool(y):\n\n                ls.appendleft(lsv)\n\n    t = 0\n\n    for i in range(len(ls)):\n\n        t = max(t, ls[i].count(True))\n\n    print(t)\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN = int(input())\n\n# Store constraints efficiently in a NumPy array\nconstraints = []\nfor i in range(N):\n    a = int(input())\n    for _ in range(a):\n        x, y = map(int, input().split())\n        constraints.append((i, x - 1, y))\n\nconstraints = np.array(constraints, dtype=[('i', 'int'), ('x', 'int'), ('y', 'int')])\n\n# Initialize the truth table as a boolean array\ntruth_table = np.ones((1 << N, N), dtype=bool)\n\n# Apply constraints incrementally\nfor i, x, y in constraints:\n    # Filter rows where the constraint is satisfied\n    mask = (truth_table[:, i] == False) | (truth_table[:, x] == bool(y))\n    truth_table = truth_table[mask]\n\n# Find the maximum number of True values in any row\nres = truth_table.sum(axis=1).max()\n\nprint(res)"}
{"problem_id":"p02901","slow_code_col":"INF = 10**10\n\n\n\nN, M = list(map(int, input().split()))\n\ncosts = []\n\nkeys = []\n\nfor _ in range(M):\n\n    A, B = list(map(int, input().split()))\n\n    cs = list(map(int, input().split()))\n\n    costs.append(A)\n\n    # \u9375\u30922\u9032\u6570\u5316\u3059\u308b\n\n    key = 0\n\n    for c in cs:\n\n        key |= 1<<(c-1)\n\n    keys.append(key)\n\n\n\n# [1]\u306e\u500b\u6570\u3067\u5206\u985e\u3059\u308b\n\nmaskss = [[] for _ in range(N+1)]\n\nnum1s = [0] * (2**N)\n\nfor S in range(2**N):\n\n    num = bin(S).count('1')\n\n    maskss[num].append(S)\n\n    num1s[S] = num\n\n\n\ndpAll = [INF] * (2**N)\n\nfor S in range(2**N):\n\n    for cost, key in zip(costs, keys):\n\n        if S & key == S:\n\n            if cost < dpAll[S]:\n\n                dpAll[S] = cost\n\n\n\ndp = [INF] * (2**N)\n\nfor S in range(2**N):\n\n    cost = dpAll[S]\n\n    num1 = num1s[S]\n\n    for k in range(1, (num1+1)\/\/2+1):\n\n        for mask in maskss[k]:\n\n            if mask & S == mask:\n\n                m2 = S^mask\n\n                c2 = dp[mask] + dp[m2]\n\n                if c2 < cost:\n\n                    cost = c2\n\n    dp[S] = cost\n\n\n\nif dp[2**N-1] == INF:\n\n    print((-1))\n\nelse:\n\n    print((dp[2**N-1]))\n","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\ndef solve():\n\n    INF = 10**10\n\n\n\n    N, M = list(map(int, input().split()))\n\n    keys = []\n\n    costs = []\n\n    for _ in range(M):\n\n        a, b = list(map(int, input().split()))\n\n        costs.append(a)\n\n        cs = list(map(int, input().split()))\n\n        key = 0\n\n        for c in cs:\n\n            key |= 1<<(c-1)\n\n        keys.append(key)\n\n\n\n    dp = [INF] * (1<<N)\n\n    dp[0] = 0\n\n    for S in range(1<<N):\n\n        for key, cost in zip(keys, costs):\n\n            S2 = S | key\n\n            c2 = dp[S] + cost\n\n            if c2 < dp[S2]:\n\n                dp[S2] = c2\n\n\n\n    if dp[-1] == INF:\n\n        print((-1))\n\n    else:\n\n        print((dp[-1]))\n\n\n\n\n\nsolve()\n","model_generated_potentially_faster_code_col":"INF = 10**10\n\n# Input parsing\nN, M = map(int, input().split())\ncosts = []\nkeys = []\n\nfor _ in range(M):\n    A, B = map(int, input().split())\n    cs = list(map(int, input().split()))\n    costs.append(A)\n    \n    # Convert key to bitmask\n    key = 0\n    for c in cs:\n        key |= 1 << (c - 1)\n    keys.append(key)\n\n# Precompute the number of '1's in each mask\nnum1s = [bin(S).count('1') for S in range(2**N)]\n\n# Initialize DP array\ndp = [INF] * (2**N)\ndp[0] = 0  # Base case: no locks opened, cost is 0\n\n# Iterate over all subsets\nfor S in range(2**N):\n    if dp[S] == INF:\n        continue  # Skip unreachable states\n    \n    # Try adding each key to the current subset\n    for cost, key in zip(costs, keys):\n        new_S = S | key  # New subset after adding the key\n        dp[new_S] = min(dp[new_S], dp[S] + cost)\n\n# Output the result\nif dp[2**N - 1] == INF:\n    print(-1)\nelse:\n    print(dp[2**N - 1])"}
{"problem_id":"p01138","slow_code_col":"def f(s):\n\n    s=list(map(int,s.split(':')))\n\n    return (s[0]*60+s[1])*60+s[2]\n\na=86401\n\nwhile 1:\n\n    t=[0]*a\n\n    n=int(eval(input()))\n\n    if n==0:break\n\n    for _ in range(n):\n\n        b,c=input().split()\n\n        t[f(b)]+=1;t[f(c)]-=1\n\n    d=0\n\n    for i in range(1,a):\n\n        t[i]+=t[i-1]\n\n        d=max(d,t[i])\n\n    print(d)","reference_code_col":"def f(s):\n\n    return (s[0]*60+s[1])*60+s[2]\n\na=86400\n\nwhile 1:\n\n    t=[0]*a\n\n    n=int(eval(input()))\n\n    if n==0:break\n\n    for _ in range(n):\n\n        b,c = [list(map(int,x.split(':'))) for x in input().split()]\n\n        t[f(b)]+=1;t[f(c)]-=1\n\n    d=0\n\n    for i in range(1,a):\n\n        t[i]+=t[i-1]\n\n        if d<t[i]:d=t[i]\n\n    print(d)","model_generated_potentially_faster_code_col":"def preprocess_time_conversion():\n    # Precompute all possible time values in seconds for \"HH:MM:SS\"\n    time_to_seconds = {}\n    for h in range(24):\n        for m in range(60):\n            for s in range(60):\n                time_str = f\"{h:02}:{m:02}:{s:02}\"\n                time_to_seconds[time_str] = h * 3600 + m * 60 + s\n    return time_to_seconds\n\ndef main():\n    # Precompute time-to-seconds mapping\n    time_to_seconds = preprocess_time_conversion()\n    max_seconds = 86400  # Total seconds in a day\n    t = [0] * max_seconds  # Array to track cumulative events\n\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n\n        # Reset t efficiently\n        for i in range(max_seconds):\n            t[i] = 0\n\n        # Process intervals\n        for _ in range(n):\n            b, c = input().split()\n            t[time_to_seconds[b]] += 1\n            t[time_to_seconds[c]] -= 1\n\n        # Compute maximum cumulative value\n        d = 0\n        current = 0\n        for i in range(max_seconds):\n            current += t[i]\n            d = max(d, current)\n\n        print(d)\n\n# Run the main function\nmain()"}
{"problem_id":"p02982","slow_code_col":"import numpy\n\nN, D = list(map(int, input().split()))\n\nlistx = []\n\ncount = 0\n\nfor i in range(N):\n\n    x = list(map(int, input().split()))\n\n    listx.append(x)\n\n\n\nfor j in range(0, N):\n\n    for k in range(j+1,N):\n\n        a = numpy.array(listx[j])\n\n        b = numpy.array(listx[k])\n\n        u = b - a\n\n        c = float(numpy.linalg.norm(u))\n\n        if c.is_integer() :\n\n            count += 1\n\nprint(count)","reference_code_col":"def LI(): return list(map(int,input().split()))\n\nN,D = LI()\n\nX = [LI() for _ in range(N)]\n\nans = 0\n\nfor i in range(N):\n\n    for j in range(i+1,N):\n\n        temp = 0\n\n        for k in range(D):\n\n            temp += (X[j][k]-X[i][k])**2\n\n        if temp **0.5%1==0:\n\n            ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input reading\nN, D = map(int, input().split())\nlistx = [list(map(int, input().split())) for _ in range(N)]\n\n# Convert listx to a NumPy array for efficient computation\nlistx = np.array(listx)\n\ncount = 0\n\n# Iterate over all pairs of points\nfor j in range(N):\n    for k in range(j + 1, N):\n        # Compute squared distance between points j and k\n        squared_distance = np.sum((listx[j] - listx[k]) ** 2)\n        \n        # Check if the squared distance is a perfect square\n        if int(np.sqrt(squared_distance)) ** 2 == squared_distance:\n            count += 1\n\nprint(count)"}
{"problem_id":"p03457","slow_code_col":"import sys\n\ncan = True; eval(input())\n\ne = [[0, 0, 0]] + [list(map(int, e.split())) for e in sys.stdin]\n\nfor a, b in zip(e[1:], e):\n\n    t = a[0] - b[0] - abs(a[1] - b[1]) - abs(a[2] - b[2])\n\n    if t < 0 or t % 2 == 1: can = False; break\n\nprint((['No', 'Yes'][can]))","reference_code_col":"import sys\n\nans = 'Yes'; eval(input())\n\nfor e in sys.stdin:\n\n    t, x, y = list(map(int, e.split()))\n\n    t = t - x - y\n\n    if t < 0 or t % 2 == 1: ans = 'No'; break\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\n\n# Initialize variables\ncan = True\nprev_time, prev_x, prev_y = 0, 0, 0\n\n# Read input line by line\nfor line in sys.stdin:\n    # Parse the current event\n    curr_time, curr_x, curr_y = map(int, line.split())\n    \n    # Calculate the time difference and distance\n    time_diff = curr_time - prev_time\n    distance = abs(curr_x - prev_x) + abs(curr_y - prev_y)\n    \n    # Check if the time difference is valid\n    if time_diff < distance or (time_diff - distance) % 2 != 0:\n        can = False\n        break\n    \n    # Update previous event\n    prev_time, prev_x, prev_y = curr_time, curr_x, curr_y\n\n# Output the result\nprint(\"Yes\" if can else \"No\")"}
{"problem_id":"p02901","slow_code_col":"import sys\n\nreadline = sys.stdin.readline\n\n\n\nN,M = list(map(int,readline().split()))\n\nINF = 10 ** 10\n\ndp = [INF] * (2 ** N)\n\ndp[0] = 0\n\n\n\nfor i in range(M):\n\n  a,b = list(map(int,readline().split()))\n\n  c = list(map(int,readline().split()))\n\n  key = 0\n\n  for j in range(len(c)):\n\n    key += (1 << (c[j] - 1))\n\n  for j in range(len(dp)):\n\n    if dp[j] == INF:\n\n      continue\n\n    if j | key == j:\n\n      continue\n\n    dp[j | key] = min(dp[j | key], dp[j] + a)\n\n\n\nif dp[-1] == INF:\n\n  print((-1))\n\nelse:\n\n  print((dp[-1]))","reference_code_col":"import sys\n\nreadline = sys.stdin.readline\n\n\n\nN,M = list(map(int,readline().split()))\n\nINF = 10 ** 10\n\ndp = [INF] * (2 ** N)\n\ndp[0] = 0\n\n\n\nfor i in range(M):\n\n  a,b = list(map(int,readline().split()))\n\n  c = list(map(int,readline().split()))\n\n  key = 0\n\n  for j in range(len(c)):\n\n    key += (1 << (c[j] - 1))\n\n  for j in range(len(dp)):\n\n    if dp[j] == INF:\n\n      continue\n\n    if j | key == j:\n\n      continue\n\n    if dp[j | key] > dp[j] + a:\n\n      dp[j | key] = dp[j] + a\n\n\n\nif dp[-1] == INF:\n\n  print((-1))\n\nelse:\n\n  print((dp[-1]))","model_generated_potentially_faster_code_col":"import sys\n\n# Fast I\/O setup\nreadline = sys.stdin.readline\n\n# Read N and M\nN, M = map(int, readline().split())\n\n# Define constants\nINF = 10 ** 10\nMAX_STATES = 1 << N  # Total number of bitmask states\n\n# Initialize DP array\ndp = [INF] * MAX_STATES\ndp[0] = 0  # Base case: starting with no keys\n\n# Process each key\nfor _ in range(M):\n    # Read cost and number of keys\n    a, b = map(int, readline().split())\n    \n    # Read the list of keys and compute the bitmask\n    c = list(map(int, readline().split()))\n    key = 0\n    for num in c:\n        key |= (1 << (num - 1))  # Set bits corresponding to keys\n    \n    # Update DP using subset enumeration\n    # Iterate over all subsets of the current state\n    for j in range(MAX_STATES):\n        if dp[j] == INF:\n            continue  # Skip unreachable states\n        \n        new_state = j | key  # Combine current state with the key\n        dp[new_state] = min(dp[new_state], dp[j] + a)\n\n# Output the result\nif dp[-1] == INF:\n    print(-1)\nelse:\n    print(dp[-1])"}
{"problem_id":"p03747","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nN,L,T = list(map(int,input().split()))\n\nXW = [[int(x) for x in input().split()] for _ in range(N)]\n\n\n\nX,W = list(zip(*XW))\n\n\n\nDX = [1 if w == 1 else -1 for w in W]\n\n\n\nY = [(x+dx*T)%L for x,dx in zip(X,DX)]\n\ny0 = Y[0]\n\nY.sort()\n\n\n\n# \u756a\u53f71\u304c\u3059\u308c\u9055\u308f\u305a\u9032\u3093\u3060\u5834\u6240\u306b\u76f8\u5f53\u3059\u308b\u30a2\u30ea\u306e\u756a\u53f7\n\n# \u3059\u308c\u9055\u3046\u305f\u3073\u306b1\u5897\u3048\u308b\uff08W1=1\uff09 or 1\u6e1b\u308b\uff08W1=-1\uff09\n\n# T\u79d2\u3061\u3087\u3046\u3069\u3082\u3059\u308c\u9055\u3044\u7d42\u308f\u3063\u305f\u3068\u8003\u3048\u308b\n\n\n\nx = 0\n\nx0,dx0 = X[0],DX[0]\n\nfor y,dy in zip(X[1:],DX[1:]):\n\n    if dx0 == dy:\n\n        continue\n\n    if dx0 == 1 and dy == -1:\n\n        # \u6b63\u306e\u5411\u304d\u306b\u8ffd\u3044\u8d8a\u3059\u306e\u3067\u756a\u53f7\u304c\u3072\u3068\u3064\u5897\u3048\u308b\n\n        x += (2*T-(y-x0)-1)\/\/L + 1\n\n    if dx0 == -1 and dy == 1:\n\n        x -= (2*T-(L+x0-y))\/\/L + 1\n\nx %= N\n\n\n\ni = Y.index(y0)\n\n\n\nY += Y\n\n\n\nanswer = [None] * N\n\nanswer[x:N] = Y[i:i+N-x]\n\nanswer[0:x] = Y[i+N-x:i+N]\n\n\n\nprint(('\\n'.join(map(str,answer))))\n\n\n","reference_code_col":"import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n\"\"\"\n\n\u30fb\u9806\u5e8f\u304c\u56fa\u5b9a\u3055\u308c\u308b\u306e\u3067\u3001\u533a\u9593\u3060\u3063\u305f\u3089\u7c21\u5358\n\n\u30fb\u5186\u306e\u3068\u304d\u3082\u3001\u5730\u70b9 0 \u3092\u305d\u308c\u305e\u308c\u306e\u65b9\u5411\u306b\u901a\u3063\u305f\u4eba\u6570\u3092\u898b\u308c\u3070\u8a08\u7b97\u3067\u304d\u308b\n\n\"\"\"\n\n\n\nN, L, T = list(map(int, readline().split()))\n\nXW = np.array(read().split(), np.int64)\n\nX = XW[::2]\n\nW = XW[1::2]\n\n\n\nspeed = np.where(W == 1, 1, -1)\n\n\n\nY = X + speed * T\n\n\n\nn = (Y \/\/ L - X \/\/ L).sum()\n\nn %= N\n\n\n\nY %= L\n\nY.sort()\n\nY = np.concatenate((Y[n:], Y[:n]))\n\n\n\nprint(('\\n'.join(map(str, Y.tolist()))))","model_generated_potentially_faster_code_col":"import sys\nfrom bisect import bisect_left\n\n# Input reading\ninput = sys.stdin.readline\n\nN, L, T = map(int, input().split())\nXW = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Separate positions and directions\nX, W = zip(*XW)\nDX = [1 if w == 1 else -1 for w in W]\n\n# Calculate new positions after T seconds\nY = [(x + dx * T) % L for x, dx in zip(X, DX)]\n\n# Sort the new positions\nY.sort()\n\n# Find the index of the first ant's position using binary search\ny0 = Y[0]\ni = bisect_left(Y, y0)\n\n# Count the number of swaps due to collisions\nx = 0\nx0, dx0 = X[0], DX[0]\nfor y, dy in zip(X[1:], DX[1:]):\n    if dx0 == dy:\n        continue\n    if dx0 == 1 and dy == -1:\n        x += (2 * T - (y - x0) - 1) \/\/ L + 1\n    elif dx0 == -1 and dy == 1:\n        x -= (2 * T - (L + x0 - y)) \/\/ L + 1\n\nx %= N\n\n# Construct the final answer using modular indexing\nanswer = [Y[(i + j) % N] for j in range(N)]\n\n# Output the result\nprint('\\n'.join(map(str, answer)))"}
{"problem_id":"p02688","slow_code_col":"N, K = list(map(int, input().split()))\n\nsunuke = [True]*N\n\nfor i in range(K):\n\n    d = int(eval(input()))\n\n    A = list(map(int, input().split()))\n\n    for a in A:\n\n        sunuke[a-1] = False\n\n\n\nans = 0\n\nfor i in range(N):\n\n    if sunuke[i]:\n\n        ans += 1\n\nprint(ans)","reference_code_col":"N, K = list(map(int, input().split()))\n\nflag = [True]*N\n\nfor i in range(K):\n\n    d = int(eval(input()))\n\n    A = list(map(int, input().split()))\n\n    for a in A:\n\n        flag[a-1] = False\n\nans = 0\n\nfor i in range(N):\n\n    if flag[i]:\n\n        ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read N and K\nN, K = map(int, input().split())\n\n# Initialize sunuke as a set of indices that are still True\nsunuke = set(range(N))\n\n# Process K iterations\nfor _ in range(K):\n    # Read d (size of A)\n    d = int(input())\n    \n    # Read A and convert to a set of indices (adjust for 0-based indexing)\n    A = set(map(lambda x: int(x) - 1, input().split()))\n    \n    # Remove elements in A from sunuke\n    sunuke -= A\n\n# The size of sunuke is the count of remaining True values\nprint(len(sunuke))"}
{"problem_id":"p02937","slow_code_col":"import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    S = readline().strip()\n\n    T = readline().strip()\n\n\n\n    idx_in_S = []\n\n    last_idx = 0\n\n    for t in T:\n\n        t_idx = S.find(t, last_idx) + 1\n\n        if t_idx:\n\n            idx_in_S.append(t_idx)\n\n            last_idx = t_idx\n\n        else:\n\n            t_idx = S.find(t, 0, last_idx) + 1\n\n            if not t_idx:\n\n                print((-1))\n\n                exit()\n\n            else:\n\n                idx_in_S.append(t_idx)\n\n                last_idx = t_idx\n\n\n\n    \n\n    rep = 0\n\n    for i in range(len(T) - 1):\n\n        if idx_in_S[i] < idx_in_S[i+1]:\n\n            continue\n\n        else:\n\n            rep += 1\n\n\n\n    ans = len(S) * rep + idx_in_S[-1]\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"# S.find()\u306e\u90e8\u5206\u3092\u9ad8\u901f\u5316\u3059\u308b\n\nfrom collections import defaultdict\n\nfrom bisect import bisect_right\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    S = readline().strip()\n\n    T = readline().strip()\n\n\n\n    S_idx = defaultdict(list)\n\n    for i, s in enumerate(S):\n\n        S_idx[s].append(i)\n\n    \n\n    rep = 0\n\n    last_idx = -1\n\n    for t in T:\n\n        t_idx_list = S_idx[t]\n\n        if t_idx_list:\n\n            t_idx = bisect_right(t_idx_list, last_idx)\n\n            if t_idx < len(t_idx_list):\n\n                last_idx = t_idx_list[t_idx]\n\n            else:\n\n                last_idx = t_idx_list[0]\n\n                rep += 1\n\n        else:\n\n            print((-1))\n\n            exit()\n\n    \n\n    ans = len(S) * rep + last_idx + 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\nfrom bisect import bisect_left\n\ndef main():\n    # Read input strings\n    S = sys.stdin.readline().strip()\n    T = sys.stdin.readline().strip()\n\n    # Preprocess S: Create a dictionary of character indices\n    char_indices = {}\n    for idx, char in enumerate(S):\n        if char not in char_indices:\n            char_indices[char] = []\n        char_indices[char].append(idx)\n\n    # Initialize variables\n    last_idx = 0  # Current position in S\n    rep = 0       # Number of repetitions of S\n    idx_in_S = [] # List of indices in S corresponding to T\n\n    for t in T:\n        if t not in char_indices:\n            print(-1)\n            return\n\n        # Find the next valid index using binary search\n        indices = char_indices[t]\n        pos = bisect_left(indices, last_idx)\n\n        if pos < len(indices):\n            idx_in_S.append(indices[pos] + 1)  # Convert to 1-based index\n            last_idx = indices[pos] + 1       # Move to the next position\n        else:\n            # Wrap around to the beginning of S\n            rep += 1\n            idx_in_S.append(indices[0] + 1)  # Convert to 1-based index\n            last_idx = indices[0] + 1        # Reset to the first occurrence\n\n    # Calculate the final answer\n    ans = len(S) * rep + idx_in_S[-1]\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03796","slow_code_col":"import sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef resolve():\n\n    import math\n\n    n=int(eval(input()))\n\n    print((math.factorial(n)%(10**9+7)))\n\nresolve()","reference_code_col":"import sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef resolve():\n\n    answer=1\n\n    n=int(eval(input()))\n\n    for i in range(1,n+1):\n\n        answer*=i\n\n        answer%=10**9+7\n\n    print(answer)\n\nresolve()","model_generated_potentially_faster_code_col":"import sys\n\ndef input(): return sys.stdin.readline().strip()\n\nMOD = 10**9 + 7  # Define the modulus constant\n\ndef resolve():\n    n = int(input())  # Read input as integer\n    result = 1        # Initialize result\n    \n    # Compute factorial iteratively with modulo\n    for i in range(2, n + 1):\n        result = (result * i) % MOD\n    \n    print(result)\n\nresolve()"}
{"problem_id":"p03416","slow_code_col":"A,B = list(map(int,input().split()))\n\nj = 0\n\nfor i in range(A,B+1):\n\n  l = list(str(i))\n\n  l_reverse = list(reversed(l))\n\n  if l == l_reverse:\n\n    j += 1\n\nprint(j)","reference_code_col":"A, B = list(map(int,input().split()))\n\n\n\nans = 0\n\nfor n in range(A, B+1):\n\n    n = str(n)\n\n    if n == n[::-1]:\n\n        ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"A, B = map(int, input().split())\n\ncount = 0\n\nfor num in range(A, B + 1):\n    str_num = str(num)\n    if str_num == str_num[::-1]:  # Check if the string is a palindrome using slicing\n        count += 1\n\nprint(count)"}
{"problem_id":"p02390","slow_code_col":"s = int(eval(input()))\n\nm, s = s \/\/ 60, s % 60\n\nh, m = m \/\/ 60, m % 60\n\nprint((':'.join(map(str, [h,m,s]))))","reference_code_col":"s = int(eval(input()))\n\n\n\nsecond = s % 60\n\ns = s \/\/ 60\n\nmin = s % 60\n\nhour = s \/\/ 60\n\n\n\nprint(f'{hour}:{min}:{second}')\n","model_generated_potentially_faster_code_col":"# Read input and convert directly to an integer\ntotal_seconds = int(input())\n\n# Calculate hours, minutes, and seconds\nhours = total_seconds \/\/ 3600\nremaining_seconds = total_seconds % 3600\nminutes = remaining_seconds \/\/ 60\nseconds = remaining_seconds % 60\n\n# Format and print the result using f-strings for efficiency\nprint(f\"{hours}:{minutes}:{seconds}\")"}
{"problem_id":"p03796","slow_code_col":"import math\n\nN = int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))","reference_code_col":"import math\n\nN = int(eval(input()))\n\na = 1\n\nfor n in range(2,N+1):\n\n    a = a*n % (10**9+7)\n\nprint(a)","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\nN = int(input())\n\nfactorial = 1\nfor i in range(2, N + 1):\n    factorial = (factorial * i) % MOD\n\nprint(factorial)"}
{"problem_id":"p03162","slow_code_col":"import numpy as np\n\n\n\nn = int(eval(input()))\n\nX = np.array([input().split() for _ in range(n)], np.int64)\n\ndp = np.zeros((n + 1, 3), np.int64)\n\ndp[0, 0] = dp[0, 1] = dp[0, 2] = 0\n\nfor i in range(n):\n\n    for j in range(3):\n\n        dp[i + 1, j] = X[i, j] + max(dp[i, k] for k in range(3) if j != k)\n\nprint((max(dp[n])))","reference_code_col":"N = int(eval(input()))\n\nx, y, z = 0, 0, 0\n\nfor _ in range(N):\n\n    a, b, c = list(map(int, input().split()))\n\n    x, y, z = max(y, z) + a, max(z, x) + b, max(x, y) + c\n\nprint((max(x, y, z)))","model_generated_potentially_faster_code_col":"import numpy as np\nimport sys\n\n# Faster input reading\ndef fast_input():\n    return sys.stdin.read().split()\n\n# Read input\nn = int(fast_input()[0])\nX = np.array(list(map(int, fast_input())), dtype=np.int64).reshape(n, 3)\n\n# Initialize dp array\ndp = np.zeros((n + 1, 3), dtype=np.int64)\n\n# Iterate through rows of X\nfor i in range(n):\n    # Precompute max and second_max of dp[i, :]\n    max_val = np.max(dp[i, :])\n    max_idx = np.argmax(dp[i, :])\n    \n    # Second max is the max of the remaining two elements\n    second_max_val = np.max(dp[i, :][dp[i, :] != max_val])\n    \n    # Update dp[i + 1, :] using precomputed values\n    for j in range(3):\n        if j == max_idx:\n            dp[i + 1, j] = X[i, j] + second_max_val\n        else:\n            dp[i + 1, j] = X[i, j] + max_val\n\n# Output the result\nprint(np.max(dp[n]))"}
{"problem_id":"p03819","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n  n, m = map(int, input().split())\n\n  LR = [list(map(int, input().split())) for _ in range(n)]\n\n  \n\n  BIT = [0]*(m+2)\n\n  def add(i, a):\n\n    while i <= m+1:\n\n      BIT[i] += a\n\n      i += i&(-i)\n\n  def bit_sum(i):\n\n    res = 0\n\n    while i > 0:\n\n      res += BIT[i]\n\n      i -= i&(-i)\n\n    return res\n\n  \n\n  S = sorted([(r-l+1, l, r) for l, r in LR], reverse=True)\n\n  cnt = n\n\n  L = []\n\n  for i in range(1, m+1):\n\n    while S and S[-1][0] == i:\n\n      c, l, r = S.pop()\n\n      cnt -= 1\n\n      add(l, 1)\n\n      add(r+1, -1)\n\n    res = cnt\n\n    for j in range(0, m+1, i):\n\n      res += bit_sum(j)\n\n    L.append(res)\n\n  print(*L, sep=\"\\n\")\n\n\n\nif __name__ == \"__main__\":\n\n  main()\n","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n  n, m = list(map(int, input().split()))\n\n  S = [[] for _ in range(m+1)]\n\n  for _ in range(n):\n\n    l, r = list(map(int, input().split()))\n\n    S[r-l+1].append((l, r))\n\n  \n\n  BIT = [0]*(m+2)\n\n  def add(i, a):\n\n    while i <= m+1:\n\n      BIT[i] += a\n\n      i += i&(-i)\n\n  def bit_sum(i):\n\n    res = 0\n\n    while i > 0:\n\n      res += BIT[i]\n\n      i -= i&(-i)\n\n    return res\n\n  cnt = n\n\n  for i in range(1, m+1):\n\n    for l, r in S[i]:\n\n      cnt -= 1\n\n      add(l, 1)\n\n      add(r+1, -1)\n\n    res = cnt\n\n    for j in range(0, m+1, i):\n\n      res += bit_sum(j)\n\n    print(res)\n\n\n\nif __name__ == \"__main__\":\n\n  main()","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\ndef main():\n    n, m = map(int, input().split())\n    LR = [tuple(map(int, input().split())) for _ in range(n)]\n\n    # Group intervals by their length (r - l + 1)\n    length_to_intervals = [[] for _ in range(m + 2)]\n    for l, r in LR:\n        length = r - l + 1\n        if length <= m:\n            length_to_intervals[length].append((l, r))\n\n    # Initialize BIT\n    BIT = [0] * (m + 2)\n\n    def add(i, a):\n        while i <= m + 1:\n            BIT[i] += a\n            i += i & (-i)\n\n    def bit_sum(i):\n        res = 0\n        while i > 0:\n            res += BIT[i]\n            i -= i & (-i)\n        return res\n\n    cnt = n  # Total number of intervals not yet processed\n    L = []   # Results for each i\n\n    for i in range(1, m + 1):\n        # Add intervals of length i to the BIT\n        for l, r in length_to_intervals[i]:\n            cnt -= 1\n            add(l, 1)\n            add(r + 1, -1)\n\n        # Calculate the result for this i\n        res = cnt\n        j = 0\n        while j <= m:\n            res += bit_sum(j)\n            j += i\n\n        L.append(res)\n\n    print(*L, sep=\"\\n\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03078","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nx, y, z, k = map(int, sys.stdin.readline().split())\n\na, b, c = (np.array(sys.stdin.readline().split(), dtype=np.int64) for _ in range(3))\n\n\n\ndef main():\n\n    res = np.sort(np.ravel(a[:, None] + b))[::-1]\n\n    res = np.sort(np.ravel(c[:, None] + res[:min(k, x*y)]))[::-1]\n\n    return res[:k]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(*ans, sep='\\n')\n","reference_code_col":"import sys\n\n\n\nx, y, z, K = map(int, sys.stdin.readline().split())\n\na, b, c = (sorted(map(int, sys.stdin.readline().split()), reverse=True) for _ in range(3))\n\ndef main():\n\n    res = []\n\n    for i in range(1, min(K, x) + 1):\n\n        for j in range(1, min(K \/\/ i, y) + 1):\n\n            for k in range(1, min(K \/\/ (i * j), z) + 1):\n\n                res.append(a[i-1] + b[j-1] + c[k-1])\n\n\n\n    return sorted(res, reverse=True)[:K]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(*ans, sep='\\n')\n","model_generated_potentially_faster_code_col":"import sys\nimport heapq\n\n\ndef main():\n    # Read input\n    x, y, z, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n    c = list(map(int, sys.stdin.readline().split()))\n\n    # Function to compute top-k pairwise sums\n    def top_k_pairwise_sums(arr1, arr2, k):\n        heap = []\n        for val1 in arr1:\n            for val2 in arr2:\n                s = val1 + val2\n                if len(heap) < k:\n                    heapq.heappush(heap, s)\n                else:\n                    if s > heap[0]:\n                        heapq.heapreplace(heap, s)\n        return sorted(heap, reverse=True)\n\n    # Compute top-k values from a + b\n    ab_top_k = top_k_pairwise_sums(a, b, k)\n\n    # Compute top-k values from (a + b) + c\n    result = top_k_pairwise_sums(ab_top_k, c, k)\n\n    return result\n\n\nif __name__ == '__main__':\n    ans = main()\n    print(*ans, sep='\\n')"}
{"problem_id":"p03126","slow_code_col":"import functools\n\nprint((len(functools.reduce(lambda x, y: x&y,[set(input().split()[1:]) for _ in [0]*int(input().split()[0])]))))","reference_code_col":"print((len(set.intersection(*[set(input().split()[1:]) for _ in [0]*int(input().split()[0])]))))","model_generated_potentially_faster_code_col":"# Read the number of sets\nn = int(input().split()[0])\n\n# Initialize the intersection with the first set\nintersection = set(input().split()[1:])\n\n# Compute the intersection iteratively\nfor _ in range(n - 1):\n    intersection &= set(input().split()[1:])\n\n# Print the size of the final intersection\nprint(len(intersection))"}
{"problem_id":"p03371","slow_code_col":"# https:\/\/atcoder.jp\/contests\/abc095\/tasks\/arc096_a\n\n\"\"\"\n\n\u5225\u89e3(\u5b9a\u6570\u6642\u9593)\n\nhttps:\/\/atcoder.jp\/contests\/abc095\/submissions\/10226556\n\n\"\"\"\n\n\n\nA,B,C,X,Y = list(map(int,input().split()))\n\n\n\nans = float(\"inf\")\n\n\n\n# AB\u30d4\u30b6\u30922\u679a1\u7d44\u3067\u8003\u3048\u308b -> AB\u30bb\u30c3\u30c8\n\n# i: AB\u30bb\u30c3\u30c8\u306e\u500b\u6570\n\nfor i in range(10**5 + 1):\n\n    ans = min(ans, i*(2*C) + max(0, X-i)*A + max(0, Y-i)*B)\n\n\n\nprint(ans)","reference_code_col":"A,B,C,X,Y = list(map(int,input().split()))\n\n\n\nAB_set = C * 2\n\n\n\nans = min(A*X + B*Y, AB_set*max(X,Y), AB_set*min(X,Y) + A*abs(X-min(X,Y)) + B*abs(Y-min(X,Y)))\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Input\nA, B, C, X, Y = map(int, input().split())\n\n# Initialize answer with a large value\nans = float(\"inf\")\n\n# Maximum possible AB-pizzas needed\nmax_pizzas = max(X, Y)\n\n# Iterate over the reduced range\nfor i in range(max_pizzas + 1):\n    # Calculate the total cost\n    total_cost = i * (2 * C) + max(0, X - i) * A + max(0, Y - i) * B\n    # Update the minimum cost\n    ans = min(ans, total_cost)\n\n# Output the result\nprint(ans)"}
{"problem_id":"p02748","slow_code_col":"def mi():return list(map(int,input().split()))\n\nimport numpy as np\n\nA,B,M=mi()\n\na=np.array(list(mi()))\n\nb=np.array(list(mi()))\n\nminab=min(a)+min(b)\n\n\n\nans=float(\"inf\")\n\n\n\nfor i in range(M):\n\n    x,y,c=mi()\n\n    tmp=a[x-1]+b[y-1]-c\n\n    ans=min(ans,tmp)\n\nprint((min(ans,minab)))\n","reference_code_col":"def mi():return list(map(int,input().split()))\n\nA,B,M=mi()\n\na=list(mi())\n\nb=list(mi())\n\nans=min(a)+min(b)\n\nfor _ in range(M):\n\n    x,y,c=mi()\n\n    ans=min(ans,a[x-1]+b[y-1]-c)\n\nprint(ans)","model_generated_potentially_faster_code_col":"def mi(): return list(map(int, input().split()))\n\n# Read inputs efficiently\nA, B, M = mi()\na = mi()  # Directly read into a list\nb = mi()  # Directly read into a list\n\n# Precompute min(a) and min(b)\nmin_a = min(a)\nmin_b = min(b)\nmin_ab = min_a + min_b\n\n# Initialize ans with a large value\nans = float(\"inf\")\n\n# Process M queries\nfor _ in range(M):\n    x, y, c = mi()  # Read x, y, c directly\n    tmp = a[x - 1] + b[y - 1] - c\n    if tmp < ans:  # Update ans only if tmp is smaller\n        ans = tmp\n\n# Output the result\nprint(min(ans, min_ab))"}
{"problem_id":"p02994","slow_code_col":"import numpy as np\n\nn,l = list(map(int,input().split()))\n\ntaste = np.array([l+i-1 for i in range(1,n+1)])\n\ntaste[np.fabs(taste).argmin()]=0\n\nprint((taste.sum()))","reference_code_col":"n,l = list(map(int,input().split()))\n\ntaste = [l+i for i in range(0,n)]\n\ntaste.sort(key=lambda x:abs(x))\n\nprint((sum(taste[1:])))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn, l = map(int, input().split())\n\n# Directly create the NumPy array\ntaste = np.arange(l, l + n)\n\n# Find the index of the element closest to 0\nclosest_index = np.argmin(np.abs(taste))\n\n# Compute the sum without modifying the array\ntotal_sum = taste.sum() - taste[closest_index]\n\n# Print the result\nprint(total_sum)"}
{"problem_id":"p03325","slow_code_col":"N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\n\n\nSUM = 0\n\nfor i in A:\n\n    count = 0\n\n    while i%2 == 0:\n\n        i\/\/=2\n\n        count += 1\n\n    SUM+=count\n\nprint(SUM)","reference_code_col":"N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nSUM = 0\n\nfor i in A:\n\n    while i%2 == 0:\n\n        i\/\/=2\n\n        SUM += 1\n\nprint(SUM)","model_generated_potentially_faster_code_col":"N = int(input())  # No need for eval; just use int(input())\nA = list(map(int, input().split()))\n\nSUM = 0\n\nfor i in A:\n    count = 0\n    while i & 1 == 0:  # Check if the number is even using bitwise AND\n        i >>= 1        # Divide by 2 using bitwise right shift\n        count += 1\n    SUM += count\n\nprint(SUM)"}
{"problem_id":"p03796","slow_code_col":"n = int(eval(input()))\n\n\n\nINF = 10**9 + 7\n\n\n\nans = [0] * (10**5 + 1)\n\nans[0] = 1\n\n\n\nfor i in range(1,10**5 + 1):\n\n    ans[i] = ans[i-1] * i % INF\n\n\n\nprint((ans[n]))\n","reference_code_col":"n = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\nans = 1\n\n\n\nfor i in range(1,n+1):\n\n    ans = ans * i % mod\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"n = int(input())\n\nINF = 10**9 + 7\n\n# Compute factorial iteratively up to n\nfactorial = 1\nfor i in range(1, n + 1):\n    factorial = factorial * i % INF\n\nprint(factorial)"}
{"problem_id":"p03371","slow_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\nans = a * x + b * y\n\nm = max(x, y)\n\nfor i in range(1, m+1):\n\n  x -= 1\n\n  y -= 1\n\n  if x < 0:\n\n    x = 0\n\n  if y < 0:\n\n    y = 0\n\n  temp = c*(i*2) + x*a + y*b\n\n  if temp < ans:\n\n    ans = temp\n\n\n\nprint(ans)\n","reference_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\nans = a * x + b * y\n\nans = min(c * max(x, y) * 2, ans)\n\nif x < y:\n\n    ans = min(c * x * 2 + (y - x) * b, ans)\n\nelse:\n\n    ans = min(c * y * 2 + (x - y) * a, ans)\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Input parsing\na, b, c, x, y = map(int, input().split())\n\n# Initial cost calculation\nans = a * x + b * y\n\n# Calculate the maximum possible steps\nm = max(x, y)\n\n# Iterate only up to the point where both x and y are reduced to 0\nfor i in range(1, m + 1):\n    # Reduce x and y\n    x_new = max(x - i, 0)\n    y_new = max(y - i, 0)\n    \n    # Calculate the new cost\n    temp = c * (i * 2) + x_new * a + y_new * b\n    \n    # Update the minimum cost\n    if temp < ans:\n        ans = temp\n    \n    # Early termination if both x and y are already 0\n    if x_new == 0 and y_new == 0:\n        break\n\n# Output the result\nprint(ans)"}
{"problem_id":"p02881","slow_code_col":"import numpy as np\n\nN=int(eval(input()))\n\nroot=int(np.sqrt(N)\/\/1)\n\na=N\n\nb=N\n\nfor i in range(root, 0, -1):\n\n    if N%i==0:\n\n        a=i\n\n        b=N\/\/i\n\n        break\n\nprint((a-1+b-1))","reference_code_col":"N=int(eval(input()))\n\nroot=int((N**0.5)\/\/1)\n\na=N\n\nb=N\n\nfor i in range(root, 0, -1):\n\n    if N%i==0:\n\n        a=i\n\n        b=N\/\/i\n\n        break\n\nprint((a-1+b-1))\n","model_generated_potentially_faster_code_col":"import math\n\n# Read input\nN = int(input())\n\n# Compute the integer square root of N\nroot = int(math.sqrt(N))\n\n# Initialize variables\na = N\nb = 1\n\n# Find the largest divisor <= sqrt(N)\nfor i in range(root, 0, -1):\n    if N % i == 0:\n        a = i\n        b = N \/\/ i\n        break\n\n# Calculate and print the result\nprint(a - 1 + b - 1)"}
{"problem_id":"p02952","slow_code_col":"n_str = eval(input())\n\nn_int = int(n_str)\n\n# 1 ~ 50000\n\n# \u6841\u6570\u304c\u5947\u6570= 1\u6841, 3\u6841, 5\u6841\n\n# 1 ~ 9, 100 ~ 999,10000 ~ 99999\u306e90909\u500b\u3057\u304b\u306a\u3044\u306e\u3067\u5168\u63a2\u7d22\u3044\u3051\u308b\u304b?\n\nexs_list = []\n\nfor i in range(1, 100000):\n\n    if len(str(i)) % 2 == 1:\n\n        exs_list.append(i)\n\n\n\nexs = {i: i for i in exs_list}\n\n\n\nn_s = []\n\nans = 0\n\nfor i in range(1, n_int + 1):\n\n    if len(str(i)) % 2 == 0:\n\n        continue\n\n    if i in exs:\n\n        ans += 1\n\n\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n","reference_code_col":"def digit_sum(n):\n\n    # \u5404\u6841\u306e\u548c\u3092\u6c42\u3081\u308b\n\n    # \u8a08\u7b97\u91cf: O(logN)\n\n    ans = 0\n\n    while n > 0:\n\n        ans += 1\n\n        n \/\/= 10\n\n    return ans\n\n\n\nn = int(eval(input()))\n\ncnt = 0\n\n\n\nfor i in range(1, n+1):\n\n    cnt += digit_sum(i) % 2\n\n\n\nprint(cnt)\n","model_generated_potentially_faster_code_col":"# Read input as an integer\nn_int = int(input())\n\n# Precompute all numbers with odd lengths (1-9, 100-999, 10000-99999)\nodd_length_numbers = (\n    list(range(1, 10)) +        # 1-digit numbers\n    list(range(100, 1000)) +    # 3-digit numbers\n    list(range(10000, 100000))  # 5-digit numbers\n)\n\n# Count how many of these numbers are <= n_int\nans = sum(1 for num in odd_length_numbers if num <= n_int)\n\n# Output the result\nprint(ans)"}
{"problem_id":"p03162","slow_code_col":"# coding: utf-8\n\n\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef f(n, abc):\n\n    dp = [[0] * 3 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n\n        for j in range(3):\n\n            dp[i][j] = max(dp[i - 1][k] + abc[i - 1][j] \\\n\n                for k in range(3) if k != j)\n\n    return(max(dp[n]))\n\n\n\nn = int(eval(input()))    # 1 <= n <= 10^5\n\nabc = [list(map(int, input().rstrip().split())) for _ in range(n)]\n\n\n\nprint((f(n, abc)))\n","reference_code_col":"# coding: utf-8\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef f(n, abc):\n\n    dp = [0] * 3\n\n    for i in range(1, n + 1):\n\n        a, b, c = abc[i - 1]\n\n        dp = [ max(dp[1] + a, dp[2] + a), \\\n\n               max(dp[0] + b, dp[2] + b), \\\n\n               max(dp[0] + c, dp[1] + c) ]\n\n    return(max(dp))\n\n\n\nn = int(eval(input()))    # 1 <= n <= 10^5\n\nabc = [list(map(int, input().rstrip().split())) for _ in range(n)]\n\n\n\nprint((f(n, abc)))\n","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\ndef f(n, abc):\n    # Initialize dp array with two rows (current and previous)\n    prev_dp = [0] * 3\n    curr_dp = [0] * 3\n\n    for i in range(n):\n        # Compute the two largest values from the previous row\n        max1 = max(prev_dp)  # Largest value\n        idx1 = prev_dp.index(max1)  # Index of the largest value\n        max2 = max(prev_dp[:idx1] + prev_dp[idx1 + 1:])  # Second largest value\n\n        # Update the current dp row\n        for j in range(3):\n            if j == idx1:\n                curr_dp[j] = max2 + abc[i][j]\n            else:\n                curr_dp[j] = max1 + abc[i][j]\n\n        # Swap current and previous dp rows\n        prev_dp, curr_dp = curr_dp, prev_dp\n\n    return max(prev_dp)\n\n# Input reading\nn = int(input())  # 1 <= n <= 10^5\nabc = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(f(n, abc))"}
{"problem_id":"p03162","slow_code_col":"N = int(eval(input()))\n\nABC = []\n\n\n\nfor n in range(N):\n\n  ABC.append(list(map(int, input().split())))\n\n\n\nimport numpy as np\n\nABC = np.array(ABC)\n\n\n\n## \u300c\u65e5\u4ed8\u300d\u3001\u300c\u9078\u629e\u3057\u305f\u884c\u52d5\u300d\u3054\u3068\u306e\u5e78\u798f\u5ea6\u306e\u6700\u5927\u5024\u3092\u683c\u7d0d\u3059\u308barray\n\nhp=np.zeros((N,3),dtype=int)\n\nhp[0] = ABC[0]\n\n\n\nfor n in range(1,N):# \u65e5\u5358\u4f4d\u3067\u306e\u30eb\u30fc\u30d7\n\n  for c in range(3): # \u9078\u629e\u80a2\u3054\u3068\u306e\u30eb\u30fc\u30d7\n\n    ## n\u65e5\u306bc\u3092\u9078\u629e\u3057\u305f\u5834\u5408\u306e\u5e78\u798f\u5ea6\u3002\u3064\u307e\u308a\u524d\u65e5\u306fc\u4ee5\u5916\u3092\u9078\u629e\u3057\u3066\u3044\u308b\n\n    if c == 0:\n\n      hp[n][0] = max(hp[n-1][1],hp[n-1][2]) + ABC[n][0]\n\n    elif c == 1:\n\n      hp[n][1] = max(hp[n-1][0],hp[n-1][2]) + ABC[n][1]\n\n    elif c == 2:\n\n      hp[n][2] = max(hp[n-1][0],hp[n-1][1]) + ABC[n][2]\n\n\n\n\n\nans = max(hp[-1])\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\n\n\ndpa,dpb,dpc = 0,0,0\n\nfor n in range(N):\n\n  a,b,c = list(map(int, input().split()))  \n\n  dpa,dpb,dpc = max(dpb+a,dpc+a),max(dpa+b,dpc+b),max(dpa+c,dpb+c)\n\n  \n\nans = max(dpa,dpb,dpc)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input parsing\nN = int(input())\nABC = np.array([list(map(int, input().split())) for _ in range(N)])\n\n# Dynamic programming array\nhp = np.zeros((N, 3), dtype=int)\nhp[0] = ABC[0]\n\n# Fill the dp array\nfor n in range(1, N):\n    # Compute the maximum happiness for each choice without explicit loops\n    hp[n] = ABC[n] + np.maximum.reduceat(hp[n-1], [[1, 2], [0, 2], [0, 1]])\n\n# The answer is the maximum value in the last row\nans = np.max(hp[-1])\nprint(ans)"}
{"problem_id":"p02595","slow_code_col":"N, D = list(map(int, input().split()))\n\npoint = []\n\nfor i in range(N):\n\n    point.append(list(map(int, input().split())))\n\n\n\nct = 0\n\nD2 = D * D\n\nfor i in point:\n\n    if (i[0]**2 + i[1]**2) <= D2:\n\n        ct += 1\n\n\n\nprint(ct)","reference_code_col":"N, D = list(map(int, input().split()))\n\n\n\nct = 0\n\nD2 = D * D\n\nfor i in range(N):\n\n    X, Y = list(map(int, input().split()))\n\n    if (X**2 + Y**2) <= D2:\n\n        ct += 1\n\n\n\nprint(ct)","model_generated_potentially_faster_code_col":"# Read N and D\nN, D = map(int, input().split())\n\n# Precompute D squared\nD2 = D * D\n\n# Initialize counter\nct = 0\n\n# Process each point directly without storing in a list\nfor _ in range(N):\n    x, y = map(int, input().split())\n    if x * x + y * y <= D2:\n        ct += 1\n\n# Print the result\nprint(ct)"}
{"problem_id":"p02767","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tN = II()\n\n\tX = LI()\n\n\tX = np.array(X, dtype=\"int32\")\n\n\tm = round(np.sum(X) \/ N)\n\n\tprint(int(np.sum((X-m)**2)))\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n","reference_code_col":"import sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tN = II()\n\n\tX = LI()\n\n\tX = np.array(X)\n\n\tm = round(np.sum(X) \/ N)\n\n\tprint(int(np.sum((X-m)**2)))\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Read input\n    N = int(sys.stdin.readline())\n    X = list(map(int, sys.stdin.readline().split()))\n    \n    # Compute the sum of X\n    total_sum = sum(X)\n    \n    # Compute the mean as an integer (no rounding needed)\n    m = total_sum \/\/ N + (total_sum % N > N \/\/ 2)\n    \n    # Compute the sum of squared differences efficiently\n    result = sum((x - m) ** 2 for x in X)\n    \n    # Output the result\n    print(result)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03162","slow_code_col":"N = int(eval(input()))\n\na = [list(map(int,input().split())) for _ in range(N)]\n\n\n\ndp = [[0]*3 for _ in range(100010)] \n\n# dp[i][j] : i\u65e5\u76ee\u306bj\u756a\u76ee\u306e\u6d3b\u52d5\u3092\u3057\u305f\u3068\u304d\u306e\u5e78\u798f\u5ea6\u306e\u7dcf\u548c\n\nidx = [[1,2],[2,0],[0,1]]\n\n\n\nfor i in range(3):\n\n    dp[0][i] = a[0][i]\n\n    \n\nfor i in range(1,N):\n\n    for j in range(3):\n\n        dp[i][j] = max(dp[i-1][idx[j][0]],dp[i-1][idx[j][1]])+a[i][j]\n\n    \n\nprint((max(dp[N-1])))","reference_code_col":"import sys\n\ndef input():\n\n    return sys.stdin.readline()[:-1]\n\n\n\nN = int(eval(input()))\n\nABC = [list(map(int,input().split())) for _ in range(N)]\n\n\n\ninf = 10**9+7\n\ndp = [[0] * 3 for _ in range(N+10)]\n\ndp[0] = [ABC[0][0],ABC[0][1],ABC[0][2]]\n\n\n\nfor i in range(N-1):\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j==k:continue\n\n            dp[i+1][j] = max(dp[i+1][j],dp[i][k]+ABC[i+1][j])\n\n        \n\n    \n\n\n\nprint((max(dp[N-1][:])))\n","model_generated_potentially_faster_code_col":"# Read input\nN = int(input())\na = [list(map(int, input().split())) for _ in range(N)]\n\n# Initialize two rows for DP (current and previous)\nprev_dp = [0] * 3\ncurr_dp = [0] * 3\n\n# Base case: initialize the first day's happiness values\nfor j in range(3):\n    prev_dp[j] = a[0][j]\n\n# Iterate over days\nfor i in range(1, N):\n    for j in range(3):\n        # Compute the current day's happiness based on the previous day's values\n        if j == 0:\n            curr_dp[j] = max(prev_dp[1], prev_dp[2]) + a[i][j]\n        elif j == 1:\n            curr_dp[j] = max(prev_dp[0], prev_dp[2]) + a[i][j]\n        else:  # j == 2\n            curr_dp[j] = max(prev_dp[0], prev_dp[1]) + a[i][j]\n    \n    # Swap current and previous rows for the next iteration\n    prev_dp, curr_dp = curr_dp, prev_dp\n\n# Output the maximum happiness on the last day\nprint(max(prev_dp))"}
{"problem_id":"p02850","slow_code_col":"n=int(eval(input()))\n\nnode={i:[] for i in range(1,n+1)}\n\nvisited=[False for i in range(n+1)]\n\nq=[]\n\nfor _ in range(n-1):\n\n    a,b=list(map(int,input().split()))\n\n    node[a].append(b)\n\n    node[b].append(a)\n\n    q.append((a,b))\n\n\n\nmother=q[0][0]\n\nvisited[mother]=True\n\n\n\nd=[]\n\ne=[]\n\n\n\n\n\npaint={i:{} for i in range(1,n+1)}\n\n\n\nmother_paint=[0 for i in range(n+1)]\n\n\n\n#\u4f7f\u3046\u8981\u7d20 node visited paint mother_paint \u306e\u56db\u3064\u306e\u30ea\u30b9\u30c8\n\nc=1\n\nfor child in node[mother]:\n\n    visited[child]=True\n\n    paint[mother][child]=c\n\n    paint[child][mother]=c\n\n    mother_paint[child]=c\n\n    c+=1\n\n    d.append(child)\n\n    \n\nwhile d:\n\n    for parent in d:\n\n        p=1 \n\n        for child in node[parent]:\n\n            if visited[child]==False:\n\n                visited[child]=True\n\n                if p!=mother_paint[parent]:\n\n                    paint[parent][child]=p\n\n                    paint[child][parent]=p\n\n                    mother_paint[child]=p\n\n                    p+=1\n\n                    e.append(child)\n\n                else:\n\n                    p+=1\n\n                    paint[parent][child]=p\n\n                    paint[child][parent]=p\n\n                    mother_paint[child]=p\n\n                    p+=1\n\n                    e.append(child)\n\n    if e:\n\n        d=e\n\n        e=[]\n\n    else:\n\n        d=[]\n\n        e=[]\n\nK=0\n\nfor i in range(1,n+1):\n\n    K=max(K,len(node[i]))\n\nprint(K)\n\nfor i in range(n-1):\n\n    s,t=q[i][0],q[i][1]\n\n    print((paint[s][t]))","reference_code_col":"#problem1\n\nfrom collections import deque\n\nd=deque()\n\ne=deque()\n\n\n\nN=int(eval(input()))\n\ngraph=[[] for i in range(N+1)]\n\nD=[]\n\nfor _ in range(N-1):\n\n    a,b=list(map(int,input().split()))\n\n    graph[a].append(b)\n\n    graph[b].append(a)\n\n    D.append((a,b))\n\n    \n\n#\u9802\u70b91\u304b\u3089\u30b9\u30bf\u30fc\u30c8\n\nK=0\n\nd.append(1)\n\nvisited=[False for i in range(N+1)]\n\ncolor=[-1 for i in range(N+1)]\n\nvisited[1]=True\n\ncolor[1]=-1\n\ndic={}\n\nwhile d:\n\n    while d:\n\n        x=d.popleft()\n\n        par_color=color[x]\n\n        c=1\n\n        for node in graph[x]:\n\n            if visited[node]==False:\n\n                visited[node]=True\n\n                e.append(node)                \n\n                if c!=par_color:\n\n                    color[node]=c\n\n                    dic[(x,node)]=c\n\n                elif c==par_color:\n\n                    c+=1\n\n                    color[node]=c\n\n                    dic[(x,node)]=c\n\n                c+=1\n\n    if e:\n\n        d=e\n\n        e=deque()\n\n\n\nA=max(color)\n\nprint(A)\n\nfor que in D:\n\n    a,b=que\n\n    if (a,b) in list(dic.keys()):\n\n        print((dic[que]))\n\n    else:\n\n        print((dic[(b,a)]))\n\n    ","model_generated_potentially_faster_code_col":"from collections import deque\n\n# Input parsing\nn = int(input())\nnode = [[] for _ in range(n + 1)]  # Adjacency list\nedges = []  # To store input edges for later output\n\n# Read edges and build the graph\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    node[a].append(b)\n    node[b].append(a)\n    edges.append((a, b))\n\n# Initialize data structures\nvisited = [False] * (n + 1)\npaint = [[0] * (n + 1) for _ in range(n + 1)]  # 2D list for edge colors\nmother_paint = [0] * (n + 1)\n\n# Start BFS from an arbitrary node (root)\nroot = edges[0][0]\nqueue = deque([root])\nvisited[root] = True\n\n# Perform BFS and assign colors\nwhile queue:\n    parent = queue.popleft()\n    color = 1  # Start with color 1 for each node's edges\n\n    for child in node[parent]:\n        if not visited[child]:\n            visited[child] = True\n            # Assign a color different from the parent's incoming color\n            if color == mother_paint[parent]:\n                color += 1\n            paint[parent][child] = paint[child][parent] = color\n            mother_paint[child] = color\n            color += 1\n            queue.append(child)\n\n# Compute the maximum degree (K)\nK = max(len(neighbors) for neighbors in node[1:])\n\n# Output results\nprint(K)\nfor a, b in edges:\n    print(paint[a][b])"}
{"problem_id":"p03796","slow_code_col":"from math import factorial\n\n\n\nmod = 10**9 + 7\n\nn = int(eval(input()))\n\n\n\nans = factorial(n) % mod\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nMOD = 10**9 + 7\n\nans = 1\n\nfor i in range(2, N+1):\n\n    ans *= i\n\n    ans %= MOD\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"mod = 10**9 + 7\n\n# Read input directly as an integer\nn = int(input())\n\n# Compute factorial with modular arithmetic\nans = 1\nfor i in range(1, n + 1):\n    ans = (ans * i) % mod\n\nprint(ans)"}
{"problem_id":"p02555","slow_code_col":"# import sys\n\n# sys.setrecursionlimit(10 ** 6)\n\n# import bisect\n\n# from collections import deque\n\n\n\ndef cmb(n, r):\n\n    \"\"\"\u7d44\u307f\u5408\u308f\u305b\"\"\"\n\n    import math\n\n    if n < r:\n\n        return 0\n\n    return math.factorial(n) \/\/ (math.factorial(n - r) * math.factorial(r))\n\n\n\n\n\n# from decorator import stop_watch\n\n#\n\n#\n\n# @stop_watch\n\ndef solve(S):\n\n    mod = 10 ** 9 + 7\n\n    ans = 0\n\n    for i in range(1, S \/\/ 3 + 1):\n\n        tama = i + (S - (i * 3))\n\n        tama -= 2\n\n        bo = i - 1\n\n        ans += cmb(tama + 1, bo)\n\n        ans %= mod\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    # S = input()\n\n    S = int(eval(input()))\n\n    # N, M = map(int, input().split())\n\n    # Ai = [int(i) for i in input().split()]\n\n    # Bi = [int(i) for i in input().split()]\n\n    # ABi = [[int(i) for i in input().split()] for _ in range(N)]\n\n    solve(S)\n\n\n\n    # # test\n\n    # from random import randint\n\n    # from func import random_str\n\n    # solve()\n","reference_code_col":"# \u89e3\u8aac\u3092\u53c2\u8003\u306b\u4f5c\u6210\n\n# import sys\n\n# sys.setrecursionlimit(10 ** 6)\n\n# import bisect\n\n# from collections import deque\n\n# from decorator import stop_watch\n\n#\n\n#\n\n# @stop_watch\n\ndef solve(S):\n\n    mod = 10 ** 9 + 7\n\n    dp = [0] * (S + 1)\n\n    dp[0] = 1\n\n    for i in range(3, S + 1):\n\n        dp[i] = dp[i - 1] + dp[i - 3]\n\n        dp[i] %= mod\n\n    print((dp[S]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    S = int(eval(input()))\n\n    solve(S)\n\n\n\n    # # test\n\n    # from random import randint\n\n    # from func import random_str\n\n    # solve()\n","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\ndef precompute_factorials(max_n, mod):\n    \"\"\"Precompute factorials and modular inverses up to max_n.\"\"\"\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n    \n    # Compute factorials\n    for i in range(2, max_n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    \n    # Compute modular inverses of factorials\n    inv_fact[max_n] = pow(fact[max_n], mod - 2, mod)\n    for i in range(max_n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n    \n    return fact, inv_fact\n\ndef cmb_precomputed(n, r, fact, inv_fact, mod):\n    \"\"\"Compute nCr using precomputed factorials and inverses.\"\"\"\n    if n < r or r < 0:\n        return 0\n    return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n\ndef solve(S):\n    mod = MOD\n    max_n = S + 1  # Maximum value for n in combinations\n    fact, inv_fact = precompute_factorials(max_n, mod)\n    \n    ans = 0\n    for i in range(1, S \/\/ 3 + 1):\n        tama = S - (i * 3) + i - 2\n        bo = i - 1\n        ans += cmb_precomputed(tama + 1, bo, fact, inv_fact, mod)\n        ans %= mod\n    \n    print(ans)\n\nif __name__ == '__main__':\n    S = int(input())\n    solve(S)"}
{"problem_id":"p03078","slow_code_col":"import heapq\n\n\n\nx, y, z, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\n\n\ndef diff(l):\n\n    m = max(l)\n\n    return sorted(m - v for v in l)[1:]\n\n\n\ns = sum(map(max, [a, b, c]))\n\nsa, sb, sc = list(map(diff, [a, b, c]))\n\nda, db, dc = [0], [0], [0]\n\nq = [0]\n\nwhile k > 0:\n\n    while True:\n\n        if len(sa) > 0 and (len(q) == 0 or q[0] > sa[0]):\n\n            for v in [sa[0] + bb + cc for bb in db for cc in dc]:\n\n                heapq.heappush(q, v)\n\n            da.append(sa[0])\n\n            sa = sa[1:]\n\n        elif len(sb) > 0 and (len(q) == 0 or q[0] > sb[0]):\n\n            for v in [sb[0] + aa + cc for aa in da for cc in dc]:\n\n                heapq.heappush(q, v)\n\n            db.append(sb[0])\n\n            sb = sb[1:]\n\n        elif len(sc) > 0 and (len(q) == 0 or q[0] > sc[0]):\n\n            for v in [sc[0] + aa + bb for aa in da for bb in db]:\n\n                heapq.heappush(q, v)\n\n            dc.append(sc[0])\n\n            sc = sc[1:]\n\n        else:\n\n            break\n\n    v = heapq.heappop(q)\n\n    print(s - v)\n\n    k -= 1\n","reference_code_col":"import heapq\n\n\n\nx, y, z, k = list(map(int, input().split()))\n\na = sorted(map(int, input().split()))\n\nb = sorted(map(int, input().split()))\n\nc = sorted(map(int, input().split()))\n\n\n\nq = []\n\nmemo = set()\n\ndef qpush(q, ai, bi, ci):\n\n    t = (-(a[ai] + b[bi] + c[ci]), ai, bi, ci)\n\n    if not t in memo:\n\n        memo.add(t)\n\n        heapq.heappush(q, t)\n\n\n\nqpush(q, len(a) - 1, len(b) - 1, len(c) - 1)\n\nfor _ in range(k):\n\n    s, ai, bi, ci = heapq.heappop(q)\n\n    if ai > 0:\n\n        qpush(q, ai - 1, bi, ci)\n\n    if bi > 0:\n\n        qpush(q, ai, bi - 1, ci)\n\n    if ci > 0:\n\n        qpush(q, ai, bi, ci - 1)\n\n    print(-s)\n","model_generated_potentially_faster_code_col":"def diff(l):\n    m = max(l)\n    # Find the second smallest value without sorting\n    first_min = float('inf')\n    second_min = float('inf')\n    for v in l:\n        if m - v < first_min:\n            second_min = first_min\n            first_min = m - v\n        elif m - v < second_min:\n            second_min = m - v\n    return [second_min] + [m - v for v in l if m - v > second_min]"}
{"problem_id":"p02837","slow_code_col":"N = int(eval(input()))\n\nA = [0]*N\n\nX = []\n\nY = []\n\nfor i in range(N):\n\n    A[i] = int(eval(input()))\n\n    X.append([])\n\n    Y.append([])\n\n    for j in range(A[i]):\n\n        x, y = list(map(int, input().split()))\n\n        X[i].append(x-1)\n\n        Y[i].append(y)\n\nans = 0\n\nfor bit in range(1<<N):\n\n    honest = 0\n\n    ok = True\n\n    for i in range(N):\n\n        if bit&(1<<i):\n\n            honest += 1\n\n            for j in range(A[i]):\n\n                if Y[i][j] == 0:\n\n                    if bit&(1<<X[i][j]):\n\n                        ok = False\n\n                        break\n\n                else:\n\n                    if not bit&(1<<X[i][j]):\n\n                        ok = False\n\n                        break\n\n            if not ok:\n\n                break\n\n    if ok:\n\n        ans = max(ans, honest)\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nXY = [[] for _ in range(N)]\n\nfor i in range(N):\n\n    A = int(eval(input()))\n\n    for _ in range(A):\n\n        x, y = list(map(int, input().split()))\n\n        XY[i].append((x-1,y))\n\nans = 0\n\nfor bit in range(1<<N):\n\n    cnt = bin(bit).count('1')\n\n    ok = True\n\n    for i in range(N):\n\n        if bit&(1<<i):\n\n            for x,y in XY[i]:\n\n                if y == 1:\n\n                    if not bit&(1<<x):\n\n                        ok = False\n\n                        break\n\n                else:\n\n                    if bit&(1<<x):\n\n                        ok = False\n\n                        break\n\n            if not ok:\n\n                break\n\n    if ok:\n\n        ans = max(ans, cnt)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\ninput = sys.stdin.read\n\n# Read all input at once\ndata = input().splitlines()\n\n# Parse N\nN = int(data[0])\n\n# Initialize A, X, Y\nA = [0] * N\nX = [[] for _ in range(N)]\nY = [[] for _ in range(N)]\n\n# Parse A, X, Y\nidx = 1\nfor i in range(N):\n    A[i] = int(data[idx])\n    idx += 1\n    for _ in range(A[i]):\n        x, y = map(int, data[idx].split())\n        X[i].append(x - 1)\n        Y[i].append(y)\n        idx += 1\n\n# Initialize answer\nans = 0\n\n# Iterate over all subsets of people\nfor bit in range(1 << N):\n    honest = bin(bit).count('1')  # Count number of honest people\n    ok = True\n    \n    # Check constraints for each person\n    for i in range(N):\n        if bit & (1 << i):  # Person i is honest\n            for j in range(A[i]):\n                x, y = X[i][j], Y[i][j]\n                if (bit & (1 << x)) != (y == 1):\n                    ok = False\n                    break\n            if not ok:\n                break\n    \n    # Update answer if valid\n    if ok:\n        ans = max(ans, honest)\n\nprint(ans)"}
{"problem_id":"p02773","slow_code_col":"from collections import Counter\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef solve():\n\n    N = int(eval(input()))\n\n    Sss = [input().rstrip() for _ in range(N)]\n\n\n\n    cnt = Counter(Sss)\n\n    #print('cnt:', cnt)\n\n\n\n    maxNum = max(cnt.values())\n\n    #print('maxNum:', maxNum)\n\n\n\n    anss = []\n\n    for key, value in list(cnt.items()):\n\n        if value == maxNum:\n\n            anss.append(key)\n\n    #print('anss:', anss)\n\n\n\n    anss.sort()\n\n\n\n    print(('\\n'.join(anss)))\n\n\n\n\n\nsolve()\n","reference_code_col":"from collections import Counter\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nN = int(eval(input()))\n\nSss = [input().rstrip() for _ in range(N)]\n\n\n\ncnt = Counter(Sss)\n\n\n\nnum = max(cnt.values())\n\n\n\nanss = []\n\nfor key in sorted(cnt.keys()):\n\n    if cnt[key] == num:\n\n        anss.append(key)\n\n\n\nprint(('\\n'.join(anss)))\n","model_generated_potentially_faster_code_col":"from collections import Counter\nimport sys\n\ninput = sys.stdin.readline\n\n\ndef solve():\n    # Read input efficiently\n    N = int(input())\n    Sss = [input().rstrip() for _ in range(N)]\n\n    # Count occurrences of each string\n    cnt = Counter(Sss)\n\n    # Find the maximum occurrence count\n    maxNum = max(cnt.values())\n\n    # Filter and sort strings with the maximum occurrence count\n    anss = sorted(key for key, value in cnt.items() if value == maxNum)\n\n    # Print the result\n    print('\\n'.join(anss))\n\n\nsolve()"}
{"problem_id":"p03796","slow_code_col":"import math\n\nn = int(eval(input()))\n\n\n\nans = math.factorial(n)  # n\u306e\u968e\u4e57\u3092\u8a08\u7b97\n\n\n\nif ans >= (10 ** 9)+7:\n\n    ans = ans % ((10 ** 9)+7)\n\n\n\nprint(ans)\n","reference_code_col":"n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # \u9014\u4e2d\u3067\u5272\u308a\u7b97\u306e\u4f59\u308a\u3092\u6c42\u3081\u3066\u3082\u3001\u6700\u7d42\u7d50\u679c\u306f\u540c\u3058\u306b\u306a\u308b\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\n# Read input safely\nn = int(input())\n\n# Compute factorial modulo MOD\nans = 1\nfor i in range(2, n + 1):\n    ans = (ans * i) % MOD\n\nprint(ans)"}
{"problem_id":"p02278","slow_code_col":"\"\"\"Minimum cost Sort.\"\"\"\n\n\n\ndef min_cost_sort(A):\n\n    \"\"\"Sort list A in ascending order.\n\n \n\n    And return the switching cost in sorting.\n\n    \"\"\"\n\n    B = list(A)\n\n    B.sort()\n\n    cost = 0\n\n    min_w = B[0]\n\n    for i, b in enumerate(B):\n\n        tmp_cost = 0\n\n        bi = A.index(b)\n\n        n = 1\n\n        while bi != i:\n\n            n += 1\n\n            st = B[bi]\n\n            si = A.index(st)\n\n            tmp_cost += b + st\n\n            A[bi], A[si] = st, b\n\n            bi = si\n\n        dec = (n - 1) * (b - min_w)\n\n        inc = 2 * (min_w + b)\n\n        if dec < inc:\n\n            cost += tmp_cost\n\n        else:\n\n            cost += tmp_cost - dec + inc\n\n    return cost\n\n\n\n\n\nn = eval(input())\n\n\n\nA = list(map(int, input().split()))\n\n\n\nans = min_cost_sort(A)\n\n\n\nprint(ans)","reference_code_col":"\"\"\"Minimum cost Sort.\"\"\"\n\n\n\ndef min_cost_sort(A):\n\n    \"\"\"Sort list A in ascending order.\n\n \n\n    And return the switching cost in sorting.\n\n    \"\"\"\n\n    B = list(A)\n\n    B.sort()\n\n    cost = 0\n\n    min_w = B[0]\n\n    for i, b in enumerate(B):\n\n        tmp_cost = 0\n\n        bi = A.index(b)\n\n        cnt = 0\n\n        while bi != i:\n\n            cnt += 1\n\n            st = B[bi]\n\n            si = A.index(st)\n\n            tmp_cost += b + st\n\n            A[bi], A[si] = st, b\n\n            bi = si\n\n        if cnt:\n\n            dec = cnt * (b - min_w)\n\n            inc = 2 * (min_w + b)\n\n            if dec < inc:\n\n                cost += tmp_cost\n\n            else:\n\n                cost += tmp_cost - dec + inc\n\n    return cost\n\n\n\n\n\nn = eval(input())\n\n\n\nA = list(map(int, input().split()))\n\n\n\nans = min_cost_sort(A)\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"def min_cost_sort(A):\n    \"\"\"Sort list A in ascending order and return the switching cost.\"\"\"\n    # Create a sorted version of A\n    B = sorted(A)\n    \n    # Precompute the index mapping for A\n    index_map = {value: idx for idx, value in enumerate(A)}\n    \n    cost = 0\n    min_w = B[0]  # Smallest element in the sorted list\n    \n    for i, b in enumerate(B):\n        # Find the current position of `b` in A using the precomputed index map\n        bi = index_map[b]\n        \n        # If `b` is already in the correct position, skip\n        if bi == i:\n            continue\n        \n        # Calculate the cost of moving `b` to its correct position\n        tmp_cost = 0\n        while bi != i:\n            # Element currently at position `bi`\n            st = B[bi]\n            \n            # Swap `b` and `st` in A\n            index_map[b], index_map[st] = index_map[st], index_map[b]\n            tmp_cost += b + st\n            \n            # Update `bi` to the new position of `b`\n            bi = index_map[b]\n        \n        # Decide whether to add or subtract based on the cost comparison\n        dec = (bi - i) * (b - min_w)\n        inc = 2 * (min_w + b)\n        if dec < inc:\n            cost += tmp_cost\n        else:\n            cost += tmp_cost - dec + inc\n    \n    return cost\n\n\n# Input handling\nn = int(input())\nA = list(map(int, input().split()))\n\n# Compute and print the result\nans = min_cost_sort(A)\nprint(ans)"}
{"problem_id":"p02982","slow_code_col":"import math\n\nimport numpy as np\n\n\n\nn, d = list(map(int, input().split()))\n\n\n\nx = np.zeros([n, d])\n\n\n\nfor i in range(n):\n\n    line = list(map(int, input().split()))\n\n    for j in range(d):\n\n        x[i, j] = line[j]\n\n\n\ncnt = 0\n\n\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        xx = (x[i] - x[j]) ** 2\n\n        dist = math.sqrt(xx.sum())\n\n        if dist % 1 == 0:\n\n            cnt += 1\n\n\n\nprint(cnt)","reference_code_col":"import math\n\n\n\nn, d = list(map(int, input().split()))\n\n\n\nx = [list(map(int, input().split())) for i in range(n)]\n\n\n\ncnt = 0\n\n\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        dist = 0\n\n        for k in range(d):\n\n            dist += (x[i][k] - x[j][k]) ** 2\n\n        if math.sqrt(dist).is_integer():\n\n            cnt += 1\n\n\n\nprint(cnt)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input: Read n (number of points) and d (dimensions)\nn, d = map(int, input().split())\n\n# Input: Read all points into a NumPy array efficiently\nx = np.array([list(map(int, input().split())) for _ in range(n)])\n\n# Precompute squared differences between all pairs of points\ncnt = 0\nfor i in range(n):\n    # Compute squared differences only for pairs (i, j) where j > i\n    squared_diffs = ((x[i] - x[i+1:]) ** 2).sum(axis=1)\n    \n    # Check if the square root of the squared differences is an integer\n    cnt += np.sum(np.sqrt(squared_diffs) % 1 == 0)\n\nprint(cnt)"}
{"problem_id":"p02555","slow_code_col":"from functools import lru_cache\n\nimport sys\n\n\n\nsys.setrecursionlimit(2000)\n\n\n\ns = int(eval(input()))\n\nmod = 10 ** 9 + 7\n\n\n\n\n\n@lru_cache(maxsize=None)\n\ndef dfs(n):\n\n    if n <= 2:\n\n        return 0\n\n    elif 3<=n<=5:\n\n        return 1\n\n    else:\n\n        count = 1\n\n        for i in range(3, n + 1):\n\n            count += dfs(n - i)\n\n            count %= mod\n\n\n\n        return count % mod\n\n\n\n\n\nans = dfs(s)\n\nprint(ans)\n","reference_code_col":"s = int(eval(input()))\n\nmod = 10 ** 9 + 7\n\n\n\ndp = [0] * (s + 1)\n\ndp[0] = 1\n\n\n\nx = 0\n\nfor i in range(3, s + 1):\n\n    x += dp[i - 3]\n\n    dp[i] = x % mod\n\n\n\nans = dp[s] % mod\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import sys\n\n# Read input and set constants\ns = int(eval(input()))\nmod = 10**9 + 7\n\n# Handle base cases explicitly\nif s <= 2:\n    print(0)\nelif 3 <= s <= 5:\n    print(1)\nelse:\n    # Initialize DP array\n    dp = [0] * (s + 1)\n\n    # Base cases\n    for i in range(3, 6):\n        dp[i] = 1\n\n    # Fill DP table iteratively\n    for n in range(6, s + 1):\n        count = 1  # Start with 1 for the current value\n        for i in range(3, n + 1):\n            count += dp[n - i]\n            count %= mod\n        dp[n] = count\n\n    # Output the result\n    print(dp[s])"}
{"problem_id":"p03457","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nplan = np.array([[0, 0, 0]] + [list(map(int, input().split())) for i in range(N)])\n\n\n\ndiff = np.diff(plan, axis = 0)\n\n\n\ndef is_possible(t, x, y):\n\n    if (t + x + y) % 2 == 0 and abs(x) + abs(y) <= t:\n\n        return True\n\n    else:\n\n        return False\n\n\n\nfor i in range(N):\n\n    ti, xi, yi = diff[i]\n\n    if not is_possible(ti, xi, yi):\n\n        print('No')\n\n        exit()\n\nprint('Yes')","reference_code_col":"N = int(eval(input()))\n\nplan = [[0, 0, 0]] + [list(map(int, input().split())) for _ in range(N)]\n\ndiff = [[plan[i + 1][j] - plan[i][j] for j in range(3)] for i in range(N)]\n\n\n\ndef is_possible(t, x, y):\n\n    if (t + x + y) % 2 == 0 and abs(x) + abs(y) <= t:\n\n        return True\n\n    else:\n\n        return False\n\n\n\nfor i in range(N):\n\n    ti, xi, yi = diff[i]\n\n    if not is_possible(ti, xi, yi):\n\n        print('No')\n\n        exit()\n\nprint('Yes')","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Read the plan as a list of tuples (t, x, y)\nplan = [(0, 0, 0)]  # Start at (0, 0, 0)\nfor _ in range(N):\n    t, x, y = map(int, input().split())\n    plan.append((t, x, y))\n\n# Iterate through consecutive steps\nprev_t, prev_x, prev_y = plan[0]\nfor i in range(1, N + 1):\n    curr_t, curr_x, curr_y = plan[i]\n    \n    # Calculate differences\n    t_diff = curr_t - prev_t\n    x_diff = curr_x - prev_x\n    y_diff = curr_y - prev_y\n    \n    # Check feasibility\n    distance = abs(x_diff) + abs(y_diff)\n    if (t_diff + x_diff + y_diff) % 2 != 0 or distance > t_diff:\n        print('No')\n        exit()\n    \n    # Update previous step\n    prev_t, prev_x, prev_y = curr_t, curr_x, curr_y\n\nprint('Yes')"}
{"problem_id":"p03721","slow_code_col":"n,k = list(map(int,input().split()))\n\nnum = 0\n\nq = []\n\nfor i in range(n):\n\n    a,b = list(map(int,input().split()))\n\n    q.append((a,b))\n\nq.sort()\n\nfor i in range(n):\n\n    a, b = q[i][0], q[i][1]\n\n    num += b\n\n    if num >= k:\n\n        print(a)\n\n        exit()\n\n\n","reference_code_col":"n,k = list(map(int,input().split()))\n\ncnt = 0\n\nnum = []\n\nfor i in range(n):\n\n    a,b = list(map(int,input().split()))\n\n    num.append((a,b))\n\nnum.sort()\n\nfor i in range(n):\n\n    cnt += num[i][1]\n\n    if cnt >= k:\n\n        print((num[i][0]))\n\n        exit()","model_generated_potentially_faster_code_col":"n, k = map(int, input().split())\n\n# Read and sort the input tuples in one step\nq = sorted(tuple(map(int, input().split())) for _ in range(n))\n\nnum = 0\n\n# Iterate through the sorted list\nfor a, b in q:\n    num += b\n    if num >= k:\n        print(a)\n        exit()"}
{"problem_id":"p03197","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\ndef dfs(x, y):\n\n    if x==0 and y==0:\n\n        t[x][y] = False\n\n        return False\n\n    \n\n    if x>=1:\n\n        t[x][y] |= not dfs(x-1, y)\n\n        \n\n    if y>=1:\n\n        t[x][y] |= not dfs(x, y-1)\n\n        \n\n    if min(x, y)>=1:\n\n        t[x][y] |= not dfs(x-1, y-1)\n\n   \n\n    return t[x][y]\n\n    \n\nt = [[False]*7 for _ in range(7)]\n\n\n\nfor i in range(7):\n\n    for j in range(7):\n\n        dfs(i, j)\n\n\n\n\"\"\"\n\nfor ti in t:\n\n    print(*ti)\n\n\"\"\"\n\n\n\nN = int(eval(input()))\n\nflag = True\n\n\n\nfor _ in range(N):\n\n    a = int(eval(input()))\n\n    \n\n    if a%2==1:\n\n        flag = False\n\n        \n\nif flag:\n\n    print('second')\n\nelse:\n\n    print('first')","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\n\"\"\"\n\ndef dfs(x, y):\n\n    if x==0 and y==0:\n\n        return False\n\n        \n\n    res = False\n\n    \n\n    if x>0:\n\n        res |= not dfs(x-1, y)\n\n    \n\n    if y>0:\n\n        res |= not dfs(x, y-1)\n\n    \n\n    if min(x, y)>0:\n\n        res |= not dfs(x-1, y-1)\n\n    \n\n    return res\n\n    \n\nt = [[False]*5 for _ in range(5)]\n\n\n\nfor i in range(5):\n\n    for j in range(5):\n\n        t[i][j] = dfs(i, j)\n\n\n\nfor ti in t:\n\n    print(*ti)\n\n\"\"\"\n\n\n\nN = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\nfor ai in a:\n\n    if ai%2==1:\n\n        print('first')\n\n        exit()\n\n\n\nprint('second')","model_generated_potentially_faster_code_col":"import sys\n\n# Use faster input method\ninput = sys.stdin.readline\n\n# Precompute the grid using dynamic programming (memoization)\ndef precompute_grid(size):\n    t = [[False] * size for _ in range(size)]\n    \n    # Base case: t[0][0] is False\n    t[0][0] = False\n    \n    # Fill the grid using bottom-up DP\n    for x in range(size):\n        for y in range(size):\n            if x == 0 and y == 0:\n                continue  # Already handled as False\n            \n            # Check moves: (x-1, y), (x, y-1), (x-1, y-1)\n            if x >= 1:\n                t[x][y] |= not t[x-1][y]\n            if y >= 1:\n                t[x][y] |= not t[x][y-1]\n            if x >= 1 and y >= 1:\n                t[x][y] |= not t[x-1][y-1]\n    \n    return t\n\n# Precompute the grid for size 7x7\nGRID_SIZE = 7\nt = precompute_grid(GRID_SIZE)\n\n# Read input and process queries\nN = int(input())\nflag = True\n\nfor _ in range(N):\n    a = int(input())\n    if a % 2 == 1:  # If any odd number is found, set flag to False\n        flag = False\n\n# Output result\nif flag:\n    print('second')\nelse:\n    print('first')"}
{"problem_id":"p03416","slow_code_col":"a,b=list(map(int, input().split()))\n\ncnt=0\n\nfor i in range(a,b+1):\n\n    n=list(str(i))\n\n    if n==list(reversed(n)):\n\n        cnt+=1\n\nprint(cnt)","reference_code_col":"from sys import stdin\n\nnii=lambda:list(map(int,stdin.readline().split()))\n\nlnii=lambda:list(map(int,stdin.readline().split()))\n\n\n\na,b=nii()\n\nans=0\n\nfor i in range(a,b+1):\n\n  s=str(i)\n\n  if s==s[::-1]:\n\n    ans+=1\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"a, b = map(int, input().split())\n\ncnt = 0\n\nfor i in range(a, b + 1):\n    n = str(i)  # Convert the number to a string once\n    if n == n[::-1]:  # Efficiently check if the string is a palindrome\n        cnt += 1\n\nprint(cnt)"}
{"problem_id":"p02881","slow_code_col":"# a+b-2\n\n# N = a*b  \u3088\u3063\u3066N\u306e\u7d04\u6570\u3092\u6c42\u3081\u308b\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nU = 10**6+100\n\nx = np.arange(1, U, dtype=np.int64)\n\ndiv = x[N%x==0]\n\nans = (div + N\/\/div).min() - 2\n\nprint(ans)","reference_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 7)\n\nread = sys.stdin.buffer.read \n\ninput = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines  \n\n\n\ndef make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append((i, n\/\/i))\n\n            \n\n    # divisors.sort()\n\n    return divisors\n\n\n\nN = int(eval(input()))\n\ndiv = make_divisors(N)\n\n\n\nans = 10**15\n\nfor a, b in div:\n\n  ans = min(ans, a+b-2)\n\nprint(ans)  \n\n\n","model_generated_potentially_faster_code_col":"import math\n\n# Input: Read the value of N\nN = int(input())\n\n# Initialize the minimum value to a large number\nmin_value = float('inf')\n\n# Iterate through potential divisors up to \u221aN\nfor i in range(1, int(math.sqrt(N)) + 1):\n    if N % i == 0:  # Check if i is a divisor of N\n        a, b = i, N \/\/ i  # Compute the pair of divisors\n        min_value = min(min_value, a + b - 2)  # Update the minimum value\n\n# Output the result\nprint(min_value)"}
{"problem_id":"p02994","slow_code_col":"import sys\n\nimport numpy as np \n\n\n\nn, l = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    f = l + np.arange(1, n+1) - 1\n\n    s = f.sum()\n\n    a = np.absolute(f)\n\n    mi = np.amin(a)\n\n    i = np.argwhere(a == mi)[0, 0]\n\n    return s - f[i]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","reference_code_col":"import sys\n\n\n\nn, l = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    s = (l - 1) * n + (1 + n) * n \/\/ 2\n\n    res = []\n\n    for i in range(1, n+1):\n\n        f = l + i - 1\n\n        res.append((abs(f), s - f))\n\n    \n\n    res.sort()\n\n    return res[0][1]\n\n\n\nif __name__=='__main__':\n\n    ans = main()\n\n    print(ans)","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Read input values\nn, l = map(int, sys.stdin.readline().split())\n\ndef main():\n    # Generate the array f\n    f = l + np.arange(n)\n    \n    # Compute the sum of f using the arithmetic series formula\n    s = n * l + n * (n - 1) \/\/ 2\n    \n    # Find the index of the element with the smallest absolute value\n    i = np.argmin(np.abs(f))\n    \n    # Return the result by subtracting the chosen element from the sum\n    return s - f[i]\n\nif __name__ == '__main__':\n    ans = main()\n    print(ans)"}
{"problem_id":"p02982","slow_code_col":"# coding: utf-8\n\nimport numpy as np\n\nn, d = list(map(int, input().split()))\n\ncnt = 0\n\nX = []\n\nfor i in range(n):\n\n    x = list(map(int, input().split()))\n\n    X.append(x[:])\n\nX = np.array(X)\n\nfor i in range(n):\n\n    X_tmp = X[:]\n\n    X_tmp -= X[i]\n\n    for i in range(n):\n\n        x = X_tmp[i]\n\n        x_sq = x**2\n\n        x_sq = np.sqrt(sum(x_sq))\n\n        if x_sq % 1 == 0:\n\n            cnt += 1\n\nprint(((cnt-n)\/\/2))","reference_code_col":"# coding: utf-8\n\nN, D = list(map(int, input().split()))\n\nX = []\n\nans = 0\n\nfor i in range(N):\n\n    X.append(list(map(int, input().split())))\n\nfor i in range(N):\n\n    for j in range(N):\n\n        dist = 0\n\n        if i == j:\n\n            continue\n\n        for d in range(D):\n\n            dist += ((X[i][d] - X[j][d])**2)\n\n        if dist**0.5 == int(dist**0.5):\n\n            ans += 1\n\nprint((ans\/\/2))","model_generated_potentially_faster_code_col":"# coding: utf-8\n\nimport numpy as np\n\n# Read input\nn, d = map(int, input().split())\n\n# Read points into a NumPy array directly\nX = np.array([list(map(int, input().split())) for _ in range(n)])\n\n# Compute pairwise squared differences using broadcasting\ndiffs = X[:, None, :] - X[None, :, :]  # Shape: (n, n, d)\n\n# Compute squared distances\nsquared_distances = np.sum(diffs**2, axis=2)  # Shape: (n, n)\n\n# Check which squared distances are perfect squares\nis_perfect_square = np.sqrt(squared_distances) % 1 == 0\n\n# Count valid pairs (excluding diagonal and double-counted pairs)\ncnt = np.sum(is_perfect_square) - n  # Subtract diagonal elements\ncnt \/\/= 2  # Divide by 2 to account for symmetry\n\nprint(cnt)"}
{"problem_id":"p03078","slow_code_col":"def d_cake_123_binary_search(X, Y, Z, K, A, B, C):\n\n    # editional\u306e\u89e3\u6cd54 O(K^2log(max(P))\n\n    # \u53c2\u8003: https:\/\/atcoder.jp\/contests\/abc123\/submissions\/4871511\n\n    import bisect\n\n    ab = sorted([e1 + e2 for e2 in B for e1 in A])  # A, B\u306e\u8981\u7d20\u306f\u5168\u90e8\u8abf\u3079\u308b\n\n\n\n    # rejected \u4ee5\u4e0a\u306e\u5024\u306f\u3001\u7f8e\u5473\u3057\u3055\u306e\u5408\u8a08\u304c\u305d\u308c\u4ee5\u4e0a\u3067\u3042\u308b\u500b\u6570\u304cK\u500b\u672a\u6e80\u3067\u3042\u308b\n\n    accepted, rejected = -1, 10**11\n\n    while abs(accepted - rejected) > 1:\n\n        mid = (accepted + rejected) \/\/ 2\n\n        count = sum([len(ab) - bisect.bisect_left(ab, mid - e) for e in C])\n\n        if count >= K:\n\n            accepted = mid\n\n        else:\n\n            rejected = mid\n\n\n\n    ans = []\n\n    for e in C:\n\n        idx = bisect.bisect_left(ab, accepted - e)\n\n        for i in range(idx, len(ab)):\n\n            ans.append(e + ab[i])\n\n    ans.sort(reverse=True)\n\n    return '\\n'.join(map(str, ans[:K]))\n\n\n\nX, Y, Z, K = [int(i) for i in input().split()]\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\nC = [int(i) for i in input().split()]\n\nprint((d_cake_123_binary_search(X, Y, Z, K, A, B, C)))","reference_code_col":"def d_cake_123_sort_modified():\n\n    \"\"\"editorial \u306e\u89e3\u6cd5 1.\"\"\"\n\n    import sys\n\n    import numpy as np\n\n    input = sys.stdin.readline\n\n    X, Y, Z, K = [int(i) for i in input().split()]\n\n    A = np.array([int(i) for i in input().split()])\n\n    B = np.array([int(i) for i in input().split()])\n\n    C = np.array([int(i) for i in input().split()])\n\n\n\n    _a, _b = np.meshgrid(A, B)\n\n    ab = np.sort((_a + _b).flatten())[::-1][:K]\n\n    _ab, _c = np.meshgrid(ab, C)\n\n    ans = np.sort((_ab + _c).flatten())[::-1][:K]\n\n    return '\\n'.join(map(str, ans))\n\n\n\nprint((d_cake_123_sort_modified()))","model_generated_potentially_faster_code_col":"import heapq\n\ndef d_cake_123_optimized(X, Y, Z, K, A, B, C):\n    # Step 1: Generate top K sums from A and B using a heap\n    ab_heap = []\n    for a in A:\n        for b in B:\n            heapq.heappush(ab_heap, -(a + b))  # Use negative for max-heap behavior\n            if len(ab_heap) > K:\n                heapq.heappop(ab_heap)\n    \n    ab = [-x for x in ab_heap]  # Extract top K sums (reverse sign back to positive)\n    ab.sort(reverse=True)  # Sort descending for binary search efficiency\n\n    # Step 2: Binary search to find the threshold for the top K sums\n    accepted, rejected = -1, 10**11\n    while abs(accepted - rejected) > 1:\n        mid = (accepted + rejected) \/\/ 2\n        count = sum(len(ab) - bisect.bisect_left(ab, mid - e) for e in C)\n        if count >= K:\n            accepted = mid\n        else:\n            rejected = mid\n\n    # Step 3: Collect top K sums using a heap\n    ans_heap = []\n    for c in C:\n        idx = bisect.bisect_left(ab, accepted - c)\n        for i in range(idx, len(ab)):\n            s = c + ab[i]\n            heapq.heappush(ans_heap, s)\n            if len(ans_heap) > K:\n                heapq.heappop(ans_heap)\n\n    # Step 4: Extract and format the result\n    ans = sorted(ans_heap, reverse=True)[:K]\n    return '\\n'.join(map(str, ans))\n\n# Input handling\nX, Y, Z, K = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\n\n# Output the result\nprint(d_cake_123_optimized(X, Y, Z, K, A, B, C))"}
{"problem_id":"p03796","slow_code_col":"import math\n\nN = int(eval(input()))\n\np = math.factorial(N)\n\nprint((p % 1000000007))","reference_code_col":"N = int(eval(input()))\n\np = 1\n\nfor i in range(1,N+1):\n\n    p *= i\n\n    p %= 1000000007\n\nprint(p)\n","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\n# Read input\nN = int(input())\n\n# Compute factorial modulo MOD\nresult = 1\nfor i in range(2, N + 1):\n    result = (result * i) % MOD\n\n# Output the result\nprint(result)"}
{"problem_id":"p02891","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\n \n\ns = input().rstrip()\n\nk = int(eval(input()))\n\n    \n\ndef check_count(s):\n\n    cnt_list = [1]\n\n    cnt = 1\n\n    for i in range(1, len(s)):\n\n        if s[i-1] == s[i]:\n\n            cnt_list[-1] += 1\n\n        else:\n\n            cnt_list.append(1)\n\n    return cnt_list\n\n\n\ndef calc_ans(cnt_list, k):\n\n    _ans = 0\n\n    for c in cnt_list:\n\n        _ans += c\/\/2\n\n    return(_ans * k)\n\n\n\nif len(s)==1:\n\n    ans = k\/\/2\n\nelse:\n\n    cnt_list = check_count(s)\n\n    if len(cnt_list)==1:\n\n        ans = (len(s)*k)\/\/2\n\n    else:\n\n        ans = calc_ans(cnt_list, k)\n\n        if s[0]==s[-1]:\n\n            if cnt_list[0]%2==1 and cnt_list[-1]%2==1:\n\n                ans += k - 1\n\n\n\nprint(ans)","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n \n\ns = input().rstrip()\n\nk = int(eval(input()))\n\n\n\ndef check_count(s):\n\n    cnt_list = []\n\n    cnt = 1\n\n    for i in range(1, len(s)):\n\n        if s[i-1] == s[i]:\n\n            cnt += 1\n\n        else:\n\n            cnt_list.append(cnt)\n\n            cnt = 1\n\n    if cnt>1:\n\n        cnt_list.append(cnt)\n\n    return cnt_list\n\n\n\ndef calc_ans(cnt_list, k):\n\n    _ans = 0\n\n    for c in cnt_list:\n\n        _ans += c\/\/2\n\n    return(_ans * k)\n\n\n\nif len(s)==1:\n\n    ans = k\/\/2\n\nelse:\n\n    cnt_list = check_count(s)\n\n    if len(cnt_list)==1:\n\n        ans = (len(s)*k)\/\/2\n\n    else:\n\n        ans = calc_ans(cnt_list, k)\n\n        if s[0]==s[-1]:\n\n            if cnt_list[0]%2==1 and cnt_list[-1]%2==1:\n\n                ans += k - 1\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\n# Read inputs\ns = input().strip()  # Use strip() instead of rstrip() for simplicity\nk = int(input())     # Replace eval() with int()\n\ndef check_count(s):\n    \"\"\"Count consecutive identical characters in the string.\"\"\"\n    cnt_list = [1]\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            cnt_list[-1] += 1\n        else:\n            cnt_list.append(1)\n    return cnt_list\n\n# Handle edge case when the string has only one character\nif len(s) == 1:\n    ans = k \/\/ 2\nelse:\n    cnt_list = check_count(s)\n\n    # Calculate the base answer\n    _ans = sum(c \/\/ 2 for c in cnt_list) * k\n\n    # Adjust for the special case when the first and last characters are the same\n    if s[0] == s[-1] and cnt_list[0] % 2 == 1 and cnt_list[-1] % 2 == 1:\n        _ans += k - 1\n\n    ans = _ans\n\n# Output the result\nprint(ans)"}
{"problem_id":"p02881","slow_code_col":"N = int(eval(input()))\n\n\n\n\n\ndef dist(i, j):\n\n    return i + j - 2\n\n\n\n\n\nmin = 10 ** 24\n\ni = 1\n\nwhile (i ** 2) <= N:\n\n    if 0 == N % i:\n\n        j = N \/\/ i\n\n        d = dist(i, j)\n\n        if min > d:\n\n            min = d\n\n    i += 1\n\nprint(d)\n","reference_code_col":"import math\n\nn = int(eval(input()))\n\n\n\nans = 0\n\nfor i in range(math.ceil(math.sqrt(n) + 1))[:0:-1]:\n\n    if 0 == n % i:\n\n        ans = i\n\n        break\n\nans_partner = n \/\/ ans\n\nprint((ans + ans_partner - 2))\n","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Initialize the minimum distance to a large value\nmin_distance = float('inf')\n\n# Iterate over potential divisors up to sqrt(N)\ni = 1\nwhile i * i <= N:\n    if N % i == 0:  # Check if i is a divisor of N\n        j = N \/\/ i  # Compute the corresponding divisor\n        d = i + j - 2  # Calculate the distance\n        if d < min_distance:  # Update the minimum distance\n            min_distance = d\n    i += 1\n\n# Output the minimum distance\nprint(min_distance)"}
{"problem_id":"p02552","slow_code_col":"n = int(eval(input()))\n\nprint((1 if n == 0 else 0))\n","reference_code_col":"n = int(eval(input()))\n\nprint((0 if n else 1))\n","model_generated_potentially_faster_code_col":"n = int(eval(input()))\nprint((1 if n == 0 else 0))"}
{"problem_id":"p02792","slow_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n# input = sys.stdin.readline    ####\n\nint1 = lambda x: int(x) - 1\n\ndef II(): return int(eval(input()))\n\n\n\ndef MI(): return list(map(int, input().split()))\n\ndef MI1(): return list(map(int1, input().split()))\n\n\n\ndef LI(): return list(map(int, input().split()))\n\ndef LI1(): return list(map(int1, input().split()))\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n\n\ndef printlist(lst, k='\\n'): print((k.join(list(map(str, lst)))))\n\nINF = float('inf')\n\n\n\nimport numpy as np\n\n\n\ndef solve():\n\n    n = II()\n\n    D = np.zeros((10, 10))\n\n\n\n    for i in range(1, n+1):\n\n        s = list(str(i))\n\n        l = int(s[0])\n\n        r = int(s[-1])\n\n        # print(s, l, r)\n\n        D[l][r] += 1\n\n    # print(D)\n\n\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += D[i][j] * D[j][i]\n\n    print((int(ans)))\n\n\n\nif __name__ == '__main__':\n\n    solve()\n","reference_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n# input = sys.stdin.readline    ####\n\nint1 = lambda x: int(x) - 1\n\ndef II(): return int(eval(input()))\n\n\n\ndef MI(): return list(map(int, input().split()))\n\ndef MI1(): return list(map(int1, input().split()))\n\n\n\ndef LI(): return list(map(int, input().split()))\n\ndef LI1(): return list(map(int1, input().split()))\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n\n\ndef printlist(lst, k='\\n'): print((k.join(list(map(str, lst)))))\n\nINF = float('inf')\n\n\n\ndef solve():\n\n    n = II()\n\n    D = [[0]*10 for _ in range(10)]\n\n\n\n    for i in range(1, n+1):\n\n        s = list(str(i))\n\n        l = int(s[0])\n\n        r = int(s[-1])\n\n        # print(s, l, r)\n\n        D[l][r] += 1\n\n    # print(D)\n\n\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += D[i][j] * D[j][i]\n\n    print((int(ans)))\n\n\n\nif __name__ == '__main__':\n\n    solve()\n","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\ndef solve():\n    n = int(sys.stdin.read())  # Read input directly\n    \n    # Initialize the 10x10 matrix\n    D = np.zeros((10, 10), dtype=int)\n    \n    # Helper function to extract first digit\n    def first_digit(x):\n        while x >= 10:\n            x \/\/= 10\n        return x\n    \n    # Process numbers from 1 to n\n    for i in range(1, n + 1):\n        l = first_digit(i)  # First digit\n        r = i % 10          # Last digit\n        D[l][r] += 1\n    \n    # Compute the result\n    ans = 0\n    for i in range(10):\n        for j in range(10):\n            ans += D[i][j] * D[j][i]\n    \n    print(ans)\n\nif __name__ == '__main__':\n    solve()"}
{"problem_id":"p03039","slow_code_col":"import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)\/\/2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)\/\/2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        ans += f1(x,y,n,m)+f1(1,1,x,y)+f1(1,y,x,m)+f1(x,1,n,y)\n\n        ans -= f2(x,n) + f2(1,x) + f2(1,y) + f2(y,m)\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n","reference_code_col":"import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)\/\/2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)\/\/2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        a = n-x+1\n\n        b = m-y+1\n\n        c = m*(a*(a-1)+x*(x-1))\n\n        d = n*(b*(b-1)+y*(y-1))\n\n        ans += (c+d)\/\/2\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n","model_generated_potentially_faster_code_col":"def precompute_factorials(max_val, mod):\n    fact = [1] * (max_val + 1)\n    inv_fact = [1] * (max_val + 1)\n\n    for i in range(2, max_val + 1):\n        fact[i] = fact[i - 1] * i % mod\n\n    inv_fact[max_val] = pow(fact[max_val], mod - 2, mod)\n    for i in range(max_val - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    return fact, inv_fact\n\n\ndef comb(n, r, fact, inv_fact, mod):\n    if r < 0 or r > n:\n        return 0\n    return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod"}
{"problem_id":"p02596","slow_code_col":"def c_repsept():\n\n    K = int(eval(input()))\n\n\n\n    if (K % 2 == 0 or K % 5 == 0):\n\n        return -1  # repsept \u306e\u56e0\u6570\u306b 2, 5 \u306f\u306a\u3044\n\n\n\n    repsept = 7 % K\n\n    count = 1\n\n    while repsept % K !=0:\n\n        repsept = ((repsept * 10) + 7) % K\n\n        count += 1\n\n    return count\n\n\n\nprint((c_repsept()))","reference_code_col":"def c_repsept():\n\n    K = int(eval(input()))\n\n\n\n    L = 9 * K \/\/ 7 if K % 7 == 0 else 9 * K\n\n    if L % 2 == 0 or L % 5 == 0:\n\n        return -1\n\n\n\n    remainder = 1\n\n    for n in range(1, L + 1):\n\n        remainder = (10 * remainder) % L\n\n        if remainder == 1:\n\n            return n\n\n    return -1\n\n\n\nprint((c_repsept()))","model_generated_potentially_faster_code_col":"def c_repsept():\n    K = int(input())  # Read input as integer\n\n    # Early exit for K divisible by 2 or 5\n    if K % 2 == 0 or K % 5 == 0:\n        return -1\n\n    repsept = 7 % K  # Initial remainder\n    count = 1        # Track the number of iterations\n    seen_remainders = set()  # To detect cycles\n\n    while repsept != 0:\n        if repsept in seen_remainders:\n            return -1  # Cycle detected, no solution exists\n        seen_remainders.add(repsept)\n        repsept = (repsept * 10 + 7) % K  # Update remainder\n        count += 1\n\n    return count\n\n\nprint(c_repsept())"}
{"problem_id":"p03013","slow_code_col":"import sys\n\nsys.setrecursionlimit(10**7)\n\ndef lmi(): return list(map(int, input().split()))\n\n\n\nn, m = lmi()\n\n\n\nl = [0] * (n+1)\n\nl[0] = 1\n\n\n\na = 0\n\nif m != 0:\n\n    a = int(eval(input()))\n\nk = 1\n\nfor i in range(n+1):\n\n\n\n    if i != a:\n\n        if i == 1:\n\n            l[i] = 1\n\n        elif i >= 2:\n\n            l[i] = l[i-1] + l[i-2]\n\n            l[i] %= 1000000007\n\n    else:\n\n        k += 1\n\n        if k <= m:\n\n            a = int(eval(input()))\n\n\n\n\n\n\n\n#print(l)\n\nprint((l[n] % 1000000007))\n","reference_code_col":"import sys\n\nsys.setrecursionlimit(10**7)\n\ndef lmi(): return list(map(int, input().split()))\n\n\n\nn, m = lmi()\n\na = [1] * (n+1)\n\nfor i in range(m):\n\n    a[int(eval(input()))] = 0\n\nk = [0] * (n+1)\n\nk[0] = 1\n\nfor i in range(1,n+1):\n\n    if i == 1 and a[1]:\n\n        k[1] = 1\n\n    elif i >= 2 and a[i]:\n\n        k[i] = k[i-1] + k[i-2]\n\n        k[i] %= 10 ** 9 + 7\n\n\n\nprint((k[n]))\n","model_generated_potentially_faster_code_col":"import sys\n\n# Set recursion limit (not strictly needed here, but kept for compatibility)\nsys.setrecursionlimit(10**7)\n\ndef main():\n    # Fast input reading\n    n, m = map(int, sys.stdin.readline().split())\n    a_values = list(map(int, sys.stdin.read().split())) if m > 0 else []\n\n    MOD = 10**9 + 7  # Modulo constant\n\n    # Initialize the list with zeros\n    l = [0] * (n + 1)\n    l[0] = 1  # Base case\n\n    # Track the current index to skip\n    skip_index = 0\n    skip_set = set(a_values)  # Use a set for O(1) lookups\n\n    # Compute the sequence\n    for i in range(1, n + 1):\n        if i in skip_set:  # Skip this index\n            continue\n\n        if i == 1:\n            l[i] = 1\n        elif i >= 2:\n            l[i] = (l[i - 1] + l[i - 2]) % MOD\n\n    # Output the result\n    print(l[n])\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02767","slow_code_col":"def c_rally():\n\n    import numpy as np\n\n    import math\n\n    N = int(eval(input()))\n\n    X = [int(i) for i in input().split()]\n\n    m = np.average(X)\n\n    ans = float('inf')\n\n    for j in (math.floor(m), math.ceil(m)):\n\n        ans = min(ans, sum([(x - j)**2 for x in X]))\n\n    return ans\n\n\n\nprint((c_rally()))","reference_code_col":"def c_rally():\n\n    N = int(eval(input()))\n\n    X = [int(i) for i in input().split()]\n\n\n\n    x_sum = sum(X)\n\n    option = (x_sum \/\/ N, (x_sum + N - 1) \/\/ N)\n\n    return min(sum([(x - p)**2 for x in X]) for p in option)\n\n\n\nprint((c_rally()))","model_generated_potentially_faster_code_col":"def c_rally():\n    # Read input values\n    N = int(input())\n    X = list(map(int, input().split()))\n\n    # Compute the mean of X\n    total_sum = sum(X)\n    m = total_sum \/ N\n\n    # Consider floor(m) and ceil(m)\n    candidates = [int(m), int(m) + 1]\n\n    # Precompute the sum of squares for each candidate\n    min_sum = float('inf')\n    for j in candidates:\n        current_sum = sum((x - j) ** 2 for x in X)\n        min_sum = min(min_sum, current_sum)\n\n    return min_sum\n\n\n# Call the function and print the result\nprint(c_rally())"}
{"problem_id":"p03013","slow_code_col":"N,M = list(map(int,input().split()))\n\nMOD = 10**9+7\n\ndp = [0]*(N+1)\n\ndp[0]=1\n\nA = [int(eval(input())) for i in range(M)]\n\nban = [1]*(N+1)\n\nfor a in A:\n\n    ban[a]=0\n\nfor i in range(N):\n\n    if i-1>=0:\n\n        dp[i+1]=dp[i]*ban[i]+dp[i-1]*ban[i-1]\n\n    else:\n\n        dp[i+1]=dp[i]*ban[i]\n\n    dp[i+1] %= MOD \n\nprint((dp[N]))","reference_code_col":"N,M = list(map(int,input().split()))\n\nA = [int(eval(input())) for i in range(M)]\n\nMOD = 10**9+7\n\nA = set(A)\n\ndp = [0]*(N+1)\n\ndp[0] = 1\n\nfor i in range(1,N+1):\n\n    if i in A:\n\n        continue\n\n    if i == 1:\n\n        dp[1] = dp[0]\n\n    else:\n\n        dp[i] = (dp[i-1]+dp[i-2])%MOD\n\nprint((dp[N]))","model_generated_potentially_faster_code_col":"N, M = map(int, input().split())\n\nMOD = 10**9 + 7\n\n# Use a set to store banned indices for faster lookup\nbanned = set()\n\nfor _ in range(M):\n    banned.add(int(input()))\n\ndp = [0] * (N + 1)\ndp[0] = 1\n\nfor i in range(N):\n    # Check if the current index is not banned\n    if i not in banned:\n        dp[i + 1] += dp[i]\n    \n    # Check if the previous index is not banned\n    if i - 1 >= 0 and i - 1 not in banned:\n        dp[i + 1] += dp[i - 1]\n    \n    dp[i + 1] %= MOD\n\nprint(dp[N])"}
{"problem_id":"p03253","slow_code_col":"from math import sqrt, ceil, factorial\n\nfrom collections import defaultdict\n\n\n\n\n\ndef prime_factors(n):\n\n    i = 2\n\n    factors = defaultdict(int)\n\n    while i * i <= n:\n\n        if n % i:\n\n            i += 1\n\n        else:\n\n            n \/\/= i\n\n            factors[i] += 1\n\n    if n > 1:\n\n        factors[n] += 1\n\n    return factors\n\n\n\n\n\nN, M = [int(elem) for elem in input().split(' ')]\n\n\n\n# \u7d20\u56e0\u6570\u5206\u89e3\n\nprime_numbers = prime_factors(M)\n\nsum = 1\n\nfac_N_m1 = factorial(N - 1)\n\n\n\nfor value in list(prime_numbers.values()):\n\n    bunshi = 1\n\n    saisho = value + N - 1\n\n    for _ in range(value):\n\n        bunshi *= saisho\n\n        saisho -= 1\n\n    sum *= (bunshi \/\/ factorial(value))\n\nprint((sum % (10**9 + 7)))\n","reference_code_col":"from collections import defaultdict\n\n\n\n\n\ndef prime_factorize(num):\n\n    prime_numbers = defaultdict(int)\n\n    i = 2\n\n    while i * i <= num:\n\n        if num % i == 0:\n\n            while num % i == 0:\n\n                prime_numbers[i] += 1\n\n                num \/\/= i\n\n        i += 1\n\n    if num != 1:\n\n        prime_numbers[num] += 1\n\n    return prime_numbers\n\n\n\n\n\nMOD = 10**9 + 7\n\nN, M = [int(elem) for elem in input().split()]\n\n\n\nprime_numbers = prime_factorize(M)\n\n\n\nnum_sequences = 1\n\nfor exponent in list(prime_numbers.values()):\n\n    denomimator = 1\n\n    numerator = 1\n\n    for i in range(1, exponent + 1):\n\n        denomimator *= (N + exponent - i)\n\n        numerator *= i\n\n    num_sequences *= denomimator \/\/ numerator\n\n    num_sequences %= MOD\n\n\n\nprint(num_sequences)\n","model_generated_potentially_faster_code_col":"from math import ceil, factorial\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\n\ndef prime_factors(n):\n    \"\"\"Efficient prime factorization.\"\"\"\n    i = 2\n    factors = defaultdict(int)\n    \n    # Handle 2 separately to skip even numbers later\n    while n % 2 == 0:\n        factors[2] += 1\n        n \/\/= 2\n    \n    # Check odd numbers\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            factors[i] += 1\n            n \/\/= i\n        i += 2\n    \n    if n > 1:\n        factors[n] += 1\n    \n    return factors\n\n\ndef mod_inverse(x, mod):\n    \"\"\"Compute modular inverse using Fermat's Little Theorem.\"\"\"\n    return pow(x, mod - 2, mod)\n\n\ndef precompute_factorials(max_n, mod):\n    \"\"\"Precompute factorials and modular inverses up to max_n.\"\"\"\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n    \n    for i in range(2, max_n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    \n    inv_fact[max_n] = mod_inverse(fact[max_n], mod)\n    for i in range(max_n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n    \n    return fact, inv_fact\n\n\n# Input\nN, M = map(int, input().split())\n\n# Precompute factorials and inverses\nmax_value = N + int(ceil(M**0.5))  # Estimate upper bound for factorials\nfact, inv_fact = precompute_factorials(max_value, MOD)\n\n# Prime factorization\nprime_numbers = prime_factors(M)\n\n# Compute result\nresult = 1\nfor value in prime_numbers.values():\n    # Compute binomial coefficient: C(value + N - 1, value)\n    n = value + N - 1\n    k = value\n    binom = fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\n    result = result * binom % MOD\n\nprint(result)"}
{"problem_id":"p03371","slow_code_col":"def main():\n\n    A, B, AB, X, Y = list(map(int, input().split()))\n\n    M = max(X, Y)\n\n\n\n    k = 0\n\n    ans = A * X + B * Y\n\n    while True:\n\n        ans = min(\n\n            ans,\n\n            AB * k * 2 + max(0, X - k) * A + max(0, Y - k) * B\n\n        )\n\n\n\n        if k >= M: break\n\n        k += 1\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def main():\n\n    A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n    ans = 1 << 30\n\n    c = 0  # even\n\n    while True:\n\n        j = c \/\/ 2\n\n        t = A * max(0, X - j) + B * max(0, Y - j) + C * c\n\n        if ans <= t: break\n\n        ans = t\n\n        c += 2\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    # Input parsing\n    A, B, AB, X, Y = map(int, input().split())\n\n    # Initialize the answer with the cost of buying individually\n    ans = A * X + B * Y\n\n    # Determine the range of k based on the smaller of X and Y\n    max_k = min(X, Y)\n\n    # Iterate over possible values of k\n    for k in range(max_k + 1):\n        # Calculate the cost for the current k\n        cost = AB * k * 2 + max(0, X - k) * A + max(0, Y - k) * B\n        # Update the minimum cost\n        ans = min(ans, cost)\n\n    # Output the result\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02245","slow_code_col":"import sys\n\n\n\ninit = ''.join(sys.stdin.read().split())\n\n\n\n# Bidirectional search using breadth-first search\n\ndef solve(start, goal):\n\n    if start == goal:\n\n        return 0\n\n    generated_state = {start: 0, goal: 1}   # 0: foreward, 1: backward\n\n    step = {start: 0, goal: 0}\n\n    s = 0\n\n    c_d = [(start, 0), (goal, 1)] # configure and direction\n\n    while True:\n\n        q = iter(c_d)\n\n        c_d = []\n\n        s += 1\n\n        for c, d in q:\n\n            i = c.find('0')\n\n            if 0 <= i <= 5:\n\n                t = str.maketrans('0' + c[i+3], c[i+3] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n            if i >= 3:\n\n                t = str.maketrans('0' + c[i-3], c[i-3] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n            if i == 0 or i == 1 or i == 3 or i == 4 or i == 6 or i == 7:\n\n                t = str.maketrans('0' + c[i+1], c[i+1] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n            if i == 1 or i == 2 or i == 4 or i == 5 or i == 7 or i == 8:\n\n                t = str.maketrans('0' + c[i-1], c[i-1] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n\n\nprint((solve(init, '123456780')))","reference_code_col":"adjacent = (\n\n    (1, 3),       # 0\n\n    (0, 2, 4),    # 1\n\n    (1, 5),       # 2\n\n    (0, 4, 6),    # 3\n\n    (1, 3, 5, 7), # 4\n\n    (2, 4, 8),    # 5\n\n    (3, 7),       # 6\n\n    (4, 6, 8),    # 7\n\n    (5, 7)        # 8\n\n)\n\n\n\nimport collections\n\n\n\nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n\n\n# Bidirectional search using breadth-first search\n\ndef solve(start):\n\n    if start == GOAL:\n\n        return 0\n\n    # 0: forward, 1: backward\n\n    generated_state = {tuple(start): 0, tuple(GOAL): 1}\n\n    step = {tuple(start): 0, tuple(GOAL): 0}\n\n    s = 0\n\n    state1 = [(start, 0), (GOAL, 1)]\n\n    while state1:\n\n        state2 = state1[:]\n\n        state1 = []\n\n        s += 1\n\n        for s2, d in state2:\n\n            i = s2.index(0)\n\n            for p in adjacent[i]:\n\n                s1 = s2[:]\n\n                s1[i], s1[p] = s1[p], 0\n\n                key = tuple(s1)\n\n                if key in generated_state:\n\n                    if generated_state[key] != d:\n\n                        return s + step[key]\n\n                    continue\n\n                state1.append((s1, d))\n\n                generated_state[key] = d\n\n                step[key] = s\n\n\n\nimport sys\n\n\n\nstart = list(map(int, sys.stdin.read().split()))\n\n\n\nprint((solve(start)))","model_generated_potentially_faster_code_col":"import sys\nfrom collections import deque\n\n# Precompute valid moves for each position of the blank tile (0)\nMOVES = {\n    0: [1, 3],\n    1: [0, 2, 4],\n    2: [1, 5],\n    3: [0, 4, 6],\n    4: [1, 3, 5, 7],\n    5: [2, 4, 8],\n    6: [3, 7],\n    7: [4, 6, 8],\n    8: [5, 7]\n}\n\ndef solve(start, goal):\n    if start == goal:\n        return 0\n\n    # Combined dictionary to store direction and step count\n    state_info = {start: (0, 0), goal: (1, 0)}  # (direction, steps)\n    queue = deque([(start, 0), (goal, 1)])  # (state, direction)\n    steps = 0\n\n    while queue:\n        steps += 1\n        next_queue = deque()\n\n        while queue:\n            current, direction = queue.popleft()\n            i = current.index('0')  # Find the position of '0'\n\n            for move in MOVES[i]:\n                # Swap '0' with the adjacent tile using slicing\n                if i < move:\n                    new_state = current[:i] + current[move] + current[i+1:move] + '0' + current[move+1:]\n                else:\n                    new_state = current[:move] + '0' + current[move+1:i] + current[move] + current[i+1:]\n\n                if new_state in state_info:\n                    prev_direction, prev_steps = state_info[new_state]\n                    if prev_direction != direction:\n                        return steps + prev_steps\n                else:\n                    state_info[new_state] = (direction, steps)\n                    next_queue.append((new_state, direction))\n\n        queue = next_queue\n\n    return -1  # No solution found\n\n# Input handling\ninit = ''.join(sys.stdin.read().split())\nprint(solve(init, '123456780'))"}
{"problem_id":"p03434","slow_code_col":"import numpy as np\n\n\n\nn=int(eval(input()))\n\na_list=list(map(int,input().split()))\n\na_list_2=sorted(a_list,reverse=True)\n\na=np.array(a_list_2,dtype='uint8')\n\n\n\nalice=0\n\nbob=0\n\nfor i in range(n):\n\n\tif i%2==0:\n\n\t\talice+=a[i]\n\n\telse:\n\n\t\tbob+=a[i]\n\n\n\nprint((alice-bob))\n","reference_code_col":"n=int(eval(input()))\n\na=list(map(int,input().split()))\n\na.sort(reverse=True)\n\n\n\nalice=0\n\nbob=0\n\n\n\nfor i in range(n):\n\n    if i%2==0:\n\n        alice+=a[i]\n\n    else:\n\n        bob+=a[i]\n\n        \n\nprint((alice-bob))","model_generated_potentially_faster_code_col":"n = int(input())  # Read the number of elements\na_list = list(map(int, input().split()))  # Read the list of integers\n\n# Sort the list in descending order\na_list.sort(reverse=True)\n\n# Use slicing to calculate sums for Alice and Bob\nalice = sum(a_list[::2])  # Sum of elements at even indices\nbob = sum(a_list[1::2])   # Sum of elements at odd indices\n\n# Print the result\nprint(alice - bob)"}
{"problem_id":"p02837","slow_code_col":"def popcount(x):\n\n  r, q = 0, x\n\n  while x:\n\n    r += 1\n\n    x &= x - 1\n\n  return r, q\n\n \n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [[0, 0] for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y] |= 1 << (x - 1)\n\nl = (1 << n) - 1 \n\nb = sorted(map(popcount, list(range(1, l + 1))))\n\nans = next((i for i, x in reversed(b)\n\n           if all(a[j][0] & x == a[j][1] & l - x == 0 for j in r if x >> j & 1)), 0)\n\nprint(ans)\n","reference_code_col":"from itertools import combinations, count\n\n \n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [(set(), set()) for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y].add(x - 1)\n\nr = next(i for i in count(n, - 1) for x in map(set, combinations(r, i))\n\n         if all(a[j][0].isdisjoint(x) and a[j][1] < x for j in x))\n\nprint(r)\n","model_generated_potentially_faster_code_col":"def popcount(x):\n    return bin(x).count('1'), x"}
{"problem_id":"p02555","slow_code_col":"S = int(eval(input()))\n\nMOD = 10 ** 9 + 7\n\n\n\n#dp[i]\u6700\u5f8c\u306b\u5207\u3063\u305f\u5834\u6240\u304ci\u3000\u30b9\u30bf\u30fc\u30c8\u304c1\u306a\u306e\u306f\u3001\u305d\u3053\u307e\u3067\u306e\u5207\u308a\u65b9\u304c1\u901a\u308a\u306a\u306e\u3067\n\n#\uff13\u4ee5\u4e0b\u306f\u30c0\u30e1\u306a\u306e\u3067\u30013\u500b\u524d\u306e\u7d50\u679c\u3092\u898b\u308b\u3088\u3046\u306b\u3059\u308b\n\ndp =  [0] * (S+1)\n\ndp[0] = 1\n\n\n\nfor i in range(1, S+1):\n\n    #\u305f\u3068\u3048\u3070i=6\u306e\u3068\u304d\u3001i=6\u3067\u521d\u3081\u3066\u5207\u308c\u76ee\u3092\u5165\u308c\u308b\u6642\u3067\uff0b\uff11\u3001i=3\u306b\u5207\u308c\u76ee\u3092\u3044\u308c\u308b\u3068\u304d\u3067\uff0b\uff11\u3067\u5408\u8a08\uff0b\uff12\n\n    for j in range(0, (i-3)+1):\n\n        dp[i] += dp[j]\n\n        dp[i] %= MOD\n\nprint((dp[S]))        ","reference_code_col":"S = int(eval(input()))\n\nMOD = 10 ** 9 + 7\n\n\n\n#dp[i]\u6700\u5f8c\u306b\u5207\u3063\u305f\u5834\u6240\u304ci\u3000\u30b9\u30bf\u30fc\u30c8\u304c1\u306a\u306e\u306f\u3001\u305d\u3053\u307e\u3067\u306e\u5207\u308a\u65b9\u304c1\u901a\u308a\u306a\u306e\u3067\n\n#\uff13\u4ee5\u4e0b\u306f\u30c0\u30e1\u306a\u306e\u3067\u30013\u500b\u524d\u306e\u7d50\u679c\u3092\u898b\u308b\u3088\u3046\u306b\u3059\u308b\n\ndp =  [0] * (S+1)\n\ndp[0] = 1\n\n\n\n#\u3053\u308c\u307e\u3067\u306e\u548c\u3092x\u306b\u4fdd\u5b58\u3057\u3066\u304a\u304f\n\nx = 0\n\nfor i in range(1, S+1):\n\n    if i-3 >= 0:\n\n        x += dp[i-3]\n\n        x %= MOD\n\n    dp[i] = x\n\nprint((dp[S]))        ","model_generated_potentially_faster_code_col":"S = int(eval(input()))\n\nMOD = 10 ** 9 + 7\n\n# dp[i] represents the number of ways to partition the number i\ndp = [0] * (S + 1)\ndp[0] = 1  # Base case: There's one way to partition 0 (do nothing)\n\n# Prefix sum to store cumulative sums of valid states\nprefix_sum = 0\n\nfor i in range(1, S + 1):\n    if i >= 3:\n        prefix_sum += dp[i - 3]\n        prefix_sum %= MOD\n    dp[i] = prefix_sum\n\nprint(dp[S])"}
{"problem_id":"p03634","slow_code_col":"# bellman_ford : O(V E)\n\n# dijkstra : O(E log V), \u8ca0\u8fba\u306f\u7121\u7406\n\n# warshall_floyd : O(V**3)\n\n\n\nimport sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\ninput = sys.stdin.readline\n\n\n\n\n\ndef solve():\n\n    inf = 10 ** 14 + 10\n\n\n\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n\n        for c, t in e[v]:\n\n            if d[t] != inf:\n\n                continue\n\n            d[t] = d[v] + c\n\n            dfs(t)\n\n\n\n    n = int(eval(input()))\n\n    e = tuple(set() for _ in range(n))\n\n    for _ in range(n - 1):\n\n        a, b, c = list(map(int, input().split()))\n\n        a -= 1\n\n        b -= 1\n\n        e[a].add((c, b))\n\n        e[b].add((c, a))\n\n\n\n    q, v = list(map(int, input().split()))\n\n    v -= 1\n\n\n\n    d = [inf] * n\n\n    d[v] = 0\n\n\n\n    dfs(v)\n\n\n\n    for _ in range(q):\n\n        x, y = list(map(int, input().split()))\n\n        x -= 1\n\n        y -= 1\n\n        print((d[x] + d[y]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n","reference_code_col":"# bellman_ford : O(V E)\n\n# dijkstra : O(E log V), \u8ca0\u8fba\u306f\u7121\u7406\n\n# warshall_floyd : O(V**3)\n\n# deque\n\n\n\nfrom collections import deque\n\nimport sys\n\n\n\ninput = sys.stdin.readline\n\n\n\n\n\ndef solve():\n\n    inf = 10 ** 14 + 10\n\n\n\n    n = int(eval(input()))\n\n    e = tuple(set() for _ in range(n))\n\n    for _ in range(n - 1):\n\n        a, b, c = list(map(int, input().split()))\n\n        a -= 1\n\n        b -= 1\n\n        e[a].add((c, b))\n\n        e[b].add((c, a))\n\n\n\n    q, v = list(map(int, input().split()))\n\n    v -= 1\n\n\n\n    d = [inf] * n\n\n    d[v] = 0\n\n\n\n    dq = deque()\n\n    for cost, to in e[v]:\n\n        dq.append((cost, to, v))\n\n        # (cost, to, parent)\n\n\n\n    while dq:\n\n        c, v, p = dq.popleft()\n\n        if d[v] != inf:\n\n            continue\n\n        d[v] = d[p] + c\n\n        for cost, to in e[v]:\n\n            if to == p:\n\n                continue\n\n            dq.append((cost, to, v))\n\n            \n\n    for _ in range(q):\n\n        x, y = list(map(int, input().split()))\n\n        x -= 1\n\n        y -= 1\n\n        print((d[x] + d[y]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n","model_generated_potentially_faster_code_col":"import sys\nfrom collections import deque\n\ndef solve():\n    inf = 10 ** 14 + 10\n\n    # Input parsing\n    n = int(input())\n    e = [[] for _ in range(n)]  # Graph as adjacency list\n    for _ in range(n - 1):\n        a, b, c = map(int, input().split())\n        a -= 1\n        b -= 1\n        e[a].append((c, b))\n        e[b].append((c, a))\n\n    q, v = map(int, input().split())\n    v -= 1\n\n    # Precompute distances using iterative DFS\n    d = [inf] * n\n    d[v] = 0\n    stack = [v]\n    while stack:\n        u = stack.pop()\n        for c, t in e[u]:\n            if d[t] == inf:  # If not visited\n                d[t] = d[u] + c\n                stack.append(t)\n\n    # Process queries\n    for _ in range(q):\n        x, y = map(int, input().split())\n        x -= 1\n        y -= 1\n        print(d[x] + d[y])\n\nif __name__ == '__main__':\n    solve()"}
{"problem_id":"p03634","slow_code_col":"import queue\n\nn = int(eval(input()))\n\n\n\nabc = [[] for i in range(n+1)]\n\n\n\nfor i in range(n-1):\n\n    a,b,c = list(map(int,input().split()))\n\n    abc[a].append([b,c])\n\n    abc[b].append([a,c])\n\n\n\nQ,k = list(map(int,input().split()))\n\nxy = [[int(i) for i in input().split()] for j in range(Q)]\n\n\n\nq = queue.Queue()\n\n\n\nq.put(k)\n\n\n\npath = [-1]*(n+1)\n\npath[k] = 0\n\n\n\nwhile not q.empty():\n\n    tmp = q.get()\n\n    for i in range(len(abc[tmp])):\n\n        #print(abc[tmp])\n\n        #exit()\n\n        num = abc[tmp][i][0]\n\n        if path[num] != -1:\n\n            continue\n\n        else:\n\n            path[num] = path[tmp] + abc[tmp][i][1]\n\n            q.put(num)\n\n            \n\nfor i in range(Q):\n\n    print((path[xy[i][0]]+path[xy[i][1]]))","reference_code_col":"import queue\n\nimport sys\n\nsys.setrecursionlimit(10**7)\n\nn = int(eval(input()))\n\n\n\nabc = [[] for i in range(n+1)]\n\n\n\nfor i in range(n-1):\n\n    a,b,c = list(map(int,input().split()))\n\n    abc[a].append([b,c])\n\n    abc[b].append([a,c])\n\n\n\nQ,k = list(map(int,input().split()))\n\nxy = [[int(i) for i in input().split()] for j in range(Q)]\n\n\n\nq = queue.Queue()\n\n\n\nq.put(k)\n\n\n\npath = [-1]*(n+1)\n\npath[k] = 0\n\n\n\ndef dfs(p):\n\n    for i in range(len(abc[p])):\n\n        num = abc[p][i][0]\n\n        if path[num] != -1:\n\n            continue\n\n        else:\n\n            path[num] = path[p] + abc[p][i][1]\n\n            dfs(num)\n\n\n\ndfs(k)\n\n\n\nfor i in range(Q):\n\n    print((path[xy[i][0]]+path[xy[i][1]]))","model_generated_potentially_faster_code_col":"from collections import deque\n\n# Read input efficiently\nn = int(input())\n\n# Initialize adjacency list\nabc = [[] for _ in range(n + 1)]\n\n# Build the graph\nfor _ in range(n - 1):\n    a, b, c = map(int, input().split())\n    abc[a].append((b, c))\n    abc[b].append((a, c))\n\n# Read query inputs\nQ, k = map(int, input().split())\nxy = [tuple(map(int, input().split())) for _ in range(Q)]\n\n# Perform BFS to compute shortest paths from node k\nq = deque([k])\npath = [-1] * (n + 1)\npath[k] = 0\n\nwhile q:\n    tmp = q.popleft()\n    for neighbor, weight in abc[tmp]:\n        if path[neighbor] == -1:  # Unvisited node\n            path[neighbor] = path[tmp] + weight\n            q.append(neighbor)\n\n# Compute and store results for all queries\nresults = [(path[x] + path[y]) for x, y in xy]\n\n# Print all results at once to reduce I\/O overhead\nprint(\"\\n\".join(map(str, results)))"}
{"problem_id":"p03000","slow_code_col":"#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nimport numpy as np\n\njump = list(np.cumsum(L))\n\nfor j in jump:\n\n    if j <= X:\n\n        cnt+=1\n\n    else:\n\n        break\n\nprint((cnt+1))","reference_code_col":"#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nd = 0\n\n\n\nfor l in L :\n\n    d+=l\n\n    if d <= X:\n\n        cnt+=1\n\n    else:\n\n        break\n\nprint((cnt+1))","model_generated_potentially_faster_code_col":"# Read input values\nN, X = map(int, input().split())\nL = list(map(int, input().split()))\n\n# Initialize variables\ncnt = 0\ncumulative_sum = 0\n\n# Iterate through the list and calculate cumulative sum on the fly\nfor jump in L:\n    cumulative_sum += jump\n    if cumulative_sum <= X:\n        cnt += 1\n    else:\n        break\n\n# Output the result\nprint(cnt + 1)"}
{"problem_id":"p03309","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nlist_ai = list(map(int,input().split()))\n\nlist1 = [x-(i+1) for i,x in enumerate(list_ai)]\n\na1 = np.array(list1)\n\nmedian1 = int(np.floor(np.median(a1)))\n\nans = np.sum(np.abs(a1-median1))\n\nprint(ans)","reference_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nlist_ai = list(map(int,input().split()))\n\na1 = np.array(list_ai)-np.arange(1,N+1)\n\nmedian1 = int(np.floor(np.median(a1)))\n\nans = np.sum(np.abs(a1-median1))\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input parsing\nN = int(input())\nlist_ai = np.array(list(map(int, input().split())))\n\n# Compute transformed array directly using NumPy\na1 = list_ai - np.arange(1, N + 1)\n\n# Calculate the median and convert it to an integer\nmedian1 = int(np.median(a1))\n\n# Compute the sum of absolute differences without creating intermediate arrays\nans = np.sum(np.abs(a1 - median1))\n\n# Output the result\nprint(ans)"}
{"problem_id":"p02394","slow_code_col":"W,H,x,y,r = [int(i) for i in input().split()]\n\nif x - r >= 0 and x + r <= W and y - r >= 0 and y + r <= H:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")","reference_code_col":"W, H, x, y, r = list(map(int, input().split()))\n\nif r <= x <= W-r and r <= y <= H-r:\n\n    print('Yes')\n\nelse:\n\n    print('No')\n","model_generated_potentially_faster_code_col":"W, H, x, y, r = map(int, input().split())\n\nif (r <= x <= W - r) and (r <= y <= H - r):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"problem_id":"p03060","slow_code_col":"# coding: utf-8\n\nimport sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nV = np.array(lr())\n\nC = np.array(lr())\n\nV -= C\n\nV = V[V>0]\n\nanswer = V.sum()\n\nprint(answer)\n","reference_code_col":"# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nV = lr()\n\nC = lr()\n\ntotal = 0\n\nfor i in range(N):\n\n    result = V[i] - C[i]\n\n    if result > 0:\n\n        total += result\n\n\n\nprint(total)\n","model_generated_potentially_faster_code_col":"# coding: utf-8\n\nimport sys\nimport numpy as np\n\n# Input reading functions\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n# Read inputs\nN = ir()\nV = np.array(lr())\nC = np.array(lr())\n\n# Compute answer without creating intermediate arrays\nanswer = sum(v - c for v, c in zip(V, C) if v > c)\n\nprint(answer)"}
{"problem_id":"p03325","slow_code_col":"from math import log2\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\nans = 0\n\n\n\nfor _a in a:\n\n    if _a%2 == 0:\n\n        cnt =0\n\n        while _a%2 == 0:\n\n            _a \/\/= 2\n\n            cnt += 1\n\n        ans += cnt\n\n\n\nprint((int(ans)))","reference_code_col":"def f(k):\n\n    cnt = 0\n\n    while k%2 == 0:\n\n        k \/\/= 2\n\n        cnt += 1\n\n        # print(k)\n\n        # print(\"-----\")\n\n    return cnt\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nans = 0\n\n\n\nfor a in A:\n\n    if a%2 == 0:\n\n        ans += f(a)\n\nprint(ans)","model_generated_potentially_faster_code_col":"from math import log2\n\nn = int(eval(input()))\na = list(map(int, input().split()))\n\nans = 0\n\nfor _a in a:\n    if _a % 2 == 0:  # Check if the number is even\n        # Count trailing zeros in binary representation of _a\n        cnt = (bin(_a)[::-1]).find('1')\n        ans += cnt\n\nprint(ans)"}
{"problem_id":"p02685","slow_code_col":"# coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    n, m, k = list(map(int, args[0].split()))\n\n    mod = 998244353\n\n\n\n    if m == 1 and n-1 == k:\n\n        return str(1)\n\n\n\n    ncr = 1\n\n    p = m*pow(m-1, n-1, mod) % mod\n\n    ret = p\n\n    inv = pow(m-1, mod-2, mod)\n\n    for i in range(1, k+1):\n\n        ncr = (ncr * (n-i)*pow(i, mod-2, mod)) % mod\n\n        p = (p*inv) % mod\n\n        ret += p*ncr % mod\n\n\n\n    return str(ret % mod)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n","reference_code_col":"# coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    n, m, k = list(map(int, args[0].split()))\n\n    mod = 998244353\n\n\n\n    if m == 1 and n-1 == k:\n\n        return str(1)\n\n\n\n    ncr = 1\n\n    p = m*pow(m-1, n-1, mod) % mod\n\n\n\n    ret = p\n\n    iR = [1]*(k+1)\n\n    im = pow(m-1, mod-2, mod)\n\n\n\n    for i in range(1, k+1):\n\n        iR[i] = max(1, (-(mod\/\/i) * iR[mod % i]) % mod)\n\n        ncr = (ncr * (n-i)*iR[i]) % mod\n\n        p = (p*im) % mod\n\n        ret += p*ncr % mod\n\n\n\n    return str(ret % mod)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n","model_generated_potentially_faster_code_col":"# coding: utf-8\n\ndef solve(*args: str) -> str:\n    # Parse input\n    n, m, k = map(int, args[0].split())\n    mod = 998244353\n\n    # Early exit for special case\n    if m == 1 and n - 1 == k:\n        return \"1\"\n\n    # Precompute modular inverses up to k\n    inv = [1] * (k + 1)\n    for i in range(2, k + 1):\n        inv[i] = mod - (mod \/\/ i) * inv[mod % i] % mod\n\n    # Precompute powers of (m-1) modulo mod\n    pow_m_minus_1 = [1] * (n)\n    base = m - 1\n    for i in range(1, n):\n        pow_m_minus_1[i] = pow_m_minus_1[i - 1] * base % mod\n\n    # Compute initial values\n    ncr = 1\n    p = m * pow_m_minus_1[n - 1] % mod\n    ret = p\n\n    # Iterate to compute the result\n    for i in range(1, k + 1):\n        ncr = ncr * (n - i) % mod * inv[i] % mod\n        p = p * inv[m - 1] % mod\n        ret += p * ncr % mod\n\n    return str(ret % mod)\n\n\nif __name__ == \"__main__\":\n    print(solve(*(open(0).read().splitlines())))"}
{"problem_id":"p03828","slow_code_col":"import collections as col\n\n\n\ndef prime(n):\n\n    ans = []\n\n    num = n\n\n    for i in range(2,n+1):\n\n        if i%2==0 and i!=2: continue\n\n        while num%i == 0: num \/\/= i ; ans.append(i)\n\n    return ans\n\n\n\nn = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\nprimes = []\n\nfor i in range(2,n+1): primes += prime(i)\n\n\n\ncnt = col.Counter(primes)\n\nans = 1\n\nfor key,val in list(cnt.items()): ans *= (val + 1) ; ans %= mod\n\nprint(ans)\n","reference_code_col":"import collections as col\n\n\n\ndef prime(n):\n\n    ans = []\n\n    num = n\n\n    for i in range(2,int(n**0.5)+1):\n\n        if i%2==0 and i!=2: continue\n\n        while num%i == 0: num \/\/= i ; ans.append(i)\n\n    if num != 1: ans.append(num)\n\n    return ans\n\n\n\nn = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\nprimes = []\n\nfor i in range(2,n+1): primes += prime(i)\n\n\n\ncnt = col.Counter(primes)\n\nans = 1\n\nfor key,val in list(cnt.items()): ans *= (val + 1) ; ans %= mod\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import collections as col\n\ndef sieve_of_eratosthenes(n):\n    \"\"\"Generate all prime numbers up to n using the Sieve of Eratosthenes.\"\"\"\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n + 1, i):\n                is_prime[j] = False\n    return [i for i in range(n + 1) if is_prime[i]]\n\ndef legendre_formula(n, p):\n    \"\"\"Calculate the power of prime p in n! using Legendre's formula.\"\"\"\n    power = 0\n    while n >= p:\n        n \/\/= p\n        power += n\n    return power\n\ndef optimized_factorial_divisors(n, mod):\n    \"\"\"Calculate the number of divisors of n! modulo mod.\"\"\"\n    # Step 1: Generate all primes up to n using the Sieve of Eratosthenes\n    primes = sieve_of_eratosthenes(n)\n    \n    # Step 2: Count the power of each prime in n!\n    cnt = col.Counter()\n    for p in primes:\n        cnt[p] = legendre_formula(n, p)\n    \n    # Step 3: Calculate the number of divisors using the formula\n    ans = 1\n    for val in cnt.values():\n        ans = (ans * (val + 1)) % mod\n    \n    return ans\n\n# Input and Output\nn = int(input())\nmod = 10**9 + 7\nprint(optimized_factorial_divisors(n, mod))"}
{"problem_id":"p02794","slow_code_col":"import sys\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    E = [[] for _ in range(N)]\n\n    for i in range(N-1):\n\n        a, b = list(map(int, input().split()))\n\n        a, b = a-1, b-1\n\n        E[a].append((b,i))\n\n        E[b].append((a,i))\n\n    \n\n    def dfs(s, g):\n\n        par = [(-1,-1)] * N\n\n        par[s] = (s,-1)\n\n        stack = [s]\n\n        while stack:\n\n            v = stack.pop()\n\n            for to, i in E[v]:\n\n                if par[to][0] >= 0: continue\n\n                par[to] = (v, i)\n\n                if to == g: break\n\n                stack.append(to)\n\n        r = set()\n\n        v = g\n\n        while v != s:\n\n            v, i = par[v]\n\n            r.add(i)\n\n        return r\n\n    \n\n    M = int(eval(input()))\n\n    path = [None] * M\n\n    for i in range(M):\n\n        u, v = list(map(int, input().split()))\n\n        u, v = u-1, v-1\n\n        path[i] = dfs(u, v)\n\n\n\n    def calc(s): return 1<<(N-1-len(s))\n\n\n\n    i_ans = 0\n\n    for p in range(1, 1<<M):\n\n        is_odd = bin(p).count('1') & 1\n\n        s = set()\n\n        for i in range(M):\n\n            if p&1: s |= path[i]\n\n            p >>= 1\n\n        if is_odd: i_ans += calc(s)\n\n        else: i_ans -= calc(s)\n\n\n\n    print(((1<<(N-1)) - i_ans))\n\n\n\nif __name__ == '__main__':\n\n    main()","reference_code_col":"import sys\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    E = [[] for _ in range(N)]\n\n    for i in range(N-1):\n\n        a, b = list(map(int, input().split()))\n\n        a, b = a-1, b-1\n\n        E[a].append((b,i))\n\n        E[b].append((a,i))\n\n    \n\n    def dfs(s, g):\n\n        par = [(-1,-1)] * N\n\n        par[s] = (s,-1)\n\n        stack = [s]\n\n        while stack:\n\n            v = stack.pop()\n\n            for to, i in E[v]:\n\n                if par[to][0] >= 0: continue\n\n                par[to] = (v, i)\n\n                if to == g: break\n\n                stack.append(to)\n\n        r = set()\n\n        v = g\n\n        while v != s:\n\n            v, i = par[v]\n\n            r.add(i)\n\n        return r\n\n    \n\n    M = int(eval(input()))\n\n    path = [None] * M\n\n    for i in range(M):\n\n        u, v = list(map(int, input().split()))\n\n        u, v = u-1, v-1\n\n        path[i] = dfs(u, v)\n\n\n\n    def calc(s): return 1<<(N-1-len(s))\n\n\n\n    i_ans = 0\n\n    for p in range(1, 1<<M):\n\n        is_odd = 0\n\n        s = set()\n\n        for i in range(M):\n\n            if p&1:\n\n                s |= path[i]\n\n                is_odd ^= 1\n\n            p >>= 1\n\n        if is_odd: i_ans += calc(s)\n\n        else: i_ans -= calc(s)\n\n\n\n    print(((1<<(N-1)) - i_ans))\n\n\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.readline\n\n    # Parse input\n    N = int(input())\n    E = [[] for _ in range(N)]\n\n    for i in range(N - 1):\n        a, b = map(int, input().split())\n        a, b = a - 1, b - 1\n        E[a].append((b, i))\n        E[b].append((a, i))\n\n    # Precompute all paths using BFS\n    def bfs(s):\n        par = [(-1, -1)] * N\n        par[s] = (s, -1)\n        queue = deque([s])\n        while queue:\n            v = queue.popleft()\n            for to, i in E[v]:\n                if par[to][0] == -1:\n                    par[to] = (v, i)\n                    queue.append(to)\n        return par\n\n    # Precompute paths for all pairs of nodes\n    parent_map = [bfs(i) for i in range(N)]\n    path_cache = {}\n\n    def get_path(u, v):\n        if (u, v) in path_cache:\n            return path_cache[(u, v)]\n        r = set()\n        while u != v:\n            if parent_map[u][0] == -1:  # No path exists\n                return None\n            u, i = parent_map[u]\n            r.add(i)\n        path_cache[(u, v)] = r\n        return r\n\n    M = int(input())\n    paths = []\n    for _ in range(M):\n        u, v = map(int, input().split())\n        u, v = u - 1, v - 1\n        paths.append(get_path(u, v))\n\n    # Precompute parity of set bits for all p\n    max_p = 1 << M\n    parity = [bin(p).count('1') & 1 for p in range(max_p)]\n\n    # Main computation\n    calc = lambda s: 1 << (N - 1 - len(s))\n    i_ans = 0\n\n    for p in range(1, max_p):\n        s = set()\n        temp_p = p\n        for i in range(M):\n            if temp_p & 1:\n                s.update(paths[i])\n            temp_p >>= 1\n        if parity[p]:\n            i_ans += calc(s)\n        else:\n            i_ans -= calc(s)\n\n    print(((1 << (N - 1)) - i_ans))\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02612","slow_code_col":"'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n#mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile = 0\n\n\n\ndef solve():\n\n    \n\n\n\n\n\n\n\n    # for _ in range(ii()):\n\n\n\n    n=ii()\n\n    n%=1000\n\n    if n!=0:\n\n        n=1000-n\n\n    print(n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()","reference_code_col":"'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom heapq import heappush,heappop\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n# mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile=0\n\n\n\n\n\n\n\n\n\n\n\ndef solve():\n\n\n\n\n\n    # for _ in range(ii()):\n\n    \n\n        \n\n\n\n    n=ii()\n\n    n%=1000\n\n    if(n!=0):\n\n        n=1000-n\n\n    print(n)\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()\n","model_generated_potentially_faster_code_col":"def solve():\n    # Read input as an integer\n    n = int(input())\n    \n    # Compute n modulo 1000\n    n %= 1000\n    \n    # If n is not zero, calculate the difference to reach the next multiple of 1000\n    if n != 0:\n        n = 1000 - n\n    \n    # Output the result\n    print(n)\n\nif __name__ == \"__main__\":\n    solve()"}
{"problem_id":"p02685","slow_code_col":"M=998244353\n\nn,m,k=list(map(int,input().split()))\n\na=0\n\nc=1\n\nfor i in range(k+1):\n\n  a+=c*m*pow(m-1,n-i-1,M)\n\n  c=c*(n-i-1)*pow(i+1,M-2,M)%M\n\nprint((a%M))","reference_code_col":"M=998244353\n\nn,m,k=list(map(int,input().split()))\n\na,c=0,1\n\nfor i in range(k+1):\n\n  a+=c*m*pow(m-1,n+~i,M)\n\n  c=c*(n+~i)*pow(i+1,-1,M)%M\n\nprint((a%M))","model_generated_potentially_faster_code_col":"M = 998244353\n\n# Input values\nn, m, k = map(int, input().split())\n\n# Precompute factorials and modular inverses\nfactorial = [1] * (n + 1)\nfor i in range(1, n + 1):\n    factorial[i] = factorial[i - 1] * i % M\n\nmodinv = [1] * (n + 1)\nmodinv[n] = pow(factorial[n], M - 2, M)  # Fermat's Little Theorem\nfor i in range(n - 1, -1, -1):\n    modinv[i] = modinv[i + 1] * (i + 1) % M\n\n# Function to compute binomial coefficient C(n, r) % M\ndef binomial_coefficient(n, r):\n    if r < 0 or r > n:\n        return 0\n    return factorial[n] * modinv[r] % M * modinv[n - r] % M\n\n# Precompute powers of (m-1)\npowers = [1] * (k + 1)\nfor i in range(1, k + 1):\n    powers[i] = powers[i - 1] * (m - 1) % M\n\n# Main computation\na = 0\nfor i in range(k + 1):\n    coeff = binomial_coefficient(n - 1, i)\n    term = coeff * m % M * powers[k - i] % M\n    a = (a + term) % M\n\nprint(a)"}
{"problem_id":"p03680","slow_code_col":"N = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\ncnt, i = 0, 0\n\nfor j in range(10 ** 6):\n\n    cnt += 1\n\n    if a[i] == 2:\n\n        print(cnt)\n\n        #break\n\n        quit()\n\n    else:\n\n        i = a[i] - 1\n\nprint((-1))","reference_code_col":"N = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\ncnt, i = 0, 0\n\nfor j in range(len(a)):\n\n    cnt += 1\n\n    if a[i] == 2:\n\n        print(cnt)\n\n        #break\n\n        quit()\n\n    else:\n\n        i = a[i] - 1\n\nprint((-1))","model_generated_potentially_faster_code_col":"# Input reading\nN = int(input())\na = [int(input()) for _ in range(N)]\n\n# Initialize variables\ncnt, i = 0, 0\nvisited = set()  # To detect cycles\n\nwhile cnt < 10**6:  # Limit iterations to avoid infinite loops\n    cnt += 1\n\n    if a[i] == 2:\n        print(cnt)\n        exit()  # Terminate the program immediately\n    elif i in visited:\n        # Cycle detected, terminate with -1\n        print(-1)\n        exit()\n    \n    # Mark current index as visited and move to the next index\n    visited.add(i)\n    i = a[i] - 1\n\n# If loop completes without finding `a[i] == 2`\nprint(-1)"}
{"problem_id":"p02555","slow_code_col":"import math\n\n\n\n\n\ndef combinations_count(n, r):\n\n    return math.factorial(n) \/\/ (math.factorial(n - r) * math.factorial(r))\n\n\n\n\n\ndef combinations_with_replacement_count(n, r):\n\n    return combinations_count(n + r - 1, r)\n\n\n\n\n\ndef main():\n\n    s = int(eval(input()))\n\n    ans = 0\n\n    n = s \/\/ 3\n\n\n\n    for i in range(1, n + 1):\n\n        ans += combinations_with_replacement_count(i, 3*(n-i)+s % 3)\n\n\n\n    print((ans % (10**9 + 7)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def main():\n\n    s = int(eval(input()))\n\n    dp = [0] * 3 + [1] * 3 + [0 for _ in range(s)]\n\n\n\n    for i in range(6, s+1):\n\n        dp[i] = dp[i-1] + dp[i-3]\n\n\n\n    print((dp[s] % (10**9+7)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\ndef precompute_factorials_and_inverses(max_n, mod):\n    \"\"\"Precompute factorials and modular inverses up to max_n.\"\"\"\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n    \n    # Compute factorials\n    for i in range(2, max_n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    \n    # Compute modular inverses of factorials using Fermat's Little Theorem\n    inv_fact[max_n] = pow(fact[max_n], mod - 2, mod)\n    for i in range(max_n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n    \n    return fact, inv_fact\n\ndef combinations_count(n, r, fact, inv_fact, mod):\n    \"\"\"Efficiently compute nCr using precomputed factorials and inverses.\"\"\"\n    if r < 0 or r > n:\n        return 0\n    return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n\ndef main():\n    s = int(input())\n    n = s \/\/ 3\n    max_n = n + 3 * n + s % 3  # Maximum possible value for n in combinations\n    fact, inv_fact = precompute_factorials_and_inverses(max_n, MOD)\n    \n    ans = 0\n    for i in range(1, n + 1):\n        r = 3 * (n - i) + s % 3\n        ans = (ans + combinations_count(i + r - 1, r, fact, inv_fact, MOD)) % MOD\n    \n    print(ans)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03806","slow_code_col":"G_MAX = 40*10\n\nN_MAX = 40\n\nINF = float('inf')\n\n\n\ndp = [[[INF]*(G_MAX+1) for _ in range(G_MAX+1)] \n\n      for _ in range(N_MAX+1)]\n\nN,Ma,Mb = list(map(int, input().split()))\n\na,b,c = [],[],[]\n\nfor _ in range(N):\n\n    ai,bi,ci = list(map(int, input().split()))\n\n    a.append(ai)\n\n    b.append(bi)\n\n    c.append(ci)\n\n\n\ndp[0][0][0] = 0\n\nfrom math import isinf\n\nfor i in range(N):\n\n    for ca in range(G_MAX+1):\n\n        for cb in range(G_MAX+1):\n\n            if isinf(dp[i][ca][cb]): continue\n\n            dp[i+1][ca][cb] = min(dp[i+1][ca][cb],\n\n                                 dp[i][ca][cb])\n\n            dp[i+1][ca+a[i]][cb+b[i]] = min(dp[i+1][ca+a[i]][cb+b[i]],\n\n                                           dp[i][ca][cb]+c[i])\n\n            \n\n    \n\nans = INF\n\nfor ca in range(1,G_MAX+1):\n\n    for cb in range(1,G_MAX+1):\n\n        if ca*Mb==cb*Ma:\n\n            ans = min(ans, dp[N][ca][cb])\n\n            \n\nif isinf(ans): ans = -1\n\nprint(ans)","reference_code_col":"from math import isinf\n\n\n\nN, Ma, Mb = list(map(int, input().split()))\n\na = [0]*N\n\nb = [0]*N\n\nc = [0]*N\n\nfor i in range(N):\n\n    a[i],b[i],c[i] = list(map(int, input().split()))\n\n\n\nW_MAX = 40*10\n\ndp = [[float('inf')]*(W_MAX+1) for _ in range(W_MAX+1)]\n\ndp[0][0] = 0\n\n\n\nfor i in range(N):\n\n    for wa in reversed(list(range(W_MAX+1))):\n\n        for wb in reversed(list(range(W_MAX+1))):\n\n            if isinf(dp[wa][wb]): continue\n\n            if wa+a[i]<=W_MAX and wb+b[i]<=W_MAX:\n\n                dp[wa+a[i]][wb+b[i]] = min(dp[wa+a[i]][wb+b[i]],\n\n                                           dp[wa][wb]+c[i])\n\n\n\nans = float('inf')\n\nfor wa in range(1, W_MAX+1):\n\n    for wb in range(1, W_MAX+1):\n\n        if wa*Mb == wb*Ma:\n\n            ans = min(ans, dp[wa][wb])\n\n\n\nif isinf(ans): ans = -1\n\nprint(ans)","model_generated_potentially_faster_code_col":"from collections import defaultdict\nfrom math import gcd\n\n# Input\nN, Ma, Mb = map(int, input().split())\nitems = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Normalize the ratio Ma:Mb to avoid floating-point precision issues\ng = gcd(Ma, Mb)\nMa \/\/= g\nMb \/\/= g\n\n# Initialize dp as a dictionary to store only valid states\ndp = defaultdict(lambda: float('inf'))\ndp[(0, 0)] = 0  # Initial state: (cost_a, cost_b) = (0, 0)\n\n# Process each item\nfor ai, bi, ci in items:\n    next_dp = defaultdict(lambda: float('inf'))\n    for (ca, cb), cost in dp.items():\n        # Option 1: Do not take the current item\n        next_dp[(ca, cb)] = min(next_dp[(ca, cb)], cost)\n        \n        # Option 2: Take the current item\n        new_ca, new_cb = ca + ai, cb + bi\n        next_dp[(new_ca, new_cb)] = min(next_dp[(new_ca, new_cb)], cost + ci)\n    \n    dp = next_dp\n\n# Find the minimum cost for valid (ca, cb) pairs\nans = float('inf')\nfor (ca, cb), cost in dp.items():\n    if ca > 0 and cb > 0 and ca * Mb == cb * Ma:\n        ans = min(ans, cost)\n\n# Output the result\nprint(-1 if ans == float('inf') else ans)"}
{"problem_id":"p03568","slow_code_col":"from itertools import product\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\ncount = 0\n\nfor C in product((-1, 0, 1), repeat=n):\n\n  total = 1\n\n  for a, c in zip(A, C):\n\n    total *= (a + c)\n\n  if total % 2 == 0:\n\n    count += 1\n\nprint(count)","reference_code_col":"n = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\ncount = 1\n\nfor a in A:\n\n  count *= 2 if a % 2 == 0 else 1\n\nprint((3 ** n - count))","model_generated_potentially_faster_code_col":"n = int(input())\nA = list(map(int, input().split()))\n\n# Initialize DP table\n# dp[i][p] = number of ways to make the product have parity p after i elements\ndp = [[0, 0] for _ in range(n + 1)]\ndp[0][1] = 1  # Base case: empty product is odd\n\nfor i in range(1, n + 1):\n    a = A[i - 1]\n    even_ways = 0\n    odd_ways = 0\n    \n    # Count how many choices of c make (a + c) even or odd\n    for c in (-1, 0, 1):\n        if (a + c) % 2 == 0:\n            even_ways += 1\n        else:\n            odd_ways += 1\n    \n    # Update DP table\n    dp[i][0] = dp[i - 1][0] * 3 + dp[i - 1][1] * even_ways\n    dp[i][1] = dp[i - 1][1] * odd_ways\n\nprint(dp[n][0])"}
{"problem_id":"p03164","slow_code_col":"import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n,W=list(map(int,input().split()))\n\n    WV=[tuple(map(int,input().split())) for _ in range(n)]\n\n\n\n    V=100000\n\n    dp=[INF]*(V+1)\n\n    dp[0]=0\n\n\n\n    for w,v in WV:\n\n        for x in range(V,-1,-1):\n\n            if(x+v<=V):\n\n                dp[x+v]=min(dp[x+v],dp[x]+w)\n\n\n\n    for x in range(V,-1,-1):\n\n        if(dp[x]<=W):\n\n            print(x)\n\n            return\n\nresolve()","reference_code_col":"import sys\n\nINF = 1 << 60\n\nMOD = 10**9 + 7 # 998244353\n\nsys.setrecursionlimit(2147483647)\n\ninput = lambda:sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n, W = list(map(int, input().split()))\n\n    dp = [INF] * (n * 1001 + 1)\n\n    dp[0] = 0\n\n    for _ in range(n):\n\n        w, v = list(map(int, input().split()))\n\n        for v0 in range(n * 1001, -1, -1):\n\n            if dp[v0] == INF:\n\n                continue\n\n            if v + v0 <= n * 1001:\n\n                dp[v + v0] = min(dp[v + v0], dp[v0] + w)\n\n    for v in range(n * 1001, -1, -1):\n\n        if dp[v] <= W:\n\n            print(v)\n\n            return\n\nresolve()","model_generated_potentially_faster_code_col":"for w, v in WV:\n         for x in range(V, -1, -1):\n             if x + v <= V:\n                 dp[x + v] = min(dp[x + v], dp[x] + w)"}
{"problem_id":"p02691","slow_code_col":"from collections import defaultdict\n\n\n\n\n\ndef main():\n\n    _ = int(eval(input()))\n\n    heights = list(map(int, input().split()))\n\n\n\n    \"\"\"\n\n    for j>i, j-i = Ai + Aj\n\n    i + Ai = j -Aj\n\n    \"\"\"\n\n\n\n    L = defaultdict(int)\n\n    R = defaultdict(int)\n\n\n\n    for i, height in enumerate(heights):\n\n        L[i + height] += 1\n\n        R[i - height] += 1\n\n\n\n    total_count = 0\n\n    for x, count_l in list(L.items()):\n\n        if x in R:\n\n            count_r = R[x]\n\n            total_count += count_l * count_r\n\n\n\n    print(total_count)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"from collections import defaultdict\n\n\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    heights = list(map(int, input().split()))\n\n\n\n    \"\"\"\n\n    for j>i, j-i = Ai + Aj\n\n    i + Ai = j -Aj\n\n    \"\"\"\n\n\n\n    L = defaultdict(int)\n\n    R = defaultdict(int)\n\n\n\n    for i, height in enumerate(heights):\n\n        if i + height < N:\n\n            L[i + height] += 1\n\n        \n\n        if i - height > 0:\n\n            R[i - height] += 1\n\n\n\n    total_count = 0\n\n    for x, count_l in list(L.items()):\n\n        if x in R:\n\n            count_r = R[x]\n\n            total_count += count_l * count_r\n\n\n\n    print(total_count)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"from collections import defaultdict\n\ndef main():\n    # Read input efficiently\n    _ = int(input())  # Number of elements (not used)\n    heights = list(map(int, input().split()))\n\n    # Use a single dictionary to track counts of i + height and i - height\n    count_map = defaultdict(int)\n\n    total_count = 0\n\n    # Iterate through the heights array\n    for i, height in enumerate(heights):\n        # Check if the current key (i - height) exists in the map\n        total_count += count_map[i - height]\n        \n        # Update the map with the current key (i + height)\n        count_map[i + height] += 1\n\n    # Print the result\n    print(total_count)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03039","slow_code_col":"import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)\/\/2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)\/\/2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        a = n-x+1\n\n        b = m-y+1\n\n        c = m*(a*(a-1)+x*(x-1))\n\n        d = n*(b*(b-1)+y*(y-1))\n\n        ans += (c+d)\/\/2\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n","reference_code_col":"import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\nans = m*n*(m+n)*(m*n-1)\/\/3\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n","model_generated_potentially_faster_code_col":"# Precompute factorials and modular inverses\nMAX = m * n + 1\nfact = [1] * MAX\ninv_fact = [1] * MAX\n\nfor i in range(2, MAX):\n    fact[i] = fact[i - 1] * i % mod\n\ninv_fact[MAX - 1] = pow(fact[MAX - 1], mod - 2, mod)\nfor i in range(MAX - 2, 0, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\ndef comb(n, r, mod):\n    if r < 0 or r > n:\n        return 0\n    return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod"}
{"problem_id":"p03253","slow_code_col":"N,M = list(map(int,input().split()))\n\ndiv =[]\n\nfor i in range(2,int(M**(1\/2))+2):\n\n    cur = 0\n\n    while M%i==0:\n\n        M = M\/\/i\n\n        cur += 1\n\n    if cur >=1:\n\n        div.append(cur)\n\nif M>1: div.append(1)\n\ndiv.sort()\n\nmod = 10**9+7\n\nfrac = [1]*(N+50)\n\nnum = len(frac)\n\nfor i in range(len(frac)-1):\n\n    frac[i+1] = frac[i]*(i+1)%mod\n\nfinv = [1] * (N+50)\n\nfinv[-1] = pow(frac[-1], mod-2, mod)\n\nfor i in range(1, num):\n\n  finv[num-1-i] = finv[num-i] * (num-i) % mod\n\nans = 1\n\nfor i in div:\n\n    ans = ans * frac[N+i-1]*finv[N-1]*finv[i]%mod\n\nprint(ans)","reference_code_col":"N,M = list(map(int,input().split()))\n\ndiv = []\n\nfor i in range(2,int(M**(1\/2))+2):\n\n    cur = 0\n\n    while M%i==0:\n\n        M\/\/=i\n\n        cur += 1\n\n    if cur >=1:\n\n        div.append(cur)\n\nif M>1:div.append(1)\n\ndiv.sort()\n\nmod = 10**9+7\n\nfrac = [1]*(N+50)\n\nnum=len(frac)\n\nfor i in range(num-1):\n\n    frac[i+1] = frac[i]*(i+1)%mod\n\nfinv = [1]*(N+50)\n\nfinv[-1] = pow(frac[-1],mod-2,mod)\n\nans = 1\n\nfor i in range(1,num):\n\n    finv[num-1-i] = finv[num-i]*(num-i)%mod\n\nfor i in div:\n\n    ans  =ans*frac[N+i-1]*finv[N-1]*finv[i]%mod\n\nprint(ans)","model_generated_potentially_faster_code_col":"div = []\ni = 2\n\n# Check divisibility by 2 separately\ncur = 0\nwhile M % i == 0:\n    M \/\/= i\n    cur += 1\nif cur >= 1:\n    div.append(cur)\n\n# Check odd numbers starting from 3\ni = 3\nwhile i * i <= M:\n    cur = 0\n    while M % i == 0:\n        M \/\/= i\n        cur += 1\n    if cur >= 1:\n        div.append(cur)\n    i += 2\n\n# If M is still greater than 1, it's a prime number\nif M > 1:\n    div.append(1)"}
{"problem_id":"p03371","slow_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(c_max+1):\n\n  ac = x - (cc \/\/ 2)\n\n  bc = y - (cc \/\/ 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)","reference_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(0, c_max+1, 2):\n\n  ac = x - (cc \/\/ 2)\n\n  bc = y - (cc \/\/ 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)\n\n  ","model_generated_potentially_faster_code_col":"# Input parsing\na, b, c, x, y = map(int, input().split())\n\n# Initialize answer to a large value\nans = float('inf')\n\n# Determine the maximum range for cc\nc_max = 2 * max(x, y)\n\n# Iterate over valid cc values\nfor cc in range(c_max + 1):\n    # Calculate ac and bc directly, ensuring they are non-negative\n    ac = max(0, x - (cc \/\/ 2))\n    bc = max(0, y - (cc \/\/ 2))\n    \n    # Compute the price for this combination\n    price = ac * a + bc * b + cc * c\n    \n    # Update the minimum price\n    ans = min(ans, price)\n\n# Output the result\nprint(ans)"}
{"problem_id":"p02899","slow_code_col":"n = int(eval(input()))\n\na = list(map(int,input().split()))\n\nans = [i for i in range(n)]\n\na1 = sorted(a)\n\nfor i in range(n):\n\n    num = a[i]\n\n    ans[num - 1] = str(i + 1)\n\n    \n\nprint((' '.join(ans)))","reference_code_col":"n = int(eval(input()))\n\n# n,k = map(int,input().split())\n\na = list(map(int,input().split()))\n\nans = [0 for _ in range(n)]\n\nfor i in range(n):\n\n  ans[a[i] - 1] = str(i + 1)\n\nprint((\" \".join(ans)))","model_generated_potentially_faster_code_col":"n = int(input())  # Read input without eval for safety and performance\na = list(map(int, input().split()))\n\n# Pair each element with its original index\nindexed_a = list(enumerate(a))\n\n# Sort the array based on values while keeping track of original indices\nsorted_indexed_a = sorted(indexed_a, key=lambda x: x[1])\n\n# Create the answer list by assigning ranks based on sorted order\nans = [str(sorted_indexed_a[i][0] + 1) for i in range(n)]\n\n# Print the result as a space-separated string\nprint(' '.join(ans))"}
{"problem_id":"p02574","slow_code_col":"class prime_factorize_by_osa_k():\n\n    def __init__(self, max_val):\n\n        '''\n\n        \u5272\u308b\u3053\u3068\u304c\u51fa\u6765\u308b\u6700\u5c0f\u306e\u5024\u3092\u683c\u7d0d\u3057\u305f\u30ea\u30b9\u30c8\u3092\u8fd4\u3059\n\n        :param max_val:\n\n        :return:\n\n        '''\n\n        self.minFactor = [-1] * (max_val + 1)\n\n        for i in range(2, max_val + 1):\n\n            if self.minFactor[i] == -1:\n\n                self.minFactor[i] = i\n\n                # \u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\u3068\u540c\u69d8\u306e\u51e6\u7406\u3092\u884c\u3046\n\n                for j in range(i * i, max_val + 1, i):\n\n                    if self.minFactor[j] == -1:\n\n                        self.minFactor[j] = i\n\n\n\n    def osa_k(self, n):\n\n        '''\n\n        preprocess\u3092\u3057\u305f\u3042\u3068\u3001O(logN)\u3067\u7d20\u56e0\u6570\u5206\u89e3\u3092\u884c\u3046\u3002n\u306e\u6700\u5927\u5024\u3092n_max\u3068\u3059\u308b\u3002\n\n        :param n:\n\n        :return:\n\n        '''\n\n        from collections import defaultdict\n\n        d = defaultdict(int)\n\n        now = n\n\n        while now > 1:\n\n            d[self.minFactor[now]] += 1\n\n            now \/\/= self.minFactor[now]\n\n        return d\n\ndef gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# N = 10 ** 6\n\n# A = [10 ** 6] * N\n\nob = prime_factorize_by_osa_k(10 ** 6)\n\npairwise = False\n\nprime_key = set(ob.osa_k(A[-1]).keys())\n\nbreak_flag = False\n\nprime_flags = [False] * (10 ** 6 + 1)\n\nfor i in range(N):\n\n    for key in list(ob.osa_k(A[i]).keys()):\n\n        if prime_flags[key]:\n\n            break_flag = True\n\n            break\n\n        else:\n\n            prime_flags[key] = True\n\n    if break_flag:\n\n        break\n\nelse:\n\n    pairwise = True\n\nif pairwise:\n\n    print('pairwise coprime')\n\n    exit()\n\nwork = gcd(A[0], A[1])\n\nfor i in range(2, N):\n\n    work = gcd(work, A[i])\n\nif work != 1:\n\n    print('not coprime')\n\nelse:\n\n    print('setwise coprime')","reference_code_col":"def gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\ndef isPrimeMR(n):\n\n    d = n - 1\n\n    d = d \/\/ (d & -d)\n\n    L = [2]\n\n    for a in L:\n\n        t = d\n\n        y = pow(a, t, n)\n\n        if y == 1: continue\n\n        while y != n - 1:\n\n            y = (y * y) % n\n\n            if y == 1 or t == n - 1: return 0\n\n            t <<= 1\n\n    return 1\n\ndef findFactorRho(n):\n\n    m = 1 << n.bit_length() \/\/ 8\n\n    for c in range(1, 99):\n\n        f = lambda x: (x * x + c) % n\n\n        y, r, q, g = 2, 1, 1, 1\n\n        while g == 1:\n\n            x = y\n\n            for i in range(r):\n\n                y = f(y)\n\n            k = 0\n\n            while k < r and g == 1:\n\n                ys = y\n\n                for i in range(min(m, r - k)):\n\n                    y = f(y)\n\n                    q = q * abs(x - y) % n\n\n                g = gcd(q, n)\n\n                k += m\n\n            r <<= 1\n\n        if g == n:\n\n            g = 1\n\n            while g == 1:\n\n                ys = f(ys)\n\n                g = gcd(abs(x - ys), n)\n\n        if g < n:\n\n            if isPrimeMR(g): return g\n\n            elif isPrimeMR(n \/\/ g): return n \/\/ g\n\n            return findFactorRho(g)\n\ndef primeFactor(n):\n\n    i = 2\n\n    ret = {}\n\n    rhoFlg = 0\n\n    while i*i <= n:\n\n        k = 0\n\n        while n % i == 0:\n\n            n \/\/= i\n\n            k += 1\n\n        if k: ret[i] = k\n\n        i += 1 + i % 2\n\n        if i == 101 and n >= 2 ** 20:\n\n            while n > 1:\n\n                if isPrimeMR(n):\n\n                    ret[n], n = 1, 1\n\n                else:\n\n                    rhoFlg = 1\n\n                    j = findFactorRho(n)\n\n                    k = 0\n\n                    while n % j == 0:\n\n                        n \/\/= j\n\n                        k += 1\n\n                    ret[j] = k\n\n\n\n    if n > 1: ret[n] = 1\n\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n\n    return ret\n\ndef gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# N = 10 ** 6\n\n# A = [10 ** 6] * N\n\npairwise = False\n\nprime_key = set(primeFactor(A[-1]).keys())\n\nbreak_flag = False\n\nprime_flags = [False] * (10 ** 6 + 1)\n\nfor i in range(N):\n\n    for key in list(primeFactor(A[i]).keys()):\n\n        if prime_flags[key]:\n\n            break_flag = True\n\n            break\n\n        else:\n\n            prime_flags[key] = True\n\n    if break_flag:\n\n        break\n\nelse:\n\n    pairwise = True\n\nif pairwise:\n\n    print('pairwise coprime')\n\n    exit()\n\nwork = gcd(A[0], A[1])\n\nfor i in range(2, N):\n\n    work = gcd(work, A[i])\n\nif work != 1:\n\n    print('not coprime')\n\nelse:\n\n    print('setwise coprime')","model_generated_potentially_faster_code_col":"import sys\nfrom collections import defaultdict\n\nclass PrimeFactorizer:\n    def __init__(self, max_val):\n        # Initialize smallest prime factor array\n        self.minFactor = list(range(max_val + 1))\n        for i in range(2, max_val + 1):\n            if self.minFactor[i] == i:  # i is a prime\n                for j in range(i * 2, max_val + 1, i):\n                    if self.minFactor[j] == j:  # Update only if not set\n                        self.minFactor[j] = i\n\n    def factorize(self, n):\n        # Factorize n using precomputed minFactor\n        factors = defaultdict(int)\n        while n > 1:\n            factors[self.minFactor[n]] += 1\n            n \/\/= self.minFactor[n]\n        return factors\n\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n\n# Fast input reading\ninput = sys.stdin.readline\nN = int(input())\nA = list(map(int, input().split()))\n\n# Precompute factorizations for all elements in A\nmax_val = 10**6\nfactorizer = PrimeFactorizer(max_val)\nfactorizations = [factorizer.factorize(a) for a in A]\n\n# Check pairwise coprime\npairwise = True\nprime_flags = [False] * (max_val + 1)\n\nfor factors in factorizations:\n    for prime in factors.keys():\n        if prime_flags[prime]:\n            pairwise = False\n            break\n        prime_flags[prime] = True\n    if not pairwise:\n        break\n\nif pairwise:\n    print('pairwise coprime')\n    exit()\n\n# Check setwise coprime\nwork = A[0]\nfor i in range(1, N):\n    work = gcd(work, A[i])\n    if work == 1:\n        break\n\nif work != 1:\n    print('not coprime')\nelse:\n    print('setwise coprime')"}
{"problem_id":"p02901","slow_code_col":"INF = 2*10**7\n\n\n\n\n\ndef main():\n\n    N, M = (int(i) for i in input().split())\n\n    A = []\n\n    B = []\n\n    C = []\n\n    for _ in range(M):\n\n        a, b = (int(i) for i in input().split())\n\n        A.append(a)\n\n        B.append(b)\n\n        bit = 0\n\n        for i in input().split():\n\n            bit |= (1 << (int(i)-1))\n\n        C.append(bit)\n\n    dp = [[INF]*(1 << N) for _ in range(M+1)]\n\n    dp[0][0] = 0\n\n    for i in range(M):\n\n        for j in range(1 << N):\n\n            dp[i+1][j] = min(dp[i+1][j], dp[i][j])\n\n            if dp[i][j] != INF:\n\n                next_bit = j | C[i]\n\n                dp[i+1][next_bit] = min(dp[i+1][next_bit], dp[i][j] + A[i])\n\n    ans = dp[-1][-1]\n\n    if ans == INF:\n\n        print((-1))\n\n    else:\n\n        print(ans)\n\n    # print(*dp, sep=\"\\n\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"INF = 2*10**7\n\n\n\n\n\ndef main():\n\n    import sys\n\n    input = sys.stdin.buffer.readline\n\n    N, M = (int(i) for i in input().split())\n\n    A = []\n\n    B = []\n\n    C = []\n\n    for _ in range(M):\n\n        a, b = (int(i) for i in input().split())\n\n        A.append(a)\n\n        B.append(b)\n\n        bit = 0\n\n        for i in input().split():\n\n            bit |= (1 << (int(i)-1))\n\n        C.append(bit)\n\n    dp = [[INF]*(1 << N) for _ in range(M+1)]\n\n    dp[0][0] = 0\n\n    for i in range(M):\n\n        for j in range(1 << N):\n\n            dp[i+1][j] = min(dp[i+1][j], dp[i][j])\n\n            if dp[i][j] != INF:\n\n                next_bit = j | C[i]\n\n                dp[i+1][next_bit] = min(dp[i+1][next_bit], dp[i][j] + A[i])\n\n    ans = dp[-1][-1]\n\n    if ans == INF:\n\n        print((-1))\n\n    else:\n\n        print(ans)\n\n    # print(*dp, sep=\"\\n\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"INF = 2 * 10**7\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    N, M = int(data[0]), int(data[1])\n    idx = 2\n    operations = []\n    for _ in range(M):\n        a, b = int(data[idx]), int(data[idx + 1])\n        idx += 2\n        bit = 0\n        for i in range(b):\n            bit |= (1 << (int(data[idx]) - 1))\n            idx += 1\n        operations.append((a, bit))\n    \n    # Initialize DP\n    target = (1 << N) - 1\n    dp = [INF] * (1 << N)\n    dp[0] = 0\n    \n    # BFS-like DP update\n    queue = [0]\n    while queue:\n        curr_queue = []\n        for state in queue:\n            for cost, mask in operations:\n                next_state = state | mask\n                if dp[next_state] > dp[state] + cost:\n                    dp[next_state] = dp[state] + cost\n                    if next_state != target:\n                        curr_queue.append(next_state)\n        queue = curr_queue\n    \n    # Output result\n    ans = dp[target]\n    print(-1 if ans == INF else ans)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03575","slow_code_col":"#!\/usr\/bin\/env python3\n\nclass UnionFind():\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = [-1] * n\n\n\n\n    def find(self, x):\n\n        if self.parents[x] < 0:\n\n            return x\n\n        else:\n\n            self.parents[x] = self.find(self.parents[x])\n\n            return self.parents[x]\n\n\n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n\n\n        if x == y:\n\n            return\n\n\n\n        if self.parents[x] > self.parents[y]:\n\n            x, y = y, x\n\n\n\n        self.parents[x] += self.parents[y]\n\n        self.parents[y] = x\n\n    \n\n\n\n    def same(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n        \n\nimport numpy as np\n\nN, M = list(map(int, input().split()))\n\nedge = []\n\nfor _ in range(M):\n\n    edge.append(list(map(int, input().split())))\n\nans = 0 \n\nfor i in range(M):\n\n    unionfind = UnionFind(N)\n\n    for j in [k for k in range(M) if k != i]:\n\n        a, b = edge[j][0] - 1, edge[j][1] - 1\n\n        unionfind.union(a, b)\n\n    if np.count_nonzero(np.array(unionfind.parents) < 0) >= 2:\n\n        ans += 1\n\nprint(ans)","reference_code_col":"#!\/usr\/bin\/env python3\n\nfrom collections import deque\n\nN, M = list(map(int, input().split()))\n\nedge = []\n\nfor _ in range(M):\n\n    edge.append(list(map(int, input().split())))\n\nans = 0 \n\nfor i in range(M):\n\n    done = [True for _ in range(N + 1)]\n\n    renketu = [[] for _ in range(N + 1)]\n\n    for j in [k for k in range(M) if k != i]:\n\n        a, b = edge[j][0], edge[j][1]\n\n        renketu[a].append(b)\n\n        renketu[b].append(a)\n\n    q = deque([1])\n\n    while q:\n\n        now = q.pop()\n\n        done[now] = False\n\n\n\n        for r in renketu[now]:\n\n            if done[r]:\n\n                q.append(r)\n\n    if sum(done) > 1:\n\n        ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env python3\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return False\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        return True\n\n    def count_roots(self):\n        # Count the number of negative values in parents, which represent roots\n        return sum(1 for p in self.parents if p < 0)\n\n\nN, M = map(int, input().split())\nedges = [tuple(map(lambda x: int(x) - 1, input().split())) for _ in range(M)]\n\n# Step 1: Create a UnionFind instance and connect all edges\nuf_full = UnionFind(N)\nfor a, b in edges:\n    uf_full.union(a, b)\n\n# Step 2: Check if the graph remains connected after removing each edge\nans = 0\nfor i in range(M):\n    uf_temp = UnionFind(N)\n    for j, (a, b) in enumerate(edges):\n        if j != i:\n            uf_temp.union(a, b)\n    if uf_temp.count_roots() > 1:  # If there are multiple components, the graph is disconnected\n        ans += 1\n\nprint(ans)"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nA = np.array(list(map(int, input().split())))\n\ncount = 0\n\nwhile True:\n\n    if np.sum(A%2) > 0:\n\n        break\n\n    count +=1\n\n    A = A\/\/2\n\nprint(count)\n","reference_code_col":"n = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\nans = float(\"inf\")\n\n\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind(\"1\") - 1) # (1)\u20262\u3067\u5272\u3063\u305f\u56de\u6570\u304c\u6700\u5c0f\u306e\u3082\u306e\u3092\u63a2\u7d22\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input\nN = int(input())\nA = np.array(list(map(int, input().split())))\n\n# Function to count trailing zeros in binary representation\ndef count_trailing_zeros(x):\n    return (x & -x).bit_length() - 1 if x != 0 else 0\n\n# Compute the minimum number of trailing zeros across all elements\nmin_trailing_zeros = min(count_trailing_zeros(x) for x in A)\n\nprint(min_trailing_zeros)"}
{"problem_id":"p03253","slow_code_col":"def prime_factorize(num):\n\n    \"\"\"\n\n    This function performs prime factorization on the input natural number.\n\n    The result is returned in the form of a dictionary with the prime number as the key\n\n    and its number as the value.\n\n    :param num:\n\n    :return prime_factor: Dictionary with the prime number as the key and its number as the value.\n\n    \"\"\"\n\n    prime_factor = {}\n\n    i = 2\n\n    while i ** 2 <= num:\n\n        while num % i == 0:\n\n            num \/\/= i\n\n            if i in list(prime_factor.keys()):\n\n                prime_factor[i] += 1\n\n            else:\n\n                prime_factor[i] = 1\n\n        i += 1\n\n    if num > 1:\n\n        prime_factor[num] = 1\n\n    return prime_factor\n\n\n\n\n\nfrom math import factorial\n\n\n\n\n\ndef comb(n, r, R):\n\n    if n not in R:\n\n        a = factorial(n)\n\n        R[n] = a\n\n    else:\n\n        a = R[n]\n\n\n\n    if n - r not in R:\n\n        b = factorial(n - r)\n\n        R[n - r] = b\n\n    else:\n\n        b = R[n - r]\n\n\n\n    if r not in R:\n\n        c = factorial(r)\n\n        R[r] = c\n\n    else:\n\n        c = R[r]\n\n    return a \/\/ (b * c)\n\n\n\n\n\nn, m = list(map(int, input().split()))\n\nr = 1\n\n\n\nR = dict()\n\nprime_fac = prime_factorize(m)\n\nfor v in list(prime_fac.values()):\n\n    r *= comb(v + n - 1, v, R)\n\nmod = 1000000000 + 7\n\nprint((r % mod))\n","reference_code_col":"def prime_factorize(num):\n\n    \"\"\"\n\n    This function performs prime factorization on the input natural number.\n\n    The result is returned in the form of a dictionary with the prime number as the key\n\n    and its number as the value.\n\n    :param num:\n\n    :return prime_factor: Dictionary with the prime number as the key and its number as the value.\n\n    \"\"\"\n\n    prime_factor = {}\n\n    i = 2\n\n    while i ** 2 <= num:\n\n        while num % i == 0:\n\n            num \/\/= i\n\n            if i in list(prime_factor.keys()):\n\n                prime_factor[i] += 1\n\n            else:\n\n                prime_factor[i] = 1\n\n        i += 1\n\n    if num > 1:\n\n        prime_factor[num] = 1\n\n    return prime_factor\n\n\n\n\n\n\n\ndef combination(n, r):\n\n    r = min(n-r, r)\n\n    result = 1\n\n    for i in range(n, n-r, -1):\n\n        result *= i\n\n    for i in range(1, r+1):\n\n        result \/\/= i\n\n    return result\n\n\n\n\n\nn, m = list(map(int, input().split()))\n\nr = 1\n\n\n\nprime_fac = prime_factorize(m)\n\nfor v in list(prime_fac.values()):\n\n    r *= combination(v + n - 1, v)\n\nmod = 1000000000 + 7\n\nprint((r % mod))\n","model_generated_potentially_faster_code_col":"def prime_factorize(num):\n    \"\"\"\n    This function performs prime factorization on the input natural number.\n    The result is returned in the form of a dictionary with the prime number as the key\n    and its exponent as the value.\n    \"\"\"\n    prime_factor = {}\n    i = 2\n\n    # Handle divisibility by 2 separately\n    while num % i == 0:\n        num \/\/= i\n        prime_factor[i] = prime_factor.get(i, 0) + 1\n    i += 1\n\n    # Check odd numbers only\n    while i * i <= num:\n        while num % i == 0:\n            num \/\/= i\n            prime_factor[i] = prime_factor.get(i, 0) + 1\n        i += 2\n\n    # If remaining num > 1, it is a prime factor\n    if num > 1:\n        prime_factor[num] = prime_factor.get(num, 0) + 1\n\n    return prime_factor"}
{"problem_id":"p02951","slow_code_col":"a, b, c = list(map(int, input().split()))\n\n\n\nif a < b + c:\n\n    print((b+c-a))\n\nelse:\n\n    print((0))","reference_code_col":"a,b,c = list(map(int, input().split()))\n\n\n\nprint((max(0, c-(a-b))))","model_generated_potentially_faster_code_col":"a, b, c = map(int, input().split())\nprint(max(0, b + c - a))"}
{"problem_id":"p03038","slow_code_col":"from collections import Counter\n\nN, M = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\n\n\nX = Counter(A)\n\nfor i in range(M):\n\n    B, C = list(map(int, input().split()))\n\n    X[C] += B\n\n\n\nZ = []\n\nfor key, value in list(X.items()):\n\n    Z.append((key, value))\n\n\n\nZ.sort(key=lambda x: x[0], reverse=True)\n\n\n\nans = 0\n\ncnt = 0\n\n\n\nfor value, key in Z:\n\n    if cnt + key <= N:\n\n        ans += key * value\n\n        cnt += key\n\n    else:\n\n        ans += (N - cnt) * value\n\n        break\n\n\n\nprint(ans)\n","reference_code_col":"N, M = list(map(int, input().split()))\n\nA = sorted(list(map(int, input().split())))\n\nquery = []\n\nfor i in range(M):\n\n    b, c = list(map(int, input().split()))\n\n    query.append([b, c])\n\nquery.sort(key=lambda q: q[1], reverse=True)\n\n\n\n\n\ni = 0\n\nfor b, c in query:\n\n    while i < N and b > 0:\n\n        if A[i] < c:\n\n            A[i] = c\n\n            b -= 1\n\n        i += 1\n\n\n\nprint((sum(A)))\n","model_generated_potentially_faster_code_col":"import sys\nfrom collections import defaultdict\n\n# Faster input handling\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse inputs\nN, M = map(int, data[:2])\nA = list(map(int, data[2:2+N]))\nqueries = data[2+N:]\n\n# Count occurrences of A\nX = defaultdict(int)\nfor num in A:\n    X[num] += 1\n\n# Process updates\nindex = 0\nfor _ in range(M):\n    B = int(queries[index])\n    C = int(queries[index+1])\n    X[C] += B\n    index += 2\n\n# Sort keys in descending order\nsorted_keys = sorted(X.keys(), reverse=True)\n\n# Calculate the result\nans = 0\ncnt = 0\n\nfor key in sorted_keys:\n    value = X[key]\n    if cnt + value <= N:\n        ans += key * value\n        cnt += value\n    else:\n        ans += key * (N - cnt)\n        break\n\nprint(ans)"}
{"problem_id":"p03723","slow_code_col":"a, b, c = list(map(int, input().split()))\n\n\n\nif any(i % 2 != 0 for i in [a, b, c]):\n\n    print((0))\n\n    exit()\n\n\n\nif a == b and b == c:\n\n    print((-1))\n\n    exit()\n\n\n\ncnt = 0\n\na_list = [0]*(1001001)\n\nb_list = [0]*(1001001)\n\nc_list = [0]*(1001001)\n\na_list[0] = a\n\nb_list[0] = b\n\nc_list[0] = c\n\n\n\nfor i in range(1, 1001001):\n\n    a_list[i] = (b_list[i-1] + c_list[i-1]) \/\/ 2\n\n    b_list[i] = (c_list[i-1] + a_list[i-1]) \/\/ 2\n\n    c_list[i] = (a_list[i-1] + b_list[i-1]) \/\/ 2\n\n    cnt += 1\n\n    if a_list[i] % 2 != 0 or b_list[i] % 2 != 0 or c_list[i] % 2 != 0:\n\n        break\n\n\n\nprint(cnt)\n","reference_code_col":"def solve(a, b, c):\n\n    if any(i % 2 == 1 for i in [a, b, c]):\n\n        return 0\n\n    if a == b == c:\n\n        return -1\n\n    a, b, c = (b + c) \/\/ 2, (c + a) \/\/ 2, (a + b) \/\/ 2\n\n    return solve(a, b, c) + 1\n\n\n\na, b, c = list(map(int, input().split()))\n\n\n\nprint((solve(a, b, c)))","model_generated_potentially_faster_code_col":"a_list[i] = (b_list[i-1] + c_list[i-1]) \/\/ 2\n     b_list[i] = (c_list[i-1] + a_list[i-1]) \/\/ 2\n     c_list[i] = (a_list[i-1] + b_list[i-1]) \/\/ 2"}
{"problem_id":"p03013","slow_code_col":"from functools import lru_cache\n\nimport sys\n\nsys.setrecursionlimit(30000)\n\n\n\nN, M = list(map(int, input().split()))\n\na = list(int(eval(input())) for _ in range(M))\n\n\n\nMOD = pow(10, 9) + 7\n\n\n\nisOk = True\n\nfor i in range(M-1):\n\n    if a[i] + 1 == a[i+1]:\n\n        isOk = False\n\n    \n\nfuncb = [-1] * 100001\n\ndef func(n):\n\n    if n <= 0:\n\n        return 1\n\n    cnt = funcb[n]\n\n    if cnt > 0:\n\n        return cnt\n\n    cnt = 0\n\n    if n >= 2:\n\n        cnt += func(n-2)\n\n    if n >= 1:\n\n        cnt += func(n-1)\n\n    funcb[n] = cnt % MOD\n\n    return funcb[n]\n\n\n\nfunc(30000)\n\nfunc(50000)\n\nfunc(80000)\n\nfunc(100000)\n\n\n\nif not isOk:\n\n    print((0))\n\nelse:\n\n    ans = 1\n\n    s = 0\n\n    for i in range(M+1):\n\n        if i >= M:\n\n            e = N\n\n        else:\n\n            e = a[i] - 1\n\n\n\n        ans = ans * func(e-s) % MOD\n\n\n\n        if i >= M:\n\n            break\n\n\n\n        s = a[i] + 1\n\n\n\n    print(ans)\n","reference_code_col":"N, M = list(map(int, input().split()))\n\na = list(int(eval(input())) for _ in range(M))\n\n\n\nMOD = pow(10, 9) + 7\n\n\n\nMAP = [0] * (N + 1)\n\n\n\nfor x in a:\n\n    MAP[x] = -1\n\n\n\nMAP[0] = 1 \n\nfor i in range(N):\n\n    if MAP[i] < 0:\n\n        continue\n\n\n\n    MAP[i] %= MOD\n\n    if i + 1 <= N and MAP[i+1] >= 0:\n\n        MAP[i+1] += MAP[i]\n\n    if i + 2 <= N and MAP[i+2] >= 0:\n\n        MAP[i+2] += MAP[i]\n\n\n\nprint((MAP[N] % MOD))\n","model_generated_potentially_faster_code_col":"from functools import lru_cache\n\n# Read input values\nN, M = map(int, input().split())\na = [int(input()) for _ in range(M)]\n\nMOD = 10**9 + 7\n\n# Check if any two consecutive restricted positions are adjacent\nisOk = True\nfor i in range(M - 1):\n    if a[i] + 1 == a[i + 1]:\n        isOk = False\n        break\n\n# Precompute Fibonacci-like values up to 100000\nMAX_N = 100000\nfunc_values = [0] * (MAX_N + 1)\nfunc_values[0] = 1  # Base case: func(0) = 1\nfunc_values[1] = 1  # Base case: func(1) = 1\nfor n in range(2, MAX_N + 1):\n    func_values[n] = (func_values[n - 1] + func_values[n - 2]) % MOD\n\n# If any two restricted positions are adjacent, the result is 0\nif not isOk:\n    print(0)\nelse:\n    ans = 1\n    s = 0\n    for i in range(M + 1):\n        # Determine the end of the current interval\n        e = N if i >= M else a[i] - 1\n        \n        # Multiply the result by func(e - s)\n        ans = ans * func_values[e - s] % MOD\n        \n        # Update the start of the next interval\n        if i < M:\n            s = a[i] + 1\n\n    print(ans)"}
{"problem_id":"p02780","slow_code_col":"import sys\n\nimport numpy as np\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nn, k = list(map(int, readline().split()))\n\np = list(map(int, readline().split()))\n\n\n\ntmp = [(i+1)\/2 for i in p]\n\ncs = list(np.cumsum(tmp))\n\n\n\nif n == k:\n\n    print((cs[-1]))\n\n    exit()\n\nans = 0\n\nfor i in range(n - k):\n\n    ans = max(ans, cs[i + k] - cs[i])\n\nprint(ans)","reference_code_col":"import sys\n\n# import numpy as np\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nn, k = list(map(int, readline().split()))\n\np = list(map(int, readline().split()))\n\n\n\ntmp = [(i+1)\/2 for i in p]\n\n# cs = list(np.cumsum(tmp))\n\n\n\ncs = [0]*n\n\ncs[0] = tmp[0]\n\nfor i in range(len(tmp)-1):\n\n    cs[i + 1] = cs[i] + tmp[i + 1]\n\n\n\nif n == k:\n\n    print((cs[-1]))\n\n    exit()\n\nans = 0\n\nfor i in range(n - k):\n\n    ans = max(ans, cs[i + k] - cs[i])\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Fast input reading\nreadline = sys.stdin.buffer.readline\n\n# Read n, k\nn, k = map(int, readline().split())\n\n# Read p as a NumPy array for efficient computation\np = np.fromstring(readline(), dtype=int, sep=' ')\n\n# Compute tmp as a NumPy array\ntmp = (p + 1) \/ 2\n\n# Compute cumulative sum using NumPy\ncs = np.cumsum(tmp)\n\n# Handle special case when n == k\nif n == k:\n    print(cs[-1])\n    exit()\n\n# Compute all possible subarray sums of length k using slicing\nsubarray_sums = cs[k:] - cs[:-k]\n\n# Find and print the maximum subarray sum\nprint(np.max(subarray_sums))"}
{"problem_id":"p02921","slow_code_col":"# 2019-11-17 20:44:23(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\n# import itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# import re\n\n# import heapq\n\n# import array\n\n# from scipy.misc import comb # (default: exact=False)\n\n# import numpy as np \n\n\n\n\n\ndef main():\n\n    s, t = sys.stdin.read().split()\n\n\n\n    count = 0\n\n    for i in range(3):\n\n        if s[i] == t[i]:\n\n            count += 1\n\n    print(count)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"import sys\n\n\n\ns, t = sys.stdin.read().split()\n\n\n\ndef main():\n\n    cnt = 0\n\n    for i in range(3):\n\n        if s[i] == t[i]:\n\n            cnt += 1\n\n    return cnt\n\n    \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","model_generated_potentially_faster_code_col":"def main():\n    # Read two strings from standard input\n    s, t = input().split()\n\n    # Count matching characters at corresponding positions\n    count = sum(1 for a, b in zip(s, t) if a == b)\n\n    # Print the result\n    print(count)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03494","slow_code_col":"# -*- coding: utf-8 -*-\n\n\n\nimport numpy as np\n\n\n\nn = int(eval(input()))\n\nl = np.array(list(map(int, input().split())))\n\n\n\ncount = 0\n\n\n\nwhile(1):\n\n    if all(1 - (l % 2)):\n\n        count += 1\n\n        l = l \/ 2\n\n    else:\n\n        break\n\n\n\nprint(count)\n","reference_code_col":"N = eval(input())\n\nA = list(map(int, input().split()))\n\n\n\ncount = 0\n\nwhile all(a%2==0 for a in A):\n\n    count += 1\n\n    A = [a\/2 for a in A]\n\n\n\nprint(count)\n","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nimport numpy as np\n\n# Input handling\nn = int(input())\nl = np.array(list(map(int, input().split())))\n\n# Function to count the number of times a number can be divided by 2\ndef count_divisions(x):\n    count = 0\n    while x % 2 == 0:\n        x \/\/= 2\n        count += 1\n    return count\n\n# Compute the minimum number of divisions across all elements\nmin_divisions = min(count_divisions(x) for x in l)\n\nprint(min_divisions)"}
{"problem_id":"p03416","slow_code_col":"#                         author:  kagemeka \n\n#                         created: 2019-11-06 21:30:22(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# import string\n\n# import bisect\n\n# import re\n\n# import itertools\n\n# import statistics\n\n# import functools\n\n# import operator\n\n\n\ndef main():\n\n    a, b = (int(x) for x in sys.stdin.read().split())\n\n\n\n    count = 0\n\n    for n in range(a, b+1):\n\n        n = str(n)\n\n        if n == n[::-1]:\n\n            count += 1\n\n\n\n    print(count)       \n\n\n\nif __name__ == \"__main__\":\n\n    # execute only if run as a script\n\n    main()\n","reference_code_col":"import sys\n\nfrom bisect import bisect_left as bi_l, bisect_right as bi_r\n\n\n\na, b = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    palindromic_nums = []\n\n    for i in range(1, 10):\n\n        for j in range(10):\n\n            for k in range(10):\n\n                x = [i, j, k, j, i]\n\n                palindromic_nums.append(int(''.join(list(map(str, x)))))\n\n\n\n    return bi_r(palindromic_nums, b) - bi_l(palindromic_nums, a)\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    a, b = map(int, sys.stdin.read().split())\n    \n    count = 0\n    max_digits = len(str(b))  # Maximum number of digits in the range [a, b]\n\n    for digits in range(1, max_digits + 1):\n        # Generate palindromes with `digits` number of digits\n        if digits % 2 == 0:  # Even-length palindromes\n            half_length = digits \/\/ 2\n            for half in range(10**(half_length - 1), 10**half_length):\n                palindrome = int(str(half) + str(half)[::-1])\n                if a <= palindrome <= b:\n                    count += 1\n        else:  # Odd-length palindromes\n            half_length = digits \/\/ 2\n            for half in range(10**(half_length - 1), 10**half_length):\n                for middle_digit in range(10):  # Middle digit can be anything from 0 to 9\n                    palindrome = int(str(half) + str(middle_digit) + str(half)[::-1])\n                    if a <= palindrome <= b:\n                        count += 1\n\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02767","slow_code_col":"N = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nX = list(sorted(X))\n\nif N == 1:\n\n  print((0))\n\n  exit()\n\nans = float('inf')\n\nfor p in range(X[0], X[N - 1] + 1):\n\n  sum = 0\n\n  for x in X:\n\n    sum += (x - p) ** 2\n\n  ans = min(sum, ans)\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nX = list(map(int, input().split()))\n\navg = round(sum(X) \/ N)\n\nprint((sum([(x - avg) ** 2 for x in X])))","model_generated_potentially_faster_code_col":"# Read input\nN = int(eval(input()))\nX = list(map(int, input().split()))\n\n# Sort the list (optional, only needed if further processing depends on sorted order)\nX.sort()\n\n# Compute the mean of the elements in X\nmean = sum(X) \/\/ N  # Use integer division for consistency with the problem constraints\n\n# Calculate the sum of squared differences around the mean\nans = sum((x - mean) ** 2 for x in X)\n\n# Output the result\nprint(ans)"}
{"problem_id":"p02725","slow_code_col":"k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nd = [0] * n\n\nd_max = 0\n\n\n\nfor i in range(n - 1):\n\n    d[i] = a[i + 1] - a[i]\n\n    d_max = max(d_max, d[i])\n\n\n\nd[-1] = (k - a[-1]) + a[0]\n\nd_max = max(d_max, d[-1])\n\n\n\nprint((k - d_max))\n","reference_code_col":"k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nd_max = 0\n\n\n\nfor i in range(n - 1):\n\n    d = a[i + 1] - a[i]\n\n    d_max = max(d_max, d)\n\n\n\nd = (k - a[-1]) + a[0]\n\nd_max = max(d_max, d)\n\n\n\nprint((k - d_max))\n","model_generated_potentially_faster_code_col":"# Read input values\nk, n = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize the maximum difference\nd_max = 0\n\n# Calculate differences between consecutive elements and update d_max\nfor i in range(n - 1):\n    diff = a[i + 1] - a[i]\n    d_max = max(d_max, diff)\n\n# Calculate the circular difference and update d_max\ncircular_diff = (k - a[-1]) + a[0]\nd_max = max(d_max, circular_diff)\n\n# Output the result\nprint(k - d_max)"}
{"problem_id":"p02822","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nfrom collections import deque\n\nN = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\ni0 = min([i for i in range(N) if len(X[i]) == 1])\n\n\n\nP = [-1] * N\n\nQ = deque([i0])\n\nR = []\n\nwhile Q:\n\n    i = deque.popleft(Q)\n\n    R.append(i)\n\n    for a in X[i]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            X[a].remove(i)\n\n            deque.append(Q, a)\n\n\n\nmod = 10 ** 9 + 7\n\ninv2 = (mod + 1) \/\/ 2\n\nA = [1] * N\n\nfor i in R[::-1]:\n\n    s = 0\n\n    for j in X[i]:\n\n        A[i] += A[j]\n\n\n\nans = 0\n\nfor i in range(N):\n\n    s = pow(inv2, N - A[i], mod)\n\n    t = 1 + (1-pow(inv2, N - A[i], mod)) * pow(2, N - A[i], mod)\n\n    for j in X[i]:\n\n        s = (s * pow(inv2, A[j], mod)) % mod\n\n        t = (t + (1-pow(inv2, A[j], mod)) * pow(2, A[j], mod)) % mod\n\n    ans = (ans + 1 - s * t) % mod\n\n\n\nprint((ans * inv2 % mod))","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\nfrom collections import deque\n\nN = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\ni0 = min([i for i in range(N) if len(X[i]) == 1])\n\n\n\nP = [-1] * N\n\nQ = deque([i0])\n\nR = []\n\nwhile Q:\n\n    i = deque.popleft(Q)\n\n    R.append(i)\n\n    for a in X[i]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            X[a].remove(i)\n\n            deque.append(Q, a)\n\n\n\nmod = 10 ** 9 + 7\n\npow2 = [1]\n\nfor i in range(N + 10):\n\n    pow2.append(pow2[-1] * 2 % mod)\n\ninv2 = (mod + 1) \/\/ 2\n\n\n\ninvpow2 = [pow(pow2[-1], mod-2, mod)]\n\nfor i in range(N + 10)[::-1]:\n\n    invpow2.append(invpow2[-1] * 2 % mod)\n\ninvpow2 = invpow2[::-1]\n\n\n\nA = [1] * N\n\nfor i in R[::-1]:\n\n    s = 0\n\n    for j in X[i]:\n\n        A[i] += A[j]\n\n\n\nans = 0\n\nfor i in range(N):\n\n    s = pow(inv2, N - A[i], mod)\n\n    t = 1 + (1-invpow2[N-A[i]]) * pow2[N-A[i]]\n\n    for j in X[i]:\n\n        s = (s * invpow2[A[j]]) % mod\n\n        t = (t + (1-invpow2[A[j]]) * pow2[A[j]]) % mod\n\n    ans = (ans + 1 - s * t) % mod\n\n\n\nprint((ans * inv2 % mod))","model_generated_potentially_faster_code_col":"import sys\nfrom collections import deque\n\n# Fast input reading\ninput = sys.stdin.readline\n\n# Constants\nmod = 10**9 + 7\ninv2 = (mod + 1) \/\/ 2\n\n# Read input\nN = int(input())\nX = [[] for _ in range(N)]\n\nfor _ in range(N - 1):\n    x, y = map(int, input().split())\n    X[x - 1].append(y - 1)\n    X[y - 1].append(x - 1)\n\n# Find a leaf node to start BFS\ni0 = next(i for i in range(N) if len(X[i]) == 1)\n\n# BFS initialization\nP = [-1] * N\nQ = deque([i0])\nR = []\n\n# Perform BFS\nwhile Q:\n    i = Q.popleft()\n    R.append(i)\n    for a in X[i]:\n        if P[i] != a:  # Avoid revisiting the parent\n            P[a] = i\n            Q.append(a)\n\n# Precompute powers of 2 and modular inverses\npowers_of_2 = [1] * N\ninv_powers_of_2 = [1] * N\n\nfor i in range(1, N):\n    powers_of_2[i] = (powers_of_2[i - 1] * 2) % mod\n    inv_powers_of_2[i] = pow(powers_of_2[i], mod - 2, mod)\n\n# Compute subtree sizes\nA = [1] * N\nfor i in R[::-1]:\n    for j in X[i]:\n        if P[j] == i:  # Only consider children\n            A[i] += A[j]\n\n# Compute the answer\nans = 0\nfor i in range(N):\n    s = inv_powers_of_2[N - A[i]]\n    t = (1 + (1 - inv_powers_of_2[N - A[i]]) * powers_of_2[N - A[i]]) % mod\n\n    for j in X[i]:\n        if P[j] == i:  # Only consider children\n            s = (s * inv_powers_of_2[A[j]]) % mod\n            t = (t + (1 - inv_powers_of_2[A[j]]) * powers_of_2[A[j]]) % mod\n\n    ans = (ans + 1 - s * t) % mod\n\n# Output the result\nprint((ans * inv2) % mod)"}
{"problem_id":"p03060","slow_code_col":"import numpy as np\n\n\n\nn = int(eval(input()))\n\nv = np.array(list(map(int, input().split())))\n\nc = np.array(list(map(int, input().split())))\n\np = v-c\n\nans = 0\n\nfor i in p:\n\n    if i>0:\n\n        ans+=i\n\n\n\nprint(ans)\n","reference_code_col":"n=int(eval(input()))\n\nV=list(map(int,input().split()))\n\nC=list(map(int,input().split()))\n\nans=0\n\nfor v,c in zip(V,C):\n\n    diff=v-c\n\n    if 0<diff:\n\n        ans+=diff\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn = int(input())  # No need for eval\nv = np.fromstring(input(), dtype=int, sep=' ')  # Directly create NumPy array from input string\nc = np.fromstring(input(), dtype=int, sep=' ')  # Same for c\n\n# Compute profit array\np = v - c\n\n# Use NumPy's boolean indexing to sum only positive values\nans = np.sum(p[p > 0])\n\n# Output the result\nprint(ans)"}
{"problem_id":"p02725","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tK,N = MI()\n\n\tA = np.array(LI())\n\n\tA_LAST = K+A[0] - A[N-1]\n\n\tB = A[1:]-A[:N-1]\n\n\tB = np.sort(B)\n\n\tprint(K-max(B[N-2],A_LAST))\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n","reference_code_col":"import sys\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tk,n = MI()\n\n\ta = LI()\n\n\tb = [0]*n\n\n\tfor i in range(n):\n\n\t\tif i == n-1:\n\n\t\t\tb[i] = a[0]+k-a[i]\n\n\t\telse:\n\n\t\t\tb[i] = a[i+1]-a[i]\n\n\tb.sort()\n\n\tprint(k-b[-1])\n\n\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Read input efficiently\n    K, N = map(int, sys.stdin.readline().split())\n    A = list(map(int, sys.stdin.readline().split()))\n\n    # Compute differences between consecutive elements\n    max_diff = 0\n    for i in range(N - 1):\n        diff = A[i + 1] - A[i]\n        if diff > max_diff:\n            max_diff = diff\n\n    # Handle the circular difference (last element to first element)\n    circular_diff = K - (A[-1] - A[0])\n\n    # Find the maximum gap and compute the result\n    largest_gap = max(max_diff, circular_diff)\n    print(K - largest_gap)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03796","slow_code_col":"from math import factorial\n\ndef myAnswer(N:int) ->int:\n\n   ans =factorial(N)\n\n   return ans % (10**9 + 7)\n\n\n\ndef modelAnswer():\n\n   tmp=1\n\ndef main():\n\n   N = int(eval(input()))\n\n   print((myAnswer(N)))\n\n\n\n\n\nif __name__ == '__main__':\n\n   main()","reference_code_col":"def modelAnswer(N:int) -> int:\n\n   ans = 1\n\n   for i in range(1,N+1):\n\n      ans = (ans*i) % (10**9 + 7)\n\n   return ans \n\ndef main():\n\n   N = int(eval(input()))\n\n   print((modelAnswer(N)))\n\n\n\n\n\nif __name__ == '__main__':\n\n   main()\n","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7  # Define the modulo constant\n\ndef myAnswer(N: int) -> int:\n    if N == 0 or N == 1:  # Factorial of 0 or 1 is 1\n        return 1\n    \n    result = 1\n    for i in range(2, N + 1):  # Start from 2 since factorial(1) = 1\n        result = (result * i) % MOD  # Compute factorial modulo MOD iteratively\n    return result\n\ndef main():\n    N = int(input())  # Read input directly without eval\n    print(myAnswer(N))\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02881","slow_code_col":"import numpy as np\n\n\n\nN=int(eval(input()))\n\na=int(np.sqrt(N))\n\nb=float('inf')\n\nfor i in range(1,a+1):\n\n    if N%i==0:\n\n        if i+N\/\/i<b:\n\n            ans=i\n\n\n\nprint((ans+N\/\/ans-2))\n","reference_code_col":"# -*- coding: utf-8 -*-\n\nimport sys\n\nfrom math import sqrt\n\nsys.setrecursionlimit(10**9)\n\nINF=10**18\n\nMOD=10**9+7\n\ndef input(): return sys.stdin.readline().rstrip()\n\n\n\ndef main():\n\n    N=int(eval(input()))\n\n    tmp=INF\n\n    for i in range(1,10**6+1):\n\n        if N%i==0:\n\n            tmp=min(tmp,i+N\/\/i)\n\n    print((tmp-2))\n\n    \n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import math\n\n# Read input\nN = int(input())\n\n# Compute square root of N\na = int(math.sqrt(N))\n\n# Initialize variables\nans = 1  # Start with the smallest divisor\nmin_sum = float('inf')  # Track the minimum sum of factors\n\n# Iterate over possible divisors\nfor i in range(1, a + 1):\n    if N % i == 0:  # Check if i is a divisor\n        j = N \/\/ i  # Compute the corresponding co-divisor\n        current_sum = i + j  # Calculate the sum of factors\n        if current_sum < min_sum:  # Update if this is the smallest sum so far\n            min_sum = current_sum\n            ans = i  # Store the divisor that minimizes the sum\n\n# Output the result\nprint(ans + N \/\/ ans - 2)"}
{"problem_id":"p03253","slow_code_col":"import math\n\nN, M = list(map(int, input().split()))\n\n\n\n\n\ndef factorization(n):\n\n    arr = []\n\n    temp = n\n\n    for i in range(2, int(-(-n**0.5\/\/1))+1):\n\n        if temp % i == 0:\n\n            cnt = 0\n\n            while temp % i == 0:\n\n                cnt += 1\n\n                temp \/\/= i\n\n            arr.append([i, cnt])\n\n    if temp != 1:\n\n        arr.append([temp, 1])\n\n\n\n    if arr == [] and n != 1:\n\n        arr.append([n, 1])\n\n\n\n    return arr\n\n\n\n\n\nmod = 10**9 + 7\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\n\n\ng1 = [1, 1]\n\ng2 = [1, 1]\n\ninverse = [0, 1]\n\nfor i in range(2, 2*10**5 + 1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inverse.append((-inverse[mod % i] * (mod\/\/i)) % mod)\n\n    g2.append((g2[-1] * inverse[-1]) % mod)\n\n\n\n\n\nprimes = factorization(M)\n\n# \u4f55\u7b87\u6240\u306b\u5206\u3051\u308b\u304b\uff08cnt\u4ee5\u4e0b\uff09,\u305d\u306e\u4e2d\u3067\u3069\u3046\u5206\u3051\u308b\u304b\uff08\u3057\u304d\u308a\u3092\u3069\u3053\u306b\u304a\u304f\u304b\uff08\u632f\u308a\u5206\u3051\u3089\u308c\u306a\u3044\u3082\u306e\u304c\u51fa\u308b\u3068\u9078\u3079\u308c\u306a\u3044\u306e\u3068\u304a\u306a\u3058\u306b\u306a\u308b\u306e\u3067\u3001cnt - \u9078\u3093\u3060\u6570\uff09\uff09\n\n\n\nans = 1\n\n\n\nfor p, cnt in primes:\n\n    tmp = cmb(N+cnt-1, N-1, mod)\n\n    ans *= tmp\n\n    ans %= mod\n\n\n\nprint(ans)\n","reference_code_col":"def main():\n\n    N, M = list(map(int, input().split()))\n\n\n\n    def factorization(n):\n\n        arr = []\n\n        temp = n\n\n        for i in range(2, int(-(-n**0.5\/\/1))+1):\n\n            if temp % i == 0:\n\n                cnt = 0\n\n                while temp % i == 0:\n\n                    cnt += 1\n\n                    temp \/\/= i\n\n                arr.append([i, cnt])\n\n        if temp != 1:\n\n            arr.append([temp, 1])\n\n\n\n        if arr == [] and n != 1:\n\n            arr.append([n, 1])\n\n\n\n        return arr\n\n\n\n    mod = 10**9 + 7\n\n\n\n    def cmb(n, r, mod):\n\n        if (r < 0 or r > n):\n\n            return 0\n\n        r = min(r, n-r)\n\n        return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\n    g1 = [1, 1]\n\n    g2 = [1, 1]\n\n    inverse = [0, 1]\n\n    for i in range(2, N+100 + 1):\n\n        g1.append((g1[-1] * i) % mod)\n\n        inverse.append((-inverse[mod % i] * (mod\/\/i)) % mod)\n\n        g2.append((g2[-1] * inverse[-1]) % mod)\n\n\n\n    primes = factorization(M)\n\n    # \u4f55\u7b87\u6240\u306b\u5206\u3051\u308b\u304b\uff08cnt\u4ee5\u4e0b\uff09,\u305d\u306e\u4e2d\u3067\u3069\u3046\u5206\u3051\u308b\u304b\uff08\u3057\u304d\u308a\u3092\u3069\u3053\u306b\u304a\u304f\u304b\uff08\u632f\u308a\u5206\u3051\u3089\u308c\u306a\u3044\u3082\u306e\u304c\u51fa\u308b\u3068\u9078\u3079\u308c\u306a\u3044\u306e\u3068\u304a\u306a\u3058\u306b\u306a\u308b\u306e\u3067\u3001cnt - \u9078\u3093\u3060\u6570\uff09\uff09\n\n\n\n    ans = 1\n\n\n\n    for p, cnt in primes:\n\n        tmp = cmb(N+cnt-1, N-1, mod)\n\n        ans *= tmp\n\n        ans %= mod\n\n\n\n    print(ans)\n\n\n\n\n\nmain()\n","model_generated_potentially_faster_code_col":"import math\n\nN, M = map(int, input().split())\n\n# Precompute primes using Sieve of Eratosthenes\ndef sieve(limit):\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(limit)) + 1):\n        if is_prime[i]:\n            for j in range(i * i, limit + 1, i):\n                is_prime[j] = False\n    return [x for x in range(limit + 1) if is_prime[x]]\n\n# Optimized factorization using precomputed primes\ndef factorization(n, primes):\n    arr = []\n    temp = n\n    for p in primes:\n        if p * p > temp:\n            break\n        if temp % p == 0:\n            cnt = 0\n            while temp % p == 0:\n                cnt += 1\n                temp \/\/= p\n            arr.append([p, cnt])\n    if temp != 1:\n        arr.append([temp, 1])\n    return arr\n\n# Precompute factorials and modular inverses\nmod = 10**9 + 7\nMAX = 2 * 10**5 + 1\ng1 = [1] * MAX  # Factorials\ng2 = [1] * MAX  # Inverse factorials\ninverse = [0] * MAX\n\nfor i in range(2, MAX):\n    g1[i] = g1[i - 1] * i % mod\n    inverse[i] = mod - (mod \/\/ i) * inverse[mod % i] % mod\n    g2[i] = g2[i - 1] * inverse[i] % mod\n\n# Combination function\ndef cmb(n, r, mod):\n    if r < 0 or r > n:\n        return 0\n    r = min(r, n - r)\n    return g1[n] * g2[r] % mod * g2[n - r] % mod\n\n# Main logic\nprimes = sieve(int(math.sqrt(M)) + 1)\nfactors = factorization(M, primes)\n\nans = 1\nfor p, cnt in factors:\n    tmp = cmb(N + cnt - 1, N - 1, mod)\n    ans = ans * tmp % mod\n\nprint(ans)"}
{"problem_id":"p02837","slow_code_col":"def check(x, y):\n\n    for a, b in zip(x, y):\n\n        if a != b and b != -1:\n\n            return False\n\n    else:\n\n        return True\n\n\n\n\n\nn = int(eval(input()))\n\nremarks = []\n\ncnt_max = 0\n\nfor _ in range(n):\n\n    a = int(eval(input()))\n\n    x = [tuple(map(int, input().split())) for i in range(a)]\n\n    r = [-1] * n\n\n    for i, j in x:\n\n        r[i - 1] = j\n\n    remarks.append(r)\n\nfor r in range(2 ** n):\n\n    r = list(bin(r)[2:].zfill(n))\n\n    r = [int(i) for i in r[:]]\n\n    cnt = 0\n\n    for i in range(n):\n\n        if r[i] == 1:\n\n            flag = check(r, remarks[i])\n\n            cnt += 1\n\n            if not flag:\n\n                cnt = 0\n\n                break\n\n    cnt_max = max(cnt, cnt_max)\n\nprint(cnt_max)","reference_code_col":"import numpy as np\n\nimport itertools\n\n\n\nn = int(eval(input()))\n\ninfo = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    for _ in range(a):\n\n        x, y = list(map(int, input().split()))\n\n        info.append((i, x - 1, y))\n\n\n\na = np.array(list(itertools.product([0, 1], repeat=n)), dtype=np.bool)\n\nfor i, x, y in info:\n\n    bl = (~a[:, i]) | (a[:, x] == bool(y))\n\n    a = a[bl]\n\n\n\nans = a.sum(axis=1).max()\n\nprint(ans)","model_generated_potentially_faster_code_col":"def check(x, y):\n    # Use generator expression for early exit and improved readability\n    return all(a == b or b == -1 for a, b in zip(x, y))\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    n = int(data[0])\n    remarks = []\n    line_idx = 1\n\n    # Preprocess input to construct remarks\n    for _ in range(n):\n        a = int(data[line_idx])\n        line_idx += 1\n        r = [-1] * n\n        for _ in range(a):\n            i, j = map(int, data[line_idx].split())\n            r[i - 1] = j\n            line_idx += 1\n        remarks.append(r)\n\n    cnt_max = 0\n\n    # Iterate over all possible binary combinations of length n\n    for r_int in range(2 ** n):\n        r = [(r_int >> i) & 1 for i in range(n)]  # Efficiently generate binary representation\n        cnt = 0\n\n        # Check consistency of r with all remarks\n        for i in range(n):\n            if r[i] == 1:\n                if not check(r, remarks[i]):\n                    cnt = 0\n                    break\n                cnt += 1\n\n        cnt_max = max(cnt, cnt_max)\n\n    print(cnt_max)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03416","slow_code_col":"A, B = list(map(int, input().split()))\n\ncount_target = 0\n\n\n\nfor i in range(A, B + 1):\n\n    str_i = str(i)\n\n    reversed_i = ''\n\n    for n_th_i in reversed(list(range(len(str_i)))):\n\n        reversed_i += str_i[n_th_i]\n\n\n\n    if str_i == reversed_i:\n\n        count_target += 1\n\n\n\nprint(count_target)","reference_code_col":"A, B = list(map(int, input().split()))\n\ncount_target = 0\n\n\n\nfor i in range(A, B+1):\n\n    str_i = str(i)\n\n    reversed_i = str_i[::-1]\n\n\n\n    if str_i == reversed_i:\n\n        count_target += 1\n\n\n\nprint(count_target)\n","model_generated_potentially_faster_code_col":"A, B = map(int, input().split())\n\ncount_target = 0\n\nfor i in range(A, B + 1):\n    str_i = str(i)\n    if str_i == str_i[::-1]:  # Use slicing to reverse the string\n        count_target += 1\n\nprint(count_target)"}
{"problem_id":"p02881","slow_code_col":"from collections import Counter,defaultdict,deque\n\nimport sys,bisect,math,itertools,string,queue\n\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn = inp()\n\nres = float('inf')\n\nfor i in range(1,2*10**6):\n\n    if (n\/i).is_integer():\n\n        res = min(res, i + n\/i)\n\nprint((int(res-2)))\n","reference_code_col":"from collections import Counter,defaultdict,deque\n\nimport sys,bisect,math,itertools,string,queue\n\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn = inp()\n\nres = float('inf')\n\nfor i in range(1,int(math.sqrt(n))+1):\n\n    if n%i == 0:\n\n        res = min(res, i + n\/i)\n\nprint((int(res-2)))\n","model_generated_potentially_faster_code_col":"from math import isqrt\n\ndef inp():\n    return int(input())\n\ndef main():\n    n = inp()\n    res = float('inf')\n    \n    # Iterate over potential divisors up to \u221an\n    for i in range(1, isqrt(n) + 1):\n        if n % i == 0:  # Check if i is a divisor of n\n            j = n \/\/ i   # Corresponding divisor\n            res = min(res, i + j)  # Update the result with the smaller sum\n    \n    print(int(res - 2))\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02555","slow_code_col":"S = int(eval(input()))\n\n\n\ndp = [0] * (S + 1)\n\ndp[0] = 1\n\nM = 10 ** 9 + 7\n\n\n\nfor i in range(1, S + 1):\n\n    num = 0\n\n    for j in range(i - 2):\n\n        num += dp[j]\n\n        dp[i] = num % M\n\n\n\nprint((dp[S]))\n\n\n","reference_code_col":"S = int(eval(input()))\n\n\n\n\n\ndef cmb(n, r, p):\n\n    r = min(n - r, r)\n\n    if r == 0:\n\n        return 1\n\n    over = 1\n\n    for i in range(n, n - r, -1):\n\n        over = over * i % p\n\n    under = 1\n\n    for i in range(1, r + 1):\n\n        under = under * i % p\n\n    inv = pow(under, p - 2, p)\n\n    return over * inv % p\n\n\n\n\n\nM = 10 ** 9 + 7\n\nans = 0\n\nfor i in range(1, S):\n\n    if S - 3 * i < 0:\n\n        break\n\n    ans += cmb(S - 3 * i + i - 1, i - 1, M)\n\n    ans %= M\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"S = int(eval(input()))\n\n# Initialize dp array and set base case\ndp = [0] * (S + 1)\ndp[0] = 1\n\n# Modulo constant\nM = 10**9 + 7\n\n# Cumulative sum to track the sum of previous dp values\ncum_sum = 0\n\nfor i in range(1, S + 1):\n    if i >= 3:\n        # Add dp[i-3] to the cumulative sum\n        cum_sum += dp[i - 3]\n        cum_sum %= M\n    dp[i] = cum_sum\n\nprint(dp[S])"}
{"problem_id":"p02837","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\nN = int(eval(input()))\n\nS = [[] for _ in range(N)]\n\nfor i in range(N):\n\n    A = int(eval(input()))\n\n    temp = []\n\n    for _ in range(A):\n\n        temp.append([str(x) for x in input().split()])\n\n        S[i] = temp\n\nans = 0\n\nfor i in range(2 ** N - 1, -1,-1):\n\n    biti = list(bin(i)[2:].zfill(N))\n\n    flag = 0\n\n    for j in range(N):\n\n        if biti[j] == \"1\":\n\n            for k in S[j]:\n\n                if biti[int(k[0])-1] != k[1]:\n\n                    flag = 1\n\n                    break\n\n        if flag:\n\n            break\n\n    if not flag:    \n\n        biti = np.array(biti)\n\n        ans = max(ans, np.count_nonzero(biti == \"1\"))\n\nprint(ans)","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\n\n\nfrom collections import defaultdict\n\nd = defaultdict(list)\n\n\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    for _ in range(a):\n\n        x, y = [int(x) for x in input().split()]\n\n        d[i].append((x - 1, y))\n\nans = 0\n\nfor k in range(2**n):\n\n    res = 0\n\n    j = bin(k)[2:].zfill(n)\n\n    flag = 1\n\n    for i in range(n):\n\n        if j[i] == \"0\":\n\n            continue\n\n        for x, y in d[i]:\n\n            if int(j[x]) != int(y):\n\n                flag = 0\n\n                break\n\n        res += 1\n\n    if flag:\n\n        ans = max(ans, res)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\n# Read N and initialize S\nN = int(input())\nS = [[] for _ in range(N)]\n\n# Efficiently parse input\nfor i in range(N):\n    A = int(input())\n    S[i] = [[int(x[0]) - 1, x[1]] for x in [input().split() for _ in range(A)]]\n\n# Initialize the answer\nans = 0\n\n# Iterate over all possible bitmasks\nfor bitmask in range((1 << N) - 1, -1, -1):\n    # Convert bitmask to binary representation\n    biti = [(bitmask >> j) & 1 for j in range(N)]\n    \n    valid = True\n    \n    # Check constraints\n    for j in range(N):\n        if biti[j]:  # Only check if person j is honest\n            for k, v in S[j]:\n                if biti[k] != int(v):  # Compare integer values directly\n                    valid = False\n                    break\n        if not valid:\n            break\n    \n    # Update the answer if the configuration is valid\n    if valid:\n        ans = max(ans, sum(biti))\n\nprint(ans)"}
{"problem_id":"p03457","slow_code_col":"#!\/usr\/bin\/python3\n\n# -*- coding: utf-8 -*-\n\n\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nprev_dst = [0,0,0]\n\n\n\nfor n in range(N):\n\n    t, x, y = list(map(int, input().split(\" \")))\n\n    a = (t - prev_dst[0]) - (np.abs(prev_dst[1]-x) + np.abs(prev_dst[2]-y))\n\n    if a >= 0 and a % 2 == 0:\n\n        prev_dst = [t, x, y]\n\n    else:\n\n        print(\"No\")\n\n        exit(0)\n\n\n\nprint(\"Yes\")\n\n\n","reference_code_col":"#!\/usr\/bin\/python3\n\n# -*- coding: utf-8 -*-\n\n\n\nN = int(eval(input()))\n\nprev_dst = [0,0,0]\n\n\n\nfor n in range(N):\n\n    t, x, y = list(map(int, input().split(\" \")))\n\n    a = (t - prev_dst[0]) - (abs(prev_dst[1]-x) + abs(prev_dst[2]-y))\n\n    if a >= 0 and a % 2 == 0:\n\n        prev_dst = [t, x, y]\n\n    else:\n\n        print(\"No\")\n\n        exit(0)\n\n\n\nprint(\"Yes\")\n\n\n","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/python3\n\n# -*- coding: utf-8 -*-\n\nN = int(input())\n\n# Initialize previous destination with time, x, and y\nprev_t, prev_x, prev_y = 0, 0, 0\n\nfor _ in range(N):\n    # Read input values\n    t, x, y = map(int, input().split())\n    \n    # Calculate the difference in time and Manhattan distance\n    time_diff = t - prev_t\n    manhattan_dist = abs(prev_x - x) + abs(prev_y - y)\n    \n    # Check if the move is valid\n    if time_diff >= manhattan_dist and (time_diff - manhattan_dist) % 2 == 0:\n        # Update previous destination\n        prev_t, prev_x, prev_y = t, x, y\n    else:\n        print(\"No\")\n        break\nelse:\n    # If all moves are valid\n    print(\"Yes\")"}
{"problem_id":"p02767","slow_code_col":"import numpy as np\n\n\n\nN = int(eval(input()))\n\nX = np.array(list(int(x) for x in input().split()))\n\nm = round(np.mean(X))\n\n\n\nprint((int(sum((X-m)**2))))","reference_code_col":"N = int(eval(input()))\n\nX = list(int(x) for x in input().split())\n\np = round(sum(X)\/len(X))\n\nans = 0\n\n\n\nfor i in range(N):\n\n    ans += (X[i] - p)**2\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN = int(input())  # Number of elements\nX = np.fromstring(input(), sep=' ', dtype=int)  # Directly create a NumPy array from input\n\n# Compute the mean and round it\nm = int(round(X.sum() \/ N))  # Efficient mean calculation and rounding\n\n# Compute the sum of squared differences\nresult = int(((X - m) ** 2).sum())\n\n# Output the result\nprint(result)"}
{"problem_id":"p02390","slow_code_col":"a = int(eval(input()))\n\nh = int(a \/ 3600)\n\nm = int((a - h * 3600) \/ 60)\n\ns = int(a - h * 3600 - m * 60)\n\nprint((\":\" .join(map(str, [h, m, s]))))","reference_code_col":"num = int(input())\n\nprint(int(num\/3600), int((num%3600)\/60), num%60, sep=\":\")\n","model_generated_potentially_faster_code_col":"# Input parsing\na = int(input())\n\n# Calculate hours, minutes, and seconds\nh = a \/\/ 3600          # Integer division to get hours\nremainder = a % 3600    # Remaining seconds after extracting hours\nm = remainder \/\/ 60     # Integer division to get minutes\ns = remainder % 60      # Remaining seconds after extracting minutes\n\n# Output formatted time\nprint(f\"{h}:{m}:{s}\")"}
{"problem_id":"p02899","slow_code_col":"n = int(eval(input()))\n\na = [int(x) for x in input().split()]\n\n\n\nans = list(range(n))\n\n\n\nfor i in range(n):\n\n    ans[a[i]-1] = i+1\n\n    \n\nprint((' '.join(map(str,ans))))","reference_code_col":"def main():\n\n\n\n    N = int(eval(input()))\n\n    A = list(int(x) for x in input().split())\n\n    ans = [0] * N\n\n\n\n    for i, a in enumerate(A):\n\n        ans[a-1] = i+1\n\n\n\n    print((' '.join(map(str, ans))))\n\n    \n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the result list with zeros\nans = [0] * n\n\n# Populate the result list\nfor i in range(n):\n    ans[a[i] - 1] = i + 1\n\n# Print the result using a generator expression\nprint(' '.join(map(str, ans)))"}
{"problem_id":"p03416","slow_code_col":"a, b = list(map(int, input().split()))\n\ncnt = 0\n\nfor x in range(a, b + 1):\n\n    s = str(x)\n\n    l = len(s)\n\n    flg = True\n\n    for i in range(l \/\/ 2):\n\n        if s[i] != s[l - 1 - i]:\n\n            flg = False\n\n            break\n\n    if flg:\n\n        cnt += 1\n\nprint(cnt)\n","reference_code_col":"a, b = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(a, b + 1):\n\n    s = str(i)\n\n    if s[0] == s[4] and s[1] == s[3]:\n\n        cnt += 1\n\nprint(cnt)","model_generated_potentially_faster_code_col":"def count_palindromes(a, b):\n    cnt = 0\n\n    # Helper function to check if a number is a palindrome using math\n    def is_palindrome(num):\n        original = num\n        reversed_num = 0\n\n        while num > 0:\n            reversed_num = reversed_num * 10 + (num % 10)\n            num \/\/= 10\n\n        return original == reversed_num\n\n    # Iterate through the range [a, b]\n    for x in range(a, b + 1):\n        if is_palindrome(x):\n            cnt += 1\n\n    return cnt\n\n\n# Input reading\na, b = map(int, input().split())\n\n# Count and print the result\nprint(count_palindromes(a, b))"}
{"problem_id":"p02959","slow_code_col":"N = int(eval(input()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\na.reverse()\n\nb.reverse()\n\nans = 0\n\ncapacity = 0\n\nfor i in range(N):\n\n    ans += min(b[i] + capacity, a[i])\n\n    capacity = max(b[i] - max(a[i] - capacity, 0), 0)\n\nans += min(a[-1], capacity)\n\nprint(ans)","reference_code_col":"n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\n\n\na = a[::-1]\n\nb = b[::-1]\n\nans = 0\n\nfor i, bi in enumerate(b):\n\n    ans += min(a[i], b[i])\n\n    remain = max(0, b[i] - a[i])\n\n    ans += min(a[i + 1], remain)\n\n    a[i + 1] = max(0, a[i + 1] - remain)\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read input values\nN = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Initialize variables\nans = 0\ncapacity = 0\n\n# Iterate from the end to the beginning\nfor i in range(N - 1, -1, -1):\n    # Calculate the contribution to the answer\n    ans += min(b[i] + capacity, a[i])\n    \n    # Update capacity\n    capacity = max(capacity + b[i] - a[i], 0)\n\n# Output the result\nprint(ans)"}
{"problem_id":"p02863","slow_code_col":"#coding:utf-8\n\nimport bisect\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nwrite = sys.stdout.write\n\ndbg = lambda *something : print(*something) if DEBUG else 0\n\nDEBUG = True\n\n\n\n\n\n\n\ndef main(given = sys.stdin.readline):\n\n    input = lambda : given().rstrip()\n\n    LMIIS = lambda : list(map(int,input().split()))\n\n    II = lambda : int(input())\n\n    XLMIIS = lambda x : [LMIIS() for _ in range(x)]\n\n\n\n    n, t = LMIIS()\n\n    ab = XLMIIS(n)\n\n\n\n    dp1 = [[0]*t for _ in range(n)]\n\n    for i in range(1, n):\n\n        for j in range(1, t):\n\n            if j < ab[i-1][0]:\n\n                dp1[i][j] = dp1[i-1][j]\n\n            else:\n\n                dp1[i][j] = max(dp1[i-1][j], dp1[i-1][j-ab[i-1][0]] + ab[i-1][1])\n\n\n\n\n\n    dp2 = [[0]*t for _ in range(n)]\n\n    for i in range(1, n):\n\n        for j in range(1, t):\n\n            if j < ab[n - i][0]:\n\n                dp2[i][j] = dp2[i-1][j]\n\n            else:\n\n                dp2[i][j] = max(dp2[i-1][j], dp2[i-1][j-ab[n-i][0]] + ab[n-i][1])\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in range(t - 1):\n\n            ans = max(ans, dp1[i][j] + dp2[n - i - 1][t - j - 1] + ab[i][1])\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"#coding:utf-8\n\nimport bisect\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nwrite = sys.stdout.write\n\ndbg = lambda *something : print(*something) if DEBUG else 0\n\nDEBUG = True\n\n\n\n\n\n\n\ndef main(given = sys.stdin.readline):\n\n    input = lambda : given().rstrip()\n\n    LMIIS = lambda : list(map(int,input().split()))\n\n    II = lambda : int(input())\n\n    XLMIIS = lambda x : [LMIIS() for _ in range(x)]\n\n\n\n    n, t = LMIIS()\n\n    ab = XLMIIS(n)\n\n    ab.sort()\n\n\n\n    dp1 = [[0]*t for _ in range(n+1)]\n\n    for i in range(1, n+1):\n\n        for j in range(1, t):\n\n            if j < ab[i-1][0]:\n\n                dp1[i][j] = dp1[i-1][j]\n\n            else:\n\n                dp1[i][j] = max(dp1[i-1][j], dp1[i-1][j-ab[i-1][0]] + ab[i-1][1])\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        ans = max(ans, dp1[i][t-1] + ab[i][1])\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"#coding:utf-8\n\nimport sys\n\nsys.setrecursionlimit(10**6)\nwrite = sys.stdout.write\n\nDEBUG = False\ndbg = lambda *something: print(*something) if DEBUG else None\n\ndef main():\n    input = sys.stdin.readline\n    LMIIS = lambda: list(map(int, input().split()))\n    II = lambda: int(input())\n\n    n, t = LMIIS()\n    ab = [LMIIS() for _ in range(n)]\n\n    # Forward DP: dp1[j] = max value for first i items with time <= j\n    dp1 = [0] * t\n    for i in range(n):\n        a, b = ab[i]\n        for j in range(t - 1, a - 1, -1):\n            dp1[j] = max(dp1[j], dp1[j - a] + b)\n\n    # Reverse DP: dp2[j] = max value for last i items with time <= j\n    dp2 = [0] * t\n    for i in range(n - 1, -1, -1):\n        a, b = ab[i]\n        for j in range(t - 1, a - 1, -1):\n            dp2[j] = max(dp2[j], dp2[j - a] + b)\n\n    # Combine results to find the maximum value\n    ans = 0\n    for i in range(n):\n        a, b = ab[i]\n        for j in range(t - a):\n            ans = max(ans, dp1[j] + dp2[t - a - j] + b)\n\n    print(ans)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03039","slow_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\nN, M, K = list(map(int,input().split()))\n\nmod = 10**9+7\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\n\ng2 = [1, 1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\ninv = [0, 1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n\n\nfor i in range(2, N*M+1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod\/\/i)) % mod)\n\n    g2.append((g2[-1] * inv[-1]) % mod)\n\n\n\ndef a(N,M):\n\n    return N*(N+1)\/\/2*(M+1) + M*(M+1)\/\/2*(N+1)\n\ndef b(N):\n\n    return N*(N+1)\/\/2\n\n\n\nans = 0\n\nfor i in range(N):\n\n    for j in range(M):\n\n        ans += a(i,j) + a(N-i-1,j) + a(i,M-j-1) + a(N-i-1,M-j-1)\n\n        ans -= b(i) + b(j) + b(N-i-1) + b(M-j-1)\n\n        ans %= mod\n\n#        print(i,j,a(i,j),a(N-i-1,j),a(i,M-j-1),a(N-i-1,M-j-1),b(i),b(j),ans)\n\nans *= g2[2]\n\n\n\nans *= cmb(N*M-2,K-2,mod)\n\nans %= mod\n\n\n\nprint(ans)\n","reference_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Wed May 29 22:49:19 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\n# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\nN, M, K = list(map(int,input().split()))\n\nmod = 10**9+7\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\n\ng2 = [1, 1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\ninv = [0, 1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n\n\nfor i in range(2, N*M+1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod\/\/i)) % mod)\n\n    g2.append((g2[-1] * inv[-1]) % mod)\n\n\n\nans1 = 0\n\ndef c(N,M):\n\n    res = 0\n\n    for i in range(1,N):\n\n        res += i*(N-i)*M*M\n\n    return res\n\nans1 += c(N,M) + c(M,N)\n\nans1 %= mod\n\n\n\nans1 *= cmb(N*M-2,K-2,mod)\n\nans1 %= mod\n\n\n\nprint(ans1)\n","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nN, M, K = map(int, input().split())\nmod = 10**9 + 7\n\n# Precompute factorials and modular inverses\ndef precompute_factorials(max_val, mod):\n    g1 = [1] * (max_val + 1)  # Factorials\n    g2 = [1] * (max_val + 1)  # Modular inverses\n    inv = [0] * (max_val + 1)\n    inv[1] = 1\n    for i in range(2, max_val + 1):\n        g1[i] = g1[i - 1] * i % mod\n        inv[i] = mod - (mod \/\/ i) * inv[mod % i] % mod\n        g2[i] = g2[i - 1] * inv[i] % mod\n    return g1, g2\n\ng1, g2 = precompute_factorials(N * M, mod)\n\n# Precompute b(i) = i * (i + 1) \/\/ 2\npre_b = [i * (i + 1) \/\/ 2 for i in range(N + M)]\n\n# Precompute a(i, j) = i * (i + 1) \/\/ 2 * (j + 1) + j * (j + 1) \/\/ 2 * (i + 1)\npre_a = [[0] * (M + 1) for _ in range(N + 1)]\nfor i in range(N + 1):\n    for j in range(M + 1):\n        pre_a[i][j] = pre_b[i] * (j + 1) + pre_b[j] * (i + 1)\n\n# Main computation\nans = 0\nfor i in range(N):\n    for j in range(M):\n        ans += (\n            pre_a[i][j] + pre_a[N - i - 1][j] +\n            pre_a[i][M - j - 1] + pre_a[N - i - 1][M - j - 1]\n        )\n        ans -= (\n            pre_b[i] + pre_b[j] +\n            pre_b[N - i - 1] + pre_b[M - j - 1]\n        )\n        ans %= mod\n\n# Final adjustments\nans = ans * g2[2] % mod\nans = ans * (g1[N * M - 2] * g2[K - 2] % mod * g2[N * M - K] % mod) % mod\n\nprint(ans)"}
{"problem_id":"p02555","slow_code_col":"s = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\n# dp[i]: \u6700\u5f8c\u306b\u5207\u3063\u305f\u5834\u6240\u304ci\n\ndp = [0]*(s + 1)\n\ndp[0] = 1\n\n\n\nfor i in range(3, s+1):\n\n    for j in range(0, (i-3)+1):\n\n        dp[i] += dp[j]\n\n        dp[i] %= mod\n\n\n\nprint((dp[s]))","reference_code_col":"s = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\n# dp[i]: \u6700\u5f8c\u306b\u5207\u3063\u305f\u5834\u6240\u304ci\n\ndp = [0]*(s + 1)\n\ndp[0] = 1\n\ntotal = 0\n\nfor i in range(3, s+1):\n\n    total += dp[i-3]\n\n    total %= mod\n\n    dp[i] = total\n\n\n\nprint((dp[s]))","model_generated_potentially_faster_code_col":"s = int(eval(input()))\n\nmod = 10**9 + 7\n\n# dp[i]: \u6700\u5f8c\u306b\u5207\u3063\u305f\u5834\u6240\u304ci\ndp = [0] * (s + 1)\ndp[0] = 1\n\n# Cumulative sum to store the sum of dp[j] for j in range(0, i-3)\ncum_sum = 0\n\nfor i in range(3, s + 1):\n    # Update cumulative sum by adding dp[i-3]\n    cum_sum += dp[i - 3]\n    cum_sum %= mod\n    \n    # Update dp[i] using the cumulative sum\n    dp[i] = cum_sum\n\nprint(dp[s])"}
{"problem_id":"p02412","slow_code_col":"while True:\n\n\tk=list(map(int,input().split(\" \")))\n\n\tif k[0]==k[1]==0:\n\n\t\tbreak\n\n\tct=0\n\n\ta=0\n\n\tb=0\n\n\tc=0\t\n\n\tmax=k[0]\n\n\tsum=k[1]\n\n\ta=max+1\n\n\t\n\n\twhile True:\n\n\t\ta-=1\n\n\t\tb=a-1\n\n\t\tc=sum-a-b\n\n\t\tif not a>b>c:\n\n\t\t\tprint(ct)\n\n\t\t\tbreak\n\n\t\twhile a>b>c:\n\n\t\t\tif a>b>c>0:\n\n\t\t\t\tct+=1\n\n\t\t\tb-=1\n\n\t\t\tc+=1\n\n\t\t\t","reference_code_col":"while True:\n\n\tk=list(map(int,input().split(\" \")))\n\n\tif k[0]==k[1]==0:\n\n\t\tbreak\n\n\tct=0\n\n\ta=0\n\n\tb=0\n\n\tc=0\t\n\n\tmax=k[0]\n\n\tsum=k[1]\n\n\ta=max+1\n\n\twhile True:\n\n\t\ta-=1\n\n\t\tb=a-1\n\n\t\tc=sum-a-b\n\n\t\tif not a>c:\n\n\t\t\tprint(ct)\n\n\t\t\tbreak\n\n\t\twhile b>c:\n\n\t\t\tif c>0:\n\n\t\t\t\tct+=1\n\n\t\t\tb-=1\n\n\t\t\tc+=1","model_generated_potentially_faster_code_col":"while True:\n    # Read input and terminate if the condition is met\n    k = list(map(int, input().split()))\n    if k[0] == k[1] == 0:\n        break\n\n    max_val = k[0]\n    total_sum = k[1]\n    count = 0\n\n    # Iterate over possible values of 'a'\n    for a in range(max_val, 0, -1):\n        # Calculate the remaining sum for 'b' and 'c'\n        remaining_sum = total_sum - a\n\n        # Iterate over possible values of 'b' such that b < a\n        for b in range(min(a - 1, remaining_sum - 1), 0, -1):\n            c = remaining_sum - b\n\n            # Check if c is valid (c < b and c > 0)\n            if c < b and c > 0:\n                count += 1\n\n    # Print the result for this iteration\n    print(count)"}
{"problem_id":"p03644","slow_code_col":"N = int(eval(input()))\n\nif N < 2:\n\n  print(N)\n\nelif 2<=N<4:\n\n  print((2))\n\nelif 4<=N<8:\n\n  print((4))\n\nelif 8<=N<16:\n\n  print((8))\n\nelif 16<=N<32:\n\n  print((16))\n\nelif 32<=N<64:\n\n  print((32))\n\nelif 64<=N:\n\n  print((64))","reference_code_col":"N = int(eval(input()))\n\nNum = [int(2**i) for i in range(7)]\n\nif N in Num:\n\n  print(N)\n\nelse:\n\n  Num.append(N)\n\n  Num = sorted(Num)\n\n  print((2 ** (Num.index(N) - 1)))","model_generated_potentially_faster_code_col":"N = int(eval(input()))\n\nif N < 2:\n    print(N)\nelse:\n    # Find the largest power of 2 less than or equal to N\n    power_of_two = 1\n    while power_of_two * 2 <= N:\n        power_of_two *= 2\n    print(power_of_two)"}
{"problem_id":"p03037","slow_code_col":"N, M = list(map(int, input().split()))\n\nLR = [list(map(int, input().split())) for _ in range(M)]\n\n\n\nleft = 1\n\nright = N\n\n\n\nfor l, r in LR:\n\n    if left < l:\n\n        left = l\n\n    if right > r:\n\n        right = r\n\n\n\nans = right - left\n\n\n\nprint((ans + 1 if ans >= 0 else 0))\n","reference_code_col":"N, M = list(map(int, input().split()))\n\n\n\nleft = 1\n\nright = N\n\n\n\nfor _ in range(M):\n\n    l, r = list(map(int, input().split()))\n\n\n\n    if left < l:\n\n        left = l\n\n    if right > r:\n\n        right = r\n\n\n\nans = right - left\n\n\n\nprint((ans + 1 if ans >= 0 else 0))\n","model_generated_potentially_faster_code_col":"import sys\n\n# Read all input at once\nlines = sys.stdin.read().splitlines()\n\n# Parse N and M from the first line\nN, M = map(int, lines[0].split())\n\n# Initialize left and right\nleft, right = 1, N\n\n# Process the remaining lines in one go\nfor line in lines[1:]:\n    l, r = map(int, line.split())\n    if left < l:\n        left = l\n    if right > r:\n        right = r\n\n# Calculate the result\nans = right - left\nprint(ans + 1 if ans >= 0 else 0)"}
{"problem_id":"p03309","slow_code_col":"import numpy as np\n\n\n\nN=int(eval(input()))\n\nA=list(map(int, input().split()))\n\n\n\nAA=[]\n\nfor i,a in enumerate(A):\n\n    AA.append(a-i+1)\n\n\n\nb=np.median(AA)\n\nans=0\n\n\n\nfor a in AA:\n\n    ans+=abs(a-b)\n\nprint((int(ans)))","reference_code_col":"N=int(eval(input()))\n\nA=list(map(int,input().split()))\n\nB=[]\n\nfor i in range(N):\n\n    B.append(A[i]-i-1)\n\nB.sort()\n\nif N%2:\n\n    b=B[N\/\/2]\n\nelse:\n\n    b=(B[N\/\/2]+B[N\/\/2-1])\/\/2\n\nans=0\n\nfor k in B:\n\n    ans+=abs(k-b)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN = int(input())  # No need for eval; just use int()\nA = list(map(int, input().split()))\n\n# Compute AA using list comprehension (faster than appending in a loop)\nAA = [a - i + 1 for i, a in enumerate(A)]\n\n# Compute the median of AA\nb = np.median(AA)\n\n# Compute the sum of absolute differences using a generator expression\nans = sum(abs(a - b) for a in AA)\n\n# Print the result\nprint(int(ans))"}
{"problem_id":"p03060","slow_code_col":"n = int(eval(input()))\n\nv = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\nresult = 0\n\nfor i in range(n):\n\n  if v[i] > c[i]:\n\n    result += v[i] - c[i]\n\nprint(result)","reference_code_col":"N = int(eval(input()))\n\nV = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\nprint((sum([V[i] - C[i] for i in range(N) if V[i] > C[i]])))\n","model_generated_potentially_faster_code_col":"# Read input values\nn = int(input())\nv = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\n# Initialize result\nresult = 0\n\n# Iterate through v and c simultaneously using zip\nfor vi, ci in zip(v, c):\n    if vi > ci:\n        result += vi - ci\n\n# Print the final result\nprint(result)"}
{"problem_id":"p02760","slow_code_col":"import numpy as np\n\n\n\na = [list(map(int, input().split())) for _ in range(3)]\n\na = np.array(a)\n\nn = int(eval(input()))\n\n\n\nfor _ in range(n):\n\n    b = int(eval(input()))\n\n    \n\n    for j in range(3):\n\n        for i in range(3):\n\n            if a[j][i] == b:\n\n                a[j][i] = 0\n\n\n\nat = a.transpose()\n\nflag = False\n\nfor i in range(3):\n\n    if sum(a[:][i]) == 0 or sum(at[:][i]) == 0:\n\n        flag = True\n\n        break\n\ndiag = a[0][0] + a[1][1] + a[2][2]\n\ndiag2 = a[2][0] + a[1][1] + a[0][2]\n\nif diag == 0 or diag2 == 0:\n\n    flag = True\n\n\n\nprint((\"Yes\" if flag else \"No\"))","reference_code_col":"a = [list(map(int, input().split())) for _ in range(3)]\n\nn = int(eval(input()))\n\nb = [int(eval(input())) for _ in range(n)]\n\n\n\nflag = False\n\nfor i in range(3):\n\n    if a[i][0] in b and a[i][1] in b and a[i][2] in b:\n\n        flag = True\n\n        break\n\n    if a[0][i] in b and a[1][i] in b and a[2][i] in b:\n\n        flag = True\n\n        break\n\nif a[0][0] in b and a[1][1] in b and a[2][2] in b:\n\n    flag = True\n\nif a[2][0] in b and a[1][1] in b and a[0][2] in b:\n\n    flag = True\n\n    \n\nprint((\"Yes\" if flag else \"No\"))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input for the 3x3 matrix\na = np.array([list(map(int, input().split())) for _ in range(3)])\n\n# Read the number of queries\nn = int(input())\n\n# Process each query\nfor _ in range(n):\n    b = int(input())\n    # Replace occurrences of `b` in the matrix with 0\n    a[a == b] = 0\n\n# Check row sums and column sums\nrow_sums = a.sum(axis=1)\ncol_sums = a.sum(axis=0)\n\n# Check diagonals\ndiag1_sum = a[0, 0] + a[1, 1] + a[2, 2]\ndiag2_sum = a[0, 2] + a[1, 1] + a[2, 0]\n\n# Determine if any row, column, or diagonal sum is zero\nflag = (0 in row_sums) or (0 in col_sums) or (diag1_sum == 0) or (diag2_sum == 0)\n\n# Output the result\nprint(\"Yes\" if flag else \"No\")"}
{"problem_id":"p03592","slow_code_col":"\n\nn,m,k = list(map(int,input().split()))\n\n#\uff11\u56de\u62bc\u3059\u3068\u5909\u308f\u308b\u30de\u30b9\u3000= N * M -1\n\n#\uff12\u56de\u76ee\u62bc\u3059\u3068\u9ed2\u306b\u5909\u308f\u308b\u30de\u30b9 N * M -1 -2\n\n# 3 = N * M -1 -4\n\n\n\ncnt = 0\n\nfor i in range(n+1):\n\n    for j in range(m + 1):\n\n        cnt = i * m + j * n -2 * i * j\n\n        if cnt == k:\n\n            print(\"Yes\")\n\n            exit()\n\nprint(\"No\")\n","reference_code_col":"\n\nn,m,k = list(map(int,input().split()))\n\n\n\nfor i in range(n+1):\n\n    for j in range(m+1):\n\n        if i*(m-j) + j*(n-i) == k:\n\n            print(\"Yes\")\n\n            exit()\n\nprint(\"No\")\n","model_generated_potentially_faster_code_col":"n, m, k = map(int, input().split())\n\nfor i in range(n + 1):\n    denominator = n - 2 * i\n    if denominator != 0:  # Avoid division by zero\n        numerator = k - i * m\n        if numerator % denominator == 0:  # Check if j is an integer\n            j = numerator \/\/ denominator\n            if 0 <= j <= m:  # Ensure j is within the valid range\n                print(\"Yes\")\n                exit()\n\nprint(\"No\")"}
{"problem_id":"p03416","slow_code_col":"a,b = list(map(int,input().split()))\n\nanswer = 0\n\nfor i in range(a,b+1) :\n\n    j = str(i)\n\n    p1 = j[4]\n\n    p2 = j[3]\n\n    p3 = j[2]\n\n    p4 = j[1]\n\n    p5 = j[0]\n\n    k = int(p1+p2+p3+p4+p5)\n\n    if i == k :\n\n        answer += 1\n\nprint(answer)\n\n\n","reference_code_col":"A,B = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(A,B+1) :\n\n    l = str(i)\n\n    if l[0] == l[4] and l[1] == l[3] :\n\n        ans += 1\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"a, b = map(int, input().split())\n\ndef reverse_number(n):\n    \"\"\"Reverse the digits of a number mathematically.\"\"\"\n    reversed_num = 0\n    while n > 0:\n        reversed_num = reversed_num * 10 + (n % 10)\n        n \/\/= 10\n    return reversed_num\n\nanswer = 0\n\nfor i in range(a, b + 1):\n    if i == reverse_number(i):  # Check if the number is equal to its reverse\n        answer += 1\n\nprint(answer)"}
{"problem_id":"p03721","slow_code_col":"N,K=list(map(int,input().split()))\n\ndic={}\n\nfor i in range(N):\n\n  a,b=list(map(int,input().split()))\n\n  if a in dic:\n\n    dic[a]+=b\n\n  else:\n\n    dic[a]=b\n\n    \n\ndic=sorted(list(dic.items()),key=lambda x:x[0])\n\nfor d in range(len(dic)):\n\n  amount=dic[d][1]\n\n  if amount>=K:\n\n    print((dic[d][0]))\n\n    exit(0)\n\n  else:\n\n    K-=amount\n\n  ","reference_code_col":"import sys\n\nreadline = sys.stdin.readline\n\n\n\nN,K = list(map(int,readline().split()))\n\n\n\nAB = [list(map(int,readline().split())) for i in range(N)]\n\n\n\nAB = sorted(AB, key = lambda x:x[0])\n\namount = 0\n\nfor a,b in AB:\n\n  amount += b\n\n  if amount >= K:\n\n    print(a)\n\n    break\n","model_generated_potentially_faster_code_col":"import heapq\n\n# Read N and K\nN, K = map(int, input().split())\n\n# Use a dictionary to aggregate values\ndic = {}\n\n# Populate the dictionary\nfor _ in range(N):\n    a, b = map(int, input().split())\n    if a in dic:\n        dic[a] += b\n    else:\n        dic[a] = b\n\n# Create a min-heap from the dictionary items\nheap = [(key, value) for key, value in dic.items()]\nheapq.heapify(heap)\n\n# Process the heap to find the result\ncumulative_sum = 0\nwhile heap:\n    key, value = heapq.heappop(heap)\n    cumulative_sum += value\n    if cumulative_sum >= K:\n        print(key)\n        exit(0)"}
{"problem_id":"p02982","slow_code_col":"import math\n\nimport numpy as np\n\nn, d = list(map(int, input().split()))\n\na = []\n\ncnt = 0\n\nfor x in range(n):\n\n    a.append(list(map(int, input().split())))\n\nfor i in range(len(a)):\n\n    for j in range(len(a)):\n\n        if i < j:\n\n            dis = np.array(a[i]) - np.array(a[j])\n\n            if np.linalg.norm(dis).is_integer():\n\n                cnt += 1\n\nprint(cnt)","reference_code_col":"n, d = list(map(int, input().split()))\n\na = [[int(i) for i in input().split()] for i in range(n)]\n\nans = 0\n\ndef dis(x,y):\n\n    T = []\n\n    for i in range(len(x)):\n\n        T.append((x[i]-y[i])**2)\n\n    return sum(T)\n\nfor i in range(n):\n\n    for j in range(i+1,n):\n\n        r = dis(a[i], a[j])\n\n        for k in range(r + 1):\n\n            if k ** 2 == r:\n\n                ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input reading\nn, d = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\n# Convert the list of points to a NumPy array for efficient computation\na = np.array(a)\n\ncnt = 0\n\n# Iterate over all unique pairs of points\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Compute the squared Euclidean distance\n        squared_distance = np.sum((a[i] - a[j]) ** 2)\n        \n        # Check if the squared distance is a perfect square (i.e., distance is an integer)\n        if int(np.sqrt(squared_distance)) ** 2 == squared_distance:\n            cnt += 1\n\nprint(cnt)"}
{"problem_id":"p03000","slow_code_col":"from itertools import accumulate\n\nfrom bisect import *\n\nN, X = list(map(int, input().split()))\n\nL = list(tuple(map(int, input().split())))\n\n\n\nacc = sorted(list(accumulate(L)) + [0])\n\n\n\nn = bisect_right(acc,X)\n\nprint(n)\n\n\n","reference_code_col":"N,X = list(map(int,input().split()))\n\nL = list(map(int,input().split()))\n\nList = [0]*(N+1)\n\nfor i in range(1,N+1):\n\n    List[i] = List[i-1] + L[i-1]\n\nA = [i for i in List if i <=X]\n\nprint((len(A)))","model_generated_potentially_faster_code_col":"from itertools import accumulate\nfrom bisect import bisect_right\n\n# Read input values\nN, X = map(int, input().split())\nL = list(map(int, input().split()))\n\n# Compute prefix sums\nprefix_sums = list(accumulate(L))\n\n# Count how many prefix sums (including 0) are <= X\ncount = 1 if X >= 0 else 0  # Start with 1 if 0 is included (since 0 is always <= X)\nfor s in prefix_sums:\n    if s <= X:\n        count += 1\n    else:\n        break  # Stop early if the sum exceeds X\n\nprint(count)"}
{"problem_id":"p03416","slow_code_col":"A, B = list(map(int, input().split()))\n\n\n\ncnt = 0\n\nfor n in range(A, B+1):\n\n    n_s = str(n)\n\n    n_s_rvs = n_s[::-1]\n\n    if n_s == n_s_rvs:\n\n        cnt += 1\n\n\n\nprint(cnt)\n","reference_code_col":"A, B = list(map(int, input().split()))\n\n\n\ncnt = 0\n\nfor n in range(A, B+1):\n\n    if n\/\/10000 == n%10 and (n\/\/1000)%10 == (n\/\/10)%10:\n\n        cnt += 1\n\n\n\nprint(cnt)\n","model_generated_potentially_faster_code_col":"def is_palindrome(n):\n    \"\"\"Check if a number is a palindrome using mathematical operations.\"\"\"\n    original = n\n    reverse = 0\n    while n > 0:\n        reverse = reverse * 10 + (n % 10)\n        n \/\/= 10\n    return original == reverse\n\ndef count_palindromes(A, B):\n    \"\"\"Count palindromes in the range [A, B] efficiently.\"\"\"\n    cnt = 0\n    for n in range(A, B + 1):\n        if is_palindrome(n):\n            cnt += 1\n    return cnt\n\n# Input reading\nA, B = map(int, input().split())\n\n# Count and print palindromes\nprint(count_palindromes(A, B))"}
{"problem_id":"p03649","slow_code_col":"from numpy import*\n\nN,*A=open(0)\n\nN,A,S,a=int(N),loadtxt(A,int),1,0\n\nwhile S:B=A\/\/N;S=sum(B);a+=S;A+=S-B*-~N\n\nprint(a)","reference_code_col":"N, *A = list(map(int, open(0).read().split()))\n\n\n\nans = 0\n\nS = -1\n\nwhile S:\n\n    S = sum(a \/\/ N for a in A)\n\n    ans += S\n\n    A = [a % N + (S - a \/\/ N) for a in A]\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"from numpy import *\n\n# Read input\nN, *A = open(0)\nN = int(N)\nA = loadtxt(A, int)\n\n# Initialize variables\na = 0\n\nwhile True:\n    # Compute B and S in one step\n    B = A \/\/ N\n    S = sum(B)\n    \n    if S == 0:  # Exit condition\n        break\n    \n    # Update a and A\n    a += S\n    A += S - B * (N + 1)\n\nprint(a)"}
{"problem_id":"p03162","slow_code_col":"#!\/usr\/bin\/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    N = int(eval(input()))\n\n    happiness = [list(map(int, input().split())) for _ in range(N)]\n\n\n\n    dp = np.zeros((N, 3), dtype=np.int64)\n\n    dp[0] = happiness[0]\n\n    for i in range(1, N):\n\n        for a, yesterday in enumerate(dp[i - 1]):\n\n            for b, today in enumerate(happiness[i]):\n\n                if a == b:\n\n                    continue\n\n                dp[i][b] = max(dp[i][b], yesterday + today)\n\n    print((max(dp[-1])))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"#!\/usr\/bin\/env python3\n\ndef main():\n\n    N = int(eval(input()))\n\n    happiness = [list(map(int, input().split())) for _ in range(N)]\n\n\n\n    dp = [0, 0, 0]\n\n    for a, b, c in happiness:\n\n        dp = [max(dp[1], dp[2]) + a,\n\n              max(dp[0], dp[2]) + b,\n\n              max(dp[0], dp[1]) + c]\n\n    print((max(dp)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env python3\n\ndef main():\n    import numpy as np\n\n    # Read input\n    N = int(input())\n    happiness = np.array([list(map(int, input().split())) for _ in range(N)], dtype=np.int64)\n\n    # Initialize DP array\n    dp = np.zeros((N, 3), dtype=np.int64)\n    dp[0] = happiness[0]\n\n    # Fill DP table\n    for i in range(1, N):\n        # Compute max happiness for each activity, excluding the same activity from the previous day\n        dp[i] = happiness[i] + np.maximum(\n            np.roll(dp[i - 1], 1),  # Exclude the same activity by rolling the array\n            np.roll(dp[i - 1], 2)   # Another roll to exclude the same activity\n        )\n\n    # Print the result\n    print(np.max(dp[-1]))\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03796","slow_code_col":"import math\n\nN=int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))","reference_code_col":"N=int(eval(input()))\n\npower=1\n\nfor i in range(1,N+1):\n\n    power*=i\n\n    power%=10**9+7\n\nprint(power)","model_generated_potentially_faster_code_col":"N = int(input())  # Safely parse input as an integer\nMOD = 10**9 + 7   # Define the modulo constant\n\n# Compute factorial iteratively with modulo at each step\nresult = 1\nfor i in range(2, N + 1):\n    result = (result * i) % MOD\n\nprint(result)"}
{"problem_id":"p03371","slow_code_col":"# ABC95 C -Half and Half\n\na,b,c,x,y = list(map(float,input().split()))\n\nans = 0\n\nif a+b > 2*c:\n\n    while x != 0.0 and y != 0.0:\n\n        ans += 2*c\n\n        x -= 1.0\n\n        y -= 1.0\n\n        if y == 0.0:\n\n            while x != 0.0:\n\n                if a > 2*c:\n\n                    ans += 2*c\n\n                    x -= 1.0\n\n                else:\n\n                    ans += a\n\n                    x -= 1.0\n\n        if x == 0.0:\n\n            while y != 0.0:\n\n                if b > 2*c:\n\n                    ans += 2*c\n\n                    y -= 1.0\n\n                else:\n\n                    ans += b\n\n                    y -= 1.0\n\nelse:\n\n    ans += a*x + b*y\n\nprint((int(ans)))\n\n\n\n    ","reference_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\nans=0\n\nans1=0\n\n\n\ne=max(x,y)\n\nans1=e*(2*c)\n\nif 2*c<a+b:\n\n    d=min(x,y)\n\n    ans+=c*(2*d)\n\n    x-=d\n\n    y-=d\n\nelse:\n\n    ans=a*x+b*y\n\n    x-=x\n\n    y-=y\n\nans+=x*a\n\nans+=y*b\n\nprint((min(ans,ans1)))","model_generated_potentially_faster_code_col":"# Input values\na, b, c, x, y = map(float, input().split())\n\n# Initialize the answer\nans = 0\n\n# Determine the number of AB pizzas needed\nab_pizzas = min(x, y)  # Number of AB pizzas that can replace one A and one B pizza\n\n# Check if buying AB pizzas is cheaper than buying individual A and B pizzas\nif a + b > 2 * c:\n    ans += ab_pizzas * 2 * c  # Add cost for AB pizzas replacing A and B\n    x -= ab_pizzas  # Reduce remaining A pizzas\n    y -= ab_pizzas  # Reduce remaining B pizzas\nelse:\n    ans += ab_pizzas * (a + b)  # Buy A and B pizzas separately\n    x -= ab_pizzas\n    y -= ab_pizzas\n\n# Handle remaining A pizzas\nif x > 0:\n    ans += min(a, 2 * c) * x  # Choose cheaper option: A pizza or AB pizza\n\n# Handle remaining B pizzas\nif y > 0:\n    ans += min(b, 2 * c) * y  # Choose cheaper option: B pizza or AB pizza\n\n# Print the result\nprint(int(ans))"}
{"problem_id":"p03032","slow_code_col":"# coding: utf-8\n\nimport copy\n\nimport numpy as np\n\n\n\nn, k = list(map(int, input().split()))\n\nv = list(map(int, input().split()))\n\nrev = copy.copy(v)\n\nrev.reverse()\n\n\n\nlcs = [0]+np.cumsum(v)\n\nrcs = [0]+np.cumsum(rev)\n\n# print(lcs,rcs)\n\n\n\nans = -10**20\n\nfor l in range(n+1):\n\n  for r in range(n+1-l):\n\n    able = True\n\n    d = k - ( l + r )\n\n    if d < 0:\n\n      able = False\n\n      break\n\n    # m = lcs[l] + rcs[r]\n\n    t = v[0:l] + rev[0:r]\n\n    m = sum(t)\n\n    # print(t,l,r,m)\n\n    t.sort()\n\n    # print(t)\n\n    d = min(d,l+r)\n\n    for i in range(d):\n\n      if 0 > t[i]:\n\n        m -= t[i]\n\n      else:\n\n        break\n\n    # print(m)\n\n    ans = max(ans,m)\n\n\n\nprint(ans)\n\n    ","reference_code_col":"# coding: utf-8\n\nimport copy\n\n\n\nn, k = list(map(int, input().split()))\n\nv = list(map(int, input().split()))\n\nrev = copy.copy(v)\n\nrev.reverse()\n\n\n\nans = -10**20\n\nfor l in range(n+1):\n\n  for r in range(n+1-l):\n\n    able = True\n\n    d = k - ( l + r )\n\n    if d < 0:\n\n      able = False\n\n      break\n\n    t = v[0:l] + rev[0:r]\n\n    m = sum(t)\n\n    t.sort()\n\n    d = min(d,l+r)\n\n    for i in range(d):\n\n      if 0 > t[i]:\n\n        m -= t[i]\n\n      else:\n\n        break\n\n    ans = max(ans,m)\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"# coding: utf-8\n\nimport numpy as np\n\n# Input reading\nn, k = map(int, input().split())\nv = list(map(int, input().split()))\n\n# Precompute cumulative sums\nlcs = [0] + np.cumsum(v).tolist()  # Cumulative sum from left\nrcs = [0] + np.cumsum(v[::-1]).tolist()  # Cumulative sum from right (reversed)\n\n# Sort the array for efficient removal of negative elements\nsorted_v = sorted(v)\n\n# Initialize answer\nans = -10**20\n\n# Iterate over all valid (l, r) pairs\nfor l in range(n + 1):\n    for r in range(n + 1 - l):\n        if l + r > k:\n            continue  # Skip invalid combinations\n        \n        # Calculate the sum of elements in v[0:l] and v[n-r:n]\n        m = lcs[l] + rcs[r]\n        \n        # Determine how many elements can be removed\n        d = k - (l + r)\n        d = min(d, l + r)  # Cannot remove more than l + r elements\n        \n        # Remove up to d smallest (most negative) elements\n        for i in range(d):\n            if sorted_v[i] < 0:\n                m -= sorted_v[i]\n            else:\n                break  # Stop once we encounter non-negative elements\n        \n        # Update the answer\n        ans = max(ans, m)\n\n# Output the result\nprint(ans)"}
{"problem_id":"p03162","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\ndp = [[0, 0, 0] for i in range(N+1)]\n\nfor i in range(1, N+1):\n\n    a, b, c = list(map(int, input().split(' ')))\n\n    dp[i][0] = max(dp[i-1][1], dp[i-1][2]) + a\n\n    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + b\n\n    dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + c\n\nprint((np.max(dp[-1])))","reference_code_col":"N = int(eval(input()))\n\ndp = [[0, 0, 0] for i in range(N+1)]\n\nfor i in range(1, N+1):\n\n    a, b, c = list(map(int, input().split(' ')))\n\n    dp[i][0] = max(dp[i-1][1], dp[i-1][2]) + a\n\n    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + b\n\n    dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + c\n\nprint((max(dp[-1])))","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Initialize previous and current DP rows\nprev_dp = [0, 0, 0]\ncurrent_dp = [0, 0, 0]\n\nfor _ in range(N):\n    # Read input values directly\n    a, b, c = map(int, input().split())\n    \n    # Compute max values from the previous row\n    max_01 = max(prev_dp[0], prev_dp[1])\n    max_02 = max(prev_dp[0], prev_dp[2])\n    max_12 = max(prev_dp[1], prev_dp[2])\n    \n    # Update current DP row\n    current_dp[0] = max_12 + a\n    current_dp[1] = max_02 + b\n    current_dp[2] = max_01 + c\n    \n    # Swap current_dp and prev_dp for the next iteration\n    prev_dp, current_dp = current_dp, prev_dp\n\n# Output the maximum value from the last row\nprint(max(prev_dp))"}
{"problem_id":"p02595","slow_code_col":"N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x ** 2 + y ** 2 <= D ** 2:\n\n        cnt += 1\n\n        \n\nprint(cnt)","reference_code_col":"N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x * x + y * y <= D * D:\n\n        cnt += 1\n\n        \n\nprint(cnt)","model_generated_potentially_faster_code_col":"# Read N and D, and precompute D_squared\nN, D = map(int, input().split())\nD_squared = D * D\n\n# Initialize the counter\ncnt = 0\n\n# Process each point\nfor _ in range(N):\n    # Read x and y directly without creating intermediate lists\n    x, y = map(int, input().split())\n    \n    # Check if the point lies within the circle\n    if x * x + y * y <= D_squared:\n        cnt += 1\n\n# Output the result\nprint(cnt)"}
{"problem_id":"p02693","slow_code_col":"S = int(eval(input()))\n\na = 0\n\ncount = 0\n\nn,m = list(map(int,input().split()))\n\nwhile count == 0:\n\n    a += S\n\n    if n <= a and m >= a:\n\n        count = 1\n\n    if a >= 1000:\n\n        break\n\nif count == 0:\n\n    print(\"NG\")\n\nelse:\n\n    print(\"OK\")","reference_code_col":"k = int(eval(input()))\n\nn = 0\n\na,b = list(map(int,input().split()))\n\nwhile True:\n\n    n += k\n\n    if n >= a and n <= b:\n\n        print(\"OK\")\n\n        break\n\n    if n > b:\n\n        print(\"NG\")\n\n        break","model_generated_potentially_faster_code_col":"# Read inputs\nS = int(input())\nn, m = map(int, input().split())\n\n# Initialize variables\na = 0\n\n# Loop to check conditions\nwhile True:\n    a += S\n    if n <= a <= m:  # Check if 'a' is within the range [n, m]\n        print(\"OK\")\n        break\n    if a >= 1000:  # Early exit if 'a' exceeds or equals 1000\n        print(\"NG\")\n        break"}
{"problem_id":"p03171","slow_code_col":"N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nn = N % 2\n\n\n\nDP = [[0] * (N+1) for _ in range(N+1)]\n\n\n\nfor w in range(1, N+1):\n\n    for i in range(N):\n\n        j = i + w\n\n        if j > N:\n\n            continue\n\n        if (w+n) % 2 == 1:\n\n            DP[i][j] = min(DP[i+1][j] - A[i], DP[i][j-1] - A[j-1])\n\n        else:\n\n            DP[i][j] = max(DP[i+1][j] + A[i], DP[i][j-1] + A[j-1])\n\n\n\nprint((DP[0][N]))\n","reference_code_col":"N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nDP = [[0] * (N+1) for _ in range(N+1)]\n\n\n\nfor num in range(1, N + 1):\n\n    for start in range(N):\n\n        end = start + num\n\n        if end > N:\n\n            break\n\n        if num == 1:\n\n            DP[start][end] = A[start]\n\n        else:\n\n            DP[start][end] = max(A[start] - DP[start+1][end], A[end - 1] - DP[start][end - 1])\n\nprint((DP[0][N]))\n","model_generated_potentially_faster_code_col":"# Input parsing\nN = int(input())\nA = list(map(int, input().split()))\nn = N % 2\n\n# Initialize DP table\nDP = [[0] * (N + 1) for _ in range(N + 1)]\n\n# Fill DP table\nfor w in range(1, N + 1):\n    parity = (w + n) % 2  # Precompute parity for this window size\n    for i in range(N - w + 1):  # Adjust loop bounds to avoid invalid indices\n        j = i + w\n        dp_i1_j = DP[i + 1][j]\n        dp_i_j1 = DP[i][j - 1]\n\n        if parity == 1:  # Odd parity\n            DP[i][j] = min(dp_i1_j - A[i], dp_i_j1 - A[j - 1])\n        else:  # Even parity\n            DP[i][j] = max(dp_i1_j + A[i], dp_i_j1 + A[j - 1])\n\n# Output the result\nprint(DP[0][N])"}
{"problem_id":"p02837","slow_code_col":"n = int(eval(input()))\n\n\n\nXY = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    xy = []\n\n    for j in range(a):\n\n        xy.append(list(map(int, input().split())))\n\n    \n\n    XY.append(xy)\n\n    \n\ndef check(i, xiyj, HoU):\n\n    # \u77db\u76fe\u3057\u305f\u3089False \u6b63\u76f4\u8005\u3068\u4eee\u5b9a\u3057\u305f\u8a3c\u8a00\u3088\u308a \u6b63\u76f4&\u6b63\u76f4\u8005\u3068\u4eee\u5b9a\u3055\u308c\u3066\u3044\u308b \/ \u4e0d\u89aa\u5207&\u4e0d\u89aa\u5207\u3068\u4eee\u5b9a\u3055\u308c\u3066\u3044\u308b True\n\n    if ((i >> xiyj) & 1) ^ HoU:\n\n        return False\n\n\n\n    return True\n\n    \n\nmax_honest = 0\n\nfor i in range(2 ** len(XY)):\n\n    count = 0\n\n    is_contradiction = True\n\n    for j in range(len(XY)):\n\n        # \u6b63\u76f4\u8005\u3068\u4eee\u5b9a\u3057\u305f\u3068\u304d\u3060\u3051\u63a1\u7528\n\n        if not ((i >> j) & 1): continue\n\n        for k in range(len(XY[j])):\n\n            xiyj = XY[j][k][0] - 1\n\n            HoU = XY[j][k][1]\n\n            \n\n            if not check(i, xiyj, HoU):\n\n                is_contradiction = False\n\n                break\n\n                \n\n        if not is_contradiction:\n\n            break\n\n\n\n    if is_contradiction:\n\n        for j in range(len(XY)):\n\n            if ((i >> j) & 1): count+=1 \n\n                \n\n        if count > max_honest:\n\n            max_honest =count\n\n            \n\nprint(max_honest)","reference_code_col":"n = int(eval(input()))\n\n\n\nXY = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    xy = []\n\n    for j in range(a):\n\n        xy.append(list(map(int, input().split())))\n\n    \n\n    XY.append(xy)\n\n\n\n\"\"\"\n\n    \u77db\u76fe\u3057\u305f\u3089False\n\n    \u77db\u76fe\u3057\u306a\u3051\u308c\u3070True\n\n    \u6b63\u76f4\u8005\u3068\u4eee\u5b9a\u3057\u305f\u8005\u306e\u8a3c\u8a00\n\n        \u6b63\u76f4&\u6b63\u76f4\u8005\u3068\u4eee\u5b9a\u3055\u308c\u3066\u3044\u308b\n\n        \u4e0d\u89aa\u5207&\u4e0d\u89aa\u5207\u3068\u4eee\u5b9a\u3055\u308c\u3066\u3044\u308b\n\n\"\"\"\n\ndef check(i, xiyj, HoU):\n\n    # XOR\n\n    if HoU ^ ((i >> xiyj) & 1):\n\n        return False\n\n\n\n    return True\n\n\n\nmax_honest = 0\n\nfor i in range(2 ** len(XY)):\n\n    count = 0\n\n    is_contradiction = True\n\n    for j in range(len(XY)):\n\n        # \u6b63\u76f4\u8005\u3068\u4eee\u5b9a\u3057\u305f\u3068\u304d\u3060\u3051\u63a1\u7528\n\n        if not ((i >> j) & 1): continue\n\n        count+=1\n\n        for k in range(len(XY[j])):\n\n            xiyj = XY[j][k][0] - 1\n\n            HoU = XY[j][k][1]\n\n            \n\n            if not check(i, xiyj, HoU):\n\n                is_contradiction = False\n\n                break # TLE\u5bfe\u7b56\n\n                \n\n        if not is_contradiction:\n\n            break # TLE\u5bfe\u7b56\n\n\n\n    # \u77db\u76fe\u304c\u306a\u304f\u3001\u6b63\u76f4\u8005\u306e\u6570\u304c\u66f4\u65b0\u3067\u304d\u308c\u3070\u66f4\u65b0\n\n    if is_contradiction and (count > max_honest):\n\n        max_honest =count\n\n            \n\nprint(max_honest)","model_generated_potentially_faster_code_col":"from itertools import combinations\n\ndef main():\n    # Input parsing\n    n = int(input())\n    XY = []\n\n    for _ in range(n):\n        a = int(input())\n        xy = [list(map(int, input().split())) for _ in range(a)]\n        XY.append(xy)\n\n    max_honest = 0\n\n    # Precompute testimonies for faster access\n    testimonies = [[] for _ in range(n)]\n    for i in range(n):\n        for xiyj, HoU in XY[i]:\n            testimonies[i].append((xiyj - 1, HoU))\n\n    # Iterate over all possible subsets of honest people\n    for num_honest in range(n, 0, -1):  # Start from the largest possible number of honest people\n        for honest_set in combinations(range(n), num_honest):\n            honest_set = set(honest_set)\n            is_contradiction = False\n\n            for i in honest_set:\n                for xiyj, HoU in testimonies[i]:\n                    if ((xiyj in honest_set) ^ HoU):  # Check for contradiction\n                        is_contradiction = True\n                        break\n                if is_contradiction:\n                    break\n\n            if not is_contradiction:\n                max_honest = num_honest\n                break  # No need to check smaller subsets\n\n        if max_honest > 0:\n            break  # Stop once the maximum is found\n\n    print(max_honest)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03796","slow_code_col":"from math import factorial as fc\n\na = int(eval(input()))\n\nprint((fc(a)%(10**9+7)))","reference_code_col":"n = int(eval(input()))\n\nm = 10**9+7\n\nans = 1\n\nfor i in range(1, n+1):\n\n  ans *= i\n\n  ans %= m\n\nprint(ans)","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\na = int(input())\n\nif a >= MOD:\n    # If a >= MOD, the factorial will include MOD as a factor, so the result is 0\n    print(0)\nelse:\n    result = 1\n    for i in range(2, a + 1):\n        result = (result * i) % MOD\n    print(result)"}
{"problem_id":"p02574","slow_code_col":"from math import gcd\n\n\n\nN = int(eval(input()))\n\nnum_lis = list(map(int, input().split()))\n\nc = True\n\n\n\ndef osa_k(max_num):\n\n  lis = [i for i in range(max_num+1)]\n\n  p = 2\n\n  while p**2 <= max_num:\n\n    if lis[p] == p:\n\n      for q in range(2*p, max_num+1, p):\n\n        if lis[q] == q:\n\n          lis[q] = p\n\n    p += 1\n\n  return lis\n\n\n\nhoge = 0\n\nfor i in num_lis:\n\n  hoge = gcd(hoge, i)\n\nif hoge > 1:\n\n  print(\"not coprime\")\n\n  exit()\n\n\n\nd_lis = osa_k(10**6+10)\n\ntmp = set()\n\nfor i in num_lis:\n\n  num = i\n\n  new_tmp = set()\n\n  while num > 1:\n\n    d = d_lis[num]\n\n    new_tmp.add(d)\n\n    num \/\/= d\n\n  for j in new_tmp:\n\n    if j in tmp:\n\n      c = False\n\n      break\n\n    else:\n\n      tmp.add(j)\n\n  else:\n\n    continue\n\n  break\n\n\n\nif c:\n\n  print(\"pairwise coprime\")\n\nelse:\n\n  print(\"setwise coprime\")","reference_code_col":"from math import gcd\n\n\n\nN = int(eval(input()))\n\nnum_lis = list(map(int, input().split()))\n\n\n\ndef osa_k(max_num):\n\n  lis = [i for i in range(max_num+1)]\n\n  p = 2\n\n  while p**2 <= max_num:\n\n    if lis[p] == p:\n\n      for q in range(2*p, max_num+1, p):\n\n        if lis[q] == q:\n\n          lis[q] = p\n\n    p += 1\n\n  return lis\n\n\n\nhoge = 0\n\nfor i in num_lis:\n\n  hoge = gcd(hoge, i)\n\nif hoge > 1:\n\n  print(\"not coprime\")\n\n  exit()\n\n\n\nd_lis = osa_k(max(num_lis))\n\ntmp = set()\n\nfor i in num_lis:\n\n  num = i\n\n  new_tmp = set()\n\n  while num > 1:\n\n    d = d_lis[num]\n\n    new_tmp.add(d)\n\n    num \/\/= d\n\n  for j in new_tmp:\n\n    if j in tmp:\n\n      print(\"setwise coprime\")\n\n      exit()\n\n    else:\n\n      tmp.add(j)\n\nprint(\"pairwise coprime\")","model_generated_potentially_faster_code_col":"from math import gcd\n\n# Input parsing\nN = int(eval(input()))\nnum_lis = list(map(int, input().split()))\n\n# Check if all numbers have a common GCD > 1\nhoge = 0\nfor i in num_lis:\n    hoge = gcd(hoge, i)\nif hoge > 1:\n    print(\"not coprime\")\n    exit()\n\n# Optimized sieve of Eratosthenes for smallest prime factors\ndef osa_k(max_num):\n    lis = list(range(max_num + 1))\n    lis[2::2] = [2] * ((max_num - 1) \/\/ 2)  # Handle multiples of 2\n    p = 3\n    while p * p <= max_num:\n        if lis[p] == p:  # p is still marked as its own SPF\n            for q in range(p * p, max_num + 1, 2 * p):  # Skip even multiples\n                if lis[q] == q:\n                    lis[q] = p\n        p += 2  # Increment by 2 to skip even numbers\n    return lis\n\n# Generate smallest prime factors up to the maximum number in num_lis\nmax_num = max(num_lis)\nd_lis = osa_k(max_num)\n\n# Check pairwise coprimality\ntmp = set()\nc = True\nfor i in num_lis:\n    num = i\n    factors = set()\n    while num > 1:\n        d = d_lis[num]\n        factors.add(d)\n        num \/\/= d\n    for factor in factors:\n        if factor in tmp:\n            c = False\n            break\n        tmp.add(factor)\n    if not c:\n        break\n\n# Output result\nprint(\"pairwise coprime\" if c else \"setwise coprime\")"}
{"problem_id":"p02850","slow_code_col":"n = int(eval(input()))\n\nedges = []\n\n\n\nfor id in range(n-1):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1, id])\n\n\n\nedges.sort()\n\n\n\nused = [0]*(n)\n\nans = [0]*(n-1)\n\nnum = 1\n\nprev = 0\n\nfor edge in edges:\n\n    _from, to, id = edge\n\n    if _from != prev:\n\n        num = 1\n\n    if used[_from] == num:\n\n        num += 1\n\n    ans[id] = num\n\n    used[to] = num\n\n    num += 1\n\n    prev = _from\n\n\n\nprint((max(ans)))\n\nfor color in ans:\n\n    print(color)\n","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\nedges = []\n\n\n\nfor id in range(n-1):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1, id])\n\n\n\nedges.sort()\n\n\n\nused = [0]*(n)\n\nans = [0]*(n-1)\n\nnum = 1\n\nprev = 0\n\nfor edge in edges:\n\n    _from, to, id = edge\n\n    if _from != prev:\n\n        num = 1\n\n    if used[_from] == num:\n\n        num += 1\n\n    ans[id] = num\n\n    used[to] = num\n\n    num += 1\n\n    prev = _from\n\n\n\nprint((max(ans)))\n\nfor color in ans:\n\n    print(color)\n","model_generated_potentially_faster_code_col":"import sys\nfrom collections import defaultdict\n\ndef main():\n    # Faster input reading using sys.stdin\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])  # Number of nodes\n    edges = []\n    \n    # Parse edges in bulk\n    idx = 1\n    for id in range(n - 1):\n        a, b = int(data[idx]), int(data[idx + 1])\n        edges.append((a - 1, b - 1, id))\n        idx += 2\n    \n    # Sort edges by the first node (_from)\n    edges.sort()\n    \n    # Initialize arrays\n    used = [0] * n\n    ans = [0] * (n - 1)\n    \n    num = 1\n    prev = -1  # Initialize to an invalid value\n    \n    # Process edges efficiently\n    for _from, to, id in edges:\n        if _from != prev:\n            num = 1  # Reset num for a new _from\n        \n        # Find the smallest unused color\n        while used[_from] == num or used[to] == num:\n            num += 1\n        \n        # Assign the color to the edge\n        ans[id] = num\n        used[to] = num  # Mark the color as used for the 'to' node\n        num += 1  # Increment for the next edge\n        prev = _from  # Update the previous _from node\n    \n    # Output results\n    print(max(ans))\n    sys.stdout.write(\"\\n\".join(map(str, ans)))\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p00003","slow_code_col":"for i in range(0, int(eval(input()))):\n\n    sidelen = [int(j) for j in input().split(\" \")]\n\n    sidelen.sort(reverse=True)\n\n    if(sidelen[0]**2 == sidelen[1]**2 + sidelen[2]**2):\n\n        print(\"YES\")\n\n    else:\n\n        print(\"NO\")","reference_code_col":"import sys\n\nfor i in sys.stdin:\n\n    try:\n\n        sidelen = [int(j) for j in i.split(\" \")]\n\n        sidelen.sort(reverse=True)\n\n        if(sidelen[0]**2 == sidelen[1]**2 + sidelen[2]**2):\n\n            print(\"YES\")\n\n        else:\n\n            print(\"NO\")\n\n    except:\n\n        continue","model_generated_potentially_faster_code_col":"n = int(input())  # Directly parse the number of test cases\n\nfor _ in range(n):\n    # Read three integers directly\n    a, b, c = map(int, input().split())\n    \n    # Compute squares once\n    a_sq, b_sq, c_sq = a * a, b * b, c * c\n    \n    # Check the Pythagorean condition without sorting\n    if (a_sq == b_sq + c_sq or \n        b_sq == a_sq + c_sq or \n        c_sq == a_sq + b_sq):\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"problem_id":"p02760","slow_code_col":"import numpy as np\n\nN_1=list(map(int, input().split()))\n\nN_2=list(map(int, input().split()))\n\nN_3=list(map(int, input().split()))\n\nN=int(eval(input()))\n\na=[int(eval(input())) for i in range(N)]\n\n\n\nn=np.array([N_1,N_2,N_3])\n\n\n\nfor a_n in a:\n\n    if a_n in n:\n\n        n[n==a_n]=0\n\n    else:\n\n        pass\n\ni=0\n\n    \n\nif np.all(n[0:,0]==0)==True:\n\n    i=+1\n\n    \n\nelif np.all(n[0:,1]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0:,2]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0,0:]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[1,0:]==0)==True:\n\n    i+=1\n\n\n\nelif np.all(n[2,0:]==0)==True:\n\n    i+=1\n\n\n\nelif n[0,0]==0 and n[1,1]==0  and n[2,2] ==0:\n\n    i+=1\n\n    \n\nelif n[0,2]==0 and n[1,1]==0 and n[2,0] ==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")","reference_code_col":"a_1=list(map(int, input().split()))\n\na_2=list(map(int, input().split()))\n\na_3=list(map(int, input().split()))\n\n\n\nc=[a_1,a_2,a_3]\n\n\n\nN=int(eval(input()))\n\n\n\nb=[int(eval(input())) for _ in range(N)]\n\n\n\nfor i in range(3):\n\n    for j in range(3):\n\n        if c[i][j] in b:\n\n            c[i][j]=0\n\n            \n\n            \n\ni=0\n\nif c[0][0]==0 and c[0][1]==0 and c[0][2]==0:\n\n    i+=1\n\nif c[1][0]==0 and c[1][1]==0 and c[1][2]==0:\n\n    i+=1\n\nif c[2][0]==0 and c[2][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][0]==0 and c[2][0]==0:\n\n    i+=1\n\nif c[0][1]==0 and c[1][1]==0 and c[2][1]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][2]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][1]==0 and c[2][0]==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n  print(\"No\")","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input parsing\nN_1 = list(map(int, input().split()))\nN_2 = list(map(int, input().split()))\nN_3 = list(map(int, input().split()))\nN = int(input())\na = [int(input()) for _ in range(N)]\n\n# Convert to NumPy array\nn = np.array([N_1, N_2, N_3])\n\n# Use a set for fast membership checks\na_set = set(a)\n\n# Vectorized zeroing of elements in n\nn[np.isin(n, list(a_set))] = 0\n\n# Precompute row, column, and diagonal sums\nrow_sums = np.all(n == 0, axis=1)\ncol_sums = np.all(n == 0, axis=0)\ndiag1_sum = np.all(np.diag(n) == 0)\ndiag2_sum = np.all(np.diag(np.fliplr(n)) == 0)\n\n# Check if any condition is satisfied\nif np.any(row_sums) or np.any(col_sums) or diag1_sum or diag2_sum:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"problem_id":"p03424","slow_code_col":"n = int(eval(input()))\n\ns = input().split()\n\ns = set(s)\n\nprint(('Four' if len(s) == 4 else 'Three'))","reference_code_col":"n = int(eval(input()))\n\ns = input().split()\n\nprint(('Four' if len(set(s)) == 4 else 'Three'))","model_generated_potentially_faster_code_col":"n = int(input())  # Read the integer input directly\ns = set(input().split())  # Create a set directly from the split input\n\n# Determine the output based on the size of the set\nprint('Four' if len(s) == 4 else 'Three')"}
{"problem_id":"p02899","slow_code_col":"import numpy as np\n\n\n\n\n\nN=int(input())\n\n\n\nA=np.array([list(map(int, input().split()))])\n\n\n\n\n\nB=np.argsort(A[0,:])\n\nfor b in B:\n\n  print(b+1, end=' ')\n","reference_code_col":"N=int(input())\n\n\n\nA=list(map(int, input().split()))\n\nB=[-1]*N\n\nfor i in range(N):\n\n  B[A[i]-1]=i+1\n\n  \n\nfor b in B:\n\n  print(b, end=\" \")\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read N (not used in computation but required for input)\nN = int(input())\n\n# Efficiently read the input array as a 1D NumPy array\nA = np.fromstring(input(), sep=' ', dtype=int)\n\n# Get the sorted indices\nB = np.argsort(A)\n\n# Convert indices to 1-based and prepare the output string\noutput = ' '.join(map(str, B + 1))\n\n# Print the result\nprint(output)"}
{"problem_id":"p00122","slow_code_col":"dX = [2,2,2,1,0,-1,-2,-2,-2,-1,0,1]\n\ndY = [-1,0,1,2,2,2,1,0,-1,-2,-2,-2]\n\ndef solve(x,y,XY):\n\n\txy = XY[:]\n\n\tif len(xy) == 0: return \"OK\"\n\n\tsx,sy = xy.pop(0),xy.pop(0)\n\n\tfor dx,dy in zip(dX,dY):\n\n\t\tif doa(x+dx,y+dy,sx,sy): \n\n\t\t\tr = solve(x+dx,y+dy,xy)\n\n\t\t\tif r: return r\n\n\n\ndef doa(x,y,sx,sy):\n\n\tif not (0 <= x <= 9 and 0 <= y <= 9): return False\n\n\treturn True if abs(x-sx) < 2 and abs(y-sy) < 2 else False\n\n\n\nwhile 1:\n\n\tx,y = list(map(int,input().split()))\n\n\tif x == y == 0: break\n\n\tn = eval(input())\n\n\txy = list(map(int,input().split()))\n\n\tans = solve(x,y,xy)\n\n\tprint(ans if ans else \"NA\")","reference_code_col":"dX = [2,2,2,1,0,-1,-2,-2,-2,-1,0,1]\n\ndY = [-1,0,1,2,2,2,1,0,-1,-2,-2,-2]\n\ndef solve(x,y,XY):\n\n\txy = XY[:]\n\n\tif len(xy) == 0: return True\n\n\tsx,sy = xy.pop(0),xy.pop(0)\n\n\tfor dx,dy in zip(dX,dY):\n\n\t\tif doa(x+dx,y+dy,sx,sy): \n\n\t\t\tr = solve(x+dx,y+dy,xy)\n\n\t\t\tif r: return r\n\n\n\ndef doa(x,y,sx,sy):\n\n\tif not (0 <= x <= 9 and 0 <= y <= 9): return False\n\n\treturn True if abs(x-sx) < 2 and abs(y-sy) < 2 else False\n\n\n\nwhile 1:\n\n\tx,y = list(map(int,input().split()))\n\n\tif x == y == 0: break\n\n\tn = eval(input())\n\n\txy = list(map(int,input().split()))\n\n\tprint(\"OK\" if solve(x,y,xy) else \"NA\")","model_generated_potentially_faster_code_col":"from collections import deque\n\n# Predefined displacement vectors\ndX = [2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1]\ndY = [-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2]\n\n# Precompute valid moves\nMOVES = list(zip(dX, dY))\n\n# Memoization cache\nmemo = {}\n\ndef doa(x, y, sx, sy):\n    \"\"\"Check if the move is valid.\"\"\"\n    if not (0 <= x <= 9 and 0 <= y <= 9):\n        return False\n    return abs(x - sx) < 2 and abs(y - sy) < 2\n\ndef solve(x, y, targets, index):\n    \"\"\"Recursive solver with memoization.\"\"\"\n    # Base case: all targets reached\n    if index == len(targets):\n        return \"OK\"\n    \n    # Check memoization cache\n    key = (x, y, index)\n    if key in memo:\n        return memo[key]\n    \n    # Get the next target\n    sx, sy = targets[index], targets[index + 1]\n    \n    # Try all possible moves\n    for dx, dy in MOVES:\n        nx, ny = x + dx, y + dy\n        if doa(nx, ny, sx, sy):\n            result = solve(nx, ny, targets, index + 2)\n            if result:\n                memo[key] = result\n                return result\n    \n    # Cache and return failure\n    memo[key] = None\n    return None\n\nwhile True:\n    # Read input\n    x, y = map(int, input().split())\n    if x == 0 and y == 0:\n        break\n    \n    n = int(input())\n    xy = list(map(int, input().split()))\n    \n    # Reset memoization cache\n    memo.clear()\n    \n    # Solve the problem\n    ans = solve(x, y, xy, 0)\n    print(ans if ans else \"NA\")"}
{"problem_id":"p03988","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(1000000)\n\nfrom collections import deque\n\ndef getN():\n\n    return int(eval(input()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\nimport math\n\n\n\nn = getN()\n\nnums = getList()\n\n\n\n# nums.sort(reverse=True)\n\nmx = max(nums)\n\nmn = (mx+1) \/\/ 2\n\nmndx = (mx % 2) + 1\n\n\n\nfrom collections import Counter\n\n\n\ncnt = Counter(nums)\n\n\n\nfor i in range(mn+1, mx+1):\n\n    if cnt[i] < 2:\n\n        print(\"Impossible\")\n\n        sys.exit()\n\n\n\nif cnt[mn] != mndx:\n\n    print(\"Impossible\")\n\nelse:\n\n    print(\"Possible\")","reference_code_col":"import sys\n\nimport math\n\nimport copy\n\nfrom heapq import heappush, heappop, heapify\n\nfrom functools import cmp_to_key\n\nfrom bisect import bisect_left, bisect_right\n\nfrom collections import defaultdict, deque, Counter\n\n# sys.setrecursionlimit(1000000)\n\n\n\n# input aliases\n\ninput = sys.stdin.readline\n\ngetS = lambda: input().strip()\n\ngetN = lambda: int(eval(input()))\n\ngetList = lambda: list(map(int, input().split()))\n\ngetZList = lambda: [int(x) - 1 for x in input().split()]\n\n\n\nINF = float(\"inf\")\n\nMOD = 10**9 + 7\n\ndivide = lambda x: pow(x, MOD-2, MOD)\n\n\n\ndef pim():\n\n    print(\"Impossible\")\n\n    sys.exit()\n\ndef pp():\n\n    print(\"Possible\")\n\n    sys.exit()\n\ndef solve():\n\n    n = getN()\n\n    nums = getList()\n\n    cnt = Counter(nums)\n\n    mx = max(nums)\n\n    mn = min(nums)\n\n\n\n    if cnt[mx] < 2:\n\n        pim()\n\n    if mn < (mx + 1) \/\/ 2:\n\n        pim()\n\n\n\n    if mx % 2 == 0:\n\n        if cnt[mx\/\/2] != 1:\n\n            pim()\n\n    else:\n\n        if cnt[(mx+1) \/\/ 2] != 2:\n\n            pim()\n\n\n\n    for i in range((mx + 1) \/\/ 2 + 1, mx+1):\n\n        if cnt[i] < 2:\n\n            pim()\n\n\n\n    pp()\n\n\n\n\n\ndef main():\n\n    n = getN()\n\n    for _ in range(n):\n\n        solve()\n\n\n\n    return\n\nif __name__ == \"__main__\":\n\n    # main()\n\n    solve()\n\n\n\n\n\n\n\n\n\n\n","model_generated_potentially_faster_code_col":"import sys\n\n# Efficient input reading\ninput = sys.stdin.readline\n\ndef getN():\n    return int(input())\n\ndef getList():\n    return list(map(int, input().split()))\n\n# Read input\nn = getN()\nnums = getList()\n\n# Find maximum value and calculate mn, mndx\nmx = max(nums)\nmn = (mx + 1) \/\/ 2\nmndx = (mx % 2) + 1\n\n# Frequency dictionary for efficient lookups\nfreq = {}\nfor num in nums:\n    freq[num] = freq.get(num, 0) + 1\n\n# Check frequencies for numbers in range (mn+1, mx+1)\nfor i in range(mn + 1, mx + 1):\n    if freq.get(i, 0) < 2:\n        print(\"Impossible\")\n        sys.exit()\n\n# Check frequency of mn\nif freq.get(mn, 0) != mndx:\n    print(\"Impossible\")\nelse:\n    print(\"Possible\")"}
{"problem_id":"p02390","slow_code_col":"import sys\n\n\n\nif __name__ == '__main__':\n\n    import doctest\n\n    doctest.testmod()\n\n    S = int(sys.stdin.read())\n\n    h = S \/ 3600\n\n    m = (S % 3600) \/ 60\n\n    s = S % 60\n\n    print(\"%d:%d:%d\" % (h, m, s))\n","reference_code_col":"#!\/usr\/bin\/env python\n\n#-*- coding: utf-8 -*-\n\n\n\n# http:\/\/judge.u-aizu.ac.jp\/onlinejudge\/description.jsp?id=ITP1_1_D\n\n\n\nif __name__ == '__main__':\n\n    S = int(input())\n\n    h = S \/ 3600\n\n    m = (S % 3600) \/ 60\n\n    s = S % 60\n\n    print(\"%d:%d:%d\" % (h, m, s))\n","model_generated_potentially_faster_code_col":"import sys\nimport doctest\n\n\ndef convert_seconds_to_time(S):\n    # Calculate hours, minutes, and seconds\n    h = S \/\/ 3600\n    remainder = S % 3600\n    m = remainder \/\/ 60\n    s = remainder % 60\n\n    # Return formatted time string\n    return f\"{h}:{m}:{s}\"\n\n\nif __name__ == '__main__':\n    # Run doctests\n    doctest.testmod()\n\n    # Read input and convert to integer\n    S = int(sys.stdin.read())\n\n    # Convert seconds to time format and print\n    print(convert_seconds_to_time(S))"}
{"problem_id":"p02880","slow_code_col":"n = int(eval(input()))\n\ns = []\n\nfor i in range(1, 10):\n\n  for j in range(1, 10):\n\n    s.append(i*j)\n\nif n in s:\n\n  print(\"Yes\")\n\nelse:\n\n  print(\"No\")","reference_code_col":"import sys\n\n\n\nn = int(eval(input()))\n\nfor i in range(1, 10):\n\n  for j in range(1, 10):\n\n    if i*j == n:\n\n      print(\"Yes\")\n\n      sys.exit()\n\nprint(\"No\")\n","model_generated_potentially_faster_code_col":"n = int(input())\n\nfound = False\n\nfor i in range(1, 10):\n    for j in range(1, 10):\n        if i * j == n:\n            found = True\n            break  # Exit inner loop early\n    if found:\n        break  # Exit outer loop early\n\nprint(\"Yes\" if found else \"No\")"}
{"problem_id":"p03796","slow_code_col":"import math\n\nN=int(eval(input()))\n\nans=math.factorial(N)\n\nprint((ans%(10**9 +7)))","reference_code_col":"mod=10**9+7\n\nN=int(eval(input()))\n\nans=1\n\nfor i in range(1,N+1):\n\n  ans*=i\n\n  ans%=mod\n\nprint(ans)","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\n# Read input as an integer\nN = int(input())\n\n# Compute factorial modulo MOD iteratively\nans = 1\nfor i in range(2, N + 1):\n    ans = (ans * i) % MOD\n\nprint(ans)"}
{"problem_id":"p03634","slow_code_col":"from collections import deque\n\nn,*t=list(map(int,open(0).read().split()))\n\ncon=[[] for _ in range(n)]\n\ndist_f_k=[0]*n\n\n\n\nfor a,b,c in zip(t[:3*n-3:3],t[1::3],t[2::3]):\n\n\tcon[a-1].append((b-1,c))\n\n\tcon[b-1].append((a-1,c))\n\n\n\nk=t[3*n-2]\n\nque=deque([k-1])\n\nwhile que:\n\n\tcur=que.popleft()\n\n\tfor nxt,dd in con[cur]:\n\n\t\tif dist_f_k[nxt]==0 and nxt!=k-1:\n\n\t\t\tque.append(nxt)\n\n\t\t\tdist_f_k[nxt]=dist_f_k[cur]+dd\n\n\n\nfor x,y in zip(t[3*n-1::2],t[3*n::2]):\n\n\tprint((dist_f_k[x-1]+dist_f_k[y-1]))","reference_code_col":"def solve():\n\n\tfrom collections import deque\n\n\tn,*t=list(map(int,open(0).read().split()))\n\n\tcon=[[] for _ in range(n)]\n\n\tdist_f_k=[0]*n\n\n\tl1,l2=t[:3*n-3],t[3*n-1:]\n\n\n\n\tfor a,b,c in zip(*[iter(l1)]*3):\n\n\t\tcon[a-1].append((b-1,c))\n\n\t\tcon[b-1].append((a-1,c))\n\n\n\n\tk=t[3*n-2]\n\n\tque=deque([k-1])\n\n\twhile que:\n\n\t\tcur=que.popleft()\n\n\t\tfor nxt,dd in con[cur]:\n\n\t\t\tif dist_f_k[nxt]==0 and nxt!=k-1:\n\n\t\t\t\tque.append(nxt)\n\n\t\t\t\tdist_f_k[nxt]=dist_f_k[cur]+dd\n\n\n\n\tfor x,y in zip(*[iter(l2)]*2):\n\n\t\tprint((dist_f_k[x-1]+dist_f_k[y-1]))\n\n\t\t\n\nif __name__==\"__main__\":\n\n\tsolve()","model_generated_potentially_faster_code_col":"import sys\nfrom collections import deque\n\ninput_data = list(map(int, sys.stdin.read().split()))\nn, *t = input_data[0], input_data[1:]"}
{"problem_id":"p03253","slow_code_col":"import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\nfac = [1, 1]     # \u5143\u30c6\u30fc\u30d6\u30eb\n\nf_inv = [1, 1]   # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\ninv = [0, 1]     # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * pow(fac[r],MOD-2,MOD) * pow(fac[n-r],MOD-2,MOD) % mod\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n \/\/= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    prepare(N+100, MOD)\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e, MOD)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"# AC: msec(Python3)\n\nfrom math import factorial\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\ndef cmb(n, r):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    r = min(n-r, r)\n\n    res = 1\n\n    for i in range(r):\n\n        res *= n - i\n\n\n\n    return res \/\/ factorial(r)\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n \/\/= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\n# Input handling\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\n# Constants\nMOD = 10**9 + 7\n\n# Precompute factorials and modular inverses\ndef prepare(n, mod):\n    fac = [1] * (n + 1)\n    f_inv = [1] * (n + 1)\n    \n    # Compute factorials\n    for i in range(2, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n    \n    # Compute modular inverses of factorials\n    f_inv[n] = pow(fac[n], mod - 2, mod)\n    for i in range(n - 1, 0, -1):\n        f_inv[i] = f_inv[i + 1] * (i + 1) % mod\n    \n    return fac, f_inv\n\n# Combinatorics function\ndef cmb(n, r, fac, f_inv, mod):\n    if n < 0 or r < 0 or r > n:\n        return 0\n    return fac[n] * f_inv[r] % mod * f_inv[n - r] % mod\n\n# Prime factorization\ndef prime_factorization(n):\n    factors = []\n    i, e = 2, 0  # factor, exponent\n    \n    # Check divisibility by 2 separately\n    while n % 2 == 0:\n        n \/\/= 2\n        e += 1\n    if e > 0:\n        factors.append((2, e))\n    \n    # Check odd factors\n    i = 3\n    while i * i <= n:\n        e = 0\n        while n % i == 0:\n            n \/\/= i\n            e += 1\n        if e > 0:\n            factors.append((i, e))\n        i += 2\n    \n    # Remaining prime factor\n    if n > 1:\n        factors.append((n, 1))\n    \n    return factors\n\n# Main function\ndef main():\n    N, M = map(int, readline().split())\n    \n    # Prepare factorial and inverse tables\n    fac, f_inv = prepare(N + 100, MOD)\n    \n    # Prime factorization of M\n    factors = prime_factorization(M)\n    \n    # Compute result\n    ans = 1\n    for p, e in factors:\n        ans = ans * cmb(N - 1 + e, e, fac, f_inv, MOD) % MOD\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02264","slow_code_col":"n, q = [ int( val ) for val in input( ).split( \" \" ) ]\n\nps = [0]*n\n\nt = [0]*n\n\nfor i in range( n ):\n\n\tps[i], t[i] = input( ).split( \" \" )\n\n\n\n\n\noutput = []\n\nqsum = 0\n\nwhile t:\n\n\tpsi = ps.pop( 0 )\n\n\tti = int( t.pop( 0 ) )\n\n\tif ti <= q:\n\n\t\tqsum += ti\t\n\n\t\toutput.append( psi+\" \"+str( qsum ) )\n\n\telse:\n\n\t\tt.append( ti - q )\n\n\t\tps.append( psi )\n\n\t\tqsum += q\n\n\n\nprint(( \"\\n\".join( output ) ))","reference_code_col":"n, q = [ int( val ) for val in input( ).split( \" \" ) ]\n\nps = [0]*n\n\nt = [0]*n\n\nfor i in range( n ):\n\n    ps[i], t[i] = input( ).split( \" \" )\n\n \n\n \n\noutput = []\n\nqsum = 0\n\nwhile t:\n\n    psi = ps.pop( 0 )\n\n    ti = int( t.pop( 0 ) )\n\n    if ti <= q:\n\n        qsum += ti\n\n        output.append( \"\".join( ( psi, \" \", str( qsum ) ) ) )\n\n    else:\n\n        t.append( ti - q )\n\n        ps.append( psi )\n\n        qsum += q\n\n \n\nprint(( \"\\n\".join( output ) ))","model_generated_potentially_faster_code_col":"# Read input values for n (number of processes) and q (quantum)\nn, q = map(int, input().split())\n\n# Initialize process names and times\nps = []\nt = []\n\nfor _ in range(n):\n    psi, ti = input().split()\n    ps.append(psi)\n    t.append(int(ti))\n\n# Output list to store results\noutput = []\n\n# Total elapsed time\nqsum = 0\n\n# Use a deque for efficient pop from the front and append at the end\nfrom collections import deque\nqueue = deque(zip(ps, t))  # Combine ps and t into a single deque\n\nwhile queue:\n    psi, ti = queue.popleft()  # Efficiently remove the first element\n    \n    if ti <= q:\n        # If the task can be completed within the quantum\n        qsum += ti\n        output.append(f\"{psi} {qsum}\")\n    else:\n        # If the task cannot be completed, reduce its time and requeue it\n        qsum += q\n        queue.append((psi, ti - q))\n\n# Print the output\nprint(\"\\n\".join(output))"}
{"problem_id":"p02688","slow_code_col":"N,K = list(map(int, input().split(' ')))\n\na=list(range(1,N+1))\n\nfor i in range(K):\n\n  count=int(eval(input()))\n\n  b=input().split(' ')\n\n  for j in range(count):\n\n    if int(b[j]) in a:\n\n      a.remove(int(b[j]))\n\nprint((len(a)))","reference_code_col":"N,K = list(map(int, input().split(' ')))\n\na=list(range(1,N+1))\n\nfor i in range(K):\n\n  count=int(eval(input()))\n\n  b=[int(x.strip()) for x in input().split(' ')]\n\n  for j in range(count):\n\n    if b[j] in a:\n\n      a.remove(b[j])\n\nprint((len(a)))","model_generated_potentially_faster_code_col":"# Read N and K\nN, K = map(int, input().split())\n\n# Initialize the set of numbers\na = set(range(1, N + 1))\n\n# Process K queries\nfor _ in range(K):\n    # Read the count of numbers to remove\n    count = int(input())\n    \n    # Read the numbers to remove and convert them to integers\n    b = set(map(int, input().split()))\n    \n    # Remove the numbers from the set\n    a -= b\n\n# Output the size of the remaining set\nprint(len(a))"}
{"problem_id":"p03796","slow_code_col":"n=int(eval(input()))\n\nx=1\n\nfor i in range(n):\n\n    x*=(i+1)\n\n    if x>10**9+7:\n\n        x=x%(10**9+7)\n\n\n\nprint(x)\n\n#import numpy as np\n\n#n=int(input())\n\n#print(np.prod([i+1 for i in range(n)]))\n\n#print(np.prod([i+1 for i in range(n)])%((10**9)+7))\n\n\n\n#\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\uff1f\n","reference_code_col":"power=1\n\nn=int(eval(input()))\n\nmod=10**9+7\n\nfor i in range(1,n+1):\n\n    power*=i\n\n    power%=mod\n\n    #print(power)\n\nprint(power)\n","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\n# Read input and convert to integer\nn = int(input())\n\n# Initialize result\nx = 1\n\n# Compute factorial modulo MOD\nfor i in range(1, n + 1):\n    x = (x * i) % MOD\n\n# Output the result\nprint(x)"}
{"problem_id":"p03162","slow_code_col":"n = int(eval(input()))\n\n\n\nfelicidade = []\n\n\n\nfor x in range(n):\n\n    felicidade.append(list(map(int,input().split())))\n\n\n\nDP = [0,0,0]\n\n\n\nif n == 1:\n\n    print((max(felicidade[0])))\n\n\n\nelse:\n\n\n\n    for x in range(3):\n\n        DP[x] = felicidade[0][x]\n\n\n\n\n\n    for dia in range(1,n):\n\n        m = [0] * 3\n\n        for x  in range(3):#As duas poss\u00edveis escolhas s\u00e3o x e y\n\n            for y  in range(3):\n\n                if x != y: #Se elas forem diferentes\n\n                    m[x] = max(m[x], DP[y] + felicidade[dia][x])\n\n        DP = m\n\n    \n\n    print((max(DP)))\n","reference_code_col":"nDays = int(eval(input()))\n\n\n\ntoday = [int(x) for x in input().split()]\n\n\n\nfor i in range(nDays - 1):\n\n    tomorrow = [int(x) for x in input().split()]\n\n    tomorrow[0] += max(today[1], today[2])\n\n    tomorrow[1] += max(today[0], today[2])\n\n    tomorrow[2] += max(today[0], today[1])\n\n    today = tomorrow\n\n\n\nprint((max(today)))","model_generated_potentially_faster_code_col":"n = int(input())  # Directly parse the input as an integer\n\n# Initialize DP array with the first day's happiness values\nDP = list(map(int, input().split()))\n\nfor _ in range(1, n):\n    # Read the current day's happiness values\n    current_day = list(map(int, input().split()))\n    \n    # Compute the new DP values\n    m = [\n        max(DP[1] + current_day[0], DP[2] + current_day[0]),  # For activity 0\n        max(DP[0] + current_day[1], DP[2] + current_day[1]),  # For activity 1\n        max(DP[0] + current_day[2], DP[1] + current_day[2])   # For activity 2\n    ]\n    \n    # Update DP for the next iteration\n    DP = m\n\n# Output the maximum happiness value\nprint(max(DP))"}
{"problem_id":"p03013","slow_code_col":"n,m = list(map(int, input().split()))\n\na = [-1] + [int(eval(input())) for _ in range(m)] + [n + 1]\n\nMOD = 10 ** 9 + 7\n\n\n\nfib = [0, 1]\n\nfor i in range(100100):\n\n\tfib.append((fib[i] + fib[i + 1] % MOD))\n\n\n\nres = 1\n\nfor i in range(m + 1):\n\n\tp, q = a[i], a[i + 1]\n\n\tres = (res * fib[q - p - 1]) % MOD\n\n\n\nprint(res)","reference_code_col":"n,m = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(m)]\n\nMOD = 10 ** 9 + 7\n\n\n\n# broken[i] : i\u6bb5\u76ee\u304c\u58ca\u308c\u3066\u3044\u305f\u3089True\n\nbroken = [False] * 100100\n\nfor i in a:\n\n\tbroken[i] = True\n\n\n\n# dp[i] : i\u6bb5\u76ee\u306b\u884c\u304f\u901a\u308a\u6570\n\ndp = [0] * 100100\n\n\n\n# 0\u6bb5\u76ee\u306b\u884c\u304f\u65b9\u6cd5\u306f1\u901a\u308a\n\ndp[0] = 1\n\n\n\n# 1\u6bb5\u76ee\u304b\u3089n\u6bb5\u76ee\u306b\u3064\u3044\u3066\u8abf\u3079\u308b\n\nfor i in range(1, n + 1):\n\n\t# \u58ca\u308c\u3066\u308b\u306a\u3089\n\n\tif broken[i]:\n\n\t\t# \u305d\u306e\u6bb5\u306b\u306f\u9032\u3081\u306a\u3044\u306e\u30670\u901a\u308a\n\n\t\tdp[i] = 0\n\n\t# \u58ca\u308c\u3066\u306a\u3044\u306a\u3089\n\n\telse:\n\n\t\t# i - 1\u6bb5\u76ee\u304b\u3089\u79fb\u52d5\u53ef\u80fd (i - 1\u6bb5\u76ee\u306f, i == 0 \u306e\u3068\u304d\u306b\u306f\u306a\u3044\u306e\u3067\u5206\u5c90)\n\n\t\tif i > 0:\n\n\t\t\tdp[i] += dp[i - 1]\n\n\t\t# i - 2\u6bb5\u76ee\u304b\u3089\u79fb\u52d5\u53ef\u80fd (i - 2\u6bb5\u76ee\u306f, i == 0, 1 \u306e\u3068\u304d\u306b\u306f\u306a\u3044\u306e\u3067\u5206\u5c90)\n\n\t\tif i > 1:\n\n\t\t\tdp[i] += dp[i - 2]\n\n\tdp[i] %= MOD\n\n\n\nprint((dp[n]))","model_generated_potentially_faster_code_col":"n, m = map(int, input().split())\n\n# Read 'm' integers safely and efficiently\na = [-1] + [int(input()) for _ in range(m)] + [n + 1]\n\nMOD = 10**9 + 7\n\n# Compute Fibonacci numbers up to the maximum required index\nmax_diff = max(a[i + 1] - a[i] - 1 for i in range(m + 1))\nfib = [0, 1]\nfor i in range(2, max_diff + 1):\n    fib.append((fib[i - 1] + fib[i - 2]) % MOD)\n\n# Compute the result\nres = 1\nfor i in range(m + 1):\n    p, q = a[i], a[i + 1]\n    res = (res * fib[q - p - 1]) % MOD\n\nprint(res)"}
{"problem_id":"p03325","slow_code_col":"N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nans = 0\n\ncheck = [0]*30\n\nfor i in range(1, 31):\n\n    check[i-1] = 2**i\n\n\n\nfor i in A:\n\n    if i % 2 == 0:\n\n        j = 0\n\n        while check[j] <= i:\n\n            if i % check[j] == 0:\n\n                add = check[j]\n\n            else:\n\n                break\n\n                \n\n            j += 1\n\n        ans += j\n\n        \n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\nans = 0\n\n\n\nfor i in a:\n\n    while i % 2 == 0:\n\n        i \/\/= 2\n\n        ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read input\nN = int(input())\nA = list(map(int, input().split()))\n\nans = 0\n\n# Process each element in A\nfor i in A:\n    if i % 2 == 0:  # Only process even numbers\n        count = 0\n        while i % 2 == 0:  # Count how many times 2 divides i\n            i \/\/= 2\n            count += 1\n        ans += count\n\nprint(ans)"}
{"problem_id":"p03845","slow_code_col":"N = int(eval(input()))\n\nT = list(map(int, input().split()))\n\nM = int(eval(input()))\n\np = []\n\nx = []\n\nans = []\n\nfor i in range(M):\n\n    p, x = list(map(int, input().split()))\n\n    ans.append(sum(T[:p-1])+x+sum(T[p:]))\n\n\n\nfor _ in ans:\n\n    print(_)","reference_code_col":"N = int(eval(input()))\n\nT = list(map(int, input().split()))\n\nM = int(eval(input()))\n\nP, X, ans = [0]*M, [0]*M, []\n\nbase = sum(T)\n\n\n\nfor i in range(M):\n\n    P, X = list(map(int, input().split()))\n\n    ans.append(base-T[P-1]+X)\n\n\n\nfor i in ans:\n\n    print(i)","model_generated_potentially_faster_code_col":"# Input reading\nN = int(input())\nT = list(map(int, input().split()))\nM = int(input())\n\n# Precompute the total sum of T\ntotal_sum = sum(T)\n\n# Precompute the prefix sums of T\nprefix_sums = [0] * (N + 1)\nfor i in range(N):\n    prefix_sums[i + 1] = prefix_sums[i] + T[i]\n\n# Process queries efficiently\nans = []\nfor _ in range(M):\n    p, x = map(int, input().split())\n    \n    # Calculate the sum without recalculating everything\n    # Sum of elements before index p-1: prefix_sums[p-1]\n    # Sum of elements after index p: total_sum - prefix_sums[p]\n    # Replace T[p-1] with x\n    result = prefix_sums[p - 1] + x + (total_sum - prefix_sums[p])\n    ans.append(result)\n\n# Output results\nfor res in ans:\n    print(res)"}
{"problem_id":"p03162","slow_code_col":"n=int(eval(input()))\n\ndp=[[0 for i in range(3)] for i in range(n)]\n\nS=[[0 for i in range(3)] for i in range(n)]\n\ndp[0]=list(map(int,input().split()))\n\nS[0]=dp[0].copy()\n\nfor i in range(1,n):\n\n    S[i]=list(map(int,input().split()))\n\n    for j in range(3):\n\n        dp[i][j]=max(dp[i-1][j-1],dp[i-1][j-2])+S[i][j]\n\n\n\nprint((max(dp[n-1][0],dp[n-1][1],dp[n-1][2])))\n\n#dp[i][j]=i\u756a\u76ee\u306bj\u3092\u9078\u3093\u3060\u6642\u306e\u6700\u5927\u5024(j\u306fa,b,c\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u3002)","reference_code_col":"n=int(eval(input()))\n\ndp=[[0 for i in range(3)] for i in range(n)]\n\ndp[0]=list(map(int,input().split()))\n\nfor i in range(1,n):\n\n    S=list(map(int,input().split()))\n\n    for j in range(3):\n\n        dp[i][j]=max(dp[i-1][j-1],dp[i-1][j-2])+S[j]\n\n\n\nprint((max(dp[n-1][0],dp[n-1][1],dp[n-1][2])))\n\n#dp[i][j]=i\u756a\u76ee\u306bj\u3092\u9078\u3093\u3060\u6642\u306e\u6700\u5927\u5024(j\u306fa,b,c\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u3002)","model_generated_potentially_faster_code_col":"n = int(input())\n\n# Initialize previous and current DP rows\nprev_dp = list(map(int, input().split()))\ncurrent_dp = [0] * 3\n\nfor i in range(1, n):\n    S = list(map(int, input().split()))\n    \n    # Compute the current DP row based on the previous row\n    for j in range(3):\n        current_dp[j] = max(prev_dp[(j + 1) % 3], prev_dp[(j + 2) % 3]) + S[j]\n    \n    # Update the previous DP row for the next iteration\n    prev_dp = current_dp[:]\n    \n# Output the maximum value in the last row\nprint(max(prev_dp))"}
{"problem_id":"p03162","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nL = [list(map(int, input().split())) for i in range(N)]\n\ndp = np.zeros((N, 3), dtype=int)\n\n\n\nfor i in range(N):\n\n    dp[i][0] = L[0][0] if i == 0 else max(dp[i-1][1]+L[i][0], dp[i-1][2]+L[i][0])\n\n    dp[i][1] = L[0][1] if i == 0 else max(dp[i-1][0]+L[i][1], dp[i-1][2]+L[i][1])\n\n    dp[i][2] = L[0][2] if i == 0 else max(dp[i-1][0]+L[i][2], dp[i-1][1]+L[i][2])\n\n\n\nprint((max(dp[-1])))","reference_code_col":"N = int(eval(input()))\n\nabc = [list(map(int, input().split())) for i in range(N)]\n\ndp = [[0 for i in range(3)] for j in range(N+1)]\n\nfor i in range(N):\n\n    dp[i+1][0] = max(dp[i][1]+abc[i][0], dp[i][2]+abc[i][0])\n\n    dp[i+1][1] = max(dp[i][0]+abc[i][1], dp[i][2]+abc[i][1])\n\n    dp[i+1][2] = max(dp[i][0]+abc[i][2], dp[i][1]+abc[i][2])\n\nprint((max(dp[-1])))","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Read all rows of input into a list of lists\nL = [list(map(int, input().split())) for _ in range(N)]\n\n# Initialize the previous row's values\nprev0, prev1, prev2 = L[0]\n\n# Iterate through the remaining rows\nfor i in range(1, N):\n    curr0 = max(prev1 + L[i][0], prev2 + L[i][0])\n    curr1 = max(prev0 + L[i][1], prev2 + L[i][1])\n    curr2 = max(prev0 + L[i][2], prev1 + L[i][2])\n    \n    # Update the previous row's values\n    prev0, prev1, prev2 = curr0, curr1, curr2\n\n# Compute the final result\nprint(max(prev0, prev1, prev2))"}
{"problem_id":"p02901","slow_code_col":"def main():\n\n    import math\n\n    N,M=list(map(int,input().split()))\n\n    a=[]\n\n    for i in range(M):\n\n        tmp=list(map(int,input().split()))\n\n        tmpc=list(map(int,input().split()))\n\n        c=0\n\n        for j in range(len(tmpc)):\n\n            c+=2**(tmpc[j]-1)\n\n        tmp[1]=c\n\n        a+=[tmp]\n\n\n\n\n\n    dp=[[10**10 for j in range(2**N)] for i in range(M)]\n\n    dp[0][0]=0\n\n    dp[0][a[0][1]]=a[0][0]\n\n\n\n\n\n    for i in range(1,M):\n\n        dp[i]=dp[i-1]\n\n        for j in range(2**N):\n\n            z,p=a[i][0],a[i][1]\n\n            q=j|p\n\n            x=dp[i-1][j]+z\n\n            if dp[i][q]>x: dp[i][q]=x\n\n\n\n    ans=dp[M-1][2**N-1]\n\n    print((ans if ans<10**10 else -1))\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"n,m=list(map(int,input().split()))\n\nL=2**n\n\ncost=[0]+[10**8 for i in range(L-1)]\n\n\n\nfor i in range(m):\n\n    a,b=list(map(int,input().split()))\n\n    c=sum([2**(int(i)-1) for i in input().split()])\n\n    for j in range(L):\n\n        q=j|c\n\n        x=cost[j]+a\n\n        if cost[q]>x:\n\n            cost[q]=x\n\nprint((cost[L-1] if cost[L-1]<10**8 else -1))","model_generated_potentially_faster_code_col":"def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    # Parse N and M\n    N, M = int(data[0]), int(data[1])\n    idx = 2\n\n    # Parse the sets\n    a = []\n    for _ in range(M):\n        cost = int(data[idx])  # Cost of the set\n        count = int(data[idx + 1])  # Number of elements in the set\n        elements = list(map(int, data[idx + 2:idx + 2 + count]))  # Elements in the set\n        bitmask = 0\n        for elem in elements:\n            bitmask |= (1 << (elem - 1))  # Convert elements to bitmask\n        a.append((cost, bitmask))\n        idx += 2 + count\n\n    # Initialize DP table with two rows (rolling DP)\n    INF = 10**10\n    prev_dp = [INF] * (1 << N)\n    curr_dp = [INF] * (1 << N)\n\n    # Base case\n    prev_dp[0] = 0\n    if a:\n        cost, mask = a[0]\n        prev_dp[mask] = cost\n\n    # Fill the DP table\n    for i in range(1, M):\n        cost, mask = a[i]\n        # Copy previous DP state to current DP state\n        curr_dp[:] = prev_dp[:]\n        for state in range(1 << N):\n            if prev_dp[state] < INF:\n                new_state = state | mask\n                new_cost = prev_dp[state] + cost\n                if curr_dp[new_state] > new_cost:\n                    curr_dp[new_state] = new_cost\n        # Swap current and previous DP rows\n        prev_dp, curr_dp = curr_dp, prev_dp\n\n    # Get the result\n    result = prev_dp[(1 << N) - 1]\n    print(result if result < INF else -1)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02574","slow_code_col":"#!\/usr\/bin\/env pypy3\n\n# N,M = map(int,sys.stdin.readline().split())\n\n# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n\n# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param\n\n# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param\n\n# s = sys.stdin.readline().rstrip()\n\n# N = int(sys.stdin.readline())\n\n# INF = float(\"inf\")\n\nimport math,sys\n\n\n\nn = int(sys.stdin.readline())\n\na = tuple(map(int,sys.stdin.readline().split()))\n\n#n = int(input())\n\n#a = list(map(int,input().split()))\n\ng = math.gcd(a[0],a[1])\n\nfor i in range(2,n):\n\n    g = math.gcd(g,a[i])\n\nM = max(a)\n\nacc = a[0]\n\nfor i in range(n):\n\n    acc = math.gcd(acc,a[i])\n\nif acc != 1:\n\n    print(\"not coprime\")\n\n    exit()\n\n\n\nLIMIT=max(a)\n\nminPrime = [0]*(LIMIT+1)\n\nminPrime[1] = 1\n\ndef make():\n\n    for i in range(2,LIMIT+1):\n\n        if minPrime[i] == 0:\n\n            minPrime[i] = i\n\n            #print(i)\n\n            for j in range(i+i,LIMIT+1,i):\n\n                #print(i,j)\n\n                if minPrime[j] == 0:\n\n                    minPrime[j] = i\n\nmake()\n\ndef factrial(N):\n\n     ret = []\n\n     while minPrime[N] != N:\n\n         ret.append(minPrime[N])\n\n         N = N\/\/minPrime[N]\n\n     if N != 1:\n\n         ret.append(N)\n\n     return ret\n\n\n\njudge = set([])\n\npc = True\n\n\n\npairwise = True\n\np = set() #all prime\n\n\n\nfor e in a:\n\n    if not pairwise:\n\n        break\n\n    asf = set(factrial(e))\n\n    if judge & asf != set():\n\n        pc = False\n\n    #     #pairwise = False\n\n    #     print(\"setwise coprime\")\n\n    #     exit(0)\n\n    judge |= asf\n\n# for i in a:\n\n#     if not pc:\n\n#         break\n\n#     asf = set(factrial(i))\n\n\n\n#     if judge & asf != set():\n\n#         pc = False\n\n#     judge |= asf\n\nif pc:\n\n    print(\"pairwise coprime\")\n\nelif g == 1:\n\n    print(\"setwise coprime\")\n\nelse:\n\n    print(\"not coprime\")\n","reference_code_col":"#!\/usr\/bin\/env pypy3\n\n# N,M = map(int,sys.stdin.readline().split())\n\n# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n\n# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param\n\n# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param\n\n# s = sys.stdin.readline().rstrip()\n\n# N = int(sys.stdin.readline())\n\n# INF = float(\"inf\")\n\nimport math,sys\n\n\n\nn = int(sys.stdin.readline())\n\na = tuple(map(int,sys.stdin.readline().split()))\n\n#n = int(input())\n\n#a = list(map(int,input().split()))\n\ng = math.gcd(a[0],a[1])\n\nfor i in range(2,n):\n\n    g = math.gcd(g,a[i])\n\nM = max(a)\n\nacc = a[0]\n\nfor i in range(n):\n\n    acc = math.gcd(acc,a[i])\n\nif acc != 1:\n\n    print(\"not coprime\")\n\n    exit()\n\n\n\nLIMIT=max(a)\n\nminPrime = [0]*(LIMIT+1)\n\nminPrime[1] = 1\n\ndef make():\n\n    for i in range(2,LIMIT+1):\n\n        if minPrime[i] == 0:\n\n            minPrime[i] = i\n\n            #print(i)\n\n            for j in range(i+i,LIMIT+1,i):\n\n                #print(i,j)\n\n                if minPrime[j] == 0:\n\n                    minPrime[j] = i\n\nmake()\n\ndef factrial(N):\n\n     ret = []\n\n     while minPrime[N] != N:\n\n         ret.append(minPrime[N])\n\n         N = N\/\/minPrime[N]\n\n     if N != 1:\n\n         ret.append(N)\n\n     return ret\n\n\n\njudge = set([])\n\n\n\nfor e in a:\n\n    asf = set(factrial(e))\n\n    if judge & asf != set():\n\n        print(\"setwise coprime\")\n\n        exit()\n\n    judge |= asf\n\n    #judge = judge | asf #too slow\n\nprint(\"pairwise coprime\")\n","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env pypy3\n\nimport math\nimport sys\n\n# Read input\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\n\n# Compute GCD of all elements\ng = a[0]\nfor i in range(1, n):\n    g = math.gcd(g, a[i])\n\n# If the overall GCD is not 1, the numbers are \"not coprime\"\nif g != 1:\n    print(\"not coprime\")\n    exit()\n\n# Sieve of Eratosthenes to precompute smallest prime factors (SPF)\nLIMIT = max(a) + 1\nminPrime = [0] * LIMIT\nminPrime[1] = 1\n\ndef sieve():\n    for i in range(2, LIMIT):\n        if minPrime[i] == 0:  # i is a prime number\n            minPrime[i] = i\n            for j in range(i * i, LIMIT, i):  # Mark multiples of i\n                if minPrime[j] == 0:\n                    minPrime[j] = i\n\nsieve()\n\n# Function to compute unique prime factors of a number using SPF\ndef get_prime_factors(x):\n    factors = set()\n    while x != 1:\n        factors.add(minPrime[x])\n        x \/\/= minPrime[x]\n    return factors\n\n# Check pairwise coprimality\njudge = set()\npairwise_coprime = True\n\nfor num in a:\n    factors = get_prime_factors(num)\n    if judge & factors:  # Intersection indicates shared prime factors\n        pairwise_coprime = False\n        break\n    judge.update(factors)\n\n# Output results\nif pairwise_coprime:\n    print(\"pairwise coprime\")\nelif g == 1:\n    print(\"setwise coprime\")\nelse:\n    print(\"not coprime\")"}
{"problem_id":"p02599","slow_code_col":"NN = 19\n\nXX = [0] * (2**(NN+1)-1)\n\n\n\ndef addvalue(j, x):\n\n    i = 2**NN + j - 1\n\n    while i >= 0:\n\n        XX[i] += x\n\n        i = (i-1) \/\/ 2\n\n\n\ndef rangesum(a, b):\n\n    l = a + (1<<NN)\n\n    r = b + (1<<NN)\n\n    s = 0\n\n    while l < r:\n\n        if l%2:\n\n            s += XX[l-1]\n\n            l += 1\n\n        if r%2:\n\n            r -= 1\n\n            s += XX[r-1]\n\n        l >>= 1\n\n        r >>= 1\n\n    return s\n\n\n\nN, Q = map(int, input().split())\n\nC = [int(a) - 1 for a in input().split()]\n\nX = [[] for _ in range(N)]\n\nfor i in range(Q):\n\n    l, r = map(int, input().split())\n\n    X[r-1].append((l - 1, i))\n\nlast = [-1] * N\n\nANS = [-1] * Q\n\naddvalue(1, N)\n\nfor r in range(N):\n\n    c = C[r]\n\n    addvalue(last[c] + 2, -1)\n\n    addvalue(r + 2, 1)\n\n    last[c] = r\n\n    for l, i in X[r]:\n\n        ANS[i] = rangesum(l + 2, 1 << NN)\n\n    \n\nprint(*ANS, sep = \"\\n\")\n","reference_code_col":"##### https:\/\/atcoder.jp\/contests\/abc174\/submissions\/15644075 \u30921\u6b21\u5143\u5316\n\n\n\nimport sys\n\nINF = 1 << 60\n\nMOD = 10**9 + 7 # 998244353\n\nsys.setrecursionlimit(2147483647)\n\ninput = lambda:sys.stdin.buffer.readline().rstrip()\n\n \n\nclass SegmentTree(object):\n\n    def __init__(self, A, dot, unit):\n\n        n = 1 << (len(A) - 1).bit_length()\n\n        tree = [unit] * (2 * n)\n\n        for i, v in enumerate(A):\n\n            tree[i + n] = v\n\n        for i in range(n - 1, 0, -1):\n\n            tree[i] = dot(tree[i << 1], tree[i << 1 | 1])\n\n        self._n = n\n\n        self._tree = tree\n\n        self._dot = dot\n\n        self._unit = unit\n\n \n\n    def __getitem__(self, i):\n\n        return self._tree[i + self._n]\n\n \n\n    def update(self, i, v):\n\n        i += self._n\n\n        self._tree[i] = v\n\n        while i != 1:\n\n            i >>= 1\n\n            self._tree[i] = self._dot(self._tree[i << 1], self._tree[i << 1 | 1])\n\n \n\n    def add(self, i, v):\n\n        self.update(i, self[i] + v)\n\n \n\n    def sum(self, l, r):\n\n        l += self._n\n\n        r += self._n\n\n        l_val = r_val = self._unit\n\n        while l < r:\n\n            if l & 1:\n\n                l_val = self._dot(l_val, self._tree[l])\n\n                l += 1\n\n            if r & 1:\n\n                r -= 1\n\n                r_val = self._dot(self._tree[r], r_val)\n\n            l >>= 1\n\n            r >>= 1\n\n        return self._dot(l_val, r_val)\n\n\n\nfrom operator import add\n\ndef resolve():\n\n    n, q = map(int, input().split())\n\n    C = list(map(lambda x : int(x) - 1, input().split()))\n\n \n\n    A = [0] * n\n\n    used = [0] * n\n\n    for i, c in enumerate(C):\n\n        if used[c]:\n\n            continue\n\n        used[c] = 1\n\n        A[i] = 1\n\n    tree = SegmentTree(A, add, 0)\n\n \n\n    next = [-1] * n\n\n    used = [-1] * n\n\n    for i in range(n - 1, -1, -1):\n\n        c = C[i]\n\n        if used[c] != -1:\n\n            next[i] = used[c]\n\n        used[c] = i\n\n \n\n    queries = [None] * q\n\n    for i in range(q):\n\n        l, r = map(int, input().split())\n\n        queries[i] = (l - 1 << 40) + (r << 20) + i\n\n    queries.sort(reverse = 1)\n\n    \n\n    m = (1 << 20) - 1\n\n    ans = [0] * q\n\n    for l in range(n):\n\n        while queries and queries[-1] >> 40 == l:\n\n            lri = queries.pop()\n\n            l = lri >> 40\n\n            r = (lri >> 20) & m\n\n            i = lri & m\n\n            ans[i] = tree.sum(l, r)\n\n        if next[l] != -1:\n\n            tree.add(next[l], 1)\n\n \n\n    print(*ans, sep = '\\n')\n\nresolve()\n","model_generated_potentially_faster_code_col":"NN = 19\nMAX_SIZE = 1 << NN\n\n# Fenwick Tree Implementation\nclass FenwickTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * (size + 2)  # 1-based indexing\n\n    def update(self, index, value):\n        while index <= self.size:\n            self.tree[index] += value\n            index += index & -index\n\n    def query(self, index):\n        res = 0\n        while index > 0:\n            res += self.tree[index]\n            index -= index & -index\n        return res\n\n    def rangesum(self, l, r):\n        return self.query(r) - self.query(l - 1)\n\n\n# Initialize Fenwick Tree\nft = FenwickTree(MAX_SIZE)\n\n# Input Parsing\nN, Q = map(int, input().split())\nC = [int(a) - 1 for a in input().split()]\nX = [[] for _ in range(N)]\n\nfor i in range(Q):\n    l, r = map(int, input().split())\n    X[r - 1].append((l - 1, i))\n\n# Preprocessing\nlast = [-1] * N\nANS = [-1] * Q\n\n# Initial Update\nft.update(1, N)\n\n# Main Loop\nfor r in range(N):\n    c = C[r]\n\n    # Update for the last occurrence of color `c`\n    if last[c] != -1:\n        ft.update(last[c] + 2, -1)\n\n    # Update for the current occurrence of color `c`\n    ft.update(r + 2, 1)\n    last[c] = r\n\n    # Process queries ending at `r`\n    for l, i in X[r]:\n        ANS[i] = ft.rangesum(l + 2, r + 2)\n\n# Output Results\nprint(*ANS, sep=\"\\n\")"}
{"problem_id":"p03039","slow_code_col":"n, m, k = list(map(int, input().split()))\n\n\n\nmod = 1000000007\n\ndef pow(x, n):\n\n    ret = 1\n\n    while n > 0:\n\n        if (n & 1) == 1:\n\n            ret = (ret * x) % mod\n\n        x = (x * x) % mod\n\n        n >>= 1\n\n    return ret\n\n\n\nfac = [1]\n\ninv = [1]\n\nfor i in range(1, n * m + 1):\n\n    fac.append((fac[-1] * i) % mod)\n\n    inv.append(pow(fac[i], mod - 2))\n\n\n\ndef cmb(n, k):\n\n    return (fac[n] * inv[k] * inv[n - k]) % mod\n\n\n\ndef doit(n, m, k):\n\n    ret = 0\n\n    for d in range(m):\n\n        ret = (ret + d * (m - d)) % mod\n\n    return (ret * n * n * cmb(n * m - 2, k - 2)) % mod\n\n\n\nprint(((doit(n, m, k) + doit(m, n, k)) % mod))","reference_code_col":"n, m, k = list(map(int, input().split()))\n\n\n\nmod = 1000000007\n\nfac = [1]\n\nfor i in range(1, n * m + 1):\n\n    fac.append((fac[-1] * i) % mod)\n\n\n\ndef pow(x, n):\n\n    ret = 1\n\n    while n > 0:\n\n        if (n & 1) == 1:\n\n            ret = (ret * x) % mod\n\n        x = (x * x) % mod\n\n        n >>= 1\n\n    return ret\n\n\n\ndef inv(i):\n\n    return pow(fac[i], mod - 2)\n\n\n\ndef cmb(n, k):\n\n    return (fac[n] * inv(k) * inv(n - k)) % mod\n\n\n\nx = sum(d * (m - d) for d in range(m)) % mod\n\ny = sum(d * (n - d) for d in range(n)) % mod\n\n\n\nc = cmb(n * m - 2, k - 2)\n\nx = (x * n * n * c) % mod\n\ny = (y * m * m * c) % mod\n\n\n\nprint(((x + y) % mod))","model_generated_potentially_faster_code_col":"n, m, k = map(int, input().split())\nmod = 1000000007\n\n# Fast modular exponentiation\ndef pow(x, n):\n    ret = 1\n    while n > 0:\n        if n & 1:\n            ret = (ret * x) % mod\n        x = (x * x) % mod\n        n >>= 1\n    return ret\n\n# Precompute factorial and inverse factorial arrays\nmax_fact = n * m\nfac = [1] * (max_fact + 1)\nfor i in range(1, max_fact + 1):\n    fac[i] = (fac[i - 1] * i) % mod\n\n# Compute inverse of the largest factorial\ninv_fac = [1] * (max_fact + 1)\ninv_fac[max_fact] = pow(fac[max_fact], mod - 2)\n\n# Compute inverses iteratively\nfor i in range(max_fact - 1, -1, -1):\n    inv_fac[i] = (inv_fac[i + 1] * (i + 1)) % mod\n\n# Efficient combination calculation\ndef cmb(n, k):\n    if k < 0 or k > n:\n        return 0\n    return (fac[n] * inv_fac[k] * inv_fac[n - k]) % mod\n\n# Closed-form summation for doit function\ndef sum_d_times_m_minus_d(m):\n    return ((m - 1) * m * (m + 1) \/\/ 6) % mod\n\n# Optimized doit function\ndef doit(n, m, k):\n    ret = sum_d_times_m_minus_d(m)\n    ret = (ret * n * n) % mod\n    ret = (ret * cmb(n * m - 2, k - 2)) % mod\n    return ret\n\n# Final result\nprint((doit(n, m, k) + doit(m, n, k)) % mod)"}
{"problem_id":"p02555","slow_code_col":"s=int(eval(input()))\n\np=10**9+7\n\nif s<=2:\n\n    print((0))\n\n    exit()\n\nn=s\/\/3\n\nans=0\n\ndef f(n,k,p):\n\n    if k==0:\n\n        return 1\n\n    elif k%2==0:\n\n        return (f(n,k\/\/2,p)**2)%p\n\n    else:\n\n        return (n*f(n,k-1,p))%p\n\n\n\nfor k in range(1,n+1):\n\n    a=1\n\n    b=1\n\n    for j in range(k-1):\n\n        a=(a*(s-3*k+1+j))%p\n\n        b=(b*(j+1))%p\n\n    ans=(ans+a*f(b,p-2,p))%p\n\n\n\nprint((ans%p))\n\n\n","reference_code_col":"s=int(eval(input()))\n\np=10**9+7\n\nif s<=2:\n\n    print((0))\n\n    exit()\n\nn=s\/\/3\n\nans=0\n\nx=[0]*(s+1)\n\nx[0]=1\n\nx[1]=1\n\ny=[0]*(s+1)\n\n\n\nfor i in range(2,s+1):\n\n    x[i]=x[i-1]*i%p\n\n\n\ny[s]=pow(x[s],p-2,p)\n\nfor i in range(s):\n\n    y[s-1-i]=y[s-i]*(s-i)%p\n\n\n\nfor k in range(1,n+1):\n\n    ans+=x[s-2*k-1]*y[k-1]*y[s-3*k]%p\n\n\n\nprint((ans%p))\n\n\n","model_generated_potentially_faster_code_col":"s = int(eval(input()))\np = 10**9 + 7\n\nif s <= 2:\n    print(0)\n    exit()\n\nn = s \/\/ 3\nans = 0\n\n# Precompute factorial and inverse factorial up to n\nfactorial = [1] * (n + 1)\nfor i in range(1, n + 1):\n    factorial[i] = (factorial[i - 1] * i) % p\n\n# Precompute modular inverses using Fermat's Little Theorem\ninv_factorial = [1] * (n + 1)\ninv_factorial[n] = pow(factorial[n], p - 2, p)\nfor i in range(n - 1, -1, -1):\n    inv_factorial[i] = (inv_factorial[i + 1] * (i + 1)) % p\n\n# Iterative modular exponentiation\ndef mod_exp(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp \/\/= 2\n    return result\n\n# Main computation\nfor k in range(1, n + 1):\n    # Compute numerator (a) and denominator (b)\n    a = 1\n    for j in range(k - 1):\n        a = (a * (s - 3 * k + 1 + j)) % p\n    b = factorial[k - 1]\n\n    # Update answer using modular arithmetic\n    ans = (ans + a * inv_factorial[k - 1]) % p\n\nprint(ans)"}
{"problem_id":"p03162","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\n\n\nabc = np.array([list(map(int, input().split())) for i in range(N)])\n\n\n\ndp = [[0]*3 for i in range(N+1)]\n\n\n\nfor i in range(1, N+1):\n\n    dp[i][0] = max(dp[i - 1][1] + abc[i - 1][1], dp[i - 1][2] + abc[i - 1][2])\n\n    dp[i][1] = max(dp[i - 1][0] + abc[i - 1][0], dp[i - 1][2] + abc[i - 1][2])\n\n    dp[i][2] = max(dp[i - 1][1] + abc[i - 1][1], dp[i - 1][0] + abc[i - 1][0])\n\n\n\nprint((max(dp[-1])))\n","reference_code_col":"N = int(eval(input()))\n\n\n\nA = [0] * (N + 1)\n\nB = [0] * (N + 1)\n\nC = [0] * (N + 1)\n\n\n\nfor i in range(1, N + 1):\n\n    A[i], B[i], C[i] = list(map(int, input().split()))\n\n\n\ndp = [[0] * 3 for _ in range(N + 1)]\n\nfor i in range(1, N + 1):\n\n    dp[i][0] = A[i] + max(dp[i-1][1], dp[i-1][2])\n\n    dp[i][1] = B[i] + max(dp[i-1][2], dp[i-1][0])\n\n    dp[i][2] = C[i] + max(dp[i-1][0], dp[i-1][1])\n\n\n\nprint((max(dp[N])))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input efficiently\nN = int(input())\nabc = np.empty((N, 3), dtype=int)\nfor i in range(N):\n    abc[i] = list(map(int, input().split()))\n\n# Initialize DP array with only two rows\nprev_dp = [0, 0, 0]\ncurr_dp = [0, 0, 0]\n\n# Compute DP values\nfor i in range(N):\n    a, b, c = abc[i]  # Extract current values for clarity\n    \n    curr_dp[0] = max(prev_dp[1] + b, prev_dp[2] + c)\n    curr_dp[1] = max(prev_dp[0] + a, prev_dp[2] + c)\n    curr_dp[2] = max(prev_dp[0] + a, prev_dp[1] + b)\n    \n    # Swap current and previous DP rows\n    prev_dp, curr_dp = curr_dp, prev_dp\n\n# Output the maximum value from the last row\nprint(max(prev_dp))"}
{"problem_id":"p03371","slow_code_col":"a,b,c,x,y=list(map(int,input().split()));print((min(k*c*2+a*max(x-k,0)+b*max(y-k,0)for k in range(max(x,y)*3))))","reference_code_col":"a,b,c,x,y=list(map(int,input().split()));print((min(x*a+y*b,2*x*c+b*max(0,y-x),2*y*c+a*max(0,x-y))))","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\n# Limit the range of k to min(x, y) + 1, as larger k values won't improve the result\nresult = min(k * c * 2 + a * (x - k) + b * (y - k) for k in range(min(x, y) + 1))\nprint(result)"}
{"problem_id":"p03723","slow_code_col":"a,b,c=list(map(int, input().split()))\n\nd=0\n\nwhile d<10**5:\n\n    if a%2==1 or b%2==1 or c%2==1:break\n\n    a,b,c=b\/2+c\/2,a\/2+c\/2,a\/2+b\/2\n\n    d+=1\n\nelse:d=-1\n\nprint(d)","reference_code_col":"a,b,c=list(map(int, input().split()))\n\nans=0\n\nwhile a%2==0 and b%2==0 and c%2==0 and ans<10000:\n\n    a,b,c=b\/\/2+c\/\/2,a\/\/2+c\/\/2,a\/\/2+b\/\/2\n\n    ans+=1\n\nif ans==10000:ans=-1\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read input values\na, b, c = map(int, input().split())\n\n# Initialize counter\nd = 0\n\n# Main loop\nwhile d < 10**5:\n    # Check if any of a, b, or c is odd using bitwise AND\n    if a & 1 or b & 1 or c & 1:\n        break\n\n    # Update a, b, c using integer division\n    a_new = b \/\/ 2 + c \/\/ 2\n    b_new = a \/\/ 2 + c \/\/ 2\n    c_new = a \/\/ 2 + b \/\/ 2\n\n    # Assign new values\n    a, b, c = a_new, b_new, c_new\n\n    # Increment counter\n    d += 1\nelse:\n    # If loop completes without breaking, set d to -1\n    d = -1\n\n# Output the result\nprint(d)"}
{"problem_id":"p03013","slow_code_col":"# https:\/\/atcoder.jp\/contests\/abc129\/tasks\/abc129_c\n\n# \u5178\u578b\u7684\u306aDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]\u3092i\u6bb5\u76ee\u307e\u3067\u306e\u901a\u308a\u306e\u6570\u3068\u3059\u308b\u3002\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False).tolist()\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # \u5e8a\u304c\u629c\u3051\u3066\u3044\u308b\u3068\u3053\u308d\n\n\n\n# dp\u30c6\u30fc\u30d6\u30eb\u306e\u7528\u610f\n\ndp = np.full((N + 1), -1).tolist()\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n","reference_code_col":"# https:\/\/atcoder.jp\/contests\/abc129\/tasks\/abc129_c\n\n# \u5178\u578b\u7684\u306aDP\n\n\n\n\n\ndef full(shape, full_value):\n\n    if isinstance(shape, tuple):\n\n        NotImplementedError()\n\n    else:\n\n        return [full_value] * shape\n\n\n\n\n\nMOD = 10**9 + 7\n\n# dp[i]\u3092i\u6bb5\u76ee\u307e\u3067\u306e\u901a\u308a\u306e\u6570\u3068\u3059\u308b\u3002\n\nN, M = list(map(int, input().split()))\n\nto_zero = full((N + 1), False)\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # \u5e8a\u304c\u629c\u3051\u3066\u3044\u308b\u3068\u3053\u308d\n\n\n\n# dp\u30c6\u30fc\u30d6\u30eb\u306e\u7528\u610f\n\ndp = full((N + 1), -1)\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\n# Input reading\nN, M = map(int, input().split())\nto_zero = [False] * (N + 1)\n\nfor _ in range(M):\n    broken_step = int(input())\n    to_zero[broken_step] = True\n\n# Initialize DP variables (space optimization)\nprev2, prev1 = 1, 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n    if to_zero[i]:\n        current = 0  # No way to reach a broken step\n    else:\n        current = (prev1 + prev2) % MOD  # Sum of ways to reach i-1 and i-2\n    # Update previous states\n    prev2, prev1 = prev1, current\n\nprint(prev1)"}
{"problem_id":"p03720","slow_code_col":"import sys\n\nimport numpy as np\n\nn,m = [int(x) for x in sys.stdin.readline().split()]\n\nr = np.zeros(n)\n\nfor i in range(m):\n\n\ta, b = [int(x) for x in sys.stdin.readline().split()]\n\n\tr[a-1] += 1\n\n\tr[b-1] += 1\n\nfor i in range(n):\n\n\tprint((int(r[i])))","reference_code_col":"import sys\n\nn,m = [int(x) for x in sys.stdin.readline().split()]\n\nr = [0]*n\n\nfor _ in range(m):\n\n\ta, b = [int(x) for x in sys.stdin.readline().split()]\n\n\tr[a-1] += 1\n\n\tr[b-1] += 1\n\nfor i in r:\n\n\tprint(i)","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Read all input at once and split into integers\ndata = list(map(int, sys.stdin.read().split()))\n\n# Extract n and m (first two integers)\nn, m = data[0], data[1]\n\n# Extract edge pairs (remaining integers)\nedges = np.array(data[2:]).reshape(m, 2)\n\n# Initialize degree array\nr = np.zeros(n, dtype=int)\n\n# Vectorized degree calculation\nr[edges[:, 0] - 1] += 1\nr[edges[:, 1] - 1] += 1\n\n# Print all degrees at once\nprint(\"\\n\".join(map(str, r)))"}
{"problem_id":"p03309","slow_code_col":"import statistics\n\nN = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\nans = 0\n\n\n\nfor i in range(1,N+1):\n\n  a[i-1] -= i\n\n\n\nb = statistics.median(a)\n\nfor i in range(N):\n\n  ans += abs(a[i]-b)\n\nprint((int(ans)))","reference_code_col":"N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nC = [A[i]-i for i in range(N)]\n\nC.sort()\n\nans = 0\n\nmed = C[N\/\/2]\n\nfor i in range(N):\n\n  ans += abs(C[i]-med)\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read input values\nN = int(input())\na = list(map(int, input().split()))\n\n# Adjust each element of the array: a[i] -= (i + 1)\na = [a[i] - (i + 1) for i in range(N)]\n\n# Custom median function\ndef find_median(arr):\n    arr.sort()\n    n = len(arr)\n    mid = n \/\/ 2\n    if n % 2 == 0:\n        return (arr[mid - 1] + arr[mid]) \/ 2\n    else:\n        return arr[mid]\n\n# Find the median of the adjusted array\nmedian = find_median(a)\n\n# Calculate the sum of absolute differences from the median\nans = sum(abs(x - median) for x in a)\n\n# Print the result as an integer\nprint(int(ans))"}
{"problem_id":"p03078","slow_code_col":"import numpy as np\n\n\n\nX, Y, Z, K = list(map(int, input().split()))\n\nA = np.array([int(i) for i in input().split()])\n\nB = np.array([int(i) for i in input().split()])\n\nC =np.array([int(i) for i in input().split()])\n\nA = -np.sort(-A) #\u8981\u30c1\u30a7\u30c3\u30af\u3084\n\nB = -np.sort(-B)\n\nC = -np.sort(-C)\n\nD = []\n\nfor i in range(min(K, X)):\n\n    for j in range(min(K, Y)):\n\n        if (i + 1) * (j + 1) > K:\n\n            break\n\n        for k in range(min(K, Z)):\n\n            if (i + 1) * (j + 1) * (k + 1) > K:\n\n                break\n\n            else:\n\n\n\n                D.append(A[i] + B[j] + C[k])\n\n\n\nX = np.array(D)\n\nX = -np.sort(-X)\n\nfor i in range(K):\n\n    print((X[i]))","reference_code_col":"X, Y, Z, K = list(map(int, input().split()))\n\nA = sorted([int(i) for i in input().split()], reverse=True)\n\nB = sorted([int(i) for i in input().split()], reverse=True)\n\nC = sorted([int(i) for i in input().split()], reverse=True)\n\nD = []\n\nfor i in range(min(K, X)):\n\n    for j in range(min(K, Y)):\n\n        if (i + 1) * (j + 1) > K:\n\n            break\n\n        for k in range(min(K, Z)):\n\n            if (i + 1) * (j + 1) * (k + 1) > K:\n\n                break\n\n            else:\n\n\n\n                D.append(A[i] + B[j] + C[k])\n\n\n\nD.sort(reverse=True)\n\nfor i in range(K):\n\n    print((D[i]))","model_generated_potentially_faster_code_col":"import numpy as np\nimport heapq\n\n# Input parsing\nX, Y, Z, K = list(map(int, input().split()))\nA = np.array(list(map(int, input().split())))\nB = np.array(list(map(int, input().split())))\nC = np.array(list(map(int, input().split())))\n\n# Sort arrays in descending order\nA = -np.sort(-A)\nB = -np.sort(-B)\nC = -np.sort(-C)\n\n# Priority queue (max-heap) to store the largest sums\nheap = []\n# Initialize heap with the largest combination\nheapq.heappush(heap, (-(A[0] + B[0] + C[0]), 0, 0, 0))\n\n# Set to track visited indices to avoid duplicates\nvisited = set()\nvisited.add((0, 0, 0))\n\nresult = []\n\n# Extract the top K sums\nfor _ in range(K):\n    # Get the largest sum from the heap\n    current_sum, i, j, k = heapq.heappop(heap)\n    result.append(-current_sum)  # Negate to get the actual sum\n\n    # Generate new candidates by incrementing one index at a time\n    for di, dj, dk in [(1, 0, 0), (0, 1, 0), (0, 0, 1)]:\n        ni, nj, nk = i + di, j + dj, k + dk\n        if ni < X and nj < Y and nk < Z and (ni, nj, nk) not in visited:\n            # Push the new combination into the heap\n            heapq.heappush(heap, (-(A[ni] + B[nj] + C[nk]), ni, nj, nk))\n            visited.add((ni, nj, nk))\n\n# Print the top K sums\nfor value in result:\n    print(value)"}
{"problem_id":"p02665","slow_code_col":"n = int(eval(input()))\n\nleaves = list(map(int, input().split()))\n\n\n\nans = 0\n\nnodes_min = [0] * (n + 1)\n\nnodes_max = [0] * (n + 1)\n\nnodes_min[n] = leaves[n]\n\nnodes_max[n] = leaves[n]\n\n\n\nfor depth in range(n, 0, -1):\n\n    root_min = nodes_min[depth] \/\/ 2 + nodes_min[depth] % 2\n\n    nodes_min[depth - 1] = leaves[depth - 1] + root_min\n\n    root_max = nodes_max[depth]\n\n    nodes_max[depth - 1] = leaves[depth - 1] + root_max\n\nnodes = [0] * (n + 1)\n\nnodes[0] = 1\n\nif nodes[0] < nodes_min[0]:\n\n    print((-1))\n\nelse:\n\n    for depth in range(n):\n\n        roots = nodes[depth]-leaves[depth]\n\n        nodes[depth + 1] = min(roots * 2, nodes_max[depth + 1])\n\n        if nodes[depth+1] < nodes_min[depth+1]:\n\n            print((-1))\n\n            break\n\n    else:\n\n        print((sum(nodes)))\n","reference_code_col":"n = int(eval(input()))\n\nleaves = list(map(int, input().split()))\n\n\n\nsum_leaves = [0]*(n+1)\n\nsum_leaves[0] = leaves[0]\n\nfor depth in range(n):\n\n    sum_leaves[depth+1] = sum_leaves[depth] + leaves[depth+1]\n\n\n\nans = 0\n\n\n\nroot = [None] * (n + 1)\n\nif n == 0:\n\n    root[0] = 0\n\nelse:\n\n    root[0] = 1\n\nif root[0] + leaves[0] != 1:\n\n    print((-1))\n\nelse:\n\n    for depth in range(n):\n\n        root[depth+1] = min(2*root[depth]-leaves[depth+1],\n\n                            sum_leaves[n]-sum_leaves[depth+1])\n\n        if root[depth + 1] < root[depth] - leaves[depth + 1] or root[depth+1] < 0:\n\n            print((-1))\n\n            break\n\n    else:\n\n        print((sum(root)+sum(leaves)))\n","model_generated_potentially_faster_code_col":"n = int(eval(input()))\nleaves = list(map(int, input().split()))\n\n# Initialize arrays\nnodes_min = [0] * (n + 1)\nnodes_max = [0] * (n + 1)\n\n# Set initial values for the last depth\nnodes_min[n] = leaves[n - 1]\nnodes_max[n] = leaves[n - 1]\n\n# Compute nodes_min and nodes_max\nfor depth in range(n - 1, 0, -1):\n    root_min = (nodes_min[depth + 1] + 1) \/\/ 2  # Equivalent to nodes_min[depth] \/\/ 2 + nodes_min[depth] % 2\n    nodes_min[depth] = leaves[depth - 1] + root_min\n\n    root_max = nodes_max[depth + 1]\n    nodes_max[depth] = leaves[depth - 1] + root_max\n\n# Check if the root node satisfies the minimum requirement\nif 1 < nodes_min[0]:\n    print(-1)\nelse:\n    nodes = [0] * (n + 1)\n    nodes[0] = 1\n    total_nodes = 1  # Maintain a running total of nodes\n\n    for depth in range(n):\n        roots = nodes[depth] - leaves[depth]\n        if roots < 0:  # Early exit if roots become negative\n            print(-1)\n            break\n\n        nodes[depth + 1] = min(roots * 2, nodes_max[depth + 1])\n        if nodes[depth + 1] < nodes_min[depth + 1]:  # Check feasibility\n            print(-1)\n            break\n\n        total_nodes += nodes[depth + 1]  # Update the running total\n    else:\n        print(total_nodes)"}
{"problem_id":"p03013","slow_code_col":"import math\n\ndef cmb(n, r, mod, g1, g2):\n\n    if ( r<0 or r>n ):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ndef main():\n\n    N, M = list(map(int, input().split()))\n\n    A = [-1] + [int(eval(input())) for i in range(M)] + [N + 1]\n\n\n\n    mod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\n\n    N = 10**5\n\n    g1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\n\n    g2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\n    inverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n    for i in range( 2, N + 1 ):\n\n        g1.append( ( g1[-1] * i ) % mod )\n\n        inverse.append( ( -inverse[mod % i] * (mod\/\/i) ) % mod )\n\n        g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\n\n    d = [0] * (len(A) - 1)\n\n    for i in range(len(A) - 1):\n\n        if A[i+1] - A[i] == 1:\n\n            print((0))\n\n            exit(0)\n\n        d[i] = A[i+1] - 1 - (A[i] + 1)\n\n\n\n    ans = 1\n\n    for dd in d:\n\n        if dd > 1:\n\n            tmp = 0\n\n            for j in range(dd\/\/2 + 1):\n\n                tmp += cmb(dd - j, j, mod, g1, g2)\n\n            ans *= tmp\n\n\n\n    print((ans % 1000000007))\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def main():\n\n    N, M = list(map(int, input().split()))\n\n    A = [int(eval(input())) for i in range(M)] + [0]\n\n\n\n    a = 0\n\n    b = 1\n\n    j = 0\n\n    tmp = 0\n\n    if N == 1:\n\n        print((1))\n\n    else:\n\n        for i in range(1, N + 1):\n\n            if A[j] == i:\n\n                if tmp == 1:\n\n                    print((0))\n\n                    exit()\n\n                tmp = 1\n\n                j += 1\n\n                a = 0\n\n            else:\n\n                if tmp == 1:\n\n                    b = a + b\n\n                    a = 0\n\n                else:\n\n                    c = a + b\n\n                    a = b\n\n                    b = c\n\n                tmp = 0\n\n        print((b % 1000000007))\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"A = [-1] + [int(input()) for _ in range(M)] + [N + 1]"}
{"problem_id":"p02691","slow_code_col":"N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\ndp = [0] * 10 ** 7\n\nans = 0\n\nfor i in range(N):\n\n    x = i + 1 - A[i]\n\n    if x >= 0:\n\n        ans += dp[x]\n\n    y = i + 1 + A[i]\n\n    if y < 10 ** 7:\n\n        dp[y] += 1\n\n\n\nprint(ans)\n","reference_code_col":"N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nINF = 2 * 10 ** 5\n\ndp = [0] * INF\n\nans = 0\n\nfor i in range(N):\n\n    i_i_ = i + 1 - A[i]\n\n    if 0 < i_i_ < INF:\n\n        ans += dp[i_i_]\n\n    i_ = i + 1 + A[i]\n\n    if 0 < i_ < INF:\n\n        dp[i_] += 1\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\n\n# Faster input reading\ndef main():\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n\n    # Use a dictionary instead of a fixed-size array for dp\n    dp = {}\n    ans = 0\n\n    for i in range(N):\n        i_plus_1 = i + 1  # Precompute i + 1\n        \n        # Calculate x and check condition\n        x = i_plus_1 - A[i]\n        if x >= 0:\n            ans += dp.get(x, 0)  # Use .get() to avoid KeyError\n        \n        # Calculate y and update dp\n        y = i_plus_1 + A[i]\n        if y < 10**7:\n            dp[y] = dp.get(y, 0) + 1  # Update dp using .get()\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03544","slow_code_col":"a,b=2,1\n\nfor i in[0]*int(eval(input())):a,b=b,a+b\n\nprint(a)","reference_code_col":"a,b=2,1\n\nfor i in[0]*eval(input()):a,b=b,a+b\n\nprint(a)","model_generated_potentially_faster_code_col":"a, b = 2, 1\n\nfor _ in range(int(input())):\n    a, b = b, a + b\n\nprint(a)"}
{"problem_id":"p02555","slow_code_col":"S = int(eval(input()))\n\nmod = 10**9+7\n\n\n\ndp = [0]*(S+1)\n\ndp[0] = 1\n\nfor i in range(1,S+1):\n\n    for j in range(0,(i-3)+1):\n\n        dp[i] += dp[j]\n\n        dp[i] %= mod\n\nprint((dp[S]))","reference_code_col":"S = int(eval(input()))\n\nmod = 10**9+7\n\n\n\ndp = [0]*(S+1)\n\ndp[0] = 1\n\nfor i in range(1,S+1):\n\n    for j in range(0,(i-3)+1):\n\n        dp[i] += dp[j]\n\n    dp[i] %= mod\n\nprint((dp[S]))","model_generated_potentially_faster_code_col":"S = int(eval(input()))\nmod = 10**9 + 7\n\nif S < 3:\n    print(0)\nelse:\n    dp = [0] * (S + 1)\n    dp[0] = 1  # Base case: one way to represent 0 (using no numbers)\n\n    cum_sum = 0  # Cumulative sum of dp[j] for j in range(i-3, i)\n    for i in range(1, S + 1):\n        if i >= 3:\n            cum_sum += dp[i - 3]\n            cum_sum %= mod\n        dp[i] = cum_sum\n\n    print(dp[S])"}
{"problem_id":"p00106","slow_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nhttp:\/\/judge.u-aizu.ac.jp\/onlinejudge\/description.jsp?id=0106&lang=jp\n\n\"\"\"\n\nimport sys\n\n\n\n\n\ndef solve(amount):\n\n    \"\"\"\n\n    :param amount: ?????\\???????????\u00b0?????????\n\n    :return: ?????????\n\n    \"\"\"\n\n    best_price = (amount + 199) \/\/ 200 * 380\n\n    for a in range(amount \/\/ 200 + 1):\n\n        for b in range(amount \/\/ 300 + 1):\n\n            for c in range(amount \/\/ 500 + 1):\n\n                for a1 in range(amount \/\/ 1000 + 1):\n\n                    for b1 in range(amount \/\/ 1200 + 1):\n\n                        for c1 in range(amount \/\/ 1500 + 1):\n\n                            if a*200 + b*300 + c*500 + a1*1000 + b1*1200 + c1*1500 == amount:\n\n                                price = a*380 + b*550 + c*850 + a1*1520 + b1*1870 + c1*2244\n\n                                if price < best_price:\n\n                                    best_price = price\n\n    return best_price\n\n\n\n\n\n\n\n\n\ndef main(args):\n\n    while True:\n\n        amount = int(eval(input()))\n\n        if amount == 0:\n\n            break\n\n        result = solve(amount)\n\n        print(result)\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])","reference_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nhttp:\/\/judge.u-aizu.ac.jp\/onlinejudge\/description.jsp?id=0106&lang=jp\n\n\"\"\"\n\nimport sys\n\n\n\n\n\ndef solve(amount):\n\n    \"\"\"\n\n    :param amount: ?????\\???????????\u00b0?????????\n\n    :return: ?????????\n\n    \"\"\"\n\n    best_price = (amount + 199) \/\/ 200 * 380\n\n    for a in range(amount \/\/ 200 + 1):\n\n        for b in range(amount \/\/ 300 + 1):\n\n            for c in range(amount \/\/ 500 + 1):\n\n                for a1 in range(amount \/\/ 1000 + 1):\n\n                    for b1 in range(amount \/\/ 1200 + 1):\n\n                        for c1 in range(amount \/\/ 1500 + 1):\n\n                            if a*200 + b*300 + c*500 + a1*1000 + b1*1200 + c1*1500 == amount:\n\n                                price = a*380 + b*550 + c*850 + a1*1520 + b1*1870 + c1*2244\n\n                                if price < best_price:\n\n                                    best_price = price\n\n    return best_price\n\n\n\n\n\ndef solve2(amount):\n\n    \"\"\"\n\n    ???????\u00a8???????????????\u00a8?????????????????\u00a7???\n\n    \"\"\"\n\n    packages = [(0, 0), (2, 380), (3, 550), (5, 850), (10, 1520), (12, 1870), (15, 2244)] # 1?\u00a2??????????(100g??????)??\u00a8??????????????\u00a2l\n\n    # dp??\u00a8???2?\u00ac??????????????\u00a8?????????????(100g??????)?????????????????\u00a8??\u00a7??????packages????\u00a8????\n\n    # 999999...??????INF??\u00a8?????? (phthon 3.5??\\??????????????????math.inf????????\u00a8??\u00a7??????)\n\n    cart = [[99999999] * (amount\/\/100 + 1) for _ in range(len(packages))]\n\n    for i in range(len(packages)):\n\n        cart[i][0] = 0          #  0g???????????\\????????\u00b4??????0???????????????\n\n\n\n    for i in range(1, len(packages)):\n\n        for j in range(1, len(cart[0])):\n\n            w = packages[i][0]  #  ??????\n\n            p = packages[i][1]  #  ??????\n\n            if j < w:\n\n                cart[i][j] = cart[i-1][j]\n\n            else:\n\n                # ???????????????????????????????????????????????????????????????????????????????\u00a8????\n\n                cart[i][j] = min(cart[i-1][j], cart[i-1][max(0, j-w)]+p, cart[i][max(0, j-w)]+p)\n\n    return cart[-1][-1]\n\n\n\n\n\ndef main(args):\n\n    while True:\n\n        amount = int(eval(input()))\n\n        if amount == 0:\n\n            break\n\n        #result = solve(amount)\n\n        #print(result)\n\n        result = solve2(amount)\n\n        print(result)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\ndef solve(amount):\n    \"\"\"\n    :param amount: Target amount to achieve\n    :return: Minimum price to achieve the target amount\n    \"\"\"\n    # Define item denominations and their prices\n    denominations = [200, 300, 500, 1000, 1200, 1500]\n    prices = [380, 550, 850, 1520, 1870, 2244]\n\n    # Initialize DP array with infinity\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0  # Base case: cost to make amount 0 is 0\n\n    # Dynamic Programming to calculate minimum price\n    for i in range(len(denominations)):\n        for j in range(denominations[i], amount + 1):\n            dp[j] = min(dp[j], dp[j - denominations[i]] + prices[i])\n\n    return dp[amount] if dp[amount] != float('inf') else -1\n\n\ndef main():\n    while True:\n        try:\n            amount = int(input())\n            if amount == 0:\n                break\n            result = solve(amount)\n            print(result)\n        except EOFError:\n            break\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02657","slow_code_col":"def iput(): return int(eval(input()))\n\ndef mput(): return list(map(int, input().split()))\n\ndef lput(): return list(map(int, input().split()))\n\n\n\ndef solve():\n\n    a, b = mput()\n\n    print((a*b))\n\n    return 0\n\n\n\nif __name__ == \"__main__\":\n\n    solve()","reference_code_col":"import math\n\ndef solve():\n\n    a, b = input().split()\n\n    a = int(a)\n\n    b = float(b)\n\n    print((int(a*b)))\n\n    return 0\n\n \n\nif __name__ == \"__main__\":\n\n    solve()","model_generated_potentially_faster_code_col":"def solve():\n    # Read two integers from input and multiply them\n    a, b = map(int, input().split())\n    print(a * b)\n\nif __name__ == \"__main__\":\n    solve()"}
{"problem_id":"p03759","slow_code_col":"a, b, c = list(map(int, input().split()))\n\nif (b - a) == (c - b):\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")","reference_code_col":"a, b, c = list(map(int, input().split()))\n\nif b - a == c - b:\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")","model_generated_potentially_faster_code_col":"a, b, c = map(int, input().split())\n\nif 2 * b == a + c:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"problem_id":"p03796","slow_code_col":"import math\n\nprint((math.factorial(int(eval(input())))%1000000007))","reference_code_col":"num = int(eval(input()))\n\nresult = 1\n\nfor i in range(1,num+1):\n\n    result = result *i % 1000000007\n\nprint(result)","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\ndef factorial_mod(n, mod):\n    \"\"\"Compute n! % mod efficiently.\"\"\"\n    if n >= mod:\n        return 0  # By properties of modular arithmetic, n! % mod = 0 if n >= mod\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % mod\n    return result\n\n# Input parsing and computation\nn = int(input())\nprint(factorial_mod(n, MOD))"}
{"problem_id":"p03416","slow_code_col":"a,b = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    j = str(i)\n\n    if j==''.join(reversed(j)):\n\n        count += 1\n\nprint(count)","reference_code_col":"a,b = list(map(int, input().split()))\n\nn = [i for i in map(str, list(range(a,b+1))) if i==i[::-1]]\n\nprint((len(n)))","model_generated_potentially_faster_code_col":"def count_palindromes(a, b):\n    count = 0\n\n    # Iterate through the range [a, b]\n    for num in range(a, b + 1):\n        # Convert the number to a string once\n        str_num = str(num)\n        \n        # Check if the string is a palindrome using direct comparison\n        if str_num == str_num[::-1]:\n            count += 1\n\n    return count\n\n# Input parsing\na, b = map(int, input().split())\n\n# Count and print the palindromes\nprint(count_palindromes(a, b))"}
{"problem_id":"p03363","slow_code_col":"from collections import Counter\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.array(input().split(), dtype=np.int64)\n\n\n\nc = Counter(A.cumsum())\n\nc[0] += 1 # np.cumsum(), 0start \u3067\u306f\u7121\u3044\u70ba 0\u3092\u52a0\u3048\u308b\n\nans = sum(v*(v-1)\/\/2 for v in list(c.values()))\n\nprint(ans)","reference_code_col":"\n\nfrom itertools import accumulate\n\nfrom collections import defaultdict\n\ndef resolve():\n\n    N = int(eval(input()))\n\n    A = list(map(int, input().split()))\n\n\n\n    Acum = [0] + list(accumulate(A))\n\n    dic = defaultdict(int)\n\n    ans = 0\n\n    for i in range(N + 1):\n\n        ans += dic[Acum[i]]\n\n        dic[Acum[i]] += 1\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    resolve()","model_generated_potentially_faster_code_col":"from collections import Counter\n\n# Read input size\nN = int(input())\n\n# Parse the array A directly into a Python list\nA = list(map(int, input().split()))\n\n# Compute the cumulative sum as a Python list\ncumsum = 0\ncumsum_counts = Counter([0])  # Start with 0 to handle the edge case\n\nfor num in A:\n    cumsum += num\n    cumsum_counts[cumsum] += 1\n\n# Compute the answer using combinatorics\nans = sum(v * (v - 1) \/\/ 2 for v in cumsum_counts.values())\n\n# Print the result\nprint(ans)"}
{"problem_id":"p03796","slow_code_col":"#!\/usr\/bin\/env pypy3\n\n\n\nimport math\n\nprint((math.factorial(int(eval(input()))) % 1000000007))","reference_code_col":"n = int(eval(input()))\n\nfor i in range(n - 1, 1, -1):\n\n\tn *= i\n\n\tn %= 10**9 + 7\n\nprint(n)","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env pypy3\n\nMOD = 1000000007  # Define the modulus as a constant\n\n# Read input and convert to integer\nn = int(input())\n\n# Compute factorial modulo MOD iteratively\nresult = 1\nfor i in range(2, n + 1):\n    result = (result * i) % MOD\n\nprint(result)"}
{"problem_id":"p03170","slow_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat Apr 25 18:20:35 2020\n\n\"\"\"\n\n\n\nimport sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 9)\n\n#def input():\n\n#    return sys.stdin.readline()[:-1]\n\nmod = 10**9+7\n\n\n\n#N = int(input())\n\nN, K = list(map(int,input().split()))\n\nA = np.array(list(map(int,input().split())))\n\n\n\ndp = [True for i in range(K + A[-1] + 1)]\n\nfor i in range(K):\n\n    if dp[i]:\n\n        for a in A:\n\n            dp[i + a] = False\n\n\n\n#    print(i, dp[i],A+i,dp[A+i])\n\n#print(dp)\n\n\n\nif dp[K]:\n\n    ans = 'Second'\n\nelse:\n\n    ans = 'First'\n\nprint(ans)","reference_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat Apr 25 18:20:35 2020\n\n\"\"\"\n\n\n\nimport sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 9)\n\n#def input():\n\n#    return sys.stdin.readline()[:-1]\n\nmod = 10**9+7\n\n\n\n#N = int(input())\n\n#N, K = map(int,input().split())\n\n#A = np.array(list(map(int,input().split())))\n\nN, K, *A = list(map(int, open(0).read().split()))\n\n\n\ndp = [True for i in range(K + A[-1] + 1)]\n\nfor i in range(K):\n\n    if dp[i]:\n\n        for a in A:\n\n            dp[i + a] = False\n\n\n\n#    print(i, dp[i],A+i,dp[A+i])\n\n#print(dp)\n\n\n\nif dp[K]:\n\n    ans = 'Second'\n\nelse:\n\n    ans = 'First'\n\nprint(ans)","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\nimport sys\nimport numpy as np\n\nsys.setrecursionlimit(10**9)\nmod = 10**9 + 7\n\n# Input reading\nN, K = map(int, input().split())\nA = np.array(list(map(int, input().split())))\n\n# Initialize dp array\ndp = [True] * (K + A[-1] + 1)\n\n# Precompute the maximum value in A for boundary checks\nmax_A = max(A)\n\n# Use a set to track which indices are affected by A\naffected = set()\n\n# Main loop to update dp\nfor i in range(K):\n    if dp[i]:\n        # Batch-update dp using a set to avoid redundant operations\n        for a in A:\n            if i + a <= K + max_A:\n                dp[i + a] = False\n\n# Determine the result based on dp[K]\nif dp[K]:\n    ans = 'Second'\nelse:\n    ans = 'First'\n\nprint(ans)"}
{"problem_id":"p03721","slow_code_col":"(N, K), *AB = [list(map(int, s.split())) for s in open(0)]\n\nfor a, b in sorted(AB):\n\n    K -= b\n\n    if K <= 0:\n\n        print(a)\n\n        break\n","reference_code_col":"N, K, *AB = list(map(int, open(0).read().split()))\n\nli = [(a, b) for a, b in zip(*[iter(AB)] * 2)]\n\nli.sort()\n\nfor a, b in li:\n\n    if K > b:\n\n        K -= b\n\n    else:\n\n        print(a)\n\n        break\n","model_generated_potentially_faster_code_col":"import heapq\nimport sys\n\n# Read input efficiently\nlines = sys.stdin.read().splitlines()\nN, K = map(int, lines[0].split())\nAB = [tuple(map(int, line.split())) for line in lines[1:]]\n\n# Use a min-heap to avoid full sorting\nheap = [(a, b) for a, b in AB]\nheapq.heapify(heap)\n\n# Process elements lazily\nwhile heap:\n    a, b = heapq.heappop(heap)\n    K -= b\n    if K <= 0:\n        print(a)\n        break"}
{"problem_id":"p03796","slow_code_col":"mod = int(1e9+7)\n\nn = int(eval(input()))\n\n\n\npower = 1\n\nfor i in range(1, n+1):\n\n    power = power * i % mod\n\nprint(power)","reference_code_col":"import sys\n\n\n\nMOD = 10 ** 9 + 7\n\nn = int(sys.stdin.readline().rstrip())\n\n\n\ndef main():\n\n    res = 1\n\n    for i in range(1, n+1):\n\n        res *= i\n\n        res %= MOD\n\n\n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","model_generated_potentially_faster_code_col":"mod = int(1e9 + 7)\n\n# Input handling\nn = int(input())\n\n# Precompute factorials up to n\nfactorials = [1] * (n + 1)\nfor i in range(1, n + 1):\n    factorials[i] = factorials[i - 1] * i % mod\n\n# Output the result\nprint(factorials[n])"}
{"problem_id":"p03307","slow_code_col":"import numpy as np\n\nN=int(eval(input()))\n\ndef gcd(a,b):\n\n    c=int(np.floor(a\/b))\n\n    return a-b*c\n\nif gcd(N,2)==0:\n\n    print(N)\n\nelse:\n\n    print((2*N))","reference_code_col":"N=int(eval(input()))\n\nif N%2==0:\n\n    print(N)\n\nelse:\n\n    print((2*N))","model_generated_potentially_faster_code_col":"# Read input as an integer\nN = int(input())\n\n# Check if N is even\nif N % 2 == 0:\n    print(N)\nelse:\n    print(2 * N)"}
{"problem_id":"p03164","slow_code_col":"N, W = list(map(int, input().split()))\n\nL = [list(map(int, input().split())) for i in range(N)]\n\nV = 0\n\nfor i in range(N):\n\n  V += L[i][1]\n\n\n\ndp = [[10**9+1] * (V + 1) for i in range(N+1)]\n\ndp[0][0] = 0\n\nfor i in range(N):\n\n    for j in range(V+1):\n\n        if j - L[i][1] >= 0:\n\n          dp[i+1][j] = min(dp[i][j], dp[i][j-L[i][1]] + L[i][0])\n\n        else:\n\n          dp[i+1][j] = dp[i][j]\n\nans = 0\n\nfor j in range(V+1):\n\n    if  W >= dp[-1][j]:\n\n        ans = max(ans, j)\n\nprint(ans)","reference_code_col":"N, W = list(map(int, input().split()))\n\nL = [list(map(int, input().split())) for i in range(N)]\n\nV = 0\n\nfor i in range(N):\n\n  V += L[i][1]\n\n\n\ndp = [10**9+1] * (V + 1)\n\ndp[0] = 0\n\nfor i in range(N):\n\n    for j in range(V, -1, -1):\n\n        dp[j] = min(dp[j], dp[j-L[i][1]] + L[i][0])\n\nans = 0\n\nfor j in range(V+1):\n\n    if  W >= dp[j]:\n\n        ans = max(ans, j)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\n\n# Faster input handling\ndef read_ints():\n    return list(map(int, sys.stdin.readline().split()))\n\nN, W = read_ints()\nL = [read_ints() for _ in range(N)]\n\n# Calculate total value (V)\nV = sum(item[1] for item in L)\n\n# Initialize DP array with a single row\ndp = [10**9 + 1] * (V + 1)\ndp[0] = 0  # Base case: 0 value requires 0 weight\n\n# Fill DP array\nfor i in range(N):\n    weight, value = L[i]\n    # Iterate backwards to avoid overwriting results\n    for j in range(V, value - 1, -1):\n        dp[j] = min(dp[j], dp[j - value] + weight)\n\n# Find the maximum value such that the corresponding weight <= W\nans = 0\nfor j in range(V + 1):\n    if dp[j] <= W:\n        ans = max(ans, j)\n\nprint(ans)"}
{"problem_id":"p02412","slow_code_col":"while 1:\n\n n,x=list(map(int,input().split()))\n\n if n+x==0:break\n\n print((len([1 for i in range(3,n+1)for j in range(2,x-i)if x-i-j<j<i])))","reference_code_col":"while 1:\n\n n,x=list(map(int,input().split()))\n\n if n+x==0:break\n\n print((len([1 for i in range(1,n-1)for j in range(i+1,n)if j<x-i-j<=n])))","model_generated_potentially_faster_code_col":"while True:\n    n, x = map(int, input().split())\n    if n + x == 0:\n        break\n\n    # Early exit for impossible cases\n    if x <= 5:\n        print(0)\n        continue\n\n    count = 0\n    for i in range(3, n + 1):\n        # Compute valid range for j\n        lower_j = max(2, (x - i) \/\/ 2 + 1)\n        upper_j = min(i - 1, x - i - 1)\n\n        # Count valid j values\n        if lower_j <= upper_j:\n            count += upper_j - lower_j + 1\n\n    print(count)"}
{"problem_id":"p03608","slow_code_col":"def main():\n\n    from sys import stdin\n\n    input = stdin.readline\n\n\n\n    n, m, r = list(map(int, input().split()))\n\n    l = list(map(int, input().split()))\n\n    for i in range(r):\n\n        l[i] -= 1\n\n    d = [[10**8] * n for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        d[i-1][j-1] = k\n\n        d[j-1][i-1] = k\n\n\n\n    # Warshall-Floyd algorithm\n\n    for k in range(n):\n\n        for i in range(n):\n\n            for j in range(n):\n\n                if d[i][j] > d[i][k] + d[k][j]:\n\n                    d[i][j] = d[i][k] + d[k][j]\n\n\n\n    # full search\n\n    # 8! = 40320\n\n    from itertools import permutations\n\n\n\n    answer = 10**8\n\n    for i in permutations(l):\n\n        ans = 0\n\n        for j in range(r-1):\n\n            ans += d[i[j]][i[j+1]]\n\n        if ans < answer:\n\n            answer = ans\n\n\n\n    print(answer)\n\n\n\nmain()\n","reference_code_col":"def main():\n\n    from sys import stdin\n\n    input = stdin.readline\n\n\n\n    n, m, r = list(map(int, input().split()))\n\n    l = list(map(int, input().split()))\n\n    for i in range(r):\n\n        l[i] -= 1\n\n    d = [[10**8] * n for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        d[i-1][j-1] = k\n\n        d[j-1][i-1] = k\n\n\n\n    # Warshall-Floyd algorithm\n\n    for k in range(n):\n\n        for i in range(n-1):\n\n            for j in range(i+1, n):\n\n                if d[i][j] > d[i][k] + d[k][j]:\n\n                    d[i][j] = d[i][k] + d[k][j]\n\n                    d[j][i] = d[i][j]\n\n\n\n    # full search\n\n    # 8! = 40320\n\n    from itertools import permutations\n\n\n\n    answer = 10**8\n\n    for i in permutations(l):\n\n        ans = 0\n\n        for j in range(r-1):\n\n            ans += d[i[j]][i[j+1]]\n\n        if ans < answer:\n\n            answer = ans\n\n\n\n    print(answer)\n\n\n\nmain()\n","model_generated_potentially_faster_code_col":"def main():\n    from sys import stdin\n    input = stdin.readline\n\n    # Input parsing\n    n, m, r = map(int, input().split())\n    l = list(map(lambda x: int(x) - 1, input().split()))  # Convert to 0-based indexing\n    d = [[10**8] * n for _ in range(n)]\n\n    # Initialize distance matrix\n    for i in range(n):\n        d[i][i] = 0\n\n    for _ in range(m):\n        i, j, k = map(int, input().split())\n        i -= 1  # Convert to 0-based indexing\n        j -= 1\n        d[i][j] = min(d[i][j], k)\n        d[j][i] = min(d[j][i], k)\n\n    # Warshall-Floyd algorithm for all-pairs shortest paths\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n\n    # Dynamic Programming for TSP\n    num_nodes = len(l)\n    dp = [[10**8] * num_nodes for _ in range(1 << num_nodes)]\n\n    # Base case: Starting at each node\n    for i in range(num_nodes):\n        dp[1 << i][i] = 0\n\n    # Fill DP table\n    for mask in range(1 << num_nodes):\n        for i in range(num_nodes):\n            if not (mask & (1 << i)):  # Skip if node i is not in the subset\n                continue\n            for j in range(num_nodes):\n                if mask & (1 << j):  # Skip if node j is already visited\n                    continue\n                new_mask = mask | (1 << j)\n                dp[new_mask][j] = min(dp[new_mask][j], dp[mask][i] + d[l[i]][l[j]])\n\n    # Find the minimum cost to visit all nodes\n    full_mask = (1 << num_nodes) - 1\n    answer = min(dp[full_mask][i] for i in range(num_nodes))\n\n    print(answer)\n\n\nmain()"}
{"problem_id":"p03325","slow_code_col":"N=int(eval(input()))\n\na=list(map(int,input().split()))\n\nfor i in range(N):\n\n  for j in range(1,31):\n\n    if a[i]%(2**j)!=0:\n\n      a[i]=j-1\n\n      break\n\nprint((sum(a)))","reference_code_col":"import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\ndef f(n):\n\n  res = 0\n\n  while n % 2 == 0:\n\n    n \/\/= 2\n\n    res += 1\n\n  return res\n\n\n\nanswer = 0\n\nfor a in A:\n\n  answer += f(a)\n\n\n\nprint(answer)","model_generated_potentially_faster_code_col":"import sys\nfrom math import log2\n\n# Read input efficiently\nN = int(sys.stdin.readline())\na = list(map(int, sys.stdin.readline().split()))\n\n# Process each element in the list\nfor i in range(N):\n    if a[i] == 0:  # Special case: 0 is divisible by all powers of 2\n        a[i] = 30\n    else:\n        # Count trailing zeros in binary representation\n        a[i] = (a[i] & -a[i]).bit_length() - 1\n\n# Output the result\nprint(sum(a))"}
{"problem_id":"p03416","slow_code_col":"a, b = list(map(int, input().split()))\n\ncnt = 0\n\n\n\nfor i in range(a, b+1):\n\n    i = str(i)\n\n    if i[0] == i[-1] and i[1] == i[-2]:\n\n        cnt += 1\n\n\n\nprint(cnt)\n","reference_code_col":"a, b = list(map(int, input().split()))\n\ncnt = 0\n\n\n\nfor i in range(10):\n\n    for j in range(10):\n\n        for k in range(10):\n\n            c = 10000*i+1000*j+100*k+10*j+i\n\n            if a <= c <= b:\n\n                cnt += 1\n\n\n\nprint(cnt)\n","model_generated_potentially_faster_code_col":"# Input parsing\na, b = map(int, input().split())\n\n# Initialize counter\ncnt = 0\n\n# Helper function to check if a number is a palindrome\ndef is_palindrome(num):\n    # Extract digits mathematically\n    digits = []\n    while num > 0:\n        digits.append(num % 10)\n        num \/\/= 10\n    # Check palindrome condition\n    n = len(digits)\n    return digits[0] == digits[-1] and digits[1] == digits[-2]\n\n# Iterate only over valid range\nfor num in range(max(a, 1000), min(b + 1, 100000)):\n    if is_palindrome(num):\n        cnt += 1\n\nprint(cnt)"}
{"problem_id":"p03835","slow_code_col":"k, s = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(k + 1):\n\n    for j in range(k + 1):\n\n        if i + j > s:\n\n            break\n\n        elif s - i - j <= k:\n\n            cnt += 1\n\nprint(cnt)\n","reference_code_col":"k, s = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(k + 1):\n\n    for j in range(k + 1):\n\n        if 0 <= s - i - j <= k:\n\n            cnt += 1\n\nprint(cnt)\n","model_generated_potentially_faster_code_col":"k, s = map(int, input().split())\n\ncnt = 0\n\nfor i in range(k + 1):\n    # Determine the valid range for j\n    j_min = 0\n    j_max = min(k, s - i)  # Ensure i + j <= s and j <= k\n    \n    if j_max < 0:\n        continue  # No valid j values for this i\n    \n    # Count valid l values for each j in the range [j_min, j_max]\n    cnt += max(0, j_max - j_min + 1)\n\nprint(cnt)"}
{"problem_id":"p02537","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\n\n\n# N: \u51e6\u7406\u3059\u308b\u533a\u9593\u306e\u9577\u3055\n\n\n\nINF = 0\n\n\n\nmx = 300001\n\nLV = (mx-1).bit_length()\n\nN0 = 2**LV\n\ndata = [INF]*(2*N0)\n\nlazy = [None]*(2*N0)\n\n\n\n# \u4f1d\u642c\u5bfe\u8c61\u306e\u533a\u9593\u3092\u6c42\u3081\u308b\n\ndef gindex(l, r):\n\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n\n    lc = 0 if l & 1 else (L & -L).bit_length()\n\n    rc = 0 if r & 1 else (R & -R).bit_length()\n\n    for i in range(LV):\n\n        if rc <= i:\n\n            yield R\n\n        if L < R and lc <= i:\n\n            yield L\n\n        L >>= 1; R >>= 1\n\n\n\n# \u9045\u5ef6\u4f1d\u642c\u51e6\u7406\n\ndef propagates(*ids):\n\n    for i in reversed(ids):\n\n        v = lazy[i-1]\n\n        if v is None:\n\n            continue\n\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n\n        lazy[i-1] = None\n\n\n\n# \u533a\u9593[l, r)\u3092x\u3067\u66f4\u65b0\n\ndef update(l, r, x):\n\n    *ids, = gindex(l, r)\n\n    propagates(*ids)\n\n\n\n    L = N0 + l; R = N0 + r\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            lazy[R-1] = data[R-1] = x\n\n        if L & 1:\n\n            lazy[L-1] = data[L-1] = x\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    for i in ids:\n\n        data[i-1] = max(data[2*i-1], data[2*i])\n\n\n\n# \u533a\u9593[l, r)\u5185\u306e\u6700\u5c0f\u5024\u3092\u6c42\u3081\u308b\n\ndef query(l, r):\n\n    propagates(*gindex(l, r))\n\n    L = N0 + l; R = N0 + r\n\n\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = max(s, data[R-1])\n\n        if L & 1:\n\n            s = max(s, data[L-1])\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    return s\n\n\n\nupdate(As[0],As[0]+1,1)\n\nfor i, a in enumerate(As[1:]):\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n    upd = query(l,r+1)\n\n    if upd == -1:continue\n\n    # print(\"i\",i,\"a\",a,\"upd\",upd,\"l\",l,\"r\",r)\n\n    update(a, a+1, upd+1)\n\n\n\nans = 0\n\nfor a in set(As):\n\n    ans = max(ans,query(a,a+1))\n\nprint(ans)","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\n\n\n# N: \u51e6\u7406\u3059\u308b\u533a\u9593\u306e\u9577\u3055\n\n\n\nINF = 0\n\n\n\nmx = 300001\n\nLV = (mx-1).bit_length()\n\nN0 = 2**LV\n\ndata = [INF]*(2*N0)\n\nlazy = [None]*(2*N0)\n\n\n\n# \u4f1d\u642c\u5bfe\u8c61\u306e\u533a\u9593\u3092\u6c42\u3081\u308b\n\ndef gindex(l, r):\n\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n\n    lc = 0 if l & 1 else (L & -L).bit_length()\n\n    rc = 0 if r & 1 else (R & -R).bit_length()\n\n    for i in range(LV):\n\n        if rc <= i:\n\n            yield R\n\n        if L < R and lc <= i:\n\n            yield L\n\n        L >>= 1; R >>= 1\n\n\n\n# \u9045\u5ef6\u4f1d\u642c\u51e6\u7406\n\ndef propagates(*ids):\n\n    for i in reversed(ids):\n\n        v = lazy[i-1]\n\n        if v is None:\n\n            continue\n\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n\n        lazy[i-1] = None\n\n\n\n# \u533a\u9593[l, r)\u3092x\u3067\u66f4\u65b0\n\ndef update(l, r, x):\n\n    *ids, = gindex(l, r)\n\n    propagates(*ids)\n\n\n\n    L = N0 + l; R = N0 + r\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            lazy[R-1] = data[R-1] = x\n\n        if L & 1:\n\n            lazy[L-1] = data[L-1] = x\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    for i in ids:\n\n        data[i-1] = max(data[2*i-1], data[2*i])\n\n\n\n# \u533a\u9593[l, r)\u5185\u306e\u6700\u5c0f\u5024\u3092\u6c42\u3081\u308b\n\ndef query(l, r):\n\n    propagates(*gindex(l, r))\n\n    L = N0 + l; R = N0 + r\n\n\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = max(s, data[R-1])\n\n        if L & 1:\n\n            s = max(s, data[L-1])\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    return s\n\n\n\nans = 0\n\nupdate(As[0],As[0]+1,1)\n\nfor i, a in enumerate(As[1:]):\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n    upd = query(l,r+1)\n\n    if upd == -1:continue\n\n    # print(\"i\",i,\"a\",a,\"upd\",upd,\"l\",l,\"r\",r)\n\n    update(a, a+1, upd+1)\n\n    ans = max(ans, upd+1)\n\nprint(ans)\n\n\n","model_generated_potentially_faster_code_col":"import sys\n\n# Efficient input reading\ninput = sys.stdin.readline\n\n# Read input values\nn, k = map(int, input().split())\nAs = [int(input()) for _ in range(n)]\n\n# Constants\nINF = 0\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\n\n# Segment tree initialization\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\n\n# Yield indices for lazy propagation\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & -L).bit_length()\n    rc = 0 if r & 1 else (R & -R).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if L < R and lc <= i:\n            yield L\n        L >>= 1\n        R >>= 1\n\n# Propagate lazy updates\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[2 * i - 1] = data[2 * i - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\n\n# Update range [l, r) with value x\ndef update(l, r, x):\n    ids = list(gindex(l, r))\n    propagates(*ids)\n\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n\n    for i in ids:\n        data[i - 1] = max(data[2 * i - 1], data[2 * i])\n\n# Query maximum in range [l, r)\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n    return s\n\n# Main logic\nupdate(As[0], As[0] + 1, 1)\nfor a in As[1:]:\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd != INF:\n        update(a, a + 1, upd + 1)\n\n# Compute the final answer\nans = max(query(a, a + 1) for a in As)\nprint(ans)"}
{"problem_id":"p02725","slow_code_col":"import numpy as np\n\n\n\nK, N = [int(i) for i in input().rstrip().split(' ')]\n\nA = [int(i) for i in input().rstrip().split(' ')]\n\n\n\nx = A[0]\n\ny = K - A[-1]\n\nn = [int(A[i+1] - A[i]) for i in range(N-1)]\n\nn.append(x+y)\n\n\n\nnp_list = np.array(n)\n\nn.pop(np_list.argmax())\n\nprint((sum(n)))","reference_code_col":"k,n = list(map(int,input().split()))\n\na = list(map(int,input().split()))\n\n\n\ndp = [0 for i in range(n)]\n\ndp[0] = abs(k-a[-1]) + a[0]\n\n\n\nfor i in range(1,n):\n\n    dp[i] = abs(a[i]-a[i-1])\n\n\n\nprint((sum(dp) - max(dp)))","model_generated_potentially_faster_code_col":"# Input parsing\nK, N = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Compute x, y, and n\nx = A[0]\ny = K - A[-1]\nn = [A[i + 1] - A[i] for i in range(N - 1)]\nn.append(x + y)\n\n# Find the maximum value and its index\nmax_val = max(n)\nmax_index = n.index(max_val)\n\n# Compute the sum excluding the maximum value\nresult = sum(n[:max_index] + n[max_index + 1:])\n\n# Output the result\nprint(result)"}
{"problem_id":"p03371","slow_code_col":"a, b, c, x, y = list(map(int, input().split(' ')))\n\n\n\nc = int(c*2)\n\nm = float('inf')\n\nfor i in range(10**5+1):\n\n    m = min(m, a*max(0, x-i)+b*max(0,y-i)+c*i)\n\nprint(m)","reference_code_col":"import math\n\na, b, c, x, y = list(map(int, input().split(' ')))\n\nans = float('inf')\n\nc = c*2\n\nfor i in range(max(x, y)+1):\n\n    if i > x:\n\n        price = b*(y-i) + c*i\n\n    elif i > y:\n\n        price = a*(x-i) + c*i\n\n    else:\n\n        price = a*(x-i) + b*(y-i) + c*i\n\n\n\n    if ans > price:\n\n        ans = price\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read input values\na, b, c, x, y = map(int, input().split())\nc *= 2  # Double the value of c\n\n# Critical points where the cost function changes\ncritical_points = sorted([0, x, y])\n\n# Initialize minimum cost to infinity\nm = float('inf')\n\n# Evaluate the cost function at critical points\nfor i in critical_points:\n    cost = a * max(0, x - i) + b * max(0, y - i) + c * i\n    m = min(m, cost)\n\nprint(m)"}
{"problem_id":"p02983","slow_code_col":"l,r=list(map(int,input().split()))\n\ns=list(range(l,r+1))[:2019]\n\nprint((min(i*j%2019for i in s for j in s if i<j)))","reference_code_col":"l,r=list(map(int,input().split()));s=list(range(l,r+1))[:673];print((min(i*j%2019for i in s for j in s if i<j)))","model_generated_potentially_faster_code_col":"l, r = map(int, input().split())\n\n# Generate unique residues modulo 2019 within the range [l, r]\nresidues = set()\nfor x in range(l, r + 1):\n    residues.add(x % 2019)\n    if len(residues) == 2019:  # Early exit if all residues are covered\n        break\n\n# Convert residues to a sorted list\nresidues = sorted(residues)\n\n# Initialize the minimum result to a large value\nmin_result = float('inf')\n\n# Iterate over all pairs of residues\nfor i in range(len(residues)):\n    for j in range(i + 1, len(residues)):\n        product_mod = (residues[i] * residues[j]) % 2019\n        if product_mod == 0:  # Early termination if 0 is found\n            print(0)\n            exit()\n        min_result = min(min_result, product_mod)\n\nprint(min_result)"}
{"problem_id":"p03796","slow_code_col":"import math\n\nmod = 10 ** 9 + 7\n\nn = int(eval(input()))\n\nprint((math.factorial(n) % mod))","reference_code_col":"mod = 10 ** 9 + 7\n\nn = int(eval(input()))\n\nans = 1\n\nfor i in range(1, n + 1):\n\n    ans *= i\n\n    ans %= mod\n\nprint(ans)","model_generated_potentially_faster_code_col":"mod = 10**9 + 7\n\n# Read input safely\nn = int(input())\n\n# Compute factorial modulo mod iteratively\nresult = 1\nfor i in range(2, n + 1):\n    result = (result * i) % mod\n\nprint(result)"}
{"problem_id":"p03416","slow_code_col":"A, B = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(A, B+1):\n\n    if(str(i) == str(i)[::-1]):\n\n        count += 1\n\nprint(count)\n","reference_code_col":"A, B = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(10):\n\n    for j in range(10):\n\n        for k in range(10):\n\n            if(A <= 10000*i + 1000*j + 100*k + 10*j +i <= B):\n\n                count += 1\n\nprint(count)","model_generated_potentially_faster_code_col":"def count_palindromes(A, B):\n    def generate_palindromes_with_n_digits(n):\n        \"\"\"Generate all palindromes with n digits.\"\"\"\n        if n == 1:\n            # Single-digit palindromes: 0 to 9\n            return [i for i in range(10)]\n        \n        # Half length of the palindrome (excluding the middle digit for odd-length palindromes)\n        half_len = (n + 1) \/\/ 2\n        palindromes = []\n        \n        # Generate all possible first halves\n        start = 10**(half_len - 1)  # Smallest half (e.g., 100 for 3-digit palindromes)\n        end = 10**half_len          # Largest half (exclusive)\n        \n        for half in range(start, end):\n            half_str = str(half)\n            if n % 2 == 0:\n                # Even-length palindrome: mirror the half\n                palindrome = int(half_str + half_str[::-1])\n            else:\n                # Odd-length palindrome: mirror the half excluding the last digit\n                palindrome = int(half_str + half_str[-2::-1])\n            \n            if A <= palindrome <= B:\n                palindromes.append(palindrome)\n        \n        return palindromes\n\n    count = 0\n    max_digits = len(str(B))  # Maximum number of digits in the range\n    min_digits = len(str(A))  # Minimum number of digits in the range\n    \n    # Generate palindromes for all digit lengths in the range\n    for num_digits in range(min_digits, max_digits + 1):\n        count += len(generate_palindromes_with_n_digits(num_digits))\n    \n    print(count)\n\n# Input\nA, B = map(int, input().split())\ncount_palindromes(A, B)"}
{"problem_id":"p03013","slow_code_col":"Mod = 10**9+7\n\nN,M = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(M)]\n\nb = [1]*(N+1)\n\nfor j in a:\n\n    b[j] = 0\n\nfor i in range(1,N+1):\n\n    if b[i] == 0:\n\n        continue\n\n    if i == 1:\n\n        b[1] = 1\n\n        continue\n\n    b[i] = b[i-1]+b[i-2]\n\n    if b[i] >= Mod:\n\n        b[i] %= Mod\n\nprint((b[N]))","reference_code_col":"# https:\/\/atcoder.jp\/contests\/abc129\/submissions\/5841482 \u3092\u53c2\u8003 \n\nN,M = list(map(int, input().split()))\n\nA = [int(eval(input())) for _ in range(M)]\n\nMOD = 10**9 + 7\n\nF = [1]*(N+1)\n\nfor j in A:\n\n    F[j-1] = 0\n\n \n\na = 1; b = 0\n\nfor i in range(N):\n\n    if not F[i]:    #F[i] == 0\n\n        a, b = 0, a\n\n    else:\n\n        a, b = ((a+b) % MOD), a\n\nprint(a)","model_generated_potentially_faster_code_col":"import sys\n\n# Constants\nMOD = 10**9 + 7\n\n# Input handling\ndef main():\n    # Read input\n    N, M = map(int, sys.stdin.readline().split())\n    restricted = set(map(int, sys.stdin.read().split()))\n\n    # Edge case: If starting point is restricted\n    if 1 in restricted:\n        print(0)\n        return\n\n    # Dynamic Programming variables\n    prev2, prev1 = 0, 1  # Represents b[i-2] and b[i-1]\n\n    for i in range(2, N + 1):\n        if i in restricted:\n            current = 0  # No way to reach restricted index\n        else:\n            current = (prev1 + prev2) % MOD  # Compute b[i]\n        \n        # Update previous values\n        prev2, prev1 = prev1, current\n\n    # Output the result\n    print(prev1)\n\n# Run the program\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02555","slow_code_col":"n = int(eval(input()))\n\nmx = n\/\/3\n\nans = 0\n\nmod = 10**9+7\n\nimport math\n\ndef combinations_count(n, r): #\u7d44\u307f\u5408\u308f\u305b(nCr)\n\n    return math.factorial(n) \/\/ (math.factorial(n - r) * math.factorial(r))\n\nfor i in range(1,mx+1):\n\n    if i == 1:\n\n        ans += 1\n\n    else:\n\n        ans += combinations_count(n-2*i-1,i-1) % mod\n\nprint((ans%mod))","reference_code_col":"s = int(eval(input()))\n\ndp = [0]*(2001)\n\ndp[3] = 1\n\nmod = 10**9+7\n\nfor i in range(4,s+1):\n\n    dp[i] = (dp[i-1] + dp[i-3]) % mod\n\nprint((dp[s]))","model_generated_potentially_faster_code_col":"n = int(eval(input()))\nmx = n \/\/ 3\nans = 0\nmod = 10**9 + 7\n\n# Precompute factorials and modular inverses\ndef mod_inv(x, mod):\n    \"\"\"Compute modular inverse of x under mod using Fermat's Little Theorem.\"\"\"\n    return pow(x, mod - 2, mod)\n\n# Precompute factorials and inverse factorials\nfact = [1] * (n + 1)\ninv_fact = [1] * (n + 1)\n\nfor i in range(2, n + 1):\n    fact[i] = fact[i - 1] * i % mod\n\ninv_fact[n] = mod_inv(fact[n], mod)\nfor i in range(n - 1, 0, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n# Efficient nCr computation\ndef combinations_count(n, r):\n    if r > n or r < 0:\n        return 0\n    return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n\n# Main loop\nfor i in range(1, mx + 1):\n    ans += combinations_count(n - 2 * i - 1, i - 1)\n    ans %= mod\n\nprint(ans)"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\nn = int(eval(input()))\n\na_list = np.array(list(map(int, input().split())))\n\n\n\ncounter = 0\n\nwhile True:\n\n    if np.sum(a_list % 2) > 0:\n\n        break\n\n    counter += 1\n\n    a_list = a_list \/ 2\n\nprint(counter)\n","reference_code_col":"n = int(eval(input()))\n\na_list = list(map(int, input().split()))\n\n\n\nstatus = True\n\nexecute = 0\n\nwhile status:\n\n    for i in range(n):\n\n        if a_list[i] % 2 == 1:\n\n            status = False\n\n            break\n\n        else:\n\n            a_list[i] = a_list[i] \/ 2\n\n    if status:\n\n        execute += 1\n\nprint(execute)\n","model_generated_potentially_faster_code_col":"n = int(input())\na_list = list(map(int, input().split()))\n\ncounter = 0\n\nwhile True:\n    # Check if any element is odd using bitwise AND\n    if any(x & 1 for x in a_list):\n        break\n    \n    # Divide all elements by 2\n    a_list = [x \/\/ 2 for x in a_list]\n    counter += 1\n\nprint(counter)"}
{"problem_id":"p03568","slow_code_col":"import math\n\nimport string\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)\/\/(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\n\n\nn = int(eval(input()))\n\na = readints()\n\n\n\n\n\ndef func(l):\n\n    if len(l) == n:\n\n        for i in range(len(l)):\n\n            if l[i] % 2 == 0:\n\n                return 1\n\n\n\n        return 0\n\n    return func(l+[(a[len(l)])])+func(l+[(a[len(l)]-1)])+func(l+[(a[len(l)]+1)])\n\n\n\n\n\nprint((func([])))\n","reference_code_col":"import math\n\nimport string\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)\/\/(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\n\n\nn = int(eval(input()))\n\na = readints()\n\nsum = 1\n\nfor i in range(len(a)):\n\n    if a[i] % 2 == 0:\n\n        sum *= 2\n\n    else:\n\n        sum *= 1\n\nprint((3**len(a)-sum))\n","model_generated_potentially_faster_code_col":"import math\nfrom functools import lru_cache\n\n\ndef readints():\n    return list(map(int, input().split()))\n\n\n@lru_cache(None)\ndef func(index, has_even):\n    # Base case: if all elements are processed\n    if index == n:\n        return 1 if has_even else 0\n\n    # Recursive case: explore all three possibilities for the current element\n    count = 0\n    for value in [a[index], a[index] - 1, a[index] + 1]:\n        # Check if the current value is even\n        new_has_even = has_even or (value % 2 == 0)\n        count += func(index + 1, new_has_even)\n\n    return count\n\n\n# Input handling\nn = int(input())\na = readints()\n\n# Start the recursive function\nresult = func(0, False)\n\nprint(result)"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nN = int(eval(input()))\n\n\n\nnum = math.factorial(N)\n\n\n\nk, r = divmod(num, 10**9 + 7)\n\nprint(r)","reference_code_col":"N = int(eval(input()))\n\n\n\nFACTOR = 10 ** 9 + 7\n\n\n\nnum = 1\n\nfor i in range(1, N+1):\n\n    num *= i\n\n    k, r = divmod(num, FACTOR)\n\n    num = r\n\n\n\nprint(r)","model_generated_potentially_faster_code_col":"N = int(input())  # Avoid using eval for security reasons\n\nMOD = 10**9 + 7  # Define the modulus constant\n\n# Compute factorial modulo MOD efficiently\nresult = 1\nfor i in range(2, N + 1):\n    result = (result * i) % MOD\n\nprint(result)"}
{"problem_id":"p03241","slow_code_col":"def main():\n\n    N, M = (int(i) for i in input().split())\n\n\n\n    def trial_division(n):\n\n        divs = []\n\n        for i in range(1, int(n**0.5)+1):\n\n            if n % i == 0:\n\n                divs.append(i)\n\n                if i != n\/\/i:\n\n                    divs.append(n\/\/i)\n\n        divs.sort(reverse=True)\n\n        return divs\n\n    divs = trial_division(M)\n\n    for d in divs:\n\n        if d*N <= M:\n\n            return print(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def main():\n\n    def trial_division(n):\n\n        divs = []\n\n        for i in range(1, int(n**0.5)+1):\n\n            if n % i == 0:\n\n                divs.append(i)\n\n                if i != n\/\/i:\n\n                    divs.append(n\/\/i)\n\n        divs.sort(reverse=True)\n\n        return divs\n\n\n\n    N, M = (int(i) for i in input().split())\n\n    divs = trial_division(M)\n\n    for d in divs:\n\n        if N*d <= M:\n\n            return print(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    # Read input values\n    N, M = map(int, input().split())\n\n    # Find the largest divisor of M such that d * N <= M\n    for d in range(M, 0, -1):  # Iterate from M down to 1\n        if M % d == 0 and d * N <= M:  # Check if d is a divisor and satisfies the condition\n            print(d)\n            return\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nN = int(eval(input()))\n\nC = 10**9 + 7\n\n\n\nprint((math.factorial(N) % C))","reference_code_col":"N = int(eval(input()))\n\nC = 10**9+7\n\nans = 1\n\nfor i in range(1, N + 1):\n\n    ans *= i\n\n    ans %= C\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(input())\nC = 10**9 + 7\n\n# Compute factorial modulo C iteratively\nresult = 1\nfor i in range(2, N + 1):\n    result = (result * i) % C\n\nprint(result)"}
{"problem_id":"p04017","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nimport bisect\n\n\n\nn = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nl = int(eval(input()))\n\nU = 17\n\ndp = [[0]*n for _ in range(U+1)]\n\nfor i, x in enumerate(X):\n\n  t = bisect.bisect_left(X, x+l)\n\n  dp[0][i] = bisect.bisect_right(X, x+l) - 1\n\nfor k in range(U):\n\n  for i in range(n):\n\n    dp[k+1][i] = dp[k][dp[k][i]]\n\ndef test(x, a, b):\n\n  for i in range(U, -1, -1):\n\n    if x >> i & 1:\n\n      a = dp[i][a]\n\n  return a >= b\n\ndef solve(a, b):\n\n  if a > b:\n\n    a, b = b, a\n\n  ng = 0\n\n  ok = n-1\n\n  while ok - ng > 1:\n\n    mid = (ng + ok) \/\/ 2\n\n    if test(mid, a, b):\n\n      ok = mid\n\n    else:\n\n      ng = mid\n\n  print(ok)\n\nq = int(eval(input()))\n\nfor _ in range(q):\n\n  a, b = list(map(int, input().split()))\n\n  a -= 1\n\n  b -= 1\n\n  solve(a, b)","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\nimport bisect\n\n\n\nn = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nl = int(eval(input()))\n\nU = 17\n\ndp = [[0]*n for _ in range(U+1)]\n\nfor i, x in enumerate(X):\n\n  t = bisect.bisect_left(X, x+l)\n\n  dp[0][i] = bisect.bisect_right(X, x+l) - 1\n\nfor k in range(U):\n\n  for i in range(n):\n\n    dp[k+1][i] = dp[k][dp[k][i]]\n\nq = int(eval(input()))\n\nfor _ in range(q):\n\n  a, b = list(map(int, input().split()))\n\n  a -= 1\n\n  b -= 1\n\n  if a > b:\n\n    a, b = b, a\n\n  res = 1\n\n  for k in range(U, -1, -1):\n\n    if dp[k][a] < b:\n\n      a = dp[k][a]\n\n      res += (1<<k)\n\n    if a == b:\n\n      break\n\n  print(res)","model_generated_potentially_faster_code_col":"import sys\nfrom bisect import bisect_right\n\n# Fast I\/O setup\ninput = sys.stdin.readline\noutput = sys.stdout.write\n\n# Input reading\nn = int(input())\nX = list(map(int, input().split()))\nl = int(input())\n\n# Constants\nU = 17\n\n# Precompute dp table\ndp = [[0] * n for _ in range(U + 1)]\n\n# Two-pointer approach to replace bisect\nj = 0\nfor i in range(n):\n    while j < n and X[j] - X[i] <= l:\n        j += 1\n    dp[0][i] = j - 1\n\n# Binary lifting (precompute dp table)\nfor k in range(U):\n    for i in range(n):\n        dp[k + 1][i] = dp[k][dp[k][i]]\n\n# Query processing helper function\ndef test(x, a, b):\n    for i in range(U, -1, -1):\n        if x >> i & 1:\n            a = dp[i][a]\n    return a >= b\n\n# Binary search for solving queries\ndef solve(a, b):\n    if a > b:\n        a, b = b, a\n    ng = 0\n    ok = n - 1\n    while ok - ng > 1:\n        mid = (ng + ok) \/\/ 2\n        if test(mid, a, b):\n            ok = mid\n        else:\n            ng = mid\n    output(f\"{ok}\\n\")\n\n# Process queries\nq = int(input())\nfor _ in range(q):\n    a, b = map(int, input().split())\n    solve(a - 1, b - 1)"}
{"problem_id":"p03164","slow_code_col":"#!\/usr\/bin\/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    np.set_printoptions(linewidth=200)\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i\u4ee5\u4e0a\u306e\u4fa1\u5024\u3092\u6301\u3064\u3068\u304d\u306e\u6700\u5c0f\u91cd\u91cf\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for n in range(N):\n\n        w, v = lst[n]\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    ans = 0\n\n    for i, w in enumerate(dp):\n\n        if w <= W:\n\n            ans = i\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"#!\/usr\/bin\/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i\u4ee5\u4e0a\u306e\u4fa1\u5024\u3092\u6301\u3064\u3068\u304d\u306e\u6700\u5c0f\u91cd\u91cf\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for w, v in lst:\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    print((np.asarray(dp <= W).nonzero()[0].max()))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env python3\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N, W = int(data[0]), int(data[1])\n    lst = []\n    idx = 2\n    for _ in range(N):\n        w, v = int(data[idx]), int(data[idx + 1])\n        lst.append((w, v))\n        idx += 2\n\n    # Maximum possible value\n    v_max = 10**5  # Adjusted based on constraints (10^3 * 100)\n\n    # Initialize DP array: dp[i] = minimum weight for achieving value i\n    dp = [float('inf')] * (v_max + 1)\n    dp[0] = 0  # Base case: 0 value requires 0 weight\n\n    # Update DP array\n    for w, v in lst:\n        for value in range(v_max, v - 1, -1):  # Iterate backwards to avoid overwriting\n            dp[value] = min(dp[value], dp[value - v] + w)\n\n    # Find the maximum value such that weight <= W\n    ans = 0\n    for value in range(v_max + 1):\n        if dp[value] <= W:\n            ans = value\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02994","slow_code_col":"n, like = list(map(int, input().split()))\n\n\n\narr = [like + i for i in range(n)]\n\n\n\narr.sort(key=lambda x:abs(x))\n\n\n\nprint((sum(arr[1:])))\n","reference_code_col":"n, like = list(map(int, input().split()))\n\narr = [like + i for i in range(n)]\n\narr.sort(key=abs)\n\nprint((sum(arr[1:])))\n","model_generated_potentially_faster_code_col":"n, like = map(int, input().split())\n\n# Initialize variables to track the smallest absolute value and total sum\nmin_abs_value = float('inf')\ntotal_sum = 0\n\nfor i in range(n):\n    value = like + i\n    total_sum += value  # Add the current value to the total sum\n    \n    # Update the smallest absolute value if needed\n    if abs(value) < min_abs_value:\n        min_abs_value = abs(value)\n\n# Subtract the smallest absolute value from the total sum\nif n > 0:\n    total_sum -= min_abs_value\n\nprint(total_sum)"}
{"problem_id":"p03371","slow_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\nans = float('inf')\n\nfor i in range(max(X,Y)+1):\n\n    cost = 2 * C * i + max(0,X-i)*A +max(0,Y-i)*B\n\n    ans = min(ans,cost)\n\nprint(ans)","reference_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\ntmp = A*X + B*Y\n\nif X >= Y:\n\n    tmp = min(tmp,2*Y*C+(X-Y)*A)\n\nelse:\n\n    tmp = min(tmp,2*X*C+(Y-X)*B)\n\ntmp = min(tmp,max(X,Y)*2*C)\n\nprint(tmp)","model_generated_potentially_faster_code_col":"A, B, C, X, Y = map(int, input().split())\n\n# Calculate the cost for i = 0 (no special deal)\ncost_i_0 = X * A + Y * B\n\n# Calculate the cost for i = min(X, Y) (maximum use of special deal)\ni_optimal = min(X, Y)\ncost_i_min = 2 * C * i_optimal + max(0, X - i_optimal) * A + max(0, Y - i_optimal) * B\n\n# Compare the two costs and print the minimum\nprint(min(cost_i_0, cost_i_min))"}
{"problem_id":"p03828","slow_code_col":"#coding: UTF-8\n\nimport math\n\nN=int(eval(input()))\n\ndef prime_list(k):\n\n    lis=[True for i in range(1,k+1)]\n\n    lis[0]=False\n\n    for i in range(2,k+1):\n\n        j=2\n\n        while j*j<=i:\n\n            if i%j==0:\n\n                lis[i-1]=False\n\n                break\n\n            else:\n\n                j+=1\n\n    return lis\n\n#    print(lis)\n\ndef p_fact(k,N):\n\n    plist=prime_list(k)\n\n    lis=[0]*N\n\n    for i in range(0,k):\n\n        n=0\n\n        if plist[i]:\n\n            while k%(i+1)==0:\n\n                n+=1\n\n                k=k\/(i+1)\n\n        lis[i]=n\n\n    return lis\n\nout_lis=[0]*N\n\nfor i in range(1,N+1):\n\n    input_lis=p_fact(i,N)\n\n    out_lis=[out_lis[j]+input_lis[j] for j in range(0,N)]\n\n#print(out_lis)\n\nout=1\n\nfor i in range(0,N):\n\n    out=out*(out_lis[i]+1)\n\nprint((out%1000000007))","reference_code_col":"#coding: UTF-8\n\nimport math\n\nN=int(eval(input()))\n\ndef prime_list(k):\n\n    lis=[True for i in range(1,k+1)]\n\n    lis[0]=False\n\n    for i in range(2,k+1):\n\n        j=2\n\n        while j*j<=i:\n\n            if i%j==0:\n\n                lis[i-1]=False\n\n                break\n\n            else:\n\n                j+=1\n\n    return lis\n\n#    print(lis)\n\ndef p_fact(k,N,plist):\n\n#    plist=prime_list(k)\n\n    lis=[0]*N\n\n    for i in range(0,k):\n\n        n=0\n\n        if plist[i]:\n\n            while k%(i+1)==0:\n\n                n+=1\n\n                k=k\/(i+1)\n\n        lis[i]=n\n\n    return lis\n\n#    print(lis)\n\nout_lis=[0]*N\n\nplist=prime_list(N)\n\nfor i in range(1,N+1):\n\n    input_lis=p_fact(i,N,plist)\n\n    out_lis=[out_lis[j]+input_lis[j] for j in range(0,N)]\n\n#print(out_lis)\n\nout=1\n\nfor i in range(0,N):\n\n    out=out*(out_lis[i]+1)\n\n#print(out%1000000007)\n\nprint((out%(10**9+7)))","model_generated_potentially_faster_code_col":"#coding: UTF-8\n\nMOD = 10**9 + 7\n\n# Input reading\nN = int(input())\n\n# Function to generate prime numbers using Sieve of Eratosthenes\ndef sieve_of_eratosthenes(limit):\n    sieve = [True] * (limit + 1)\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n    for i in range(2, int(math.sqrt(limit)) + 1):\n        if sieve[i]:\n            for j in range(i * i, limit + 1, i):\n                sieve[j] = False\n    return sieve\n\n# Precompute primes up to N\nis_prime = sieve_of_eratosthenes(N)\n\n# Count the frequency of each prime factor across all numbers from 1 to N\nprime_factors_count = [0] * (N + 1)\n\nfor i in range(2, N + 1):\n    if is_prime[i]:  # Only consider prime numbers\n        power = i\n        while power <= N:\n            prime_factors_count[i] += N \/\/ power\n            power *= i\n\n# Compute the final result using modular arithmetic\nresult = 1\nfor count in prime_factors_count:\n    result = (result * (count + 1)) % MOD\n\nprint(result)"}
{"problem_id":"p02245","slow_code_col":"import sys\n\nimport queue\n\n\n\nN = 3\n\nf= ''.join(sys.stdin.readline().split())\n\nf+= ''.join(sys.stdin.readline().split())\n\nf+= ''.join(sys.stdin.readline().split())\n\n\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\n\n\nQ = queue.Queue()\n\nV = dict()\n\n\n\nQ.put([f,f.index('0'),0])\n\nV[f] = True\n\n\n\nwhile not Q.empty():\n\n    u = Q.get()\n\n    if u[0] == '123456780':  break\n\n    sx, sy = u[1]\/\/N, u[1]%N\n\n    for dx, dy in dd:\n\n        tx, ty = sx+dx, sy+dy\n\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n\n        v = u[:]\n\n        n1, n2 = u[1], tx*N+ty\n\n        v[1] = n2\n\n        if n1>n2: n1, n2 = n2, n1\n\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n\n        if not V.get(v[0], False):\n\n            V[v[0]] = True\n\n            v[2] += 1                                                    \n\n            Q.put(v)\n\n\n\nprint((u[2]))\n","reference_code_col":"import sys\n\nimport queue\n\n\n\nN = 3\n\n\n\nf = ''.join(sys.stdin.readline().split())\n\nf += ''.join(sys.stdin.readline().split())\n\nf += ''.join(sys.stdin.readline().split())\n\n\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\n\n\nQ = [[f,f.index('0'),0]]\n\nV = { f: True }\n\n\n\nwhile len(Q)>0:\n\n    u = Q.pop(0)\n\n    if u[0] == '123456780':  break\n\n    sx, sy = u[1]\/\/N, u[1]%N\n\n    for dx, dy in dd:\n\n        tx, ty = sx+dx, sy+dy\n\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n\n        v = u[:]\n\n        n1, n2 = u[1], tx*N+ty\n\n        v[1] = n2\n\n        if n1>n2: n1, n2 = n2, n1\n\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n\n        if not V.get(v[0], False):\n\n            V[v[0]] = True\n\n            v[2] += 1 # dir[r]                                                       \n\n            Q.append(v)\n\n\n\nprint((u[2]))\n","model_generated_potentially_faster_code_col":"import sys\nfrom collections import deque\n\nN = 3\n\n# Read input and construct the initial state\ninitial_state = ''.join(sys.stdin.read().split())\n\n# Define directions for moving the empty tile\ndirections = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n\n# Initialize BFS\nQ = deque([(initial_state, initial_state.index('0'), 0)])  # (state, position of '0', moves)\nvisited = {initial_state: True}\n\nwhile Q:\n    state, zero_pos, moves = Q.popleft()\n\n    # Check if the current state is the goal state\n    if state == '123456780':\n        print(moves)\n        break\n\n    # Compute the row and column of the empty tile\n    sx, sy = divmod(zero_pos, N)\n\n    # Explore all possible moves\n    for dx, dy in directions:\n        tx, ty = sx + dx, sy + dy\n\n        # Skip invalid positions\n        if not (0 <= tx < N and 0 <= ty < N):\n            continue\n\n        # Compute the new position of the empty tile\n        new_zero_pos = tx * N + ty\n\n        # Swap the empty tile with the target tile\n        n1, n2 = min(zero_pos, new_zero_pos), max(zero_pos, new_zero_pos)\n        new_state = (\n            state[:n1] + state[n2] + state[n1 + 1:n2] + state[n1] + state[n2 + 1:]\n        )\n\n        # If the new state hasn't been visited, add it to the queue\n        if new_state not in visited:\n            visited[new_state] = True\n            Q.append((new_state, new_zero_pos, moves + 1))"}
{"problem_id":"p03806","slow_code_col":"N,MA,MB = list(map(int,input().split()))\n\nsrc = [tuple(map(int,input().split())) for i in range(N)]\n\n\n\nINF = 10**9\n\ndp = [[INF for j in range(401)] for i in range(401)]\n\ndp[0][0] = 0\n\nmaxa = maxb = 0\n\nfor a,b,c in src:\n\n    for ai in range(maxa,-1,-1):\n\n        for bi in range(maxb,-1,-1):\n\n            dp[ai+a][bi+b] = min(dp[ai+a][bi+b], dp[ai][bi] + c)\n\n    maxa += a\n\n    maxb += b\n\n\n\nans = INF\n\nfor i in range(1,401):\n\n    if MA*i > 400 or MB*i > 400: break\n\n    ans = min(ans, dp[MA*i][MB*i])\n\nprint((-1 if ans == INF else ans))","reference_code_col":"N,MA,MB = list(map(int,input().split()))\n\nsrc = [tuple(map(int,input().split())) for i in range(N)]\n\n\n\nINF = 10**9\n\nMAX = 401\n\ndp = [[INF] * MAX for i in range(MAX)]\n\ndp[0][0] = 0\n\namax = bmax = 0\n\nfor a,b,n in src:\n\n    for i in reversed(list(range(bmax+1))):\n\n        for j in range(amax+1):\n\n            if dp[i][j] == INF: continue\n\n            dp[i+b][j+a] = min(dp[i+b][j+a], dp[i][j] + n)\n\n    amax += a\n\n    bmax += b\n\n\n\nans = INF\n\nfor i in range(1,MAX):\n\n    if i*MA >= MAX or i*MB >= MAX: break\n\n    ans = min(ans, dp[i*MB][i*MA])\n\nprint((-1 if ans == INF else ans))","model_generated_potentially_faster_code_col":"N, MA, MB = map(int, input().split())\nsrc = [tuple(map(int, input().split())) for _ in range(N)]\n\nINF = 10**9\n\n# Initialize DP table with INF\ndp = [INF] * 401\ndp[0] = 0\n\nmaxa = maxb = 0\n\n# Temporary array to store updates\ntmp = [INF] * 401\n\nfor a, b, c in src:\n    # Reset temporary array\n    tmp[:] = [INF] * 401\n\n    for ai in range(401):\n        if dp[ai] == INF:\n            continue  # Skip unreachable states\n        for bi in range(401):\n            if dp[ai] + c < tmp[ai + a]:\n                tmp[ai + a] = min(tmp[ai + a], dp[ai] + c)\n\n    # Update DP table with temporary array\n    for i in range(401):\n        if tmp[i] < dp[i]:\n            dp[i] = tmp[i]\n\n    maxa += a\n    maxb += b\n\n# Find the minimum cost for valid (MA*i, MB*i)\nans = INF\nfor i in range(1, 401):\n    if MA * i > 400 or MB * i > 400:\n        break\n    ans = min(ans, dp[MA * i])\n\nprint(-1 if ans == INF else ans)"}
{"problem_id":"p03253","slow_code_col":"import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\nfac = [1, 1]     # \u5143\u30c6\u30fc\u30d6\u30eb\n\nf_inv = [1, 1]   # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\ninv = [0, 1]     # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n        inv.append((-inv[mod % i] * (mod\/\/i)) % mod)\n\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * f_inv[r] * f_inv[n-r] % mod\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n \/\/= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    prepare(N+100, MOD)\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e, MOD)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\nfac = [1, 1]     # \u5143\u30c6\u30fc\u30d6\u30eb\n\nf_inv = [1, 1]   # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\ninv = [0, 1]     # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * pow(fac[r],MOD-2,MOD) * pow(fac[n-r],MOD-2,MOD) % mod\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n \/\/= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    prepare(N+100, MOD)\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e, MOD)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"def prepare(n, mod):\n    fac = [1] * (n + 1)\n    inv = [1] * (n + 1)\n    f_inv = [1] * (n + 1)\n\n    for i in range(2, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        inv[i] = mod - (mod \/\/ i) * inv[mod % i] % mod\n        f_inv[i] = f_inv[i - 1] * inv[i] % mod\n\n    return fac, inv, f_inv"}
{"problem_id":"p03494","slow_code_col":"_,t=open(0);n=eval(t.replace(' ','|'));print((len(bin(n&-n))-3))","reference_code_col":"n=eval([*open(0)][1].replace(*' |'))\n\nprint((len(bin(n&-n))-3))","model_generated_potentially_faster_code_col":"_,t=open(0);n=eval(t.replace(' ','|'));print((len(bin(n&-n))-3))"}
{"problem_id":"p02780","slow_code_col":"import numpy as np\n\n\n\nN, K= list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\n\n\ntmp = np.sum(p[:K])\n\nmax = tmp\n\nfor i in range(N-K):\n\n    tmp = tmp-p[i]+p[i+K]\n\n    if tmp>max:\n\n        max = tmp\n\n\n\nprint(((max+K)\/2))","reference_code_col":"N, K= list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\ntmp = sum(p[:K])\n\nmax = tmp\n\nfor i in range(N-K):\n\n    tmp = tmp-p[i]+p[i+K]\n\n    if tmp>max:\n\n        max = tmp\n\n\n\nprint(((max+K)\/2))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN, K = map(int, input().split())\np = np.fromiter(map(int, input().split()), dtype=int)\n\n# Compute the initial sum of the first K elements\ncurrent_sum = np.sum(p[:K])\nmax_sum = current_sum\n\n# Sliding window to find the maximum sum\nfor i in range(N - K):\n    current_sum += p[i + K] - p[i]  # Update the sliding window sum\n    if current_sum > max_sum:\n        max_sum = current_sum\n\n# Compute and print the result\nprint((max_sum + K) \/ 2)"}
{"problem_id":"p03309","slow_code_col":"import statistics\n\nN = int(eval(input()))\n\nA = [int(a)-i-1 for i,a in enumerate(input().split(),1)]\n\nb = statistics.median_low(A)\n\nc = statistics.median_high(A)\n\nd = sum([abs(x-b) for x in A])\n\ne = sum([abs(x-c) for x in A])\n\nprint((min(d,e)))","reference_code_col":"N=int(eval(input()))\n\nA=sorted(a-i-1 for i,a in enumerate(map(int,input().split())))\n\nprint((sum(abs(a-A[N\/\/2]) for a in A)))","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Parse input and compute A\nA = [int(a) - i - 1 for i, a in enumerate(input().split(), 1)]\n\n# Sort A once\nA.sort()\n\n# Compute median_low and median_high\nmid = N \/\/ 2\nb = A[mid - 1] if N % 2 == 0 else A[mid]  # median_low\nc = A[mid] if N % 2 == 0 else A[mid]      # median_high\n\n# Compute the sum of absolute differences in a single pass\nsum_b = sum_c = 0\nfor x in A:\n    sum_b += abs(x - b)\n    sum_c += abs(x - c)\n\n# Print the minimum of the two sums\nprint(min(sum_b, sum_c))"}
{"problem_id":"p03416","slow_code_col":"a,b = list(map(int,input().split()))\n\nc = 0\n\n\n\nfor i in range(a,b+1):\n\n  new = list(reversed(list(str(i))))\n\n  if new == list(str(i)):\n\n    c += 1\n\n    \n\n    \n\nprint(c)","reference_code_col":"a,b = list(map(int,input().split()))\n\nc = 0\n\n\n\nfor i in range(a,b+1):\n\n  if list(str(i)) == list(str(i))[::-1]:\n\n    c += 1\n\n    \n\n    \n\nprint(c)","model_generated_potentially_faster_code_col":"def count_palindromes(a, b):\n    c = 0\n    for num in range(a, b + 1):\n        original = num\n        reversed_num = 0\n        temp = num\n\n        # Reverse the digits of the number using integer arithmetic\n        while temp > 0:\n            reversed_num = reversed_num * 10 + (temp % 10)\n            temp \/\/= 10\n\n        # Check if the number is a palindrome\n        if original == reversed_num:\n            c += 1\n\n    return c\n\n\n# Input\na, b = map(int, input().split())\n\n# Output\nprint(count_palindromes(a, b))"}
{"problem_id":"p03013","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nN, M = list(map(int,input().split()))\n\nhole = [0] * (N+1)\n\nfor i in range(M):\n\n    hole[int(eval(input()))] = 1\n\nif N == 1:\n\n    print((1))\n\n    exit()\n\nif N == 2:\n\n    if hole[1] == 1:\n\n        print((1))\n\n        exit()\n\n    if hole[1] == 0:\n\n        print((2))\n\n        exit()\n\nflg_one = False\n\nflg_two = False\n\nfirst = 1\n\nsecond = 2\n\nif hole[1] == 1:\n\n    first = 0\n\n    second = 1\n\n    flg_one = True\n\nif hole[2] == 1:\n\n    first = 1\n\n    second = 0\n\n    flg_two = True\n\nif flg_one and flg_two:\n\n    print((0))\n\n    exit()\n\n\n\nfor i in range(3,N):\n\n    if hole[i] == 1:\n\n        first = second\n\n        second = 0\n\n        continue\n\n    tmp = first + second\n\n    tmp %= 1000000007\n\n    first = second\n\n    second = tmp\n\ntmp = first + second\n\ntmp %= 1000000007\n\nprint(tmp)","reference_code_col":"MOD = 10**9 + 7\n\nN, M = list(map(int, input().split()))\n\nstairs = [0]*(N+1)\n\nfor _ in range(M):\n\n    stairs[int(eval(input()))] = 1\n\nif N == 1:\n\n    print((1))\n\n    exit()\n\nans = [0]*(N+1)\n\nans[1] = 1 if stairs[1] == 0 else 0\n\nans[2] = 1 + ans[1] if stairs[2] == 0 else 0\n\nfor i in range(3,N+1):\n\n    if stairs[i] == 1:\n\n        ans[i] = 0\n\n        continue\n\n    ans[i] = (ans[i-1] + ans[i-2]) % MOD\n\nprint((ans[N]))","model_generated_potentially_faster_code_col":"import sys\n\n# Read all input at once\ninput_data = sys.stdin.read().split()\nN, M = map(int, input_data[:2])\nhole_indices = list(map(int, input_data[2:]))\n\n# Initialize the hole array\nhole = [0] * (N + 1)\nfor idx in hole_indices:\n    hole[idx] = 1\n\n# Handle edge cases for N == 1 or N == 2\nif N == 1:\n    print(1 if hole[1] == 0 else 0)\n    exit()\n\nif N == 2:\n    if hole[1] == 1 and hole[2] == 1:\n        print(0)\n    elif hole[1] == 1 or hole[2] == 1:\n        print(1)\n    else:\n        print(2)\n    exit()\n\n# Initialize variables for Fibonacci-like sequence\nfirst, second = 1, 1 if hole[2] == 0 else 0\n\n# Early exit if both first two positions are blocked\nif hole[1] == 1 and hole[2] == 1:\n    print(0)\n    exit()\n\n# Compute the number of ways to reach position N\nMOD = 1000000007\nfor i in range(3, N + 1):\n    if hole[i] == 1:\n        first, second = second, 0\n    else:\n        tmp = (first + second) % MOD\n        first, second = second, tmp\n\nprint(second)"}
{"problem_id":"p03558","slow_code_col":"#!usr\/bin\/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    s = S()\n\n    t = S()\n\n    if s+t == t[::-1]+s[::-1]:\n\n        print(\"YES\")\n\n    else:\n\n        print(\"NO\")\n\n\n\n#B\n\ndef B():\n\n    n = I()\n\n    for i in range(int(n**0.5)+2)[::-1]:\n\n        if i*i <= n:\n\n            print((i*i))\n\n            quit()\n\n#C\n\ndef C():\n\n    n = I()\n\n    a = LI()\n\n    b = LI()\n\n    c = LI()\n\n    q = [0 for i in range(n)]\n\n    ans = 0\n\n    a.sort()\n\n    b.sort()\n\n    c.sort()\n\n    for i in range(n):\n\n        j = bisect.bisect_left(a,b[i])\n\n        q[i] = j\n\n    for i in range(n-1):\n\n        q[i+1] += q[i]\n\n    q.insert(0,0)\n\n    for i in range(n):\n\n        j = bisect.bisect_left(b,c[i])\n\n        ans += q[j]\n\n    print(ans)\n\n#D\n\ndef D():\n\n    def dijkstra():\n\n        d = [float(\"inf\") for i in range(k)]\n\n        q = [[0,1]]\n\n        d[1] = 0\n\n        while q:\n\n            dx,x = heappop(q)\n\n            for y,dy in v[x]:\n\n                if d[y] > dx+dy:\n\n                    d[y] = dx+dy\n\n                    heappush(q,[d[y],y])\n\n        print((d[0]+1))\n\n    k = I()\n\n    if k == 1:\n\n        print((1))\n\n        quit()\n\n    v = [[] for i in range(k)]\n\n    for i in range(1,k):\n\n        v[i].append([(i+1)%k,1])\n\n        v[i].append([i*10%k,0])\n\n    dijkstra()\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    return\n\n\n\n#G\n\ndef G():\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    D()\n","reference_code_col":"#!usr\/bin\/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    def v(n):\n\n        return [n*10%k, (n+1)%k]\n\n    k = I()\n\n    d = [float(\"inf\")]*k\n\n    d[1] = 1\n\n    q = deque([1])\n\n    while q:\n\n        x = q.popleft()\n\n        vx = v(x)\n\n        dx = d[x]\n\n        for c in range(2):\n\n            nd = dx+c\n\n            y = vx[c]\n\n            if nd < d[y]:\n\n                d[y] = nd\n\n                if c:\n\n                    q.append(y)\n\n                else:\n\n                    q.appendleft(y)\n\n    print((d[0]))\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n","model_generated_potentially_faster_code_col":"def A():\n    s = S()\n    t = S()\n    # Reverse strings only once\n    s_rev = s[::-1]\n    t_rev = t[::-1]\n    if s + t == t_rev + s_rev:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"problem_id":"p02994","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nN, L = list(map(int, input().split()))\n\n\n\n# \u5473\n\nLL = np.arange(L,L+N)\n\n\n\nm = abs(LL[0])\n\n\n\nfor i in range(N):\n\n    if abs(m) > abs(LL[i]):\n\n        m = LL[i]\n\n\n\nprint((np.sum(LL)-m))\n","reference_code_col":"N, L = list(map(int, input().split()))\n\n\n\nA = [i for i in range(L, L + N)]\n\n\n\nif A[0] < 0:\n\n    if A[-1] < 0:\n\n        print((sum(A) - max(A)))\n\n    else:\n\n        print((sum(A)))\n\nelse:\n\n    print((sum(A) - min(A)))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN, L = map(int, input().split())\n\n# Create the array\nLL = np.arange(L, L + N)\n\n# Find the element with the smallest absolute value\nmin_abs_value = LL[np.argmin(np.abs(LL))]\n\n# Compute the result\nresult = np.sum(LL) - min_abs_value\n\n# Print the result\nprint(result)"}
{"problem_id":"p02537","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\n\n\n# N: \u51e6\u7406\u3059\u308b\u533a\u9593\u306e\u9577\u3055\n\n\n\nINF = 0\n\n\n\nmx = 300001\n\nLV = (mx-1).bit_length()\n\nN0 = 2**LV\n\ndata = [INF]*(2*N0)\n\nlazy = [None]*(2*N0)\n\n\n\n# \u4f1d\u642c\u5bfe\u8c61\u306e\u533a\u9593\u3092\u6c42\u3081\u308b\n\ndef gindex(l, r):\n\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n\n    lc = 0 if l & 1 else (L & -L).bit_length()\n\n    rc = 0 if r & 1 else (R & -R).bit_length()\n\n    for i in range(LV):\n\n        if rc <= i:\n\n            yield R\n\n        if L < R and lc <= i:\n\n            yield L\n\n        L >>= 1; R >>= 1\n\n\n\n# \u9045\u5ef6\u4f1d\u642c\u51e6\u7406\n\ndef propagates(*ids):\n\n    for i in reversed(ids):\n\n        v = lazy[i-1]\n\n        if v is None:\n\n            continue\n\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n\n        lazy[i-1] = None\n\n\n\n# \u533a\u9593[l, r)\u3092x\u3067\u66f4\u65b0\n\ndef update(l, r, x):\n\n    *ids, = gindex(l, r)\n\n    propagates(*ids)\n\n\n\n    L = N0 + l; R = N0 + r\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            lazy[R-1] = data[R-1] = x\n\n        if L & 1:\n\n            lazy[L-1] = data[L-1] = x\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    for i in ids:\n\n        data[i-1] = max(data[2*i-1], data[2*i])\n\n\n\n# \u533a\u9593[l, r)\u5185\u306e\u6700\u5c0f\u5024\u3092\u6c42\u3081\u308b\n\ndef query(l, r):\n\n    propagates(*gindex(l, r))\n\n    L = N0 + l; R = N0 + r\n\n\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = max(s, data[R-1])\n\n        if L & 1:\n\n            s = max(s, data[L-1])\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    return s\n\n\n\nans = 0\n\nupdate(As[0],As[0]+1,1)\n\nfor i, a in enumerate(As[1:]):\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n    upd = query(l,r+1)\n\n    if upd == -1:continue\n\n    # print(\"i\",i,\"a\",a,\"upd\",upd,\"l\",l,\"r\",r)\n\n    update(a, a+1, upd+1)\n\n    ans = max(ans, upd+1)\n\nprint(ans)\n\n\n","reference_code_col":"# \u30bb\u30b0\u30e1\u30f3\u30c8\u6728\n\n# segment tree\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nclass segmented_tree:\n\n    X_unit = 0\n\n    X_f = lambda self, a, b: max(a,b)\n\n    def __init__(self, N):\n\n        self.N = N\n\n        self.X = [self.X_unit] * (2*N)\n\n        \n\n    def build(self, seq):\n\n        for i, x in enumerate(seq, self.N):\n\n            self.X[i] = x \n\n        # \u5f8c\u308d\u304b\u3089\u5165\u308c\u3066\u3044\u304f\n\n        for i in range(self.N-1, 0, -1):\n\n            self.X[i] = self.X_f(self.X[i<<1], self.X[i<<1|1])\n\n\n\n    # 1\u70b9\u66f4\u65b0\n\n    def set_val(self, i, x):\n\n        i += self.N\n\n        self.X[i] = x\n\n        while i > 1:\n\n            i >>= 1\n\n            self.X[i] = self.X_f(self.X[i<<1],self.X[i<<1|1])\n\n    \n\n    # \u533a\u9593\u53d6\u5f97\n\n    def fold(self, l, r):\n\n        l += self.N\n\n        r += self.N\n\n        vl = self.X_unit\n\n        vr = self.X_unit\n\n        # \u5916\u304b\u3089\u6c7a\u3081\u3066\u3044\u304f\n\n        while l < r:\n\n            # print(l,r)\n\n            if l & 1:\n\n                vl = self.X_f(vl, self.X[l])\n\n                l += 1\n\n            if r & 1:\n\n                r -= 1\n\n                vr = self.X_f(vr, self.X[r])\n\n            l >>= 1\n\n            r >>= 1\n\n        return self.X_f(vl,vr)\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\nmx = 300001\n\nans = 0\n\nsg = segmented_tree(330000)\n\n\n\nfor a in As:\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n\n\n    upd = sg.fold(l,r+1)\n\n    ans = max(ans, upd+1)\n\n\n\n    sg.set_val(a, upd+1)\n\nprint(ans)\n\n\n","model_generated_potentially_faster_code_col":"n, k = map(int, input().split())\nAs = [int(input()) for _ in range(n)]"}
{"problem_id":"p02596","slow_code_col":"# coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    k = int(args[0])\n\n\n\n    l = 9*(k\/\/7 if k % 7 == 0 else k)\n\n    if l % 2 == 0 or l % 5 == 0:\n\n        return '-1'\n\n\n\n    r = phi = l\n\n    for i in range(2, int(-pow(l, 1\/2))):\n\n        if r % i == 0:\n\n            phi = phi\/\/i*(i-1)\n\n            while r % i:\n\n                r \/\/= i\n\n\n\n    a = 10 % l\n\n    ret = 1\n\n    while(a != 1):\n\n        a = a*10 % l\n\n        ret += 1\n\n        if phi < ret:\n\n            ret = -1\n\n            break\n\n\n\n    return str(ret)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n","reference_code_col":"# coding: utf-8\n\nfrom math import sqrt\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    k = int(args[0])\n\n\n\n    l = 9*(k\/\/7 if 0 == k % 7 else k)\n\n    if 0 == l % 2 or 0 == l % 5:\n\n        return '-1'\n\n\n\n    r = phi = l\n\n    for i in range(2, int(sqrt(l)+1)):\n\n        if 0 == r % i:\n\n            phi = phi*(i-1)\/\/i\n\n            while 0 == r % i:\n\n                r \/\/= i\n\n    if 1 < r:\n\n        phi = phi*(r-1)\/\/r\n\n\n\n    D = set()\n\n    for d in range(1, int(sqrt(phi)+1)):\n\n        if 0 == phi % d:\n\n            D.add(d)\n\n            D.add(phi\/\/d)\n\n\n\n    ret = -1\n\n    for m in sorted(D):\n\n        if 1 == pow(10, m, l):\n\n            ret = m\n\n            break\n\n\n\n    return str(ret)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n","model_generated_potentially_faster_code_col":"def solve(*args: str) -> str:\n    k = int(args[0])\n    \n    # Compute l\n    l = 9 * (k \/\/ 7 if k % 7 == 0 else k)\n    \n    # Check divisibility by 2 or 5\n    if l % 2 == 0 or l % 5 == 0:\n        return '-1'\n    \n    # Compute phi (Euler's totient function)\n    r = l\n    phi = l\n    sqrt_l = int(l**0.5) + 1  # Precompute square root of l\n    for i in range(2, sqrt_l):\n        if r % i == 0:\n            phi = phi \/\/ i * (i - 1)\n            while r % i == 0:\n                r \/\/= i\n    if r > 1:  # Handle remaining prime factor\n        phi = phi \/\/ r * (r - 1)\n    \n    # Find the smallest ret such that 10^ret \u2261 1 (mod l)\n    a = 10 % l\n    ret = 1\n    while a != 1:\n        a = (a * 10) % l\n        ret += 1\n        if ret > phi:  # Early exit if ret exceeds phi\n            return '-1'\n    \n    return str(ret)\n\n\nif __name__ == \"__main__\":\n    print(solve(*(open(0).read().splitlines())))"}
{"problem_id":"p03013","slow_code_col":"import sys\n\nsys.setrecursionlimit(100000)\n\n\n\ndef intinput(): return list(map(int,sys.stdin.readline().split()))\n\n\n\nfib={0:0,1:1,2:1}\n\nfor i in range(3,100003):\n\n    fib[i]=fib[i-1]+fib[i-2]\n\n  #  fib.append(fib[i-1]+fib[i-2])\n\n\n\nn,m=intinput()\n\nmod=10**9+7\n\na=[int(sys.stdin.readline()) for _ in range(m)]\n\nif m!=0:\n\n    l=[a[0]]\n\n    for i in range(len(a)-1):\n\n        l.append(a[i+1]-a[i]-1)\n\n    l.append(n-a[-1])\n\n    k=1\n\n    for i in l:\n\n        k=fib[i]*k%mod\n\n    print((k%mod))\n\nelse:\n\n    print((fib[n+1]%mod))","reference_code_col":"import sys\n\nsys.setrecursionlimit(100000)\n\n\n\ndef intinput(): return list(map(int,sys.stdin.readline().split()))\n\n\n\n\n\nn, m = intinput()\n\na = {int(sys.stdin.readline()) for _ in range(m)}\n\nmemo = [0 for x in range(n + 4)]\n\nmemo[0] = 1\n\nmod = 10 ** 9 + 7\n\nfor i in range(n):\n\n    if i + 1 not in a:\n\n        memo[i + 1] = (memo[i + 1] + memo[i]) % mod\n\n    if i + 2 not in a:\n\n        memo[i + 2] = (memo[i + 2] + memo[i]) % mod\n\nprint((memo[n]))","model_generated_potentially_faster_code_col":"import sys\n\n# Set recursion limit if needed\nsys.setrecursionlimit(100000)\n\n# Input function\ndef intinput():\n    return list(map(int, sys.stdin.read().split()))\n\n# Precompute Fibonacci numbers with modulo\nMOD = 10**9 + 7\nMAX_FIB = 100003\nfib = [0] * MAX_FIB\nfib[0], fib[1], fib[2] = 0, 1, 1\nfor i in range(3, MAX_FIB):\n    fib[i] = (fib[i - 1] + fib[i - 2]) % MOD\n\n# Read all inputs at once\ndata = intinput()\nn, m = data[0], data[1]\na = data[2:2 + m]\n\nif m == 0:\n    # If no restricted positions, the answer is simply fib[n + 1]\n    print(fib[n + 1])\nelse:\n    # Calculate segments between restricted positions\n    segments = [a[0]]  # First segment\n    for i in range(1, m):\n        segments.append(a[i] - a[i - 1] - 1)\n    segments.append(n - a[-1])  # Last segment\n\n    # Calculate the product of Fibonacci numbers for each segment\n    result = 1\n    for seg in segments:\n        result = (result * fib[seg]) % MOD\n\n    print(result)"}
{"problem_id":"p03013","slow_code_col":"import sys\n\n\n\nmod = 10 ** 9 + 7\n\nn, m, *a = [int(x) for x in sys.stdin.read().split()]\n\n\n\nsafe = sorted(set(range(1,n+1)) - set(a))\n\ndp = [0] * (n + 2)\n\ndp[0] = 0\n\ndp[1] = 1\n\nfor i in safe:\n\n    dp[i+1] = (dp[i] + dp[i-1]) % mod\n\n\n\nprint((dp[-1]))","reference_code_col":"\n\n# 2019-11-14 10:01:24(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\n# import itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# from scipy.misc import comb # float\n\n# import numpy as np \n\n\n\nmod = 10 ** 9 + 7\n\ndef main():\n\n    n, m, *a = [int(x) for x in sys.stdin.read().split()]\n\n\n\n    safe = sorted(set(range(1,n+1)) - set(a))\n\n    dp = [0] * (n + 2) # dp[i+1]: i\u6bb5\u76ee\u307e\u3067\u3044\u304f\u30d1\u30bf\u30fc\u30f3\u6570\n\n    dp[0] = 0  # -1\u6bb5\u76ee\u306b\u306f\u3044\u3051\u306a\u3044\n\n    dp[1] = 1  # \u521d\u671f\u6761\u4ef6(0\u6bb5\u76ee\u306b\u3044\u308b)\n\n    for i in safe:\n\n        dp[i+1] = (dp[i] + dp[i-1]) % mod\n\n\n\n    print((dp[-1]))\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\nmod = 10**9 + 7\n\n# Read input\nn, m, *a = map(int, sys.stdin.read().split())\n\n# Convert 'a' to a set for O(1) lookups\na_set = set(a)\n\n# Initialize DP array\ndp = [0] * (n + 2)\ndp[1] = 1\n\n# Iterate over all positions from 1 to n\nfor i in range(1, n + 1):\n    if i in a_set:\n        dp[i + 1] = 0  # Unsafe position, reset dp[i+1]\n    else:\n        dp[i + 1] = (dp[i] + dp[i - 1]) % mod\n\n# Output the result\nprint(dp[n + 1])"}
{"problem_id":"p02767","slow_code_col":"N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nanswer = 10 ** 9\n\nfor i in range(1,101):\n\n    tmp = 0\n\n    for a in A:\n\n        tmp += abs(a-i) ** 2\n\n    answer = min(answer,tmp)\n\nprint(answer)","reference_code_col":"N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nchushin = sum(A)\/\/N\n\nchushin_1 = sum(A)\/\/N +1\n\nanswer = 0\n\nanswer_1 = 0\n\nfor a in A:\n\n    answer += abs(a-chushin) ** 2\n\n    answer_1 += abs(a-chushin_1) ** 2\n\nprint((min(answer,answer_1)))","model_generated_potentially_faster_code_col":"N = int(eval(input()))\nA = list(map(int, input().split()))\n\n# Compute the mean of A to narrow down the search range\nmean_A = sum(A) \/ N\n\n# Define a small range around the mean to search for the optimal i\nsearch_range = range(max(1, int(mean_A) - 10), min(101, int(mean_A) + 11))\n\n# Initialize the answer with a large value\nanswer = float('inf')\n\n# Iterate only over the narrowed-down range\nfor i in search_range:\n    tmp = sum((a - i) ** 2 for a in A)\n    answer = min(answer, tmp)\n\nprint(answer)"}
{"problem_id":"p02691","slow_code_col":"# E - This Message Will Self-Distruct in 5s\n\n\n\nfrom collections import Counter\n\n\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\nassert len(a) == n\n\n\n\n# Ai + Aj == j - i\n\n# Aj - j == -Ai - i\n\n\n\n# Aj - j \u306e\u5404\u5024\u306e\u500b\u6570\n\ndiff = Counter(a[j] - (j+1) for j in range(n))\n\n\n\n# \u5404Ai\u306b\u3064\u3044\u3066 Aj - j == -Ai - i \u3068\u306a\u308bj\u306e\u500b\u6570\u3092\u6570\u3048\u308b\n\ncount = 0\n\nfor i in range(n):\n\n    diff[a[i] - (i+1)] -= 1  # i\u81ea\u8eab\u3092\u53d6\u308a\u9664\u304f\n\n    count += diff[-a[i] - (i+1)]\n\n\n\nprint(count)\n","reference_code_col":"# E - This Message Will Self-Distruct in 5s\n\n\n\nfrom collections import Counter\n\n\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\nassert len(a) == n\n\n\n\n# Aj - j \u306e\u5404\u5024\u306e\u500b\u6570\n\ndiff = Counter(a[j] - (j+1) for j in range(n))\n\n\n\n# Aj - j == -Ai - i \u3068\u306a\u308b(i,j)\u306e\u500b\u6570\n\ncount = sum(diff[-a[i] - (i+1)] for i in range(n))\n\nprint(count)\n","model_generated_potentially_faster_code_col":"n = int(input())\na = list(map(int, input().split()))\nassert len(a) == n\n\ncount = 0\nleft = {}  # Tracks occurrences of a[i] - (i + 1)\nright = {}  # Tracks occurrences of -a[i] - (i + 1)\n\nfor i in range(n):\n    diff = a[i] - (i + 1)\n    neg_diff = -a[i] - (i + 1)\n    \n    # Count pairs where Aj - j == -Ai - i (using previously stored values)\n    if neg_diff in left:\n        count += left[neg_diff]\n    \n    # Update the `left` dictionary with the current value\n    if diff in left:\n        left[diff] += 1\n    else:\n        left[diff] = 1\n\nprint(count)"}
{"problem_id":"p03253","slow_code_col":"import sys\n\ninput = sys.stdin.buffer.readline\n\nfrom collections import defaultdict\n\nimport copy\n\n\n\ndef main():\n\n    N,M = list(map(int,input().split()))\n\n    d = defaultdict(int)\n\n    MOD = 10**9+7\n\n    R = 10**5+100\n\n    fac = [0 for _ in range(R+1)]\n\n    fac[0],fac[1] = 1,1\n\n    inv = copy.deepcopy(fac)\n\n    invfac = copy.deepcopy(fac)\n\n    \n\n    for i in range(2,R+1):\n\n        fac[i] = (fac[i-1]*i)%MOD\n\n        inv[i] = MOD-(MOD\/\/i)*inv[MOD%i]%MOD\n\n        invfac[i] = (invfac[i-1]*inv[i])%MOD\n\n        \n\n    def coef(x,y):\n\n        num = (((fac[x+y]*invfac[y])%MOD)*invfac[x]%MOD)\n\n        return num\n\n\n\n    while M%2 == 0:\n\n        d[2] += 1\n\n        M \/\/= 2\n\n    f = 3\n\n    while f ** 2 <= M:\n\n        if M % f == 0:\n\n            d[f] += 1\n\n            M \/\/= f\n\n        else:\n\n            f += 2\n\n    if M != 1:\n\n        d[M] += 1\n\n    \n\n    l = list(d.values())\n\n    ans = 1\n\n    for num in l:\n\n        ans *= coef(num,N-1)\n\n        ans %= MOD\n\n        \n\n    print(ans)\n\n    \n\nif __name__ == \"__main__\":\n\n    main()","reference_code_col":"import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\ndef main():\n\n    N,M = list(map(int,input().split()))\n\n    MOD = 10**9+7\n\n    \n\n    def factorization(n):\n\n        arr = []\n\n        temp = n\n\n        for i in range(2, int(-(-n**0.5\/\/1))+1):\n\n            if temp%i==0:\n\n                cnt=0\n\n                while temp%i==0:\n\n                    cnt+=1\n\n                    temp \/\/= i\n\n                arr.append([i, cnt])\n\n\n\n        if temp!=1:\n\n            arr.append([temp, 1])\n\n\n\n        return arr\n\n        \n\n    cl = factorization(M)\n\n    \n\n    def combinations(x,y,N):\n\n        fac = [0]*(N+1)\n\n        fac[0],fac[1] = 1,1\n\n        \n\n        for i in range(2,N+1):\n\n            fac[i] = (fac[i-1]*i)%MOD\n\n            \n\n        return (fac[x+y]*pow(fac[x],MOD-2,MOD)*pow(fac[y],MOD-2,MOD))%MOD\n\n        \n\n    ans = 1\n\n    for pr,num in cl:\n\n        ans *= combinations(N-1,num,N+num)\n\n        ans %= MOD\n\n    \n\n    print(ans)\n\n    \n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\nfrom math import isqrt\n\nMOD = 10**9 + 7\nR = 10**5 + 100\n\ndef main():\n    # Fast input\n    N, M = map(int, sys.stdin.buffer.readline().split())\n    \n    # Precompute factorials, modular inverses, and inverse factorials\n    fac = [1] * (R + 1)\n    inv = [1] * (R + 1)\n    invfac = [1] * (R + 1)\n    \n    for i in range(2, R + 1):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = MOD - (MOD \/\/ i) * inv[MOD % i] % MOD\n        invfac[i] = invfac[i - 1] * inv[i] % MOD\n    \n    # Function to compute binomial coefficient C(x + y, y)\n    def coef(x, y):\n        return fac[x + y] * invfac[y] % MOD * invfac[x] % MOD\n    \n    # Prime factorization of M\n    d = {}\n    while M % 2 == 0:\n        d[2] = d.get(2, 0) + 1\n        M \/\/= 2\n    \n    f = 3\n    while f * f <= M:\n        while M % f == 0:\n            d[f] = d.get(f, 0) + 1\n            M \/\/= f\n        f += 2\n    \n    if M > 1:\n        d[M] = d.get(M, 0) + 1\n    \n    # Compute the result\n    ans = 1\n    for num in d.values():\n        ans = ans * coef(num, N - 1) % MOD\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03000","slow_code_col":"import bisect\n\n\n\nN, X = list(map(int, input().split()))\n\nl = list(map(int, input().split()))\n\nd = [-1]*(N+1) #0-index #\u30d0\u30a6\u30f3\u30c9\u3059\u308b\u4f4d\u7f6e\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n\nd[0] = 0 #\u30d0\u30a6\u30f3\u30c9\u3059\u308b\u521d\u671f\u5024\u306f0\n\n\n\nfor i in range(1, N+1):\n\n    d[i] = d[i-1] + l[i-1]\n\n\n\n#print(d)\n\n#print('left:', bisect.bisect_left(d, X))\n\n#print('right:', bisect.bisect_right(d, X))\n\nprint((bisect.bisect_right(d, X)))","reference_code_col":"import bisect\n\n\n\nn,x = list(map(int, input().split()))\n\nl = tuple(map(int, input().split()))\n\n\n\nd = [-1]*(n+1)\n\nd[0] = 0\n\nfor i in range(1, n+1):\n\n    d[i] = d[i-1] + l[i-1]\n\nres = bisect.bisect_right(sorted(d), x)\n\nprint(res)","model_generated_potentially_faster_code_col":"import sys\n\n# Fast input reading\ndef fast_input():\n    return sys.stdin.read().split()\n\n# Read inputs\ndata = fast_input()\nN, X = int(data[0]), int(data[1])\nl = list(map(int, data[2:2+N]))\n\n# Custom binary search with dynamic cumulative sum\ndef find_position(N, l, X):\n    low, high = 0, N\n    cumulative_sum = 0  # Start with the initial cumulative sum\n    result = N + 1  # Default result if X is greater than all cumulative sums\n\n    while low <= high:\n        mid = (low + high) \/\/ 2\n        # Calculate cumulative sum up to mid on-the-fly\n        if mid > 0:\n            cumulative_sum += sum(l[:mid]) if mid == 1 else l[mid-1]\n        \n        if cumulative_sum > X:\n            result = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n\n    return result\n\n# Output the result\nprint(find_position(N, l, X))"}
{"problem_id":"p00145","slow_code_col":"from functools import reduce\ndef f(a,b): return [Card[a][0], Card[b][1]]\n\nn = int(input())\n\nCard = [[] for _ in [0]*n]\n\nCost = {}\n\nfor i in range(n):\n\n  Card[i] = list(map(int, input().split()))\n\n  Cost[(i, i)] = 0\n\nfor i in range(1, n):\n\n  for j in range(0, n-i):\n\n    a = j+i\n\n    Cost[(j, a)] = min([reduce(lambda a,b: a*b, f(j, k) + f(k+1, a)) + Cost[(j, k)] + Cost[(k+1, a)] for k in range(j, j+i)])\n\nprint(Cost[0, n-1])","reference_code_col":"from functools import reduce\nn = int(input())\n\nCard = [[] for _ in [0]*n]\n\nCost = {}\n\nfor i in range(n):\n\n  Card[i] = list(map(int, input().split()))\n\n  Cost[(i, i)] = 0\n\nfor i in range(1, n):\n\n  for j in range(0, n-i):\n\n    a = j+i\n\n    Cost[(j, a)] = min([reduce(lambda a,b: a*b, [Card[j][0],Card[k][1],Card[k+1][0],Card[a][1]]) + Cost[(j, k)] + Cost[(k+1, a)] for k in range(j, j+i)])\n\nprint(Cost[0, n-1])","model_generated_potentially_faster_code_col":"def main():\n    n = int(input())\n    \n    # Read the input cards into a list of lists\n    Card = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Initialize the cost matrix using a 2D list\n    Cost = [[0] * n for _ in range(n)]\n    \n    # Fill the cost matrix using dynamic programming\n    for length in range(2, n + 1):  # length of the subchain\n        for i in range(n - length + 1):\n            j = i + length - 1\n            # Initialize the cost for this subchain to a large value\n            Cost[i][j] = float('inf')\n            \n            # Try all possible splits between i and j\n            for k in range(i, j):\n                # Compute the cost of splitting at k\n                cost = (\n                    Cost[i][k] \n                    + Cost[k + 1][j] \n                    + Card[i][0] * Card[k][1] * Card[j][1]\n                )\n                # Update the minimum cost\n                if cost < Cost[i][j]:\n                    Cost[i][j] = cost\n    \n    # The result is the minimum cost for the entire chain\n    print(Cost[0][n - 1])\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03039","slow_code_col":"def cmb(n, r, mod):\n\n    if ( r<0 or r>n ):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\nA=2*10**5\n\nmod = 10**9+7\n\ng1 = [1, 1]\n\ng2 = [1, 1]\n\ninverse = [0, 1]\n\n\n\nfor i in range( 2, A + 1 ):\n\n    g1.append( ( g1[-1] * i ) % mod )\n\n    inverse.append( ( -inverse[mod % i] * (mod\/\/i) ) % mod )\n\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\n\nN,M,K=list(map(int,input().split()))\n\nkeisuu=cmb(N*M-2,K-2,mod)\n\n\n\nsum_=0\n\nfor i in range(N):\n\n    a=min(abs(i),abs(N-i-1))\n\n    b=max(abs(i),abs(N-i-1))\n\n    sum_+=(M**2)*((a*(a+1)\/\/2)+(b*(b+1)\/\/2))\n\nfor i in range(M):\n\n    a=min(abs(i),abs(M-i-1))\n\n    b=max(abs(i),abs(M-i-1))\n\n    sum_+=(N**2)*((a*(a+1)\/\/2)+(b*(b+1)\/\/2))\n\nprint(((keisuu * (sum_\/\/2))%mod))","reference_code_col":"def power_mod(a,b,mod=10**9+7):\n\n    i,temp,box=0,b,[]\n\n    while(2**i<=b):\n\n        i+=1\n\n    for j in range(i-1,-1,-1):\n\n        box=[[j,temp\/\/2**j]]+box\n\n        temp-=2**j*(temp\/\/2**j)\n\n    box[0].append(a)\n\n    ans=box[0][1]*a%mod\n\n    for j in range(1,i):\n\n        box[j].append(box[j-1][2]**2%mod)\n\n        if box[j][1]==1:\n\n            ans=(ans*box[j][2])%mod\n\n    return ans\n\ndef n_func(n,mod=10**9+7):\n\n    ans=1\n\n    for i in range(1,n+1):\n\n        ans=(ans*i)%mod\n\n    return ans\n\ndef nPr(n,r,mod=10**9+7):\n\n    ans=n_func(n-r,mod)\n\n    ans=power_mod(ans,mod-2,mod)\n\n    return ans*n_func(n,mod)%mod\n\ndef nCr(n,r,mod=10**9+7):\n\n    ans=n_func(n-r,mod)*n_func(r,mod)%mod\n\n    ans=power_mod(ans,mod-2,mod)\n\n    return ans*n_func(n,mod)%mod\n\n\n\nN,M,K=list(map(int,input().split()))\n\nkeisuu=nCr(N*M-2,K-2)\n\nmod=10**9+7\n\n\n\nsum_=0\n\nfor i in range(N):\n\n    a=min(abs(i),abs(N-i-1))\n\n    b=max(abs(i),abs(N-i-1))\n\n    sum_+=(M**2)*((a*(a+1)\/\/2)+(b*(b+1)\/\/2))\n\nfor i in range(M):\n\n    a=min(abs(i),abs(M-i-1))\n\n    b=max(abs(i),abs(M-i-1))\n\n    sum_+=(N**2)*((a*(a+1)\/\/2)+(b*(b+1)\/\/2))\n\nprint(((keisuu * (sum_\/\/2))%mod))","model_generated_potentially_faster_code_col":"def cmb(n, r, mod):\n    if r < 0 or r > n:\n        return 0\n    r = min(r, n - r)\n    return (g1[n] * g2[r] * g2[n - r]) % mod\n\n# Constants\nA = 2 * 10**5\nmod = 10**9 + 7\n\n# Precompute factorials and modular inverses\ng1 = [1] * (A + 1)  # Factorials\ng2 = [1] * (A + 1)  # Inverse factorials\ninverse = [0] * (A + 1)\n\nfor i in range(2, A + 1):\n    g1[i] = (g1[i - 1] * i) % mod\n    inverse[i] = (-inverse[mod % i] * (mod \/\/ i)) % mod\n    g2[i] = (g2[i - 1] * inverse[i]) % mod\n\n# Input\nN, M, K = map(int, input().split())\n\n# Precompute constants\nkeisuu = cmb(N * M - 2, K - 2, mod)\nM_squared = M**2 % mod\nN_squared = N**2 % mod\nmod_inv_2 = pow(2, mod - 2, mod)  # Modular inverse of 2 under mod\n\n# Compute sum_\nsum_ = 0\nfor i in range(N):\n    a = min(i, N - i - 1)\n    b = max(i, N - i - 1)\n    sum_ += M_squared * ((a * (a + 1) \/\/ 2) + (b * (b + 1) \/\/ 2))\n    sum_ %= mod\n\nfor i in range(M):\n    a = min(i, M - i - 1)\n    b = max(i, M - i - 1)\n    sum_ += N_squared * ((a * (a + 1) \/\/ 2) + (b * (b + 1) \/\/ 2))\n    sum_ %= mod\n\n# Final result\nresult = (keisuu * sum_ * mod_inv_2) % mod\nprint(result)"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\nn=int(eval(input()))\n\na=np.array(list(map(int,input().split())))\n\nb=0\n\nwhile np.all(a%2==0):\n\n\ta=a\/2\n\n\tb+=1\n\n\t\n\nprint(b)","reference_code_col":"a = int(eval(input(\"\")))\n\nb = input(\"\").split(\" \")\n\nc = 0\n\nd = []\n\n\n\nfor i in range(a):\n\n\tc = 0\n\n\twhile (int(b[i]) % 2 == 0):\n\n\t\tb[i] = int(b[i]) \/ 2\n\n\t\tc += 1\n\n\td.append(c)\n\nprint((min(d)))","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\ndef count_trailing_zeros(x):\n    \"\"\"Count the number of trailing zeros in the binary representation of x.\"\"\"\n    return (x & -x).bit_length() - 1\n\ndef main():\n    # Read input efficiently\n    n = int(sys.stdin.readline())\n    a = np.fromstring(sys.stdin.readline(), dtype=int, sep=' ')\n    \n    # Find the minimum number of trailing zeros across all elements\n    min_trailing_zeros = min(count_trailing_zeros(x) for x in a)\n    \n    print(min_trailing_zeros)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02959","slow_code_col":"\n\nimport numpy as np\n\nN = int(eval(input()))\n\n\n\nA_ls = np.array(list(map(int,input().split(\" \"))))\n\nB_ls = np.array(list(map(int,input().split(\" \"))))\n\n\n\nS = 0\n\n\n\nfor i,b in enumerate(B_ls):\n\n    if b > A_ls[i]:\n\n        b -= A_ls[i]\n\n        S += A_ls[i]\n\n        if A_ls[i+1] >= b:\n\n            A_ls[i+1] -=b\n\n            S+=b\n\n        else:\n\n            S+=A_ls[i+1]\n\n            A_ls[i+1] = 0 \n\n    else:\n\n        S += b\n\n\n\nprint(S)\n","reference_code_col":"\n\nN = int(eval(input()))\n\n\n\nA_ls = list(map(int,input().split(\" \")))\n\nB_ls = list(map(int,input().split(\" \")))\n\n\n\nS = 0\n\n\n\nfor i,b in enumerate(B_ls):\n\n    if b > A_ls[i]:\n\n        b -= A_ls[i]\n\n        S += A_ls[i]\n\n        if A_ls[i+1] >= b:\n\n            A_ls[i+1] -=b\n\n            S+=b\n\n        else:\n\n            S+=A_ls[i+1]\n\n            A_ls[i+1] = 0 \n\n    else:\n\n        S += b\n\n\n\nprint(S)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input reading\nN = int(input())\nA_ls = np.fromstring(input(), dtype=int, sep=' ')\nB_ls = np.fromstring(input(), dtype=int, sep=' ')\n\nS = 0\n\nfor i in range(N):\n    if B_ls[i] > A_ls[i]:\n        # Subtract A_ls[i] from B_ls[i]\n        remaining_b = B_ls[i] - A_ls[i]\n        S += A_ls[i]\n\n        # Handle the next element (A_ls[i+1])\n        if i + 1 < N:\n            if A_ls[i + 1] >= remaining_b:\n                A_ls[i + 1] -= remaining_b\n                S += remaining_b\n            else:\n                S += A_ls[i + 1]\n                A_ls[i + 1] = 0\n    else:\n        S += B_ls[i]\n\nprint(S)"}
{"problem_id":"p02725","slow_code_col":"k,n = list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na.append(a[0]+k)\n\nlongd=0\n\nfor i in range(n):\n\n    tmp=abs(a[i+1]-a[i])\n\n    longd=max(longd,tmp)\n\nprint((k-longd))","reference_code_col":"k,n=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na.append(a[0]+k)\n\n\n\nx=0\n\nfor i in range(len(a)-1):\n\n    dis=abs(a[i+1]-a[i])\n\n    x=max(x,dis)\n\n\n\nprint((k-x))","model_generated_potentially_faster_code_col":"# Read inputs\nk, n = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize variables for maximum difference and previous element\nlongd = 0\nprev = a[0]\n\n# Iterate through the list to find the maximum difference\nfor i in range(1, n):\n    tmp = a[i] - prev  # Compute difference (no abs() yet)\n    longd = max(longd, tmp if tmp >= 0 else -tmp)  # Update max difference\n    prev = a[i]  # Update previous element\n\n# Handle the circular boundary condition\ntmp = (a[0] + k) - prev  # Difference between last and first element (circular)\nlongd = max(longd, tmp if tmp >= 0 else -tmp)\n\n# Output the result\nprint(k - longd)"}
{"problem_id":"p02886","slow_code_col":"def ii():return int(eval(input()))\n\ndef iim():return list(map(int,input().split()))\n\ndef iil():return list(map(int,input().split()))\n\ndef ism():return list(map(str,input().split()))\n\ndef isl():return list(map(str,input().split()))\n\n\n\nn = ii()\n\nD = iil()\n\nans = 0\n\nfor i in range(n):\n\n    for j in range(i+1,n):\n\n#        print(i,j)\n\n        ans += D[i]*D[j] \n\nprint(ans)","reference_code_col":"def ii():return int(eval(input()))\n\ndef iim():return list(map(int,input().split()))\n\ndef iil():return list(map(int,input().split()))\n\ndef ism():return list(map(str,input().split()))\n\ndef isl():return list(map(str,input().split()))\n\n\n\nn = ii()\n\nD = iil()\n\nsumD = sum(D)\n\nans = 0\n\nfor i in range(n):\n\n    ans += D[i]*(sum(D)-D[i])\n\nprint((ans\/\/2))","model_generated_potentially_faster_code_col":"def ii():\n    return int(input())\n\ndef iil():\n    return list(map(int, input().split()))\n\n# Read input\nn = ii()\nD = iil()\n\n# Compute the sum and sum of squares\ntotal_sum = sum(D)\nsum_of_squares = sum(x * x for x in D)\n\n# Calculate the result using the formula\nans = (total_sum * total_sum - sum_of_squares) \/\/ 2\n\nprint(ans)"}
{"problem_id":"p02702","slow_code_col":"s = input()[::-1]\n\nl = len(s)\n\nc = [0] * 2019\n\nc[0] = 1\n\nten = 1\n\nmod = 0\n\nans = 0\n\n\n\nfor i in range(l):\n\n    mod = (mod + int(s[i]) * ten) % 2019\n\n    ten = ten * 10 % 2019\n\n    c[mod] += 1\n\n\n\nfor i in c:\n\n    ans += i * (i - 1) \/\/ 2\n\n\n\nprint(ans)","reference_code_col":"s = input()[::-1]\n\nc = [0] * 2019\n\nc[0] = 1\n\nmod = 0\n\nten = 1\n\nans = 0\n\n\n\nfor i in s:\n\n    mod = (mod + int(i) * ten) % 2019\n\n    ten = ten * 10 % 2019\n\n    c[mod] += 1\n\n\n\nfor i in c:\n\n    ans += i * (i - 1) \/\/ 2\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Input and reverse the string\ns = input()[::-1]\n\n# Precompute integer values for all characters in s\nint_s = [int(ch) for ch in s]\n\n# Initialize variables\nl = len(s)\nc = [0] * 2019\nc[0] = 1\nten = 1\nmod = 0\nans = 0\n\n# First loop: Compute modular values\nfor i in range(l):\n    mod = (mod + int_s[i] * ten) % 2019\n    ten = ten * 10 % 2019\n    c[mod] += 1\n\n# Second loop: Compute the final answer\nfor count in c:\n    ans += count * (count - 1) \/\/ 2\n\n# Output the result\nprint(ans)"}
{"problem_id":"p02994","slow_code_col":"import numpy as np\n\n\n\nn,l=list(map(int,input().split()))\n\nli=[]\n\nfor i in range(n):\n\n  li.append(l+i)\n\ns=sum(li)\n\np=np.array(li)\n\na=np.abs(p).tolist()\n\nk=min(a)\n\nb=a.index(k)\n\nprint((s-li[b]))","reference_code_col":"n,l=list(map(int,input().split()))\n\na=0\n\nfor i in range(n):\n\n  a+=i+l\n\nif l>=0:\n\n  print((a-l))\n\nelif l+n-1<0:\n\n  print((a-(l+n-1)))\n\nelse:\n\n  print(a)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn, l = map(int, input().split())\n\n# Create the array directly using NumPy\narr = np.arange(l, l + n)\n\n# Calculate the sum of the array\ntotal_sum = arr.sum()\n\n# Find the index of the element with the smallest absolute value\nmin_index = np.abs(arr).argmin()\n\n# Exclude the element at min_index from the sum\nresult = total_sum - arr[min_index]\n\n# Print the result\nprint(result)"}
{"problem_id":"p02780","slow_code_col":"import numpy as np\n\nN, K = list(map(int, input().split()))\n\nplist = list(map(int, input().split()))\n\nkitaiti = np.array([(0.5*(p+1)) for p in plist])\n\nans = 0\n\nval = sum(kitaiti[:K])\n\nans = max(ans, val)\n\nfor i in range(1, N-K+1):\n\n    # print(i-1, i+K)\n\n    val -= kitaiti[i-1]\n\n    val += kitaiti[i+K-1]\n\n    ans = max(ans, val)\n\nprint(ans)","reference_code_col":"N, K = list(map(int, input().split()))\n\nplist = [((num*(num+1))\/\/2)\/num for num in list(map(int, input().split()))]\n\n# print(plist)\n\nans = 0\n\nfor i in range(K):\n\n    ans += plist[i]\n\n_ = ans\n\nfor i in range(N-K):\n\n    temp = _\n\n    temp -= plist[i]\n\n    temp += plist[i+K]\n\n    # print(i, i+K, ans, temp)\n\n    ans = max(ans, temp)\n\n    _ = temp\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\nimport sys\n\n# Faster input reading\ninput = sys.stdin.read\ndata = input().split()\n\nN, K = map(int, data[:2])\nplist = list(map(int, data[2:]))\n\n# Convert plist to NumPy array and compute kitaiti using vectorized operations\nkitaiti = 0.5 * (np.array(plist) + 1)\n\n# Compute the initial sum of the first K elements\nval = np.sum(kitaiti[:K])\nans = val\n\n# Sliding window to compute the maximum sum\nfor i in range(1, N - K + 1):\n    val += kitaiti[i + K - 1] - kitaiti[i - 1]\n    ans = max(ans, val)\n\nprint(ans)"}
{"problem_id":"p03000","slow_code_col":"#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nimport numpy as np\n\njump = list(np.cumsum(L))\n\nfor j in jump:\n\n    if j <= X:\n\n        cnt+=1\n\nprint((cnt+1))","reference_code_col":"#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nimport numpy as np\n\njump = list(np.cumsum(L))\n\nfor j in jump:\n\n    if j <= X:\n\n        cnt+=1\n\n    else:\n\n        break\n\nprint((cnt+1))","model_generated_potentially_faster_code_col":"# Input reading\nN, X = map(int, input().split())\nL = list(map(int, input().split()))\n\n# Initialize variables\ncnt = 1  # Start with 1 because the initial position is always within range\ncurrent_position = 0\n\n# Iterate through the list and calculate cumulative sum on the fly\nfor jump_distance in L:\n    current_position += jump_distance\n    if current_position <= X:\n        cnt += 1\n    else:\n        break  # No need to continue if the position exceeds X\n\n# Output the result\nprint(cnt)"}
{"problem_id":"p03371","slow_code_col":"#!usr\/bin\/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LS()\n\n    return l\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    return\n\n\n\n#B\n\ndef B():\n\n    return\n\n\n\n#C\n\ndef C():\n\n    return\n\n\n\n#D\n\ndef D():\n\n    return\n\n\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    a,b,c,X,Y = LI()\n\n    ans = float(\"inf\")\n\n    for z in range(300001):\n\n        if z%2 == 0:\n\n            m = c*z\n\n            x = z\/\/2\n\n            y = z\/\/2\n\n            m += a*max(0,X-x)\n\n            m += b*max(0,Y-y)\n\n            if m < ans:\n\n                ans = m\n\n    print(ans)\n\n    return\n\n\n\n#G\n\ndef G():\n\n    n = I()\n\n    x = LI()\n\n    f = [(i,x[i]) for i in range(n)]\n\n    f.sort(key = lambda x:x[1])\n\n    g = [(f[i][0],i) for i in range(n)]\n\n    g.sort(key = lambda x:x[0])\n\n    for i in range(n):\n\n        if g[i][1] < n\/\/2:\n\n            print((f[n\/\/2][1]))\n\n        else:\n\n            print((f[n\/\/2-1][1]))\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#I\n\ndef I_():\n\n    return\n\n\n\n#J\n\ndef J():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    F()\n","reference_code_col":"#!usr\/bin\/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    A,B,C,x,y = LI()\n\n    ans = float(\"inf\")\n\n    for c in range(200001)[::2]:\n\n        a = b = c >> 1\n\n        a = max(0,x-a)\n\n        b = max(0,y-b)\n\n        s = A*a+B*b+C*c\n\n        if s < ans:\n\n            ans = s\n\n    print(ans)\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n","model_generated_potentially_faster_code_col":"def F():\n    a, b, c, X, Y = LI()\n    \n    # Initialize the minimum cost to infinity\n    ans = float(\"inf\")\n    \n    # Determine the range of valid z values\n    min_z = 0\n    max_z = 2 * max(X, Y)\n    \n    # Iterate over the valid range of z\n    for z in range(min_z, max_z + 1, 2):  # Increment by 2 since z must be even\n        # Calculate the cost for the current z\n        x_needed = max(0, X - z \/\/ 2)\n        y_needed = max(0, Y - z \/\/ 2)\n        cost = c * z + a * x_needed + b * y_needed\n        \n        # Update the minimum cost\n        ans = min(ans, cost)\n    \n    # Print the result\n    print(ans)"}
{"problem_id":"p02612","slow_code_col":"n = int(eval(input())) % 1000\n\nif n == 0:\n\n    print((0))\n\nelse:\n\n    print((1000 - n))","reference_code_col":"n = int(eval(input()))\n\nprint(((1000 - n % 1000) % 1000))","model_generated_potentially_faster_code_col":"n = int(input()) % 1000\nprint(0 if n == 0 else 1000 - n)"}
{"problem_id":"p02599","slow_code_col":"import sys\n\n\n\n\n\nclass BinaryIndexedTree():\n\n    '''\n\n    1-indexed\n\n    '''\n\n    def __init__(self, A):\n\n        self.__n = len(A)\n\n        self.__node = [0] * (self.__n + 1)\n\n        self.__data = [0] * (self.__n + 1)\n\n\n\n        S = [0] * (self.__n + 1)\n\n        for i in range(1, self.__n + 1):\n\n            S[i] = S[i - 1] + A[i - 1]\n\n            self.__data[i] = A[i - 1]\n\n            self.__node[i] = S[i] - S[i - (i & -i)]\n\n\n\n    def add(self, i, v):\n\n        self.__data[i] += v\n\n        while i <= self.__n:\n\n            self.__node[i] += v\n\n            i += i & -i\n\n\n\n    def sum(self, i):\n\n        ''' [1, i]\u306e\u548c\n\n        '''\n\n        rst = 0\n\n        while i > 0:\n\n            rst += self.__node[i]\n\n            i -= i & -i\n\n        return rst\n\n    \n\n    def get(self, i, j):\n\n        '''[i, j]\u306e\u548c\n\n        '''\n\n        if i == j:\n\n            return self.__data[i]\n\n        else:\n\n            return self.sum(j) - self.sum(i - 1)\n\n\n\n\n\ndef main():\n\n    N, Q = map(int, input().split())\n\n    C = list(map(int, input().split()))\n\n\n\n    P = [[] for _ in range(N)]\n\n    for i, c in enumerate(C):\n\n        P[c - 1].append(i)\n\n\n\n    right = [0] * N\n\n    for p in P:\n\n        if len(p):\n\n            right[p.pop()] = 1\n\n    BIT = BinaryIndexedTree(right)\n\n\n\n    query = [[] for _ in range(N)]\n\n    for i, s in enumerate(sys.stdin.readlines()):\n\n        l, r = map(int, s.split())\n\n        query[r - 1].append((l - 1, i))\n\n\n\n    ans = [None] * Q\n\n\n\n    cur = N - 1\n\n    for r, q in enumerate(reversed(query)):\n\n        r = (N - 1) - r\n\n        while q:\n\n            l, i = q.pop()\n\n            while r < cur:\n\n                c = C[cur] - 1\n\n                p = P[c]\n\n                if len(p):\n\n                    BIT.add(p.pop() + 1, 1)\n\n                cur -= 1\n\n            tmp = BIT.get(l + 1, r + 1)\n\n            ans[i] = tmp\n\n\n\n    print(*ans, sep='\\n')\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"import sys\n\n\n\n\n\nclass BinaryIndexedTree():\n\n    '''\n\n    1-indexed\n\n    '''\n\n    def __init__(self, A):\n\n        self.__n = len(A)\n\n        self.__node = [0] * (self.__n + 1)\n\n        self.__data = [0] * (self.__n + 1)\n\n\n\n        S = [0] * (self.__n + 1)\n\n        for i in range(self.__n):\n\n            S[i + 1] = S[i] + A[i]\n\n\n\n        for i in range(1, self.__n + 1):\n\n            self.__data[i] = A[i - 1]\n\n            self.__node[i] = S[i] - S[i - (i & -i)]\n\n\n\n    def add(self, i, v):\n\n        self.__data[i] += v\n\n        while i <= self.__n:\n\n            self.__node[i] += v\n\n            i += i & -i\n\n\n\n    def sum(self, i):\n\n        ''' [1, i]\u306e\u548c\n\n        '''\n\n        rst = 0\n\n        while i > 0:\n\n            rst += self.__node[i]\n\n            i -= i & -i\n\n        return rst\n\n    \n\n    def get(self, i, j):\n\n        '''[i, j]\u306e\u548c\n\n        '''\n\n        if i == j:\n\n            return self.__data[i]\n\n        else:\n\n            return self.sum(j) - self.sum(i - 1)\n\n\n\n\n\ndef main():\n\n    N, Q = map(int, input().split())\n\n    C = list(map(int, input().split()))\n\n\n\n    P = [[] for _ in range(N)]\n\n    for i, c in enumerate(C):\n\n        P[c - 1].append(i)\n\n\n\n    right = [0] * N\n\n    for p in P:\n\n        if len(p):\n\n            right[p.pop()] = 1\n\n    BIT = BinaryIndexedTree(right)\n\n\n\n    query = [[] for _ in range(N)]\n\n    for i, s in enumerate(sys.stdin.readlines()):\n\n        l, r = map(int, s.split())\n\n        query[r - 1].append((l - 1, i))\n\n\n\n    ans = [None] * Q\n\n\n\n    cur = N - 1\n\n    for r, q in enumerate(reversed(query)):\n\n        r = (N - 1) - r\n\n        while q:\n\n            l, i = q.pop()\n\n            while r < cur:\n\n                c = C[cur] - 1\n\n                p = P[c]\n\n                if len(p):\n\n                    BIT.add(p.pop() + 1, 1)\n\n                cur -= 1\n\n            tmp = BIT.get(l + 1, r + 1)\n\n            ans[i] = tmp\n\n\n\n    print(*ans, sep='\\n')\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\ndef read_input():\n    N, Q = map(int, sys.stdin.readline().split())\n    C = list(map(int, sys.stdin.readline().split()))\n    return N, Q, C"}
{"problem_id":"p02983","slow_code_col":"L ,R = list(map(int,input().split()))\n\n\n\nans =[]\n\nif R - L <= 2019:\n\n    for i in range(L,R+1):\n\n        for j in range(i+1,R+1):\n\n            ans.append(i*j%2019)\n\n\n\nelse:\n\n    for i in range(R-L-1010,R-L+1010):\n\n        for j in range(i,R-L+1010):\n\n            ans.append(i*j%2019)\n\n\n\nprint((min(ans)))\n","reference_code_col":"L ,R = list(map(int,input().split()))\n\n\n\nans =[]\n\nfor i in range(L,R+1):\n\n    for j in range(i+1,R+1):\n\n        ans.append(i*j%2019)\n\n        if (i * j % 2019) == 0:\n\n            break\n\n    else:\n\n        continue\n\n    break\n\n\n\nprint((min(ans)))","model_generated_potentially_faster_code_col":"L, R = map(int, input().split())\n\n# Reduce the range to unique residues modulo 2019\nunique_residues = set(range(L % 2019, R % 2019 + 1)) if L \/\/ 2019 == R \/\/ 2019 else set(range(2019))\n\nmin_value = float('inf')\n\n# Iterate over unique residues\nfor i in unique_residues:\n    for j in unique_residues:\n        if i < j:  # Ensure i < j to avoid duplicate pairs\n            product_mod = (i * j) % 2019\n            min_value = min(min_value, product_mod)\n            if min_value == 0:  # Early exit if minimum value is 0\n                print(0)\n                exit()\n\nprint(min_value)"}
{"problem_id":"p02773","slow_code_col":"from collections import Counter\n\nimport heapq\n\n\n\nn = int(eval(input()))\n\nss = []\n\nfor _ in range(n):\n\n    ss.append(input().rstrip())\n\nctr = Counter(ss)\n\nheap = [(-v, k) for k, v in list(ctr.items())]\n\nheapq.heapify(heap)\n\nmaxv = heap[0][0]\n\nwhile heap:\n\n    c = heapq.heappop(heap)\n\n    if c[0] != maxv:\n\n        break\n\n    print((c[1]))\n","reference_code_col":"from collections import Counter\n\n\n\nn = int(eval(input()))\n\nss = []\n\nfor _ in range(n):\n\n    ss.append(input().rstrip())\n\nctr = Counter(ss)\n\n\n\na = sorted([(-v, k) for k, v in list(ctr.items())])\n\nmaxv = a[0][0]\n\nfor i in range(len(a)):\n\n    if a[i][0] != maxv:\n\n        break\n\n    print((a[i][1]))","model_generated_potentially_faster_code_col":"from collections import Counter\nimport heapq\n\n# Read input efficiently\nimport sys\nlines = sys.stdin.read().splitlines()\n\n# Parse the first line as 'n'\nn = int(lines[0])\n\n# Count occurrences of each string\nctr = Counter(lines[1:])\n\n# Find the most frequent strings using heapq.nlargest\nmax_freq = max(ctr.values())\nmost_frequent = [k for k, v in ctr.items() if v == max_freq]\n\n# Print the most frequent strings\nfor s in most_frequent:\n    print(s)"}
{"problem_id":"p02685","slow_code_col":"import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nfac = [1, 1]     # \u5143\u30c6\u30fc\u30d6\u30eb\n\nf_inv = [1, 1]   # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\ninv = [0, 1]     # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n        inv.append((-inv[mod % i] * (mod\/\/i)) % mod)\n\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * f_inv[r] * f_inv[n-r] % mod\n\n\n\n\n\ndef main():\n\n    N,M,K = list(map(int, readline().split()))\n\n\n\n    MOD = 998244353\n\n    prepare(N + 10, MOD)\n\n\n\n    if M == 1 and K == N - 1:\n\n        print((1))\n\n        exit()\n\n\n\n    m = M\n\n    for _ in range(N-1):\n\n        m *= M - 1\n\n        m %= MOD\n\n\n\n    ans = 0\n\n    for k in range(K+1):\n\n        ans += (m * cmb(N-1, k, MOD)) % MOD\n\n        ans %= MOD\n\n\n\n        m *= pow(M-1, MOD-2, MOD)\n\n        m %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\n# 0^0 = 1\n\n\n\ndef main():\n\n    N,M,K = list(map(int, readline().split()))\n\n\n\n    MOD = 998244353\n\n\n\n    if M == 1:\n\n        if K == N - 1:\n\n            print((1))\n\n        else:\n\n            print((0))\n\n        exit()\n\n\n\n    m = pow(M-1, N-1, MOD)\n\n    m_1_inv = pow(M-1, MOD-2, MOD)\n\n    comb = 1\n\n    ans = comb * m\n\n    for k in range(1,K+1):\n\n        m *= m_1_inv\n\n        m %= MOD\n\n        comb *= N - k\n\n        comb %= MOD\n\n        comb *= pow(k, MOD-2, MOD)\n\n        \n\n        ans += (m * comb) % MOD\n\n        ans %= MOD\n\n\n\n    print((ans * M % MOD))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\n# Precompute factorial, inverse factorial, and modular inverses\nfac = [1, 1]     # Factorial table\nf_inv = [1, 1]   # Inverse factorial table\ninv = [0, 1]     # Modular inverse table\n\n\ndef prepare(n, mod):\n    \"\"\"Precompute factorial, inverse factorial, and modular inverses up to n.\"\"\"\n    for i in range(2, n + 1):\n        fac.append((fac[-1] * i) % mod)\n        inv.append((-inv[mod % i] * (mod \/\/ i)) % mod)\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\n\n\ndef cmb(n, r, mod):\n    \"\"\"Calculate combination C(n, r) modulo mod using precomputed tables.\"\"\"\n    if n < 0 or r < 0 or r > n:\n        return 0\n    return fac[n] * f_inv[r] % mod * f_inv[n - r] % mod\n\n\ndef main():\n    # Read input\n    N, M, K = map(int, readline().split())\n    MOD = 998244353\n\n    # Edge case: If M == 1 and K == N - 1, the result is always 1\n    if M == 1 and K == N - 1:\n        print(1)\n        return\n\n    # Precompute factorial and inverse factorial tables\n    prepare(N + 10, MOD)\n\n    # Compute m = M * (M-1)^(N-1) % MOD\n    m = M\n    for _ in range(N - 1):\n        m = m * (M - 1) % MOD\n\n    # Precompute the modular inverse of (M-1)\n    inv_M_minus_1 = pow(M - 1, MOD - 2, MOD)\n\n    # Calculate the answer\n    ans = 0\n    for k in range(K + 1):\n        ans = (ans + m * cmb(N - 1, k, MOD)) % MOD\n        m = m * inv_M_minus_1 % MOD  # Update m efficiently\n\n    # Output the result\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02748","slow_code_col":"# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\nfrom collections import Counter\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x \/\/ y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\ndef fft(A, B):\n\n    \"\"\" \n\n    \u9ad8\u901f\u30d5\u30fc\u30ea\u30a8\u5909\u63db(FFT)\n\n        A\uff1a\u51fa\u73fe\u56de\u6570\u3092\u30ab\u30a6\u30f3\u30c8\u3057\u305f\u30ea\u30b9\u30c8\n\n        B\uff1a\u51fa\u73fe\u56de\u6570\u3092\u30ab\u30a6\u30f3\u30c8\u3057\u305f\u30ea\u30b9\u30c8\n\n    \"\"\"\n\n    import numpy as np\n\n    from numpy.fft import rfft, irfft\n\n\n\n    # \u51fa\u73fe\u6570\u30ab\u30a6\u30f3\u30c8\n\n    MAXA = max(A)\n\n    MAXB = max(B)\n\n    C1 = [0] * (MAXA+1)\n\n    C2 = [0] * (MAXB+1)\n\n    for a in A:\n\n        C1[a] += 1\n\n    for b in B:\n\n        C2[b] += 1\n\n    # max(A)+max(B)\u3088\u308a\u5927\u304d\u30442\u51aa\n\n    L = 1\n\n    k = 0\n\n    while L <= MAXA + MAXB:\n\n        k += 1\n\n        L = 2**k\n\n    # FFT\n\n    res = irfft(rfft(C1, L) * rfft(C2, L), L)\n\n    # \u56db\u6368\u4e94\u5165\u3057\u3066\u6574\u6570\u306b\n\n    res = np.rint(res).astype(np.int64)\n\n    return res\n\n\n\nN, M, L = MAP()\n\nA = LIST()\n\nB = LIST()\n\n\n\nres = list(fft(A, B))\n\n\n\nmn = INF\n\nfor i, a in enumerate(res):\n\n    if a != 0:\n\n        mn = i\n\n        break\n\n\n\nfor _ in range(L):\n\n    x, y, c = MAP()\n\n    x -= 1; y -= 1\n\n    mn = min(mn, A[x] + B[y] - c)\n\nprint(mn)\n","reference_code_col":"# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\nfrom collections import Counter\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x \/\/ y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\nN, M, L = MAP()\n\nA = LIST()\n\nB = LIST()\n\n\n\nmn = min(A) + min(B)\n\nfor _ in range(L):\n\n    x, y, c = MAP()\n\n    x -= 1; y -= 1\n\n    mn = min(mn, A[x] + B[y] - c)\n\nprint(mn)\n","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import Counter\n\ndef main():\n    # Read all input at once and split into integers\n    inp = sys.stdin.read().split()\n    N, M, L = map(int, inp[:3])\n    A = list(map(int, inp[3:3+N]))\n    B = list(map(int, inp[3+N:3+N+M]))\n    queries = [tuple(map(int, inp[3+N+M+i*3:3+N+M+(i+1)*3])) for i in range(L)]\n\n    # Frequency count for A and B\n    freq_A = Counter(A)\n    freq_B = Counter(B)\n\n    # Compute maximum values\n    max_A = max(A)\n    max_B = max(B)\n\n    # Initialize result array for convolution\n    res = [0] * (max_A + max_B + 1)\n    for a, count_a in freq_A.items():\n        for b, count_b in freq_B.items():\n            res[a + b] += count_a * count_b\n\n    # Find the minimum index with non-zero value\n    mn = float('inf')\n    for i, count in enumerate(res):\n        if count > 0:\n            mn = i\n            break\n\n    # Process queries\n    for x, y, c in queries:\n        mn = min(mn, A[x-1] + B[y-1] - c)\n\n    print(mn)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02899","slow_code_col":"import numpy as np\n\n\n\nN = int(eval(input()))\n\nA = [int(_) for _ in input().split(\" \")]\n\n\n\ntmp = np.argsort(A)\n\ntmp2= tmp + np.ones(N)\n\ntmp3 = [int(_) for _ in tmp2.tolist()]\n\nans = [str(_) for _ in tmp3]\n\n\n\nprint((\" \".join(ans)))","reference_code_col":"N = int(eval(input()))\n\nA = [int(_) for _ in input().split(\" \")]\n\n\n\ntmp = sorted(list(range(1, len(A) + 1)), key=lambda x:A[x - 1])\n\nans = [str(_) for _ in tmp]\n\nprint((\" \".join(ans)))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN = int(input())\nA = np.fromstring(input(), sep=\" \", dtype=int)\n\n# Compute the sorted indices and adjust them by adding 1\nsorted_indices = np.argsort(A) + 1\n\n# Convert the indices to a space-separated string and print\nprint(\" \".join(map(str, sorted_indices)))"}
{"problem_id":"p03037","slow_code_col":"# -*- coding: utf-8 -*-\n\n\n\nN, M = list(map(int, input().split()))\n\nL, R = [None] * M, [None] * M\n\nfor i in range(M):\n\n    L[i], R[i] = list(map(int, input().split()))\n\n\n\nl = max(L)\n\nr = min(R)\n\n\n\nans = max(r - l + 1, 0)\n\n\n\nprint(ans)\n","reference_code_col":"# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nN, M = list(map(int, input().split()))\n\nL, R = [None] * M, [None] * M\n\nfor i in range(M):\n\n    L[i], R[i] = list(map(int, input().split()))\n\n\n\nans = max(min(R) - max(L) + 1, 0)\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\n# Read N and M\nN, M = map(int, input().split())\n\n# Initialize variables for tracking max(L) and min(R)\nl_max = float('-inf')  # Smallest possible value for max(L)\nr_min = float('inf')   # Largest possible value for min(R)\n\n# Process each pair of inputs on-the-fly\nfor _ in range(M):\n    l, r = map(int, input().split())\n    l_max = max(l_max, l)  # Update max(L)\n    r_min = min(r_min, r)  # Update min(R)\n\n# Compute the final answer\nans = max(r_min - l_max + 1, 0)\n\n# Print the result\nprint(ans)"}
{"problem_id":"p02881","slow_code_col":"import math\n\ninput_num = int(eval(input()))\n\nnum_sqrt = int(math.sqrt(input_num))\n\n\n\nminimam = input_num\n\nfor i in range(num_sqrt+1,0,-1):\n\n    q, mod = divmod(input_num, i)\n\n    distance = q + i -2\n\n    if mod == 0 and minimam > distance:\n\n        minimam = distance\n\nprint(minimam)","reference_code_col":"import math\n\ndef main1():\n\n    input_num = int(eval(input()))\n\n    num_sqrt = int(math.sqrt(input_num))\n\n\n\n    minimam = input_num\n\n    for i in range(num_sqrt+1,0,-1):\n\n        q, mod = divmod(input_num, i)\n\n        if mod == 0:\n\n            distance = q + i -2\n\n            if minimam > distance:\n\n                minimam = distance\n\n    print(minimam)\n\nmain1()","model_generated_potentially_faster_code_col":"import math\n\n# Read input safely\ninput_num = int(input())\n\n# Calculate the square root of the input number\nnum_sqrt = int(math.sqrt(input_num))\n\n# Initialize the minimum distance\nminimam = float('inf')\n\n# Iterate over potential divisors up to sqrt(input_num)\nfor i in range(1, num_sqrt + 1):\n    if input_num % i == 0:  # Check if i is a divisor\n        q = input_num \/\/ i  # Calculate the complementary divisor\n        distance = q + i - 2  # Calculate the distance\n        \n        # Update the minimum distance if the current one is smaller\n        if distance < minimam:\n            minimam = distance\n\nprint(minimam)"}
{"problem_id":"p02881","slow_code_col":"# C - Walk on Multiplication Table\n\n# https:\/\/atcoder.jp\/contests\/abc144\/tasks\/abc144_c\n\n\n\nn = int(eval(input()))\n\n\n\nans = 10 ** 12\n\nfor i in range(1, 10 ** 6 + 1):\n\n  if n % i == 0:\n\n    ans = min(ans, n \/\/ i + i)\n\n\n\nprint((ans - 2))","reference_code_col":"# C - Walk on Multiplication Table\n\n# https:\/\/atcoder.jp\/contests\/abc144\/tasks\/abc144_c\n\n\n\nn = int(eval(input()))\n\n\n\nans = n\n\nfor i in range(1, int(n**.5) + 2):\n\n  if n % i == 0:\n\n    ans = min(ans, n \/\/ i + i - 2)\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import math\n\n# Read input\nn = int(input())\n\n# Initialize the answer with a large value\nans = float('inf')\n\n# Iterate only up to the square root of n\nfor i in range(1, int(math.sqrt(n)) + 1):\n    if n % i == 0:  # Check if i is a factor of n\n        j = n \/\/ i   # Compute the corresponding factor j\n        ans = min(ans, i + j)  # Minimize the sum of i and j\n\n# Output the result (subtracting 2 as per the problem statement)\nprint(ans - 2)"}
{"problem_id":"p04020","slow_code_col":"# AGC003B - Simplified mahjong\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    # split in subsequences when 0 appears -> sum up cur \/\/ 2\n\n    N = int(eval(input()))\n\n    A = list(map(int, [eval(input()) for _ in range(N)])) + [0]\n\n    ans, cur = 0, 0\n\n    for i in A:\n\n        if i:\n\n            cur += i\n\n        else:\n\n            ans += cur \/\/ 2\n\n            cur = 0\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()","reference_code_col":"# AGC003B - Simplified mahjong\n\ndef main():\n\n    # split in subsequences when 0 appears -> sum up cur \/\/ 2\n\n    N, *A = list(map(int, open(0).read().split()))\n\n    A.append(0)\n\n    ans, cur = 0, 0\n\n    for i in A:\n\n        if i:\n\n            cur += i\n\n        else:\n\n            ans += cur \/\/ 2\n\n            cur = 0\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Read input efficiently\n    input = sys.stdin.readline\n    N = int(input())\n    \n    ans = 0\n    cur = 0\n    \n    for _ in range(N):\n        i = int(input())  # Read each number directly\n        if i:\n            cur += i\n        else:\n            ans += cur \/\/ 2\n            cur = 0\n    \n    # Process the last subsequence (if cur > 0)\n    ans += cur \/\/ 2\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02412","slow_code_col":"while True:\n\n    (n, x) = [int(i) for i in input().split()]\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    for a in range(1, n + 1):\n\n        for b in range(a + 1, n + 1):\n\n            for c in range(b + 1, n + 1):\n\n                if sum([a,b,c]) == x:\n\n                    count += 1\n\n\n\n    print(count)","reference_code_col":"while True:\n\n    (n, x) = [int(i) for i in input().split()]\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    limit = n if n < x else x\n\n    for a in range(1, limit + 1):\n\n        for b in range(a + 1, limit + 1):\n\n            for c in range(b + 1, limit + 1):\n\n                if sum([a,b,c]) == x:\n\n                    count += 1\n\n\n\n    print(count)","model_generated_potentially_faster_code_col":"while True:\n    # Read input\n    n, x = map(int, input().split())\n    \n    # Termination condition\n    if n == 0 and x == 0:\n        break\n\n    count = 0\n\n    # Iterate over possible values of 'a'\n    for a in range(1, n + 1):\n        # Determine the valid range for 'b' based on 'a'\n        for b in range(a + 1, min(n, (x - a) \/\/ 2) + 1):\n            c = x - a - b\n            # Check if 'c' is valid\n            if b < c <= n:\n                count += 1\n\n    # Output the result\n    print(count)"}
{"problem_id":"p04005","slow_code_col":"'''\n\n\u3042\u308b\u5e73\u9762\u306e\u30d6\u30ed\u30c3\u30af\u6570\u00d7(0,1)\n\n\u4e00\u3064\u3067\u3082\u5076\u6570\u304c\u3042\u308c\u3070\u3001\u5747\u7b49\u5206\u5272\u53ef\u80fd\n\n\u3059\u3079\u3066\u5947\u6570\u306e\u3068\u304d\u3001\n\n\u3042\u308b\u5e73\u9762\u306e\u30d6\u30ed\u30c3\u30af\u6570\u3092\u6700\u5c0f\u3068\u306a\u308b\u3088\u3046\u306b\u3059\u308b\u3068\u3001\u305d\u306e\u6570\u304c\u7b54\u3048\u306b\u306a\u308b\n\n'''\n\n\n\narr = list(map(int, input().split()))\n\n\n\nret = -1\n\nif 0 in list([x % 2 for x in arr]):\n\n    ret = 0\n\nelse:\n\n    arr_sorted = sorted(arr)\n\n    ret = arr_sorted[0] * arr_sorted[1]\n\nprint(ret)","reference_code_col":"a = list(map(int, input().split()))\n\n\n\nif any([x % 2 == 0 for x in a]):\n\n    print((0))\n\nelse:\n\n    a = list(sorted(a))\n\n    print((a[0] * a[1]))\n","model_generated_potentially_faster_code_col":"# Input parsing\narr = list(map(int, input().split()))\n\n# Check if any number is even\nif any(x % 2 == 0 for x in arr):\n    ret = 0\nelse:\n    # Find the two smallest numbers in one pass\n    min1 = float('inf')\n    min2 = float('inf')\n    \n    for num in arr:\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n    \n    # Result is the product of the two smallest numbers\n    ret = min1 * min2\n\n# Output the result\nprint(ret)"}
{"problem_id":"p03162","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    abc.append(list(map(int, input().split())))\n\n    \n\ndp = np.zeros(shape=(N, 3), dtype=int)\n\ndp[0, :] = abc[0]\n\nfor i in range(N-1):\n\n    dp[i+1, 0] = max(dp[i+1, 0], dp[i, 1] + abc[i+1][0], dp[i, 2] + abc[i+1][0])\n\n    dp[i+1, 1] = max(dp[i+1, 1], dp[i, 0] + abc[i+1][1], dp[i, 2] + abc[i+1][1])\n\n    dp[i+1, 2] = max(dp[i+1, 2], dp[i, 0] + abc[i+1][2], dp[i, 1] + abc[i+1][2])\n\nprint((max(dp[N-1, :])))","reference_code_col":"N = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    data = list(map(int, input().split()))\n\n    abc.append(data)\n\n\n\ndp = [[0 for i in range(3)] for j in range(N)]\n\ndp[0][0] = abc[0][0]\n\ndp[0][1] = abc[0][1]\n\ndp[0][2] = abc[0][2]\n\n\n\nfor i in range(N-1):\n\n    for j in range(3):\n\n        if j == 0:\n\n            dp[i+1][1] = max(dp[i][0] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][2] = max(dp[i][0] + abc[i+1][2], dp[i+1][2])\n\n        if j == 1:\n\n            dp[i+1][0] = max(dp[i][1] + abc[i+1][0], dp[i+1][0])\n\n            dp[i+1][2] = max(dp[i][1] + abc[i+1][2], dp[i+1][2])\n\n        if j == 2:\n\n            dp[i+1][1] = max(dp[i][2] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][0] = max(dp[i][2] + abc[i+1][0], dp[i+1][0])\n\n\n\nprint((max(dp[N-1])))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input N\nN = int(input())\n\n# Preallocate a NumPy array for abc\nabc = np.empty((N, 3), dtype=int)\nfor i in range(N):\n    abc[i] = list(map(int, input().split()))\n\n# Initialize DP arrays\ndp_prev = np.copy(abc[0])  # Previous state\ndp_curr = np.zeros(3, dtype=int)  # Current state\n\n# Fill DP array\nfor i in range(1, N):\n    dp_curr[0] = max(dp_prev[1], dp_prev[2]) + abc[i][0]\n    dp_curr[1] = max(dp_prev[0], dp_prev[2]) + abc[i][1]\n    dp_curr[2] = max(dp_prev[0], dp_prev[1]) + abc[i][2]\n    \n    # Swap dp_prev and dp_curr for the next iteration\n    dp_prev, dp_curr = dp_curr, dp_prev\n\n# Output the maximum value from the last row\nprint(max(dp_prev))"}
{"problem_id":"p02994","slow_code_col":"N , L = list(map(int , input().split()))\n\n\n\napple_taste = []\n\n\n\nfor i in range(N):\n\n    taste = L + i + 1 - 1\n\n    apple_taste.append(taste)\n\n    \n\nimport numpy as np\n\n\n\nabs_apple_taste = np.abs(apple_taste)\n\nm = min(abs_apple_taste)\n\n\n\nfor j in range(N):\n\n    if m == abs_apple_taste[j]:\n\n        apple_taste.remove(apple_taste[j])\n\n\n\npie_taste = 0       \n\n\n\nfor k in range(N-1):\n\n    pie_taste += apple_taste[k]\n\n    \n\nprint(pie_taste)","reference_code_col":"n,l = list(map(int,input().split()))\n\nans = l\n\neat = l\n\n\n\nfor i in range(n-1):\n\n    l += 1\n\n    ans += l\n\n    \n\n    if abs(l) < abs(eat):\n\n        eat = l\n\n        \n\nprint((ans-eat))","model_generated_potentially_faster_code_col":"# Read input\nN, L = map(int, input().split())\n\n# Calculate apple_taste list using list comprehension\napple_taste = [L + i for i in range(N)]\n\n# Find the index of the element with the minimum absolute value\nmin_index = 0\nmin_abs_value = abs(apple_taste[0])\nfor i in range(1, N):\n    if abs(apple_taste[i]) < min_abs_value:\n        min_abs_value = abs(apple_taste[i])\n        min_index = i\n\n# Compute the sum excluding the element with the minimum absolute value\npie_taste = sum(apple_taste[:min_index] + apple_taste[min_index + 1:])\n\n# Print the result\nprint(pie_taste)"}
{"problem_id":"p02245","slow_code_col":"from collections import deque\n\nN = 3\n\nm = {8: {7, 5}, 7: {8, 6, 4}, 6: {7, 3}, 5: {8, 4, 2}, 4: {7, 5, 3, 1}, 3: {6, 4, 0}, 2: {5, 1}, 1: {4, 2, 0},\n\n     0: {3, 1}}\n\ngoal = 123456780\n\ndef g(i, j, a):\n\n    t = a \/\/ (10 ** j) % 10\n\n    return a - t * (10 ** j) + t * (10 ** i)\n\ndef solve():\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    start = 8 - MAP.find(\"0\")\n\n    MAP = int(MAP)\n\n    if MAP == goal:\n\n        return 0\n\n    dp = deque([(0, start, MAP)])\n\n    LOG = {MAP}\n\n    while dp:\n\n        cnt, yx, M = dp.popleft()\n\n        if M == goal:\n\n            return cnt\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            CM = g(yx, nyx, M)\n\n            if not CM in LOG:\n\n                dp.append((cnt, nyx, CM))\n\n                LOG.add(CM)\n\ndef MAIN():\n\n    print((solve()))\n\nMAIN()\n\n\n","reference_code_col":"from collections import deque\n\nN = 3\n\nm = {8: {7, 5}, 7: {8, 6, 4}, 6: {7, 3}, 5: {8, 4, 2}, 4: {7, 5, 3, 1}, 3: {6, 4, 0}, 2: {5, 1}, 1: {4, 2, 0},\n\n     0: {3, 1}}\n\ngoal = 123456780\n\ndef g(i, j, a):\n\n    t = a \/\/ (10 ** j) % 10\n\n    return a - t * (10 ** j) + t * (10 ** i)\n\ndef solve():\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    zero = 8 - MAP.find(\"0\")\n\n    start = int(MAP)\n\n    if start == goal:\n\n        return 0\n\n    dp = deque([(0, start, zero, 1), (0, goal, 0, 0)])\n\n    TABLE = {start: (1, 0), goal: (0, 0)}\n\n    while dp:\n\n        cnt, M, yx, flg = dp.popleft()\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            key = g(yx, nyx, M)\n\n            if key in TABLE:\n\n                if TABLE[key][0] != flg:\n\n                    return TABLE[key][1] + cnt\n\n                continue\n\n            TABLE[key] = (flg, cnt)\n\n            dp.append((cnt, key, nyx, flg))\n\ndef MAIN():\n\n    print((solve()))\n\nMAIN()\n\n\n","model_generated_potentially_faster_code_col":"from collections import deque\n\n# Constants\nN = 3\nm = {\n    8: {7, 5}, 7: {8, 6, 4}, 6: {7, 3},\n    5: {8, 4, 2}, 4: {7, 5, 3, 1}, 3: {6, 4, 0},\n    2: {5, 1}, 1: {4, 2, 0}, 0: {3, 1}\n}\nGOAL = \"123456780\"\n\ndef swap(state, i, j):\n    \"\"\"Swap characters at indices i and j in the string state.\"\"\"\n    lst = list(state)\n    lst[i], lst[j] = lst[j], lst[i]\n    return ''.join(lst)\n\ndef solve():\n    # Read input and preprocess\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n    start = 8 - MAP.find(\"0\")  # Find the position of '0'\n\n    # Early exit if already at the goal\n    if MAP == GOAL:\n        return 0\n\n    # BFS initialization\n    dp = deque([(0, start, MAP)])  # (steps, position of '0', current state)\n    LOG = {MAP}  # Set of visited states\n\n    while dp:\n        cnt, yx, M = dp.popleft()\n\n        # Explore neighbors\n        for nyx in m[yx]:\n            # Swap '0' with the neighbor\n            new_state = swap(M, yx, nyx)\n\n            # Check if the new state is visited\n            if new_state not in LOG:\n                if new_state == GOAL:\n                    return cnt + 1  # Return immediately if goal is reached\n                dp.append((cnt + 1, nyx, new_state))\n                LOG.add(new_state)\n\n    return -1  # If no solution is found\n\ndef MAIN():\n    print(solve())\n\nMAIN()"}
{"problem_id":"p03371","slow_code_col":"inf = (5000 * 10 ** 5) * 3\n\n\n\na, b, c, x, y = list(map(int, input().split()))\n\n\n\nret = inf\n\nfor cnt_ab in range(max(x, y) * 2 + 1):\n\n    d = cnt_ab \/\/ 2\n\n\n\n    cnt_a = max(0, x - d)\n\n    cnt_b = max(0, y - d)\n\n\n\n    t = cnt_ab * c + cnt_a * a + cnt_b * b\n\n    ret = min(ret, t)\n\nprint(ret)\n","reference_code_col":"def main():\n\n    A, B, AB, X, Y = list(map(int, input().split()))\n\n    M = max(X, Y)\n\n\n\n    k = 0\n\n    ans = A * X + B * Y\n\n    while True:\n\n        ans = min(\n\n            ans,\n\n            AB * k * 2 + max(0, X - k) * A + max(0, Y - k) * B\n\n        )\n\n\n\n        if k >= M: break\n\n        k += 1\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"inf = (5000 * 10 ** 5) * 3\n\n# Read input values\na, b, c, x, y = map(int, input().split())\n\n# Initialize result to a large value\nret = inf\n\n# Iterate over feasible values of cnt_ab\nfor cnt_ab in range(0, max(x, y) * 2 + 1):\n    d = cnt_ab \/\/ 2  # Number of AB coupons used as pairs\n    \n    # Calculate remaining A and B coupons needed\n    cnt_a = max(0, x - d)\n    cnt_b = max(0, y - d)\n    \n    # Calculate total cost\n    t = cnt_ab * c + cnt_a * a + cnt_b * b\n    \n    # Update result if the current cost is lower\n    ret = min(ret, t)\n    \n    # Early termination: If further increasing cnt_ab won't reduce cost\n    if cnt_ab * c >= ret:\n        break\n\nprint(ret)"}
{"problem_id":"p02555","slow_code_col":"S = int(eval(input()))\n\nf = [0]*(S+1)\n\nf[0] = 1\n\nif S >= 3: f[3] = 1\n\nif S >= 4: f[4] = 1\n\nif S >= 5: f[5] = 1\n\nfor i in range(6, S+1):\n\n    f[i] = sum(f[i-j] for j in range(3, i+1))%(10**9+7)\n\nprint((f[S]))\n","reference_code_col":"S=int(eval(input()))\n\nf=[1,0,0]\n\nfor i in range(S-2):f.append(f[i]+f[i+2])\n\nprint((f[S]%(10**9+7)))\n","model_generated_potentially_faster_code_col":"S = int(eval(input()))\n\n# Initialize the array with zeros\nf = [0] * (S + 1)\n\n# Base cases\nf[0] = 1\nif S >= 3: f[3] = 1\nif S >= 4: f[4] = 1\nif S >= 5: f[5] = 1\n\n# Sliding window sum initialization\nwindow_sum = 0\nif S >= 3: window_sum += f[3]\nif S >= 4: window_sum += f[4]\nif S >= 5: window_sum += f[5]\n\n# Compute f[i] using sliding window optimization\nfor i in range(6, S + 1):\n    f[i] = window_sum % (10**9 + 7)\n    # Update the sliding window sum\n    window_sum += f[i] - f[i - 3]\n\n# Output the result\nprint(f[S])"}
{"problem_id":"p03806","slow_code_col":"import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\nN, Ma, Mb = list(map(int, input().split()))\n\nABC = [list(map(int, input().split())) for _ in range(N)]\n\n\n\nINF = 10 ** 15\n\ndp = [[INF for j in range(401)] for i in range(401)]\n\ndp[0][0] = 0\n\n\n\nfor a, b, c in ABC:\n\n  for i in range(400, -1, -1):\n\n    for j in range(400, -1, -1):\n\n      if dp[i][j] != INF:\n\n        dp[i + a][j + b] = min(dp[i + a][j + b], dp[i][j] + c)\n\n\n\nanswer = INF\n\nfor i in range(1, 401):\n\n  for j in range(1, 401):\n\n    if dp[i][j] != INF and i \/ j == Ma \/ Mb:\n\n      answer = min(answer, dp[i][j])\n\n      \n\nprint((answer if answer != INF else -1))","reference_code_col":"import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\nN, Ma, Mb = list(map(int, input().split()))\n\nABC = [list(map(int, input().split())) for _ in range(N)]\n\n\n\nsumA = sum([ABC[i][0] for i in range(N)])\n\nsumB = sum([ABC[i][1] for i in range(N)])\n\n\n\nINF = 10 ** 15\n\ndp = [[INF for j in range(sumB + 1)] for i in range(sumA + 1)]\n\ndp[0][0] = 0\n\n\n\nfor a, b, c in ABC:\n\n  for i in range(sumA, -1, -1):\n\n    for j in range(sumB, -1, -1):\n\n      if dp[i][j] != INF:\n\n        dp[i + a][j + b] = min(dp[i + a][j + b], dp[i][j] + c)\n\n\n\nanswer = INF\n\nfor i in range(1, sumA + 1):\n\n  for j in range(1, sumB + 1):\n\n    if dp[i][j] != INF and i \/ j == Ma \/ Mb:\n\n      answer = min(answer, dp[i][j])\n\n      \n\nprint((answer if answer != INF else -1))","model_generated_potentially_faster_code_col":"import sys\nfrom math import gcd\n\ninput = sys.stdin.buffer.readline\n\n# Read input\nN, Ma, Mb = map(int, input().split())\nABC = [list(map(int, input().split())) for _ in range(N)]\n\n# Normalize Ma\/Mb ratio to avoid floating-point precision issues\ng = gcd(Ma, Mb)\nMa \/\/= g\nMb \/\/= g\n\n# Initialize variables\nINF = 10**15\nmax_a = sum(a for a, b, c in ABC)\nmax_b = sum(b for a, b, c in ABC)\n\n# Sparse DP using a dictionary\ndp = {(0, 0): 0}\n\n# Update DP table\nfor a, b, c in ABC:\n    temp_dp = dp.copy()  # Temporary copy to avoid overwriting during iteration\n    for (i, j), cost in dp.items():\n        new_i, new_j = i + a, j + b\n        if new_i <= max_a and new_j <= max_b:\n            if (new_i, new_j) not in temp_dp:\n                temp_dp[(new_i, new_j)] = cost + c\n            else:\n                temp_dp[(new_i, new_j)] = min(temp_dp[(new_i, new_j)], cost + c)\n    dp = temp_dp\n\n# Find the minimum cost for valid (i, j) pairs\nanswer = INF\nfor (i, j), cost in dp.items():\n    if i > 0 and j > 0 and i * Mb == j * Ma:  # Check if the ratio matches Ma\/Mb\n        answer = min(answer, cost)\n\n# Output the result\nprint(answer if answer != INF else -1)"}
{"problem_id":"p02555","slow_code_col":"from sys import stdin, stdout, setrecursionlimit\n\nfrom collections import deque, defaultdict, Counter\n\nfrom heapq import heappush, heappop\n\nfrom functools import lru_cache\n\nimport math\n\n\n\nsetrecursionlimit(10**6)\n\nrl = lambda: stdin.readline()\n\nrll = lambda: stdin.readline().split()\n\nrli = lambda: list(map(int, stdin.readline().split()))\n\nrlf = lambda: list(map(float, stdin.readline().split()))\n\n\n\nINF, NINF = float('inf'), float('-inf')\n\nMOD = 10**9 + 7\n\n\n\ndef main():\n\n\ts = int(rl())\n\n\n\n\t@lru_cache(None)\n\n\tdef dp(currsum):\n\n\t\tif currsum == s: return 1\n\n\t\tcnt = 0\n\n\t\tfor d in range(3, 2001):\n\n\t\t\tif currsum + d <= s:\n\n\t\t\t\tcnt += dp(currsum + d)\n\n\t\t\t\tcnt %= MOD \n\n\t\treturn cnt\n\n\tprint((dp(0)))\n\n\tstdout.close()\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()","reference_code_col":"from sys import stdin, stdout, setrecursionlimit\n\nfrom collections import deque, defaultdict, Counter\n\nfrom heapq import heappush, heappop\n\nfrom functools import lru_cache\n\nimport math\n\n\n\n#setrecursionlimit(10**6)\n\nrl = lambda: stdin.readline()\n\nrll = lambda: stdin.readline().split()\n\nrli = lambda: list(map(int, stdin.readline().split()))\n\nrlf = lambda: list(map(float, stdin.readline().split()))\n\n\n\nINF, NINF = float('inf'), float('-inf')\n\nMOD = 10**9 + 7\n\n\n\ndef main():\n\n\ts = int(rl())\n\n\n\n\tdef binom_tables(n, q):\n\n\t\tfact = [1 for _ in range(n + 1)]\n\n\t\tinv = [1 for _ in range(n + 1)]\n\n\t\tfor i in range(1, n+1):\n\n\t\t\tfact[i] = (fact[i-1] * i) % q\n\n\t\t\tinv[i] = pow(fact[i], q-2, q)\n\n\t\treturn fact, inv\n\n\n\n\tF, I = binom_tables(s + 700, MOD)\n\n\n\n\tdef binom(n, k, q):\n\n\t\treturn (F[n]*((I[k]*I[n-k])%q))%q\n\n\n\n\tans = 0\n\n\tfor r in range(1, 700):\n\n\t\tobjects = s - 3*r\n\n\t\tif objects + r - 1 < objects or objects < 0: \n\n\t\t\tbreak\n\n\t\tx = binom(objects + r - 1, objects, MOD)\n\n\t\tans += x\n\n\t\tans %= MOD \n\n\n\n\tprint(ans)\n\n\tstdout.close()\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()","model_generated_potentially_faster_code_col":"from sys import stdin, stdout\n\nMOD = 10**9 + 7\n\ndef main():\n    s = int(stdin.readline())\n\n    # Initialize DP array\n    dp = [0] * (s + 1)\n    dp[0] = 1  # Base case: There's one way to make sum 0 (using no numbers)\n\n    # Iterate over all possible sums from 1 to s\n    for currsum in range(1, s + 1):\n        # For each sum, consider adding numbers from 3 to min(2000, currsum)\n        for d in range(3, min(2001, currsum + 1)):\n            dp[currsum] += dp[currsum - d]\n            dp[currsum] %= MOD  # Apply modulo to avoid overflow\n\n    print(dp[s])\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02688","slow_code_col":"N,K=list(map(int,input().split()))\n\na = [[0]*N]*K\n\na = [[0 for n in range(N)] for k in range(K)]\n\n\n\nfor k in range(K):\n\n    d=int(eval(input()))\n\n    have_k=list(map(int,input().split()))\n\n    for h in have_k:\n\n        a[k][h-1]=1\n\n\n\nan=[0]*N\n\nfor k in range(K):\n\n  for n in range(N):\n\n    an[n] = an[n]+a[k][n]\n\n\n\nresult=0\n\nfor i in an:\n\n  if i == 0:\n\n    result+=1\n\n\n\nprint(result)","reference_code_col":"N,K=list(map(int,input().split()))\n\na = [[0 for n in range(N)] for k in range(K)]\n\n\n\nfor k in range(K):\n\n    d=int(eval(input()))\n\n    have_k=list(map(int,input().split()))\n\n    for h in have_k:\n\n        a[k][h-1]=1\n\n\n\nan=[0]*N\n\nfor k in range(K):\n\n  for n in range(N):\n\n    an[n] = an[n]+a[k][n]\n\n\n\nresult=0\n\nfor i in an:\n\n  if i == 0:\n\n    result+=1\n\n\n\nprint(result)","model_generated_potentially_faster_code_col":"# Read N (number of elements) and K (number of subsets)\nN, K = map(int, input().split())\n\n# Initialize the array to count occurrences of each element\nan = [0] * N\n\n# Process each subset\nfor _ in range(K):\n    # Read the size of the subset and its elements\n    d = int(input())\n    have_k = list(map(int, input().split()))\n    \n    # Update the count for elements in the current subset\n    for h in have_k:\n        an[h - 1] += 1\n\n# Count how many elements appear in zero subsets\nresult = sum(1 for count in an if count == 0)\n\n# Print the result\nprint(result)"}
{"problem_id":"p02767","slow_code_col":"import numpy as np \n\nn = int(eval(input()))\n\nx = list(map(int, input().split()))\n\nx = np.array(x)\n\nans = float('inf')\n\nidx = 200\n\nfor i in range(100):\n\n  y = x \n\n  ans = min(ans, np.sum((y-i)**2))\n\n  \n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nmx = max(X)\n\nans = float('inf')\n\nfor i in range(mx+1):\n\n  tmp = 0\n\n  for x in X:\n\n    tmp += (x-(i+1))**2\n\n  ans = min(ans, tmp)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input parsing\nn = int(input())\nx = np.array(list(map(int, input().split())))\n\n# Precompute (x - i)**2 for all i in one step using broadcasting\ni_values = np.arange(100).reshape(-1, 1)  # Shape: (100, 1)\nsquared_diffs = (x - i_values) ** 2       # Shape: (100, n)\n\n# Compute the sum along the columns (axis=1) to get the total squared difference for each i\nsum_squared_diffs = np.sum(squared_diffs, axis=1)\n\n# Find the minimum value among all sums\nans = np.min(sum_squared_diffs)\n\nprint(ans)"}
{"problem_id":"p03037","slow_code_col":"n,m=list(map(int,input().split()))\n\nc=[0]*(n+2)\n\nfor i in range(m):\n\n  l,r=list(map(int,input().split()))\n\n  c[l-1]+=1\n\n  c[r]-=1\n\nfor i in range(1,n+2):\n\n  c[i]=c[i]+c[i-1]\n\nans=0\n\nfor i in range(n+2):\n\n  if c[i]==m:\n\n    ans+=1\n\nprint(ans)","reference_code_col":"n,m=list(map(int,input().split()))\n\nl,r=list(map(int,input().split()))\n\nfor i in range(m-1):\n\n  tl,tr=list(map(int,input().split()))\n\n  if l<tl:\n\n    l=tl\n\n  if tr<r:\n\n    r=tr\n\nprint((max(r-l+1,0)))","model_generated_potentially_faster_code_col":"# Read input values for n and m\nn, m = map(int, input().split())\n\n# Initialize the difference array c with size n+2\nc = [0] * (n + 2)\n\n# Process range updates\nfor _ in range(m):\n    l, r = map(int, input().split())\n    c[l - 1] += 1\n    c[r] -= 1\n\n# Compute prefix sums\nans = 0\ncurrent_sum = 0\nfor i in range(n + 1):  # Only iterate up to n+1 since c[n+1] is not needed\n    current_sum += c[i]\n    if current_sum == m:  # Check condition during prefix sum computation\n        ans += 1\n\n# Output the result\nprint(ans)"}
{"problem_id":"p03287","slow_code_col":"n,m=list(map(int,input().split()))\n\na=[int(x) for x in input().split()]\n\nb=[0 for x in range(n+1)]\n\nl=list([0])\n\n\n\nfor i in range(1,n+1):\n\n  b[i]=b[i-1]+a[i-1]\n\n\n\nfor i in range(1,n+1):\n\n  l.append(b[i]%m)\n\n\n\nd=list()\n\nl.sort()\n\nt,c=0,1\n\nfor i in range(1,n+1):\n\n  if l[i]==l[i-1]:\n\n    c+=1\n\n  else:\n\n    if c!=1:\n\n      t += c*(c-1)\/\/2\n\n      c=1\n\n\n\nif c!=1:\n\n  t += c*(c-1)\/\/2  \n\n\n\nprint(t)\n","reference_code_col":"n,m=list(map(int,input().split()))\n\na=[int(x) for x in input().split()]\n\nl=list([0])\n\n\n\nb=0\n\nfor i in range(0,n):\n\n  b += a[i]\n\n  l.append(b%m)\n\nl.append(m)\n\n\n\nl.sort()\n\nt,c=0,1\n\nfor i in range(1,n+2):\n\n  if l[i]==l[i-1]:\n\n    c+=1\n\n  else:\n\n    if c!=1:\n\n      t += c*(c-1)\/\/2\n\n      c=1\n\nprint(t)\n","model_generated_potentially_faster_code_col":"# Input parsing\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Frequency dictionary for modulo values\nfreq = {0: 1}  # Initialize with 0 to handle cases where prefix sum itself is divisible by m\nprefix_sum_mod = 0\n\n# Compute prefix sums and count modulo frequencies\nfor num in a:\n    prefix_sum_mod = (prefix_sum_mod + num) % m\n    freq[prefix_sum_mod] = freq.get(prefix_sum_mod, 0) + 1\n\n# Count pairs using the frequency dictionary\nresult = 0\nfor count in freq.values():\n    if count > 1:\n        result += count * (count - 1) \/\/ 2\n\nprint(result)"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nA = np.array(A)\n\ncounter = 0\n\nwhile True:\n\n    if all( i%2==0 for i in A):\n\n        counter  += 1\n\n        A = A\/2\n\n    else:\n\n        print(counter)\n\n        break","reference_code_col":"N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nc = 0\n\nwhile True:\n\n    if all(a% 2 ==0 for a in A):\n\n        c += 1\n\n        A = list([x\/\/2 for x in A])\n\n    else:\n\n        break\n\nprint(c)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input\nN = int(input())\nA = np.array(list(map(int, input().split())))\n\ncounter = 0\n\nwhile True:\n    # Check if all elements are divisible by 2 using NumPy's vectorized operations\n    if np.all(A % 2 == 0):\n        counter += 1\n        # Perform in-place division to avoid creating a new array\n        A \/\/= 2\n    else:\n        print(counter)\n        break"}
{"problem_id":"p02850","slow_code_col":"import copy\n\n\n\nn=int(eval(input()))\n\norg_set=set([i for i in range(1,10**5)])\n\nedges=[]\n\nrelations={}\n\nnodes=[]\n\nfor i in range(n-1):\n\n    a,b=list(map(int,input().split(\" \")))\n\n    edges.append([a,b])\n\n    relations.setdefault(a,[]).append(b)\n\n    nodes.append([])\n\nnodes.append([])\n\nnodes.append([])\n\n\n\nmax_color=0\n\nfor start in range(1,n+1):\n\n    targets=relations.get(start,[])\n\n    color=1\n\n    for target in targets:\n\n        if color in nodes[start]:\n\n            color+=1\n\n        else:\n\n            pass\n\n        nodes[target].append(color)\n\n        if color>=max_color:\n\n            max_color=color\n\n        color+=1\n\n\n\nprint(max_color)\n\nfor edge in edges:\n\n    print((nodes[edge[1]][0]))","reference_code_col":"n=int(eval(input()))\n\nedges=[]\n\nrelations={}\n\nnodes=[0,0]\n\nfor i in range(n-1):\n\n    a,b=list(map(int,input().split(\" \")))\n\n    edges.append([a,b])\n\n    relations.setdefault(a,[]).append(b)\n\n    nodes.append(0)\n\n\n\nmax_color=0\n\nfor start in range(1,n+1):\n\n    targets=relations.get(start,[])\n\n    color=1\n\n    for target in targets:\n\n        if color == nodes[start]:\n\n            color+=1\n\n        else:\n\n            pass\n\n        nodes[target]=color\n\n        if color>=max_color:\n\n            max_color=color\n\n        color+=1\n\n\n\nprint(max_color)\n\nfor edge in edges:\n\n    print((nodes[edge[1]]))","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Faster input reading\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])  # Number of nodes\n    edges = [list(map(int, line.split())) for line in data[1:]]  # Read edges\n    \n    # Initialize adjacency list and color dictionary\n    relations = {}\n    node_colors = {}\n    \n    # Build adjacency list\n    for a, b in edges:\n        relations.setdefault(a, []).append(b)\n        relations.setdefault(b, []).append(a)\n    \n    max_color = 0\n    \n    # Assign colors to edges\n    for start in range(1, n + 1):\n        used_colors = set()  # Track colors used for adjacent nodes\n        targets = relations.get(start, [])\n        \n        for target in targets:\n            # Find the smallest available color for the edge (start, target)\n            color = 1\n            while color in used_colors or (target in node_colors and color in node_colors[target]):\n                color += 1\n            \n            # Assign the color to the edge\n            if target not in node_colors:\n                node_colors[target] = set()\n            node_colors[target].add(color)\n            \n            # Update max_color\n            max_color = max(max_color, color)\n    \n    # Output results\n    print(max_color)\n    for a, b in edges:\n        # Print the smallest color assigned to the edge (a, b)\n        print(next(iter(node_colors[b])))\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03780","slow_code_col":"# x < y\u3067y\u304c\u4e0d\u8981\u3068\u3059\u308b\u3002y\u629c\u304d\u3067[K-y,K)\u3092\u4f5c\u308c\u308b\u3002\n\n# \u3053\u306e\u3068\u304d\u306bx\u3092\u4f7f\u3063\u3066\u3044\u306a\u3044\u306e\u306a\u3089\u3070\u3001x\u3082\u4e0d\u8981\u3002\n\n# x\u3092\u4f7f\u3063\u3066\u3044\u308b\u306e\u306a\u3089\u3070\u3001xy\u629c\u304d\u3067[K-x-y,K-x)\u3092\u4f5c\u308c\u308b\u3002\n\n# y\u3092\u52a0\u3048\u3066\u3001x\u629c\u304d\u3067[K-x,K)\u3092\u4f5c\u308c\u308b\u3002\n\n# \u3088\u3063\u3066y\u4e0d\u8981\u306a\u3089\u3070x\u4e0d\u8981\u3002\n\nimport numpy as np\n\nimport itertools\n\n\n\nN,K = list(map(int,input().split()))\n\nA = [int(x) for x in input().split()]\n\nA.sort()\n\n\n\n# \u30ab\u30fc\u30c9\u306f[0,N)-indexed\n\n\n\ndef test(i):\n\n  # i\u756a\u76ee\u306e\u30ab\u30fc\u30c9\u306f\u4e0d\u8981\n\n  dp = np.zeros(K,dtype=np.bool)\n\n  dp[0] = True\n\n  for a in itertools.chain(A[:i],A[i+1:]):\n\n    dp[a:] = np.logical_or(dp[a:],dp[:-a])\n\n  return not dp[-A[i]:].any()\n\n\n\nleft = -1 # \u4e0d\u8981\u3060\u3068\u5224\u660e\n\nright = N # \u4e0d\u8981\u3067\u306a\u3044\u3068\u5224\u660e\n\nwhile right - left > 1:\n\n  mid = (left+right)\/\/2\n\n  if test(mid):\n\n    left = mid\n\n  else:\n\n    right = mid\n\n\n\n   \n\nanswer = left+1\n\nprint(answer)","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\n\n\n\"\"\"\n\n\u30fb\u300c\u5fc5\u8981\u300d\u3068\u306f\uff5e\uff5e\u304c\u5b58\u5728\n\n\u30fbx \u3092\u542b\u307e\u306a\u3044\u3001[K-x,K) \u5185\u306e\u7dcf\u548c\u304c\u5b58\u5728\n\n\u30fb\u96c6\u5408\u3092\u6307\u5b9a\u3059\u308b\u3068\u3001\u3042\u308b\u5024\u6bb5\u3088\u308a\u4e0a\u5074\n\n\u30fb\u5168\u4f53\u3068\u3057\u3066\u3082\u5358\u8abf\u6027\u304c\u3042\u308b\n\n\"\"\"\n\n\n\nN,K,*A = list(map(int,read().split()))\n\n\n\nA = [x if x <= K else K + 1 for x in A]\n\nA.sort()\n\n\n\nmask = (1 << K) - 1\n\n\n\ndef test(x):\n\n    # x\u756a\u76ee\u306f\u5fc5\u8981\n\n    if A[x] > K:\n\n        return True\n\n    dp = 1\n\n    for a in itertools.chain(A[:x], A[x+1:]):\n\n        dp |= (dp << a)\n\n        dp &= mask\n\n    dp >>= (K - A[x])\n\n    return (dp > 0)\n\n\n\nleft = -1 # \u5fc5\u8981\n\nright = N # \u4e0d\u8981\n\nwhile left + 1 < right:\n\n    x = (left + right) \/\/ 2\n\n    if test(x):\n\n        right = x\n\n    else:\n\n        left = x\n\n\n\nanswer = left + 1\n\nprint(answer)\n","model_generated_potentially_faster_code_col":"import sys\nimport itertools\n\ndef main():\n    # Input reading\n    N, K = map(int, sys.stdin.readline().split())\n    A = list(map(int, sys.stdin.readline().split()))\n    A.sort()\n\n    # Function to test if the i-th card is unnecessary\n    def test(i):\n        dp = [False] * K\n        dp[0] = True\n        \n        # Process all cards except the i-th card\n        for idx in itertools.chain(range(i), range(i + 1, N)):\n            a = A[idx]\n            # Update DP array efficiently\n            for j in range(K - 1, a - 1, -1):\n                if dp[j - a]:\n                    dp[j] = True\n        \n        # Check if removing A[i] still allows constructing values in [K - A[i], K)\n        return not any(dp[K - A[i]:])\n\n    # Binary search to find the largest unnecessary card index\n    left, right = -1, N\n    while right - left > 1:\n        mid = (left + right) \/\/ 2\n        if test(mid):\n            left = mid\n        else:\n            right = mid\n\n    # Output the result\n    print(left + 1)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02691","slow_code_col":"n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nk=[]\n\nans=0\n\nfor i in range(400005):\n\n  k.append(0)\n\nfor i in range(n):\n\n  if i-a[i]>=0:\n\n    ans+=k[i-a[i]]\n\n  if a[i]+i<400005:\n\n    k[a[i]+i]+=1\n\nprint(ans)","reference_code_col":"n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nthing={}\n\nans=0\n\nfor i in range(n):\n\n  if i-a[i] in thing:\n\n    ans+=thing[i-a[i]]\n\n  if i+a[i] in thing:\n\n    thing[i+a[i]]+=1\n\n  else:\n\n    thing[i+a[i]]=1\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\nfrom collections import defaultdict\n\ndef main():\n    # Faster input method\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    \n    # Dictionary to store counts of (a[i] + i)\n    k = defaultdict(int)\n    ans = 0\n\n    for i in range(n):\n        # Check if there exists a j such that a[j] + j == i - a[i]\n        target = i - a[i]\n        if target in k:\n            ans += k[target]\n\n        # Update the dictionary with the current value of a[i] + i\n        k[a[i] + i] += 1\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03060","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nN = eval(input())\n\n\n\nV = input().split()\n\nv = np.array([ int(x) for x in V])\n\n\n\nC = input().split()\n\nc = np.array([ int(x) for x in C])\n\n\n\ndelt = v - c\n\nprint((delt[delt>0].sum()))","reference_code_col":"N = int(eval(input()))\n\nV = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor v, c in zip(V, C):\n\n    p = v - c\n\n    if p > 0:\n\n        ans += p\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read N (number of elements)\nN = int(input())\n\n# Read V and C as space-separated strings and convert directly to NumPy arrays\nV = np.fromstring(input(), dtype=int, sep=' ')\nC = np.fromstring(input(), dtype=int, sep=' ')\n\n# Compute delta (v - c) and sum only positive values\ndelta = V - C\nresult = np.sum(delta[delta > 0])\n\n# Print the result\nprint(result)"}
{"problem_id":"p02881","slow_code_col":"import sys\n\nimport os\n\nimport math\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    N = ii()\n\n    ret = float('inf')\n\n    I = int(math.sqrt(N)) * 10\n\n    for i in range(1, I):\n\n        if N%i == 0:\n\n            j = N\/\/i\n\n            ret = min(ret, j + i - 2)\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"import sys\n\nimport os\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    N = ii()\n\n    m = int(N ** .5)\n\n    while N % m != 0:\n\n        m -= 1\n\n    else:\n\n        print((int(N \/ m + m - 2)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\nimport os\nimport math\n\n# Input helper functions\nii = lambda: int(sys.stdin.buffer.readline())\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\niln = lambda n: [int(sys.stdin.buffer.readline()) for _ in range(n)]\n\ndef main():\n    # Redirect input from file if running locally\n    if os.getenv(\"LOCAL\"):\n        sys.stdin = open(\"input.txt\", \"r\")\n\n    # Read input\n    N = ii()\n\n    # Initialize result with a large value\n    ret = float('inf')\n\n    # Loop only up to sqrt(N)\n    limit = int(math.sqrt(N))\n    for i in range(1, limit + 1):\n        if N % i == 0:  # Check if i is a factor of N\n            j = N \/\/ i  # Compute the corresponding factor\n            ret = min(ret, j + i - 2)  # Update the minimum value\n\n    # Output the result\n    print(ret)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03774","slow_code_col":"import numpy as np\n\nn, m = list(map(int, input().split()))\n\nab = [list(map(int, input().split())) for i in range(n)]\n\ncd = [list(map(int, input().split())) for i in range(m)]\n\n\n\ndist = np.zeros((n, m))\n\nfor i in range(n):\n\n  for j in range(m):\n\n    dist[i, j] = abs(ab[i][0] - cd[j][0]) + abs(ab[i][1] - cd[j][1])\n\n\n\nfor dis in dist:\n\n  print((dis.argmin()+1))","reference_code_col":"n, m = list(map(int, input().split()))\n\nab = [list(map(int, input().split())) for i in range(n)]\n\ncd = [list(map(int, input().split())) for i in range(m)]\n\n\n\nfor i in range(n):\n\n  a, b = ab[i]\n\n  \n\n  dist = 1e+15\n\n  ans = 0\n\n  for j in range(m):\n\n    c, d = cd[j]    \n\n\n\n    if dist > abs(a - c) + abs(b - d):\n\n      ans = j\n\n      dist = abs(a - c) + abs(b - d)\n\n  \n\n  print((ans+1))\n\n    \n\n    \n\n    ","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input reading and conversion to numpy arrays\nn, m = map(int, input().split())\nab = np.array([list(map(int, input().split())) for _ in range(n)])\ncd = np.array([list(map(int, input().split())) for _ in range(m)])\n\n# Vectorized computation of Manhattan distances\n# Expand dimensions for broadcasting: ab[:, None, :] -> shape (n, 1, 2), cd[None, :, :] -> shape (1, m, 2)\ndistances = np.abs(ab[:, None, 0] - cd[None, :, 0]) + np.abs(ab[:, None, 1] - cd[None, :, 1])\n\n# Find the index of the minimum distance for each row in ab\nmin_indices = np.argmin(distances, axis=1)\n\n# Output the results (add 1 to convert zero-based index to one-based index)\nprint(*(min_indices + 1), sep='\\n')"}
