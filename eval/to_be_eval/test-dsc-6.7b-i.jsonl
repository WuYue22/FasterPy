{"problem_id":"p03371","slow_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = 5000 * 2 * 10 ** 5\n\nfor i in range(10 ** 5 + 1):\n\n    s = i * 2 * C + max(0, X - i) * A + max(0, Y - i) * B\n\n    ans = min(ans, s)\n\n\n\nprint(ans)","reference_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nif X > Y:\n\n    v = A\n\nelse:\n\n    v = B\n\n\n\nans = min(A*X+B*Y, C*max(X, Y)*2, C*min(X,Y)*2+(max(X,Y)-min(X,Y))*v)\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read input values\nA, B, C, X, Y = map(int, input().split())\n\n# Initialize the answer with a large number\nans = float('inf')\n\n# Iterate over all possible values of i from 0 to 10^5\nfor i in range(X + 1):\n    s = 2 * C * i + A * (X - i) + B * Y\n    ans = min(ans, s)\n\nfor i in range(Y + 1):\n    s = 2 * C * i + A * X + B * (Y - i)\n    ans = min(ans, s)\n\nprint(ans)"}
{"problem_id":"p02612","slow_code_col":"import sys\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN = int(read())\n\nx = N + (-N) % 1000\n\nprint((x - N))","reference_code_col":"import math\n\nN = int(eval(input()))\n\nx = math.ceil(N\/1000) * 1000\n\nprint((x-N))","model_generated_potentially_faster_code_col":"import sys\n\n# Read input directly from stdin\nN = int(sys.stdin.readline().strip())\n\n# Calculate the result\nresult = (N \/\/ 1000 + 1) * 1000 - N\n\n# Print the result\nprint(result)"}
{"problem_id":"p03013","slow_code_col":"import numpy as np\n\ndef resolve():\n\n    MOD = 10 ** 9 + 7\n\n    n, m = list(map(int, input().split()))\n\n    a = [int(eval(input())) for _ in range(m)]\n\n\n\n    dp = np.array([1] * (n + 1))\n\n    dp[a] = 0\n\n\n\n    for i in range(2, n + 1):\n\n        if dp[i] != 0:\n\n            dp[i] = np.sum(dp[i - 2:i]) % MOD\n\n\n\n    print((dp[n]))\n\n    \n\nresolve()","reference_code_col":"def resolve():\n\n    MOD = 10 ** 9 + 7\n\n    n, m = list(map(int, input().split()))\n\n\n\n    # i\u6bb5\u76ee\u306b\u5230\u9054\u3059\u308b\u307e\u3067\u306e\u30eb\u30fc\u30c8\u306e\u7dcf\u6570\n\n    dp = [1] * (n + 1)\n\n\n\n    for _ in range(m):\n\n        dp[int(eval(input()))] = 0\n\n\n\n    for i in range(2, n + 1):\n\n        if dp[i] == 0:\n\n            continue\n\n\n\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n\n\n\n    print((dp[n]))\n\n    \n\nresolve()","model_generated_potentially_faster_code_col":"import numpy as np\n\nMOD = 10 ** 9 + 7\n\nn, m = list(map(int, input().split()))\na = [int(eval(input())) for _ in range(m)]\n\ndp = np.zeros(n + 1)\ndp[0], dp[1] = 1, 1\n\nfor x in a:\n    dp[x] = 0\n\nprefix_sum = np.cumsum(dp)\n\nfor i in range(2, n + 1):\n    if dp[i] != 0:\n        dp[i] = prefix_sum[i] - prefix_sum[i - 2]\n\nprint(dp[n])"}
{"problem_id":"p02596","slow_code_col":"def c_repsept():\n\n    K = int(eval(input()))\n\n\n\n    L = 9 * K \/\/ 7 if K % 7 == 0 else 9 * K\n\n    if L % 2 == 0 or L % 5 == 0:\n\n        return -1\n\n\n\n    remainder = 1\n\n    for n in range(1, L + 1):\n\n        remainder = (10 * remainder) % L\n\n        if remainder == 1:\n\n            return n\n\n    return -1\n\n\n\nprint((c_repsept()))","reference_code_col":"def c_repsept_totient():\n\n    def euler_phi(n):\n\n        \"\"\"\u6b63\u6574\u6570 n \u306b\u5bfe\u3057\u3066\u3001n \u3068\u4e92\u3044\u306b\u7d20\u306a n \u4ee5\u4e0b\u306e\u6b63\u6574\u6570\u306e\u500b\u6570\"\"\"\n\n        ret = n\n\n        for i in range(2, int(n**0.5) + 1):\n\n            if n % i == 0:\n\n                ret = ret \/\/ i * (i - 1)\n\n                while n % i == 0:\n\n                    n \/\/= i\n\n        if n > 1:\n\n            ret -= ret \/\/ n\n\n        return ret\n\n\n\n    def divisor_list(n):\n\n        \"\"\"n \u306e\u6b63\u306e\u7d04\u6570\u306e\u30ea\u30b9\u30c8\"\"\"\n\n        ret = set()\n\n        for k in range(1, int(n**0.5) + 1):\n\n            if n % k == 0:\n\n                ret.update({k, n \/\/ k})\n\n        return sorted(ret)\n\n\n\n    K = int(eval(input()))\n\n    L = 9 * (K \/\/ 7 if K % 7 == 0 else K)\n\n\n\n    for d in divisor_list(euler_phi(L)):\n\n        if pow(10, d, L) == 1:\n\n            return d\n\n    return -1\n\n\n\nprint((c_repsept_totient()))","model_generated_potentially_faster_code_col":"def c_repsept():\n    K = int(eval(input()))\n\n    # Calculate L based on the given formula\n    L = 9 * K \/\/ 7 if K % 7 == 0 else 9 * K\n\n    # Check if L is divisible by 2 or 5\n    if L % 2 == 0 or L % 5 == 0:\n        return -1\n\n    # Use Euler's theorem to find the smallest positive integer n such that 10^n \u2261 1 (mod L)\n    phi_l = L - 1  # Euler's totient function \u03c6(L)\n\n    while True:\n        if pow(10, phi_l, L) == 1:  # Using built-in pow() function with three arguments\n            return phi_l\n        phi_l -= 1\n\nprint(c_repsept())"}
{"problem_id":"p03039","slow_code_col":"H, W, K = list(map(int, input().split()))\n\nMOD = 10 ** 9 + 7\n\n\n\nHd = sum([d * (H - d) * (W ** 2) for d in range(H)])\n\nWd = sum([d * (W - d) * (H ** 2) for d in range(W)])\n\n\n\n\n\n# \u968e\u4e57 & \u9006\u5143\u8a08\u7b97\n\nfactorial = [1]\n\ninverse = [1]\n\nfor i in range(1, H * W + 2):\n\n    factorial.append(factorial[-1] * i % MOD)\n\n    inverse.append(pow(factorial[-1], MOD - 2, MOD))\n\n\n\n\n\nans = (Hd + Wd) * factorial[H * W - 2] * inverse[K - 2] * inverse[H * W - K] % MOD\n\nprint(ans)\n","reference_code_col":"H, W, K = list(map(int, input().split()))\n\nMOD = 10 ** 9 + 7\n\n\n\nfactorial = [1, 1]  # \u5143\u30c6\u30fc\u30d6\u30eb\n\ninverse = [1, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\ninverse_from = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n\n\nfor i in range(2, H * W + 1):\n\n    factorial.append((factorial[-1] * i) % MOD)\n\n    inverse_from.append((-inverse_from[MOD % i] * (MOD \/\/ i)) % MOD)\n\n    inverse.append((inverse[-1] * inverse_from[-1]) % MOD)\n\n\n\n\n\ndef nCr(n, r):\n\n    if n < r or r < 0:\n\n        return 0\n\n    elif r == 0:\n\n        return 1\n\n    return factorial[n] * inverse[r] * inverse[n - r] % MOD\n\n\n\n\n\nans = 0\n\n# H\u306b\u3064\u3044\u3066\n\nfor d in range(1, H):\n\n    ans += d * (H - d) * pow(W, 2, MOD) * nCr(H * W - 2, K - 2) % MOD\n\n    ans %= MOD\n\n# W\u306b\u3064\u3044\u3066\n\nfor d in range(1, W):\n\n    ans += d * (W - d) * pow(H, 2, MOD) * nCr(H * W - 2, K - 2) % MOD\n\n    ans %= MOD\n\n\n\nprint((ans % MOD))\n","model_generated_potentially_faster_code_col":"from math import comb\n\n# Input values\nH, W, K = map(int, input().split())\n\n# Constants\nMOD = 10 ** 9 + 7\n\n# Precompute binomial coefficients modulo MOD\nbinom_mod = [[comb(i, j) % MOD for j in range(i + 1)] for i in range(H * W + 2)]\n\n# Calculate Hd and Wd using combinatorial identities\nHd = sum((i * (H - i) * (W ** 2) * binom_mod[H * W][K]) % MOD for i in range(H))\nWd = sum((i * (W - i) * (H ** 2) * binom_mod[H * W][K]) % MOD for i in range(W))\n\n# Calculate the final answer using modular arithmetic properties\nans = ((Hd + Wd) * pow(binom_mod[H * W][K], MOD - 2, MOD)) % MOD\n\n# Output the result\nprint(ans)"}
{"problem_id":"p03078","slow_code_col":"# -*- coding: utf-8 -*-\n\nx, y, z, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\n\n\na.sort(reverse=True)\n\nb.sort(reverse=True)\n\nc.sort(reverse=True)\n\n\n\nabc = []\n\n\n\nfor i, _a in enumerate(a):\n\n    for j, _b in enumerate(b):\n\n        if (i+1) * (j+1) > k:\n\n            break\n\n        for l, _c in enumerate(c):\n\n            if (i+1) * (j+1) * (l+1) > k:\n\n                break\n\n            abc.append(_a + _b + _c)\n\n\n\nabc.sort(reverse=True)\n\nfor x in abc[:k]:\n\n    print(x)\n","reference_code_col":"# -*- coding: utf-8 -*-\n\nimport heapq\n\n\n\nx, y, z, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\n\n\nla, lb, lc = len(a), len(b), len(c)\n\n\n\na.sort(reverse=True)\n\nb.sort(reverse=True)\n\nc.sort(reverse=True)\n\n\n\nfix = set()\n\n\n\nq = [(-(a[0]+b[0]+c[0]), 0, 0, 0)]\n\n\n\nfor _ in range(k):\n\n    abc, i, j, l = heapq.heappop(q)\n\n    print((-abc))\n\n\n\n    if i+1 < la and (i+1, j, l) not in fix:\n\n        heapq.heappush(q, (-(a[i+1]+b[j]+c[l]), i+1, j, l))\n\n        fix.add((i+1, j, l))\n\n\n\n    if j+1 < lb and (i, j+1, l) not in fix:\n\n        heapq.heappush(q, (-(a[i]+b[j+1]+c[l]), i, j+1, l))\n\n        fix.add((i, j+1, l))\n\n\n\n    if l+1 < lc and (i, j, l+1) not in fix:\n\n        heapq.heappush(q, (-(a[i]+b[j]+c[l+1]), i, j, l+1))\n\n        fix.add((i, j, l+1))\n","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nx, y, z, k = map(int, input().split())\n\na = sorted(map(int, input().split()), reverse=True)\nb = sorted(map(int, input().split()), reverse=True)\nc = sorted(map(int, input().split()), reverse=True)\n\nprefix_sum_b = [0] * (y + 1)\nprefix_sum_c = [0] * (z + 1)\n\nfor i in range(1, y + 1):\n    prefix_sum_b[i] = prefix_sum_b[i - 1] + b[i - 1]\n\nfor i in range(1, z + 1):\n    prefix_sum_c[i] = prefix_sum_c[i - 1] + c[i - 1]\n\nresult = []\n\nfor i in range(min(k, x)):\n    target = k \/\/ (i + 1)\n    left = 0\n    right = y\n\n    while left < right:\n        mid = (left + right + 1) \/\/ 2\n        if prefix_sum_b[mid] >= target:\n            left = mid\n        else:\n            right = mid - 1\n\n    for j in range(left, max(0, k \/\/ (i + 1) - (x - i - 1) * y), -1):\n        remaining = k - (i + 1) * (j + 1)\n        if remaining <= 0:\n            continue\n\n        left = 0\n        right = z\n\n        while left < right:\n            mid = (left + right + 1) \/\/ 2\n            if prefix_sum_c[mid] >= remaining:\n                left = mid\n            else:\n                right = mid - 1\n\n        result.append(a[i] + b[j] + c[left])\n\nresult.sort(reverse=True)\nprint(result[k - 1])"}
{"problem_id":"p03559","slow_code_col":"N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nA.sort()\n\nC.sort()\n\n\n\nans = 0\n\nfrom bisect import bisect, bisect_left\n\nfor b in B:\n\n    i = bisect_left(A, b)\n\n    j = bisect(C, b)\n\n    ans += i * (N-j)\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nA.sort()\n\nC.sort()\n\n\n\nfrom bisect import bisect_left, bisect\n\nans = 0\n\nfor b in B:\n\n    i = bisect_left(A,b)\n\n    j = bisect(C,b)\n\n    ans += i * (N-j)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\nfrom bisect import bisect_left, bisect_right\n\n# Read input from stdin\ninput_data = sys.stdin.read()\ndata = input_data.split()\n\n# Convert input to integers\nN = int(data[0])\nA = list(map(int, data[1:N+1]))\nB = list(map(int, data[N+1:2*N+1]))\nC = list(map(int, data[2*N+1:]))\n\n# Sort arrays A and C\nA.sort()\nC.sort()\n\n# Initialize answer\nans = 0\n\n# Use bisect functions to count valid pairs\nfor b in B:\n    i = bisect_left(A, b)\n    j = bisect_right(C, b)\n    ans += i * (N - j)\n\nprint(ans)"}
{"problem_id":"p03674","slow_code_col":"n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nD = {i: [0] for i in range(1, n+1)}\n\nfor i in range(n+1):\n\n  D[a[i]][0] += 1\n\n  D[a[i]].append(i)\n\npl, pr = 0, 0\n\nfor i in D:\n\n  if D[i][0] == 2:\n\n    pl = D[i][1]\n\n    pr = D[i][2]\n\n    break\n\nL = pl\n\nM = pr - pl - 1\n\nN = n - pr\n\nmod = int(1e9) + 7 # <-- input modulo\n\nmaxf = n+11          # <-- input factional limitation\n\n\n\ndef make_fact(n, k):\n\n    tmp = n\n\n    perm = [i for i in range(k)]\n\n    L = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        L[i] = tmp % (i + 1)\n\n        tmp \/\/= i + 1\n\n    LL = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        LL[i] = perm[L[-i-1]]\n\n        for j in range(L[-i-1]+1, k):\n\n            perm[j-1] = perm[j]\n\n    return LL\n\n\n\ndef doubling(n, m, modulo=mod):\n\n    y = 1\n\n    base = n\n\n    tmp = m\n\n    while tmp != 0:\n\n        if tmp % 2 == 1:\n\n            y *= base\n\n            if modulo > 0:\n\n                y %= modulo\n\n        base *= base\n\n        if modulo > 0:\n\n            base %= modulo\n\n        tmp \/\/= 2\n\n    return y\n\n\n\ndef inved(a, modulo=mod):\n\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n\n    while l != 0:\n\n        x, y, u, v = u, v, x - u * (k \/\/ l), y - v * (k \/\/ l)\n\n        k, l = l, k % l\n\n    return x % modulo\n\n\n\nfact = [1 for _ in range(maxf+1)]\n\ninvf = [1 for _ in range(maxf+1)]\n\n\n\nfor i in range(maxf):\n\n    fact[i+1] = (fact[i] * (i+1)) % mod\n\ninvf[-1] = inved(fact[-1])\n\nfor i in range(maxf, 0, -1):\n\n    invf[i-1] = (invf[i] * i) % mod\n\n\n\nfor i in range(1, n+2):\n\n  S = fact[n]*invf[i-1]*invf[n-i+1]%mod\n\n  if i <= n-1:\n\n    S += fact[n-1]*invf[i]*invf[n-1-i]%mod\n\n    S %= mod\n\n  if i <= n-M:\n\n    S -= fact[n-1-M]*invf[i-1]*invf[n-M-i]%mod\n\n    S %= mod\n\n  if i <= n:\n\n    S += fact[n-1]*invf[i-1]*invf[n-i]%mod\n\n    S %= mod\n\n  print(S)","reference_code_col":"n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nD = {i: [0] for i in range(1, n+1)}\n\nfor i in range(n+1):\n\n  D[a[i]][0] += 1\n\n  D[a[i]].append(i)\n\npl, pr = 0, 0\n\nfor i in D:\n\n  if D[i][0] == 2:\n\n    pl = D[i][1]\n\n    pr = D[i][2]\n\n    break\n\nL = pl\n\nM = pr - pl - 1\n\nN = n - pr\n\nmod = int(1e9) + 7 # <-- input modulo\n\nmaxf = n+11          # <-- input factional limitation\n\n\n\ndef make_fact(n, k):\n\n    tmp = n\n\n    perm = [i for i in range(k)]\n\n    L = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        L[i] = tmp % (i + 1)\n\n        tmp \/\/= i + 1\n\n    LL = [0 for _ in range(k)]\n\n    for i in range(k):\n\n        LL[i] = perm[L[-i-1]]\n\n        for j in range(L[-i-1]+1, k):\n\n            perm[j-1] = perm[j]\n\n    return LL\n\n\n\ndef doubling(n, m, modulo=mod):\n\n    y = 1\n\n    base = n\n\n    tmp = m\n\n    while tmp != 0:\n\n        if tmp % 2 == 1:\n\n            y *= base\n\n            if modulo > 0:\n\n                y %= modulo\n\n        base *= base\n\n        if modulo > 0:\n\n            base %= modulo\n\n        tmp \/\/= 2\n\n    return y\n\n\n\ndef inved(a, modulo=mod):\n\n    x, y, u, v, k, l = 1, 0, 0, 1, a, modulo\n\n    while l != 0:\n\n        x, y, u, v = u, v, x - u * (k \/\/ l), y - v * (k \/\/ l)\n\n        k, l = l, k % l\n\n    return x % modulo\n\n\n\nfact = [1 for _ in range(maxf+1)]\n\ninvf = [1 for _ in range(maxf+1)]\n\n\n\nfor i in range(maxf):\n\n    fact[i+1] = (fact[i] * (i+1)) % mod\n\ninvf[-1] = inved(fact[-1])\n\nfor i in range(maxf, 0, -1):\n\n    invf[i-1] = (invf[i] * i) % mod\n\n\n\nfor i in range(1, n+2):\n\n  S = fact[n+1]*invf[i]*invf[n-i+1]%mod\n\n  if i <= n-M:\n\n    S -= fact[n-1-M]*invf[i-1]*invf[n-M-i]%mod\n\n    S %= mod\n\n  print(S)\n","model_generated_potentially_faster_code_col":"n = int(input())\na = list(map(int, input().split()))\nD = {}\nfor i, num in enumerate(a):\n    if num not in D:\n        D[num] = [0, i]\n    else:\n        D[num][0] += 1\n        D[num].append(i)\n\npl, pr = 0, 0\nfor key, value in D.items():\n    if value[0] == 2:\n        pl, pr = value[1], value[2]\n        break\n\nL = pl\nM = pr - pl - 1\nN = n - pr\nmod = int(1e9) + 7\n\nfact = [1] * (n + 1)\nfor i in range(1, n + 1):\n    fact[i] = fact[i - 1] * i % mod\n\ninvf = [1] * (n + 1)\ninvf[n] = pow(fact[n], mod - 2, mod)\nfor i in range(n - 1, 0, -1):\n    invf[i] = invf[i + 1] * (i + 1) % mod\n\nresult = []\nfor i in range(1, n + 2):\n    S = fact[n] * invf[i - 1] * invf[n - i + 1] % mod\n    if i <= n - 1:\n        S += fact[n - 1] * invf[i] * invf[n - 1 - i] % mod\n        S %= mod\n    if i <= n - M:\n        S -= fact[n - 1 - M] * invf[i - 1] * invf[n - M - i] % mod\n        S %= mod\n    if i <= n:\n        S += fact[n - 1] * invf[i - 1] * invf[n - i] % mod\n        S %= mod\n    result.append(S)\n\nprint('\\n'.join(map(str, result)))"}
{"problem_id":"p02952","slow_code_col":"n = int(eval(input()))\n\n\n\n\n\ndef countKeta(num):\n\n    count = 1\n\n    while num \/ 10 >= 1:\n\n        count += 1\n\n        num = num \/\/ 10\n\n    return count\n\n\n\n\n\ncount = 0\n\n\n\nfor i in range(1, n+1):\n\n    if(countKeta(i) % 2 == 1):\n\n        count += 1\n\n\n\nprint(count)","reference_code_col":"n = int(eval(input()))\n\n\n\nif n < 10:\n\n    print(n)\n\nelif n < 100:\n\n    print((9))\n\nelif n < 1000:\n\n    print((n-90))\n\nelif n < 10000:\n\n    print((909))\n\nelif n < 100000:\n\n    print((n-9090))\n\nelif n < 1000000:\n\n    print((90909))","model_generated_potentially_faster_code_col":"import math\n\nn = int(eval(input()))\n\ncount = 0\n\nfor i in range(1, n + 1):\n    if (int(math.log10(i)) + 1) % 2 == 1:\n        count += 1\n\nprint(count)"}
{"problem_id":"p03721","slow_code_col":"import numpy as np\n\n\n\nn, k = list(map(int, input().split()))\n\nz = np.zeros(10**5 + 1)\n\nfor i in range(n):\n\n  a, b = list(map(int, input().split()))\n\n  z[a] += b\n\n\n\na = 0\n\nfor i in range(1, 10**5 + 1):\n\n  if k <= z[i]:\n\n    a = i\n\n    break\n\n  k -= z[i]\n\n\n\nprint((int(a)))\n","reference_code_col":"n, k = list(map(int, input().split()))\n\nd = {}\n\nfor i in range(n):\n\n  a, b = list(map(int, input().split()))\n\n  d[a] = d[a] + b if a in d else b\n\n \n\na = 0\n\nfor i in range(1, 10**5+1):\n\n  if i in d and k <= d[i]:\n\n    a = i\n\n    break\n\n  k -= d[i] if i in d else 0\n\n \n\nprint(a)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn, k = map(int, input().split())\n\n# Initialize an array with zeros\nz = np.zeros(10**5 + 2, dtype=int)  # Increase size to avoid index out of bounds\n\n# Populate the array with cumulative sums\nfor _ in range(n):\n    a, b = map(int, input().split())\n    z[a] += b\n    z[a+1:] += b  # Update the rest of the array at once\n\n# Find the smallest index where k <= cumulative sum\nindex = np.argmax(z >= k)\n\nprint(index)"}
{"problem_id":"p02996","slow_code_col":"\n\n\n\nn = int(eval(input()))\n\n\n\nabn = [list(map(int,input().split())) for _ in range(n)]\n\n\n\n\n\nabn.sort()\n\nabn.sort(key = lambda x:x[1])\n\n\n\n\n\n#print(abn)\n\n\n\nts = 0 # time_stamp\n\nenable = True\n\nfor abi in abn:\n\n    a, b = abi\n\n\n\n    if not ts + a <= b:\n\n        enable = False\n\n        break\n\n    else:\n\n        ts += a\n\n\n\nprint(('Yes' if enable else 'No'))","reference_code_col":"\n\nn = int(eval(input()))\n\n\n\nabn = [list(map(int,input().split())) for _ in range(n)]\n\n\n\n\n\n#abn.sort()\n\nabn.sort(key = lambda x:x[1])\n\n\n\n\n\n#print(abn)\n\n\n\nts = 0 # time_stamp\n\nenable = True\n\nfor abi in abn:\n\n    a, b = abi\n\n\n\n    if not ts + a <= b:\n\n        enable = False\n\n        break\n\n    else:\n\n        ts += a\n\n\n\nprint(('Yes' if enable else 'No'))","model_generated_potentially_faster_code_col":"n = int(eval(input()))\n\nabn = [list(map(int, input().split())) for _ in range(n)]\n\n# Sort based on the second value then first\nabn.sort(key=lambda x: (x[1], x[0]))\n\n# Initialize variables\nts = 0  # time_stamp\nenable = True\n\nfor abi in abn:\n    a, b = abi\n    \n    if not ts + a <= b:\n        enable = False\n        break\n    \n    ts += a\n\nprint('Yes' if enable else 'No')"}
{"problem_id":"p00053","slow_code_col":"def isPrime(x):\n\n    if x == 2:\n\n        return True\n\n    if x < 2 or x % 2 == 0:\n\n        return False\n\n    i, root_x = 3, int(pow(x, 0.5))\n\n    while i <= root_x:\n\n        if x % i == 0:\n\n            return False\n\n        i += 2\n\n    return True\n\n\n\nprimes = [2]\n\nfor i in range(3, 104730):\n\n    if isPrime(i):\n\n        primes.append(primes[-1]+i)\n\nwhile True:\n\n    n = int(eval(input()))\n\n    if n == 0:\n\n        break\n\n    print((primes[n-1]))","reference_code_col":"primes = [0, 0] + [1] * 150000\n\nfor i in range(2, 388):\n\n    if primes[i]:\n\n        for j in range(i*i, 150001, i):\n\n            primes[j] = 0\n\n\n\nvalues = [i for i, v in enumerate(primes) if v]\n\nwhile True:\n\n    n = int(eval(input()))\n\n    if n == 0:\n\n        break\n\n    print((sum(values[:n])))","model_generated_potentially_faster_code_col":"def is_prime(num):\n    if num == 2: \n        return True\n    if num < 2 or num % 2 == 0: \n        return False\n    limit = int(num ** 0.5) + 1\n    for divisor in range(3, limit, 2):\n        if num % divisor == 0:\n            return False\n    return True\n\n\nprimes = [2]\nfor i in range(3, 104730, 2): # Only check odd numbers\n    if is_prime(i):\n        primes.append(primes[-1] + i)\n\n\nwhile True:\n    try:\n        n = int(input())\n        if n == 0:\n            break\n        print(primes[n - 1])\n    except EOFError:\n        break"}
{"problem_id":"p03162","slow_code_col":"# https:\/\/atcoder.jp\/contests\/dp\/tasks\/dp_c\n\nimport numpy as np\n\nN = int(eval(input()))\n\nMax_List=[]\n\nN_List=[i for i in range(3)]\n\nfor i in range(N):\n\n    Current_List=list(map(int,input().split())) \n\n    if i == 0:\n\n        Max_List.append(Current_List)\n\n    else:\n\n        Current_Max_List = []\n\n        for j in range(3):\n\n            Index_List=np.array(Max_List[i-1])\n\n            ind = np.ones(3, dtype=bool)\n\n            ind[j] = False\n\n            Current_Max_List.append(max(Index_List[ind])+Current_List[j])\n\n            \n\n        Max_List.append(Current_Max_List)\n\n        \n\n    \n\nprint((max(Max_List[-1])))","reference_code_col":"# https:\/\/atcoder.jp\/contests\/dp\/tasks\/dp_c\n\nN = int(eval(input()))\n\nMax_List=[]\n\nN_List=[i for i in range(3)]\n\nfor i in range(N):\n\n    Current_List=list(map(int,input().split())) \n\n    if i == 0:\n\n        Max_List.append(Current_List)\n\n    else:\n\n        Current_Max_List = []\n\n        Search_List=Max_List[i-1]\n\n        for j in range(3):\n\n            Current_Search_List=Search_List[1:3]\n\n            Current_Max_List.append(max(Current_Search_List)+Current_List[j])\n\n            Search_List.append(Search_List[0])\n\n            del Search_List[0]\n\n        Max_List.append(Current_Max_List)\n\n        \n\n    \n\nprint((max(Max_List[-1])))","model_generated_potentially_faster_code_col":"N = int(input())\n\nmax_list = [[0, 0, 0]]\n\nfor _ in range(N):\n    current_list = list(map(int, input().split()))\n    \n    if len(max_list) == 1:\n        max_list[0] = current_list\n    else:\n        new_max_list = [0, 0, 0]\n        \n        for j in range(3):\n            max_values = [max_list[-1][k] for k in range(3) if k != j]\n            new_max_list[j] = max(max_values) + current_list[j]\n            \n        max_list.append(new_max_list)\n\nprint(max(max_list[-1]))"}
{"problem_id":"p03835","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nK, S = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor z in range(K+1):\n\n    for y in range(K+1):\n\n        x = S - (z + y)\n\n        if x >= 0 and x <= K:\n\n            ans += 1\n\nprint(ans)","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nK, S = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor z in range(K+1):\n\n    for y in range(K+1):\n\n        x = S - (z + y)\n\n        if 0 <= x <= K:\n\n            ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\nK, S = map(int, input().split())\n\nans = 0\n\nfor z in range(min(S, K)+1):\n    for y in range(min(S-z, K-z)+1):\n        ans += 1\n\nprint(ans)"}
{"problem_id":"p02996","slow_code_col":"n=int(eval(input()))\n\ntask=[] \n\nfor _ in range(n):\n\n    a,b=list(map(int,input().split()))\n\n    task.append((b, -a))\n\n\n\ntask.sort()\n\n\n\ntime=0\n\nflag=True\n\nfor i in task:\n\n    time-=i[1]\n\n    if time>i[0]:\n\n        flag=False\n\n        break\n\n\n\nif flag:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")\n\n\n","reference_code_col":"import sys\n\nfrom collections import defaultdict\n\nfrom operator import itemgetter\n\ninput = sys.stdin.readline\n\n\n\nN = int(eval(input()))\n\nd = defaultdict(int)\n\nfor _ in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    d[b] += a\n\ntask = list(d.items())\n\ntask.sort()\n\n\n\nnow = 0\n\nans = \"Yes\"\n\nfor limit, time in task:\n\n    now += time\n\n    if now > limit:\n\n        ans = \"No\"\n\n        break\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"def can_complete_tasks(n):\n    # Read all inputs at once for better performance\n    inputs = [tuple(map(int, input().split())) for _ in range(n)]\n\n    # Sort tasks based on deadline (b), and start time (-a)\n    inputs.sort()\n\n    # Initialize variables\n    time = 0\n    flag = True\n\n    # Process tasks\n    for b, a in inputs:\n        time -= a\n        if time > b:\n            flag = False\n            break\n\n    return \"Yes\" if flag else \"No\"\n\n# Read input\nn = int(input())\nresult = can_complete_tasks(n)\nprint(result)"}
{"problem_id":"p02767","slow_code_col":"import numpy as np\n\n\n\nn = int(eval(input()))\n\nx = list(map(int,input().split()))\n\nx2 = np.power(x,2)\n\n\n\np1 = sum(x)\/\/n\n\np2 = -(-sum(x)\/\/n)\n\n\n\nw1 = n*(p1**2) -2*sum(x)*p1 +sum(x2)\n\nw2 = n*(p2**2) -2*sum(x)*p2 +sum(x2)\n\n\n\nprint((min(w1,w2)))","reference_code_col":"n = int(eval(input()))\n\nX = sorted(map(int,input().split()))\n\nans = 10**6\n\n\n\nfor i in range(X[0],X[-1]+1):\n\n    HP = 0\n\n    \n\n    for j in X:\n\n        HP += (j - i) ** 2\n\n        \n\n    ans = min(ans,HP)\n\n    \n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n\nn = int(input())\nx = np.array(list(map(int, input().split())))\n\n\nx2 = x ** 2\n\n\np1 = np.mean(x)\np2 = round(np.mean(x))\n\n\nw1 = n * (p1 ** 2) - 2 * np.sum(x) * p1 + np.sum(x2)\nw2 = n * (p2 ** 2) - 2 * np.sum(x) * p2 + np.sum(x2)\n\n\nprint(min(w1, w2))"}
{"problem_id":"p03038","slow_code_col":"from collections import Counter,defaultdict,deque\n\nfrom heapq import heapify,heappop,heappush\n\nfrom bisect import bisect_left,bisect_right\n\nimport sys,math,itertools,string,queue\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn,m = inpl()\n\na = inpl()\n\nb = [0] * m\n\nfor i in range(m):\n\n    x,y = inpl()\n\n    b[i] = [x,y]\n\na.sort()\n\nb.sort(key=lambda x:x[1], reverse = True)\n\nres = sum(a)\n\ni = 0\n\nj = 0\n\nwhile True:\n\n    # print(i,j)\n\n    if a[i] < b[j][1]:\n\n        res += b[j][1] - a[i]\n\n        i += 1\n\n    else:\n\n        break\n\n    b[j][0] -= 1\n\n    if b[j][0] == 0:\n\n        j += 1\n\n    if i >= n or j >= m:\n\n        break\n\nprint(res)\n","reference_code_col":"from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nfrom bisect import bisect_left,bisect_right \n\nimport sys,math,itertools,fractions,pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn,m = inpl()\n\na = inpl()\n\na.sort()\n\nbc = [inpl() for _ in range(m)]\n\nbc.sort(key = lambda x:x[1], reverse = True)\n\nlm = sum(x[1] for x in bc)\n\nnow = 0\n\nalt = 0\n\nwhile now < n and alt < m:\n\n    c,b = bc[alt]\n\n    if a[now] > b:\n\n        break\n\n    else:\n\n        a[now] = b\n\n    bc[alt][0] -= 1\n\n    if bc[alt][0] == 0:\n\n        alt += 1\n\n    now += 1\n\nprint((sum(a)))\n","model_generated_potentially_faster_code_col":"from collections import defaultdict\nimport heapq\n\nn, m = map(int, input().split())\na = sorted(map(int, input().split()))\nb = [tuple(map(int, input().split())) for _ in range(m)]\nb.sort(key=lambda x: x[1], reverse=True)\n\nres = sum(a)\ni = 0\nj = 0\nq = []\n\nwhile i < n and j < m:\n    while q and q[0][0] <= a[i]:\n        _, k = heapq.heappop(q)\n        b[k][0] += 1\n    \n    if not b[j][0]:\n        j += 1\n        continue\n    \n    heapq.heappush(q, (-b[j][1], j))\n    res += b[j][1] - a[i]\n    i += 1\n    b[j][0] -= 1\n\nprint(res)"}
{"problem_id":"p03325","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\na = list(map(int,input().split()))\n\nans = 0\n\na = np.array(a)\n\nwhile a.size > 0:\n\n    a = a[a%2 == 0]\n\n    ans += len(a)\n\n    a = a\/\/2\n\nprint(ans)","reference_code_col":"n = int(eval(input()))\n\na = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(n):\n\n    while a[i]%2 == 0:\n\n        a[i] \/\/=2\n\n        ans+=1\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(eval(input()))\na = list(map(int, input().split()))\nans = 0\n\n# Convert the list to a NumPy array\na = np.array(a)\n\n# Iterate while there are elements in the array\nwhile a.size > 0:\n    # Count the number of even elements\n    count_even = np.sum(a % 2 == 0)\n    \n    # Add the count of even elements to the answer\n    ans += count_even\n    \n    # Right shift all elements by 1 bit (equivalent to dividing by 2)\n    a >>= 1\n\nprint(ans)"}
{"problem_id":"p03013","slow_code_col":"import numpy as np\n\n\n\nn, m = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(m)] + [0]\n\nmod = 10 ** 9 + 7\n\n\n\ndp = np.zeros(n + 1, dtype=np.int64)\n\ndp[0] = 1\n\nb = a[0]\n\nj = 1\n\nfor i in range(1, n + 1):\n\n    if i == b:\n\n        b = a[j]\n\n        j += 1\n\n    else:\n\n        tmp = dp[i - 2] + dp[i - 1]\n\n        if tmp >= mod:\n\n            tmp -= mod\n\n        dp[i] = tmp\n\nprint((int(dp[-1])))","reference_code_col":"n, m = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(m)] + [0]\n\nmod = 10 ** 9 + 7\n\n\n\ndp = [0] * (n + 1)\n\ndp[0] = 1\n\nb = a[0]\n\nj = 1\n\nfor i in range(1, n + 1):\n\n    if i == b:\n\n        b = a[j]\n\n        j += 1\n\n    else:\n\n        tmp = dp[i - 2] + dp[i - 1]\n\n        if tmp >= mod:\n\n            tmp -= mod\n\n        dp[i] = tmp\n\nprint((int(dp[-1])))","model_generated_potentially_faster_code_col":"import numpy as np\n\n\nn, m = map(int, input().split())\n\na = [int(eval(input())) for _ in range(m)]\n\nmod = int(1e9) + 7\n\ndp = np.ones(n + 1, dtype=np.int64)\ndp[0] = 0\n\ni = 1\nj = 0\n\nwhile i <= n and j < len(a):\n    \n    while i <= n and i != a[j]:\n        dp[i] = (dp[i-1] + dp[i-2]) % mod\n        i += 1\n        \n    if i > n:\n        break\n    \n    dp[i] = 0\n    j += 1\n    i += 1\n\nprint(dp[n])"}
{"problem_id":"p03013","slow_code_col":"N, M = list(map(int, input().split(\" \")))\n\nA = {int(eval(input())) for _ in range(M)}\n\n\n\nmemo = [0] * (N + 1)\n\nmemo[0] = 1\n\nmemo[1] = 0 if 1 in A else 1\n\n\n\nif N == 1:\n\n    print((memo[1]))\n\nelse:\n\n    for i in range(2, N + 1):\n\n        if i in A:\n\n            continue\n\n        memo[i] = (memo[i - 2] + memo[i - 1]) % 1000000007\n\n\n\n    print((memo[N]))\n","reference_code_col":"N, M = list(map(int, input().split(\" \")))\n\nA = {int(input()) for _ in range(M)}\n\n\n\nmemo = [0] * (N + 1)\n\nmemo[0] = 1\n\nmemo[1] = 0 if 1 in A else 1\n\n\n\nif N == 1:\n\n    print((memo[1]))\n\nelse:\n\n    for i in range(2, N + 1):\n\n        if i in A:\n\n            continue\n\n        memo[i] = (memo[i - 2] + memo[i - 1]) % 1000000007\n\n    print((memo[N]))\n","model_generated_potentially_faster_code_col":"def count_ways(N, A):\n    # Initialize memoization table with -1\n    memo = [-1] * (N + 1)\n    \n    def dp(n):\n        # Base cases\n        if n == 0:\n            return 1\n        elif n == 1:\n            return 0 if 1 in A else 1\n        \n        # Check if result is already computed\n        if memo[n] != -1:\n            return memo[n]\n        \n        # Calculate result recursively\n        if n not in A:\n            memo[n] = (dp(n - 2) + dp(n - 1)) % 1000000007\n        else:\n            memo[n] = 0\n        \n        return memo[n]\n    \n    return dp(N)\n\n# Read input\nN, M = map(int, input().split())\nA = {int(eval(input())) for _ in range(M)}\n\n# Print result\nprint(count_ways(N, A))"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nn = int(eval(input()))\n\nprint((math.factorial(n) % (10 ** 9 + 7)))","reference_code_col":"n = int(eval(input()))\n\np = 1\n\nfor i in range(1, n + 1):\n\n  p = p * i % (10 ** 9 + 7)\n\nprint(p)","model_generated_potentially_faster_code_col":"import math\n\nn = int(input())\n\n# Calculate factorial iteratively instead of using built-in function\nfactorial = 1\nfor i in range(2, n + 1):\n    factorial *= i\n\n# Take modulo with 10^9+7\nresult = factorial % (10 ** 9 + 7)\n\nprint(result)"}
{"problem_id":"p02883","slow_code_col":"N, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nF = list(map(int, input().split()))\n\n\n\nA.sort()\n\nF.sort(reverse=True)\n\n\n\n#\u7a4d\u3092x\u4ee5\u4e0b\u306b\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u4fee\u884c\u56de\u6570\n\ndef f(x):\n\n    r = 0\n\n    for i in range(N):\n\n        a, f = A[i], F[i]\n\n        m = a * f\n\n        if m > x:\n\n            r += (m - x + f - 1) \/\/ f\n\n    return r\n\n\n\nunder = -1\n\nr = 10**18\n\nwhile r - under > 1:\n\n    m = (under + r) \/\/ 2\n\n    if f(m) > K: under = m\n\n    else: r = m\n\nprint(r)","reference_code_col":"# \u3067\u3064oO(YOU PLAY WITH THE CARDS YOU'RE DEALT..)\n\nimport sys\n\ndef main(N, K, A, F):\n\n    A.sort()\n\n    F.sort(reverse=True)\n\n\n\n    def f(x):\n\n        sy = 0\n\n        for a, f in zip(A, F):\n\n            m = a * f\n\n            if m > x:\n\n                sy += (m - x + f - 1) \/\/ f\n\n        return sy\n\n\n\n    under = -1\n\n    hi = 10**12 + 1\n\n    while hi - under > 1:\n\n        m = (hi + under) \/\/ 2\n\n        if f(m) <= K: hi = m\n\n        else: under = m\n\n    print(hi)\n\n\n\nif __name__ == '__main__':\n\n    input = sys.stdin.readline\n\n    N, K = list(map(int, input().split()))\n\n    *A, = list(map(int, input().split()))\n\n    *F, = list(map(int, input().split()))\n\n    main(N, K, A, F)\n","model_generated_potentially_faster_code_col":"N, K = map(int, input().split())\n\nA = sorted(map(int, input().split()))\nF = sorted(map(int, input().split()), reverse=True)\n\n# Calculate prefix sum of F\nprefix_sum_F = [0] * (N + 1)\nfor i in range(1, N + 1):\n    prefix_sum_F[i] = prefix_sum_F[i - 1] + F[i - 1]\n\n# Calculate the number of training sessions required for a given x\ndef f(x):\n    total_sessions = 0\n    j = 0\n    for i in range(N):\n        while j < N and A[j] * F[j] <= x:\n            j += 1\n        if j == 0:\n            break\n        total_sessions += prefix_sum_F[j]\n    return total_sessions\n\nunder = -1\nr = 10**18\n\nwhile r - under > 1:\n    m = (under + r) \/\/ 2\n    if f(m) > K: under = m\n    else: r = m\n\nprint(r)"}
{"problem_id":"p03035","slow_code_col":"a,b=list(map(int,input().split()))\n\nprint((b if 13<=a else b\/\/2 if 6<=a else 0))","reference_code_col":"a,b=list(map(int,input().split()))\n\nprint((b if 12<a else b\/\/2 if 5<a else 0))","model_generated_potentially_faster_code_col":"def calculate(a, b):\n    if 13 <= a:\n        return b\n    elif 6 <= a:\n        return b \/\/ 2\n    else:\n        return 0\n\na, b = map(int, input().split())\nprint(calculate(a, b))"}
{"problem_id":"p02688","slow_code_col":"N,K=list(map(int,input().split()))\n\n\n\ncon = 0\n\nans = list(int() for _ in range(100000))\n\npre = 0\n\n\n\n\n\nfor _ in range(K):\n\n\n\n    D = int(eval(input()))\n\n    arr = list(map(int,input().split()))\n\n\n\n    for j in range(D):\n\n\n\n        ans[pre+j]=arr[j]\n\n\n\n    pre += D\n\n\n\n        \n\nfin = (N+1) - len(set(ans))\n\n\n\nprint(fin)","reference_code_col":"N,K=list(map(int,input().split()))\n\n\n\ncon = 0\n\nans = list(int() for _ in range(10001))\n\npre = 0\n\n\n\n\n\nfor _ in range(K):\n\n\n\n    D = int(eval(input()))\n\n    arr = list(map(int,input().split()))\n\n\n\n    for j in range(D):\n\n\n\n        ans[pre+j]=arr[j]\n\n\n\n    pre += D\n\n\n\n        \n\nfin = (N+1) - len(set(ans))\n\n\n\nprint(fin)","model_generated_potentially_faster_code_col":"N,K=list(map(int,input().split()))\ncon = 0\nans = [0]*N\npre = 0\nfor _ in range(K):\n    D = int(input())\n    arr = list(map(int,input().split()))\n    for j in range(D):\n        ans[pre+j]=arr[j]\n    pre += D\nfin = N - len(set(ans))\nprint(fin)"}
{"problem_id":"p03162","slow_code_col":"def main():\n\n  n = int(eval(input()))\n\n  a = [0]\n\n  b = [0]\n\n  c = [0]\n\n\n\n  for i in range(n):\n\n      aa,bb,cc = list(map(int,input().split()))\n\n      a.append(max(b[i] + aa, c[i] + aa))\n\n      b.append(max(a[i] + bb, c[i] + bb))\n\n      c.append(max(a[i] + cc, b[i] + cc))\n\n\n\n  print((max(a[-1], b[-1], c[-1])))\n\n\n\nmain()","reference_code_col":"def main():\n\n    n = int(eval(input()))\n\n    a = 0\n\n    b = 0\n\n    c = 0\n\n\n\n    for i in range(n):\n\n        aa,bb,cc = list(map(int,input().split()))\n\n        a,b,c = max(b,c)+aa, max(a,c)+bb, max(a,b)+cc\n\n\n\n    print((max(a,b,c)))\n\n\n\nmain()\n","model_generated_potentially_faster_code_col":"def main():\n    n = int(input())\n    \n    # Initialize the triangle with zero padding\n    triangle = [[0] * (i+1) for i in range(n)]\n    \n    # Read the input values into the triangle\n    for i in range(n):\n        row = list(map(int, input().split()))\n        for j in range(i+1):\n            triangle[i][j] = row[j]\n    \n    # Calculate the maximum sum path using dynamic programming\n    for i in range(n-2, -1, -1):\n        for j in range(i+1):\n            triangle[i][j] += max(triangle[i+1][j], triangle[i+1][j+1])\n    \n    # Print the maximum sum path\n    print(triangle[0][0])\n\nmain()"}
{"problem_id":"p03078","slow_code_col":"def main():\n\n    import sys\n\n    input = sys.stdin.readline\n\n    sys.setrecursionlimit(10**7)\n\n    from collections import Counter, deque\n\n    #from collections import defaultdict\n\n    from itertools import combinations, permutations, accumulate, groupby\n\n    #from itertools import product\n\n    from bisect import bisect_left,bisect_right\n\n    import heapq\n\n    from math import floor, ceil\n\n    #from operator import itemgetter\n\n\n\n    #inf = 10**17\n\n    #mod = 10**9 + 7\n\n\n\n    x,y,z,k = list(map(int, input().split()))\n\n    a = list(map(int, input().split()))\n\n    b = list(map(int, input().split()))\n\n    c = list(map(int, input().split()))\n\n    ab = []\n\n    for i in a:\n\n        for j in b:\n\n            ab.append(i+j)\n\n    ab.sort(reverse=1)\n\n    ab = ab[:k]\n\n    abc = []\n\n    for i in ab:\n\n        for j in c:\n\n            abc.append(i+j)\n\n    abc.sort(reverse=1)\n\n    for i in range(k):\n\n        print((abc[i]))\n\n\n\nif __name__ == '__main__':\n\n    main()","reference_code_col":"#xyz\u306e\u5168\u901a\u308a\u8abf\u3079\u308b\u3068\u9593\u306b\u5408\u308f\u306a\u3044\n\n#\u307e\u305a\u554f\u984c\u3092\u5206\u3051\u3088\u3046\n\n#\u5148\u306bxy\u3060\u3051\u8003\u3048\u3066\u307f\u308b\n\n#xy\u306e\u548c\u3092\u3068\u3063\u3066\u304b\u3089\u305d\u308c\u3068z\u306e\u548c\u3092\u3068\u308b\u3068\u304d\n\n#xy\u306e\u548c\u306b\u304a\u3044\u3066k\u756a\u76ee\u4ee5\u964d\u306e\u5024\u3092\u4f7f\u3046\u3053\u3068\u306f\u7121\u3044\n\n#\n\n\n\ndef main():\n\n    import sys\n\n    input = sys.stdin.readline\n\n    sys.setrecursionlimit(10**7)\n\n    from collections import Counter, deque\n\n    #from collections import defaultdict\n\n    from itertools import combinations, permutations, accumulate, groupby\n\n    #from itertools import product\n\n    from bisect import bisect_left,bisect_right\n\n    import heapq\n\n    from math import floor, ceil\n\n    #from operator import itemgetter\n\n\n\n    #inf = 10**17\n\n    #mod = 10**9 + 7\n\n\n\n    x,y,z,k = list(map(int, input().split()))\n\n    a = list(map(int, input().split()))\n\n    b = list(map(int, input().split()))\n\n    c = list(map(int, input().split()))\n\n    a.sort(reverse=1)\n\n    b.sort(reverse=1)\n\n    c.sort(reverse=1)\n\n    abc = []\n\n    for i in range(x):\n\n        for j in range(y):\n\n            if i*j>k:\n\n                continue\n\n            for t in range(z):\n\n                if i*j*t>k:\n\n                    continue\n\n                abc.append(a[i]+b[j]+c[t])\n\n    abc.sort(reverse=1)\n\n    for i in range(k):\n\n        print((abc[i]))\n\n\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    x, y, z, k = map(int, data[0:4])\n    a = list(map(int, data[4:4+x]))\n    b = list(map(int, data[4+x:4+x+y]))\n    c = list(map(int, data[4+x+y:]))\n\n    ab = []\n    for i in a:\n        for j in b:\n            ab.append(i + j)\n    ab.sort(reverse=True)[:k]\n\n    abc = []\n    for i in ab[:k]:\n        for j in c:\n            abc.append(i + j)\n    abc.sort(reverse=True)[:k]\n\n    for num in abc[:k]:\n        print(num)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02414","slow_code_col":"import sys\n\ne=[list(map(int,e.split()))for e in sys.stdin]\n\nn=e[0][0]+1\n\nfor c in e[1:n]:\n\n t=''\n\n for l in zip(*e[n:]):t+=f'{sum(s*t for s,t in zip(c,l))} '\n\n print((t[:-1]))\n","reference_code_col":"import sys\n\ne=[list(map(int,e.split()))for e in sys.stdin]\n\nn=e[0][0]+1\n\nt=''\n\nfor c in e[1:n]:\n\n for l in zip(*e[n:]):t+=f'{sum(s*t for s,t in zip(c,l))} '\n\n t=t[:-1]+'\\n'\n\nprint((t[:-1]))\n","model_generated_potentially_faster_code_col":"import sys\n\n# Read input from stdin\ninput_data = sys.stdin.read().splitlines()\n\n# Parse the input data\ne = [list(map(int, line.split())) for line in input_data]\n\n# Extract n\nn = e[0][0] + 1\n\n# Process each column\nresults = []\nfor c in e[1:n]:\n    # Calculate the result for this column\n    result = [str(sum(s * t for s, t in zip(c, l))) for l in zip(*e[n:])]\n    results.append(' '.join(result))\n\n# Print all results\nprint('\\n'.join(results))"}
{"problem_id":"p02886","slow_code_col":"n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nimport itertools as it\n\nimport numpy as np\n\nal=list(it.combinations(a,2))\n\ntotal=0\n\nfor i in al:\n\n    total+=np.prod(i)\n\nprint(total)","reference_code_col":"n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nans=0\n\nfor i in range(n-1):\n\n    for j in range(i+1,n):\n\n        ans+=a[i]*a[j]\n\nprint(ans)","model_generated_potentially_faster_code_col":"n = int(input())\na = list(map(int, input().split()))\n\ntotal = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        total += a[i] * a[j]\n\nprint(total)"}
{"problem_id":"p02552","slow_code_col":"x = int(eval(input()))\n\nif x == 0:\n\n  print((1))\n\nelse:\n\n  print((0))","reference_code_col":"x = int(eval(input()))\n\nprint((x^1))\n","model_generated_potentially_faster_code_col":"x = int(input())\n\nprint(1 if x == 0 else 0)"}
{"problem_id":"p03325","slow_code_col":"import numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.array(input().split(),dtype=np.int32)\n\n\n\ndef ord(n):\n\n  cnt = 0\n\n  while not n&1:\n\n    n >>= 1\n\n    cnt += 1\n\n  return cnt\n\n\n\nnp_ord = np.frompyfunc(ord,1,1)\n\nanswer = np_ord(A).sum()\n\nprint(answer)","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport numpy as np\n\n\n\nN = int(readline())\n\nA = np.array(read().split(),np.int32)\n\n\n\nanswer = 0\n\nfor _ in range(32):\n\n    A = A[A%2 == 0]\n\n    answer += len(A)\n\n    A >>= 1\n\n\n\nprint(answer)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN = int(input())\nA = np.array(input().split(), dtype=np.int32)\n\n# Function to count trailing zeros\ndef count_trailing_zeros(arr):\n    # Find the first non-zero bit position for each number\n    leading_ones = np.binary_repr(arr, width=arr.itemsize * 8).find('1')\n    # Calculate the number of trailing zeros\n    trailing_zeros = arr.itemsize * 8 - leading_ones - 1\n    return trailing_zeros\n\n# Apply the function to the array and sum the results\nanswer = count_trailing_zeros(A).sum()\n\n# Print the result\nprint(answer)"}
{"problem_id":"p02994","slow_code_col":"import numpy as np\n\n\n\nn,l = [int(x) for x in input().split()] \n\nx = np.arange(l,l+n)\n\ny = np.abs(x)\n\nx = np.delete(x, np.argmin(y))\n\nprint((np.sum(x)))","reference_code_col":"N, L = list(map(int, input().split()))\n\napples = [i for i in range(L, L+N)]\n\napples_abs = [abs(i) for i in apples]\n\nmin_idx = apples_abs.index(min(apples_abs))\n\n\n\nprint((sum(apples) - apples[min_idx]))","model_generated_potentially_faster_code_col":"import numpy as np\n\nn, l = map(int, input().split()) \nx = np.arange(l, l + n)\nx_min, idx = np.min(x), np.argmin(x)\nx[idx] = np.inf  # replace the minimum value with infinity\nx_sum = np.sum(x)\nprint(x_sum)"}
{"problem_id":"p02792","slow_code_col":"N=int(eval(input()))\n\nC=[[0]*9  for i in range(9)]\n\ncount=0\n\n\n\nfor n in range(1,N+1):\n\n   if str(n)[-1]!=\"0\":\n\n      left=int(str(n)[0])-1\n\n      right=int(str(n)[-1])-1\n\n      C[left][right]+=1\n\n      \n\nfor i in range(1,10):\n\n   for j in range(1,10):\n\n      count+=C[i-1][j-1]*C[j-1][i-1]\n\n\n\nprint(count)","reference_code_col":"from sys import stdin\n\ndef main():\n\n    #\u5165\u529b\n\n    readline=stdin.readline\n\n    N=int(readline())\n\n    d=dict()\n\n    for i in range(1,N+1):\n\n        i=str(i)\n\n        head=i[0]\n\n        tail=i[-1]\n\n        if tail==\"0\":\n\n            continue\n\n        if (head,tail) not in d:\n\n            d[(head,tail)]=1\n\n        else:\n\n            d[(head,tail)]+=1\n\n\n\n    ans=0\n\n    s=set()\n\n    for k in list(d.keys()):\n\n        m,l=k[0],k[1]\n\n        if (m,l) in s:\n\n            continue\n\n        if (l,m) in d:\n\n            ans+=d[(m,l)]*d[(l,m)]\n\n            if (m,l)!=(l,m):\n\n                ans+=d[(m,l)]*d[(l,m)]\n\n        s.add((m,l))\n\n        s.add((l,m))\n\n\n\n    print(ans)\n\n\n\nif __name__==\"__main__\":\n\n    main()","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Initialize the matrix C with zeros\nC = [[0] * 9 for _ in range(9)]\n\n# Count the occurrences of each valid (left, right) pair\nfor n in range(1, N + 1):\n    if n % 10 != 0:  # Check if the last digit is not '0'\n        left = n \/\/ 10  # Extract the first digit\n        right = n % 10   # Extract the last digit\n        C[left - 1][right - 1] += 1\n\n# Calculate the final count based on the matrix C\ncount = 0\nfor i in range(1, 10):\n    for j in range(i, 10):  # Only iterate over upper triangular part to avoid duplicates\n        count += C[i - 1][j - 1] * C[j - 1][i - 1]\n\nprint(count)"}
{"problem_id":"p03254","slow_code_col":"import numpy as np\n\nN, x = list(map(int, input().split()))\n\na = np.array(list(map(int, input().split())))\n\n\n\ncs = np.sort(a).cumsum()\n\n\n\nif cs[-1]<x:\n\n    print((N-1))\n\nelif cs[-1]==x:\n\n    print(N)\n\nelse:\n\n    print((np.where(cs<=x)[0].shape[0]))","reference_code_col":"from bisect import bisect_right\n\nfrom itertools import accumulate\n\n\n\nn, x = list(map(int, input().split()))\n\narr = list(map(int, input().split()))\n\n\n\narr.sort()\n\narr = list(accumulate(arr))\n\n\n\n\n\nhappy = bisect_right(arr, x)\n\n\n\nif happy == n:\n\n    if arr[-1] != x:\n\n        happy -= 1\n\n\n\nprint(happy)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN, x = map(int, input().split())\na = np.array(list(map(int, input().split())))\n\n# Sort the array and calculate cumulative sums\ncs = np.cumsum(np.sort(a))\n\n# Find the index where cumulative sum exceeds x\nindex = np.searchsorted(cs, x, side='right')\n\n# Adjust index based on whether it exceeds x exactly\nresult = N - 1 if cs[index] < x else index\n\nprint(result)"}
{"problem_id":"p02959","slow_code_col":"from sys import stdin,stdout\n\n\n\nif __name__==\"__main__\":\n\n    n=int(stdin.readline())\n\n\n\n    a=[int(x) for x in stdin.readline().split()]\n\n    b=[int(x) for x in stdin.readline().split()]\n\n\n\n    cnt=0\n\n\n\n    for i in range(n):\n\n        if(a[i]>=b[i]):\n\n            cnt+=b[i]\n\n        else:\n\n            cnt+=a[i]\n\n            d=b[i]-a[i]\n\n            cnt+=min(a[i+1],d)\n\n            if(d>a[i+1]):\n\n                a[i+1]=0\n\n            else: a[i+1]-=d\n\n            \n\n    stdout.write(str(cnt)+\"\\n\")\n","reference_code_col":"n = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\na1 = sum(A)\n\nfor i in range(n):\n\n  b = B[i]\n\n  if A[i] >= b:A[i] -= b\n\n  else:\n\n    if A[i+1]+A[i] >= b:\n\n      A[i+1] = A[i+1]+A[i]-b\n\n      A[i] = 0\n\n    else:A[i], A[i+1] = 0, 0\n\na2 = sum(A)\n\nprint((a1-a2))","model_generated_potentially_faster_code_col":"from sys import stdin, stdout\n\ndef main():\n    n = int(stdin.readline())\n    \n    # Read both lines at once and split into integers\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n    \n    cnt = 0\n    \n    for i in range(n):\n        diff = abs(a[i] - b[i])\n        \n        if a[i] >= b[i]:\n            cnt += b[i]\n        else:\n            cnt += a[i]\n            if diff <= a[i + 1]:\n                cnt += diff\n                a[i + 1] -= diff\n            else:\n                cnt += a[i + 1]\n                a[i + 1] = 0\n    \n    stdout.write(str(cnt) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03608","slow_code_col":"def main():\n\n    from itertools import permutations\n\n\n\n    n, m, r, *x = list(map(int, open(0).read().split()))\n\n    to = x[:r]\n\n\n\n    dis = [[float(\"Inf\")] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n\n        dis[i][i] = 0\n\n\n\n    for a, b, c in zip(*[iter(x[r:])] * 3):\n\n        dis[a][b] = c\n\n        dis[b][a] = c\n\n\n\n    for k in range(1, n + 1):\n\n        for i in range(1, n + 1):\n\n            for j in range(1, n + 1):\n\n                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n\n\n    ans = float(\"Inf\")\n\n    for p in permutations(to):\n\n        tmp = 0\n\n        nw = p[0]\n\n        for nx in p[1:]:\n\n            tmp += dis[nw][nx]\n\n            nw = nx\n\n\n\n        ans = min(ans, tmp)\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def main():\n\n    from itertools import permutations\n\n\n\n    n, m, r, *x = list(map(int, open(0).read().split()))\n\n    to = x[:r]\n\n\n\n    dis = [[10 ** 8] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n\n        dis[i][i] = 0\n\n\n\n    for a, b, c in zip(*[iter(x[r:])] * 3):\n\n        dis[a][b] = c\n\n        dis[b][a] = c\n\n\n\n    for k in range(1, n + 1):\n\n        for i in range(1, n + 1):\n\n            for j in range(1, n + 1):\n\n                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n\n\n\n    ans = 10 ** 8\n\n    for p in permutations(to):\n\n        tmp = 0\n\n        nw = p[0]\n\n        for nx in p[1:]:\n\n            tmp += dis[nw][nx]\n\n            nw = nx\n\n\n\n        ans = min(ans, tmp)\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    n, m, r, *x = map(int, input().split())\n    to = x[:r]\n    dis = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dis[i][i] = 0\n    for a, b, c in zip(*[iter(x[r:])] * 3):\n        dis[a][b] = dis[b][a] = c\n    for k in range(1, n + 1):\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])\n    dp = [[float('inf')] * (1 << r) for _ in range(n + 1)]\n    for i in range(r):\n        dp[to[i]][1 << i] = 0\n    for s in range(1 << r):\n        for i in range(r):\n            if s & (1 << i):\n                prev_s = s ^ (1 << i)\n                for j in range(r):\n                    if prev_s & (1 << j):\n                        dp[to[j]][s] = min(dp[to[j]][s], dp[to[i]][prev_s] + dis[to[i]][to[j]])\n    ans = float('inf')\n    for s in range(1 << r):\n        ans = min(ans, dp[to[-1]][s] + sum([dis[to[i]][to[i+1]] for i in range(r-1) if s & (1 << i)]))\n    print(ans)\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03416","slow_code_col":"counter = 0\n\nc = list(map(int, input().split(' ')))\n\nfor i in range(c[0], c[1] + 1):\n\n  if str(i)[0] != str(i)[4]:\n\n    continue\n\n  if str(i)[1] != str(i)[3]:\n\n    continue\n\n  counter += 1\n\n\n\nprint(counter)","reference_code_col":"a = list(map(int, input().split()))\n\ncounter = 0\n\nfor i in range(a[0], a[1] + 1):\n\n  stri = str(i)\n\n  if (stri[0] == stri[4] and stri[1] == stri[3]):\n\n    counter += 1\n\n    \n\nprint(counter)","model_generated_potentially_faster_code_col":"counter = 0\n\n# Get the start and end values from user input\nc = list(map(int, input().split(' ')))\n\n# Calculate the count of numbers in the format aabb\n# For example, if c[0]=1000 and c[1]=9999, there are 900 such numbers (from 1000 to 9999)\n\nstart_a = max(1, c[0] \/\/ 1000)  # Minimum value of 'a' that will still be within range\nend_a = min(9, c[1] \/\/ 1000)    # Maximum value of 'a'\n\n# Each 'b' can take any value from 0 to 9, so there are 10 possibilities for 'b'\ncounter = (end_a - start_a + 1) * 10\n\nprint(counter)"}
{"problem_id":"p03038","slow_code_col":"I=lambda:list(map(int,input().split()))\n\nn,m=I()\n\na=I()\n\na.sort(reverse=True)\n\nqq=[I() for i in range(m)]\n\nqq.sort(key=lambda x:x[1],reverse=True)\n\nans=0\n\nfor x,y in qq:\n\n    for j in range(x):\n\n        if not a:\n\n            break\n\n        aa=a.pop()\n\n        ans+=max(aa,y)\n\nans+=sum(a)\n\nprint(ans)\n\n        ","reference_code_col":"I=lambda : list(map(int,input().split()))\n\nn,m = I()\n\nl=I();s=sum(l);l.sort();d=[]\n\nfor _ in range(m):\n\n    b,c=I()\n\n    d.append([c,b])\n\np=s=0    \n\nfor i in sorted(d,reverse=True):\n\n    while i[1]:\n\n        if p>=n or l[p]>=i[0]:\n\n            break\n\n        i[1]-=1\n\n        s+=i[0]\n\n        p+=1\n\n    if p>=n:\n\n        break\n\ns+=sum(l[p:])\n\nprint(s)","model_generated_potentially_faster_code_col":"# Read input\ndef read_ints():\n    return list(map(int, input().split()))\n\n# Read n and m\nn, m = read_ints()\n\n# Read array a and sort it in descending order\na = read_ints()\na.sort(reverse=True)\n\n# Read all queries and sort them by y in descending order\nqueries = [read_ints() for _ in range(m)]\nqueries.sort(key=lambda q: q[1], reverse=True)\n\n# Initialize answer\nans = 0\n\n# Process each query\ni = 0\nfor x, y in queries:\n    # Use at most x elements from a\n    while x > 0 and a:\n        ans += max(a.pop(), y)\n        x -= 1\n\n# Add remaining elements from a\nans += sum(a)\n\nprint(ans)"}
{"problem_id":"p02780","slow_code_col":"import numpy as np\n\nn,k=list(map(int,input().split()))\n\nexp=tuple([(int(x)+1)\/2 for x in input().split()])\n\nl=np.cumsum(exp)\n\n\n\nans=l[k-1]\n\nfor i in range(0,n-k):\n\n  x=l[i+k]-l[i]\n\n  ans=max(ans,x)\n\nprint(ans)","reference_code_col":"def main():\n\n    from itertools import accumulate\n\n    n, k = list(map(int, input().split()))\n\n    *exp, = [(int(x) + 1) \/ 2 for x in input().split()]\n\n    l = accumulate(exp)\n\n    l = list(l)\n\n    ans = l[k - 1]\n\n    for i in range(0, n - k):\n\n        x = l[i + k] - l[i]\n\n        ans = max(ans, x)\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import numpy as np\n\nn, k = map(int, input().split())\n\nexp = np.array([(int(x) + 1) \/ 2 for x in input().split()], dtype=float)\n\n# Cumulative sum\nl = np.cumsum(exp)\n\n# The maximum value between the last element and the difference of elements from index k to n-k\nans = max(l[-1], l[n - k:].max() - l[:n - k].min())\n\nprint(ans)"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\nimport sys\n\n\n\nn = int(eval(input()))\n\na = np.array(list(map(int, input().split())))\n\n\n\ncnt = 1\n\n\n\nif np.any(a%2==1):\n\n    print((0))\n\n    sys.exit()\n\n\n\nwhile True:\n\n    a2 = a % 2**cnt\n\n    if np.all(a2==0):\n\n        cnt += 1\n\n        continue\n\n    else:\n\n        print((cnt-1))\n\n        break","reference_code_col":"N = int(eval(input()))\n\na = list(map(int,input().split()))\n\nans = 0\n\nwhile all(A%2 == 0 for A in a):\n\n\ta = [i\/2 for i in a ]\n\n\tans += 1\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import numpy as np\nimport sys\n\nn = int(eval(input()))\na = np.array(list(map(int, input().split())))\n\ncnt = 1\n\nif any(x & 1 for x in a):\n    print(0)\n    sys.exit()\n\nwhile True:\n    a2 = a >> cnt\n    if np.all(a2 == 0):\n        cnt += 1\n        continue\n    else:\n        print(cnt - 1)\n        break"}
{"problem_id":"p03723","slow_code_col":"a,b,c=list(map(int,input().split()))\n\ne=(a-b)|(b-c)\n\nprint((bool(e|(a|b|c)%2)*(e^~-e).bit_length()-1))","reference_code_col":"a,b,c=list(map(int,input().split()))\n\ne=(a-b)|(b-c)\n\nprint((bool(e|b%2)*(e^~-e).bit_length()-1))","model_generated_potentially_faster_code_col":"# Read input values and convert them to integers\na, b, c = map(int, input().split())\n\n# Calculate e using bitwise OR\ne = (a - b) | (b - c)\n\n# Check if e is non-zero and calculate the result\nresult = 0\nif e != 0:\n    # Calculate the number of bits required to represent e in binary\n    result = e.bit_length() - 1\n\n# Print the final result\nprint(result)"}
{"problem_id":"p02970","slow_code_col":"import numpy as np\n\nN, D = list(map(int, input().split()))\n\nprint((int(np.ceil(N\/(2*D+1)))))","reference_code_col":"N, D = list(map(int, input().split()))\n\nimport math\n\nprint((math.ceil(N\/(2*D+1))))","model_generated_potentially_faster_code_col":"N, D = map(int, input().split())\nresult = (N \/\/ (2 * D + 1)) + bool(N % (2 * D + 1))\nprint(result)"}
{"problem_id":"p03037","slow_code_col":"N, M =list(map(int, input().split()))\n\nL = [0 for i in range(N+1)]\n\nR = [0 for i in range(N+1)]\n\nfor i in range(M):\n\n    l,r = list(map(int, input().split()))\n\n    L[l] += 1\n\n    R[r] += 1\n\ncnt = 0\n\ntmp = 0\n\nfor i in range(N+1):\n\n    tmp += L[i]\n\n    if tmp == M:\n\n        cnt += 1\n\n    tmp -= R[i]\n\nprint(cnt)\n","reference_code_col":"n,m = list(map(int, input().split()))\n\nll = 1\n\nrr = n\n\nfor i in range(m):\n\n    l,r = list(map(int,input().split()))\n\n    if l > ll:\n\n        ll = l\n\n    if r < rr:\n\n        rr = r\n\nprint((max(rr - ll + 1, 0)))\n","model_generated_potentially_faster_code_col":"N, M = map(int, input().split())\n\n# Initialize the array to store the prefix sums\nprefix_sum = [0] * (N + 2)\n\n# Read the intervals and update the prefix sum array\nfor _ in range(M):\n    l, r = map(int, input().split())\n    prefix_sum[l] += 1\n    prefix_sum[r + 1] -= 1\n\n# Calculate the number of valid segments\ncount = 0\ncurrent_sum = 0\n\nfor value in prefix_sum[1:N+1]:\n    current_sum += value\n    if current_sum == M:\n        count += 1\n\nprint(count)"}
{"problem_id":"p03457","slow_code_col":"import numpy as np\n\n\n\nn = int(eval(input()))\n\ninput_X = [[int(i) for i in input().split()] for i in range(n)]\n\nX = np.array(input_X)\n\n\n\npre_t = 0\n\npre_x = 0\n\npre_y = 0\n\nfor i in range(n):\n\n    x_move = abs(X[i][1] - pre_x)\n\n    y_move = abs(X[i][2] - pre_y)\n\n    xy_sum = x_move + y_move\n\n    spend_time = X[i][0]-pre_t\n\n    if xy_sum%2 == spend_time%2 and spend_time >= xy_sum:\n\n        pre_t = X[i][0]\n\n        pre_x = X[i][1]\n\n        pre_y = X[i][2]\n\n        if i+1 == n:\n\n            print('Yes')\n\n        else:\n\n            continue\n\n    else:\n\n        print('No')\n\n        break","reference_code_col":"# C\n\nimport copy\n\nn = int(eval(input()))\n\npreX = [0,0,0]\n\nans = True\n\nfor i in range(n):\n\n    curX = list(map(int, input().split()))\n\n    dt = curX[0] - preX[0]\n\n    dx = abs(curX[1] - preX[1])\n\n    dy = abs(curX[2] - preX[2])\n\n    if dt < dx + dy  or (dt % 2) != ((dx + dy) % 2):\n\n        ans = False\n\n    preX = copy.copy(curX)\n\nif ans:\n\n    print('Yes')\n\nelse:\n\n    print('No')","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn = int(eval(input()))\ninput_X = [list(map(int, input().split())) for _ in range(n)]\nX = np.array(input_X)\n\n# Initialize previous position and time\npre_t = 0\npre_x = 0\npre_y = 0\n\n# Iterate through each point\nfor i in range(n):\n    # Calculate movement and time difference\n    x_move = abs(X[i][1] - pre_x)\n    y_move = abs(X[i][2] - pre_y)\n    xy_sum = x_move + y_move\n    spend_time = X[i][0] - pre_t\n    \n    # Check if conditions are met\n    if xy_sum % 2 == spend_time % 2 and spend_time >= xy_sum:\n        pre_t = X[i][0]\n        pre_x = X[i][1]\n        pre_y = X[i][2]\n        \n        # If we've reached the last point, print 'Yes'\n        if i == n - 1:\n            print('Yes')\n    else:\n        # Print 'No' and break if conditions are not met\n        print('No')\n        break"}
{"problem_id":"p03558","slow_code_col":"from collections import deque\n\nK = int(eval(input()))\n\nG = [[] for i in range(K)]\n\n\n\nfor n in range(K):\n\n    G[n].append([(n + 1) % K, 1])\n\n    G[n].append([(10 * n) % K, 0])\n\n\n\nque = deque([[1, 1]])\n\ndist = [float('inf')] * K\n\n\n\nwhile que:\n\n    node, cost = que.pop()\n\n    dist[node] = min(cost, dist[node])\n\n    for e, e_cost in G[node]:\n\n        if dist[e] != float('inf'):\n\n            continue\n\n\n\n        if e_cost == 0:\n\n            que.append([e, cost + 0])\n\n\n\n        if e_cost == 1:\n\n            que.appendleft([e, cost + 1])\n\n\n\nprint((dist[0]))\n","reference_code_col":"from collections import deque\n\nK = int(eval(input()))\n\nG = [[] for i in range(K)]\n\nfor i in range(K):\n\n    G[i].append(((10 * i) % K, 0))\n\n    G[i].append(((i + 1) % K, 1))\n\n\n\ndist = [float('inf')] * K\n\ndist[1] = 1\n\nque = deque()\n\nque.append(1)\n\n\n\nwhile que:\n\n    n = que.pop()\n\n    for v, c in G[n]:\n\n        if dist[v] > dist[n] + c:\n\n            dist[v] = dist[n] + c\n\n            if c == 0:\n\n                que.append(v)\n\n            else:\n\n                que.appendleft(v)\n\n\n\nprint((dist[0]))\n","model_generated_potentially_faster_code_col":"import heapq\n\nK = int(eval(input()))\n\nG = [[] for _ in range(K)]\n\nfor n in range(K):\n    G[n].append(((n + 1) % K, 1))\n    G[n].append(((10 * n) % K, 0))\n\nque = [(1, 1)]\ndist = [float('inf')] * K\ndist[1] = 1\n\nwhile que:\n    cost, node = heapq.heappop(que)\n\n    for e, e_cost in G[node]:\n        new_cost = cost + e_cost\n\n        if new_cost < dist[e]:\n            dist[e] = new_cost\n            heapq.heappush(que, (new_cost, e))\n\nprint(dist[0])"}
{"problem_id":"p03720","slow_code_col":"import numpy as np\n\n\n\nN, M = [int(x) for x in input().split()]\n\nL = [[int (y) for y in input().split()] for _ in range(M)]\n\nL = sum(L, [])\n\n\n\nfor i in np.arange(1, N+1):\n\n    print((L.count(i)))","reference_code_col":"N, M = [int(x) for x in input().split()]\n\nL = [[int (y) for y in input().split()] for _ in range(M)]\n\nL = sum(L, [])\n\n\n\nfor i in range(1, N+1):\n\n    print((L.count(i)))","model_generated_potentially_faster_code_col":"import numpy as np\n\nN, M = [int(x) for x in input().split()]\n\n# Create a dictionary to store the counts\ncounts = {}\n\n# Read the input and update the counts\nfor _ in range(M):\n    row = [int(y) for y in input().split()]\n    for num in row:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n# Print the counts\nfor i in range(1, N+1):\n    print(counts.get(i, 0))"}
{"problem_id":"p02881","slow_code_col":"import numpy as np\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n\n\n    INF = 10**6 + 100\n\n\n\n    x = np.arange(1,INF,dtype=np.int64)\n\n    div = x[N % x == 0]\n\n    #print(div)\n\n    #print(N \/\/ div)\n\n    \n\n    ans = (div + N\/\/div).min() - 2\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nfrom math import sqrt\n\n\n\ndef divisor_enumeration(n):\n\n    div = []\n\n    for i in range(1, int(sqrt(n))+1):\n\n        if n % i == 0:\n\n            if n \/\/ i != i:\n\n                div.append((i, n \/\/ i))\n\n            else:\n\n                div.append((i, i))\n\n        \n\n    return div\n\n\n\n\n\ndef main():\n\n    N = int(readline())\n\n\n\n    d = divisor_enumeration(N)\n\n    \n\n    ans = 10**15\n\n    for x, y in d:\n\n        ans = min(ans, x + y - 2)\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import numpy as np\n\ndef main():\n    N = int(input())\n    \n    INF = 10**6 + 100\n    \n    # Find all divisors of N\n    divisors = []\n    for i in range(1, int(np.sqrt(N)) + 1):\n        if N % i == 0:\n            divisors.append(i)\n            if i != N \/\/ i:\n                divisors.append(N \/\/ i)\n    \n    # Sort the divisors to find the minimum sum of divisor and quotient\n    divisors.sort()\n    \n    min_sum = float('inf')\n    for d in divisors:\n        min_sum = min(min_sum, d + N \/\/ d)\n    \n    ans = min_sum - 2\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02555","slow_code_col":"from math import factorial as fac\n\n\n\nS = int(eval(input()))\n\nans = 0\n\n\n\nif S == 1 or S == 2:\n\n  print((0))\n\nelif S == 3:\n\n  print((1))\n\nelse:\n\n  for k in range(1,S):\n\n    if S-2*k-1 >= 0 and S-3*k >= 0:\n\n      ans += fac(S-2*k-1)\/\/(fac(k-1)*fac(S-3*k))\n\n  print((ans%1000000007))","reference_code_col":"S = int(eval(input()))\n\n\n\nif S == 1 or S ==2:\n\n  print((0))\n\nelif S == 3 or S == 4 or S == 5:\n\n  print((1))\n\nelse:\n\n  #\u521d\u671f\u5316\n\n  dp = [0]*S\n\n  dp[2] = 1\n\n  dp[3] = 1\n\n  dp[4] = 1\n\n  dp_S = 0\n\n  #dp\n\n  for i in range(5,S):\n\n    dp_S += dp[i-3] \n\n    dp[i] = 1+dp_S\n\n\n\n  print((dp[S-1]%1000000007))","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\ndef count_partitions(n):\n    dp = [0]*(n+1)\n    dp[0] = 1\n    for i in range(1,n+1):\n        dp[i] = sum(dp[j]*dp[i-j] for j in range(i)) % MOD\n    return dp[n]\n\nS = int(input())\nprint(count_partitions(S))"}
{"problem_id":"p02555","slow_code_col":"import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, gcd\n\nfrom itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce, lru_cache\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\nS = INT()\n\n\n\n@lru_cache(maxsize=None)\n\ndef rec(x):\n\n    if x == 0: return 1\n\n\n\n    ret = 0\n\n    for i in range(x-2):\n\n        ret += rec(i)\n\n        ret %= mod\n\n    return ret\n\n\n\nprint((rec(S)))\n","reference_code_col":"import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, gcd\n\nfrom itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce, lru_cache\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\nS = INT()\n\n\n\n@lru_cache(maxsize=None)\n\ndef rec(x):\n\n    if x == 0: return 1\n\n\n\n    ret = 0\n\n    if x >= 3:\n\n        return (rec(x-1)+rec(x-3))%mod\n\n    else:\n\n        return 0\n\n\n\nprint((rec(S)))\n","model_generated_potentially_faster_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nS = int(sys.stdin.readline().strip())\n\n# Iterative function to calculate nth Fibonacci number modulo mod\ndef fib_mod(n):\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, (a + b) % mod\n    \n    return b\n\nprint(fib_mod(S))"}
{"problem_id":"p03250","slow_code_col":"# \u30a4\u30f3\u30dd\u30fc\u30c8\n\nimport numpy as np\n\n# A,B,C\u306e\u5024\u306e\u7372\u5f97\n\nnum = list(map(int, input().split()))\n\n# num\u30ea\u30b9\u30c8\u306e\u6700\u5927\u5024\u309210\u500d\n\nnum[num.index(max(num))] = max(num) * 10\n\n# np\u3067\u8981\u7d20\u306e\u548c\u3092\u8a08\u7b97\u3057\u3001\u51fa\u529b\n\nprint((np.sum(num)))","reference_code_col":"# A,B,C\u306e\u5024\u306e\u7372\u5f97\n\nnum = list(map(int, input().split()))\n\n# num\u30ea\u30b9\u30c8\u306e\u6700\u5927\u5024\u309210\u500d\n\nnum[num.index(max(num))] *= 10\n\n# np\u3067\u8981\u7d20\u306e\u548c\u3092\u8a08\u7b97\u3057\u3001\u51fa\u529b\n\nprint((sum(num)))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# A,B,C\u306e\u5024\u306e\u7372\u5f97\nnums = np.array(list(map(int, input().split())))\n\n# \u6700\u5927\u5024\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3068\u5024\u3092\u53d6\u5f97\nmax_index = np.argmax(nums)\nmax_value = nums[max_index]\n\n# \u6700\u5927\u5024\u309210\u500d\u306b\u66f4\u65b0\nnums[max_index] = max_value * 10\n\n# np\u3067\u8981\u7d20\u306e\u548c\u3092\u8a08\u7b97\u3057\u3001\u51fa\u529b\nprint(np.sum(nums))"}
{"problem_id":"p03037","slow_code_col":"import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nlr = list(zip(*[iter(lr)] * 2))\n\n\n\ndef main():\n\n    cnt = [0] * (n + 1)\n\n    for l, r in lr:\n\n        cnt[l-1] += 1\n\n        cnt[r] -= 1\n\n    \n\n    for i in range(n):\n\n        cnt[i+1] += cnt[i]\n\n    \n\n    res = 0\n\n    for i in range(n):\n\n        res += (cnt[i] == m) & 1\n\n    \n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","reference_code_col":"import sys\n\n\n\nn, m, *lr = list(map(int, sys.stdin.read().split()))\n\nl, r = lr[::2], lr[1::2]\n\n\n\ndef main():\n\n    ans = max(min(r) - max(l) + 1, 0)\n\n    return ans\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","model_generated_potentially_faster_code_col":"import sys\nfrom itertools import pairwise\n\n# Read input\ninput_data = sys.stdin.read()\nn, m, *lr = map(int, input_data.split())\n\n# Create pairs of (l, r)\nlr_pairs = list(pairwise(lr))\n\ndef main():\n    # Initialize count array with an extra element for easier index handling\n    cnt = [0] * (n + 2)\n\n    # Increment count at start and decrement at end of each interval\n    for l, r in lr_pairs:\n        cnt[l] += 1\n        cnt[r + 1] -= 1\n\n    # Compute prefix sums\n    for i in range(1, n + 1):\n        cnt[i] += cnt[i - 1]\n\n    # Count the number of intervals where the count equals m\n    result = sum(cnt[i] == m for i in range(1, n + 1))\n\n    return result\n\nif __name__ == '__main__':\n    ans = main()\n    print(ans)"}
{"problem_id":"p01438","slow_code_col":"from collections import defaultdict\n\nwhile 1:\n\n    n = int(input())\n\n    if n == 0: break\n\n    L = [0]*n\n\n    D = [0]*n\n\n    for man in range(n):\n\n        m,l = list(map(int,input().split()))\n\n        L[man] = l\n\n        t = 0\n\n        for date in range(m):\n\n            s,e = list(map(int,input().split()))\n\n            for s in range(s-6,e-6):\n\n                t |= 1 << s\n\n        D[man] = t\n\n\n\n    dp = [defaultdict(int) for i in range(n)]\n\n    dp[0][D[0]] = L[0]\n\n    for i in range(1,n):\n\n        for bit in list(dp[i-1].keys()):\n\n            if bit&D[i] == 0:\n\n                dp[i][bit|D[i]] = max(dp[i][bit|D[i]], dp[i-1][bit]+L[i])\n\n            dp[i][bit] = max(dp[i][bit],dp[i-1][bit])\n\n        dp[i][D[i]] = max(dp[i][D[i]], L[i])\n\n        \n\n    ans = max(max(dp[i].values()) for i in range(n))\n\n    print(ans)","reference_code_col":"from collections import defaultdict\n\nwhile 1:\n\n    n = int(input())\n\n    if n == 0: break\n\n    L = [0]*n\n\n    T = [0]*n\n\n    for man in range(n):\n\n        m,l = list(map(int,input().split()))\n\n        L[man] = l\n\n        t = 0\n\n        for date in range(m):\n\n            s,e = list(map(int,input().split()))\n\n            t |= 2**(e-6)-2**(s-6)\n\n        T[man] = t\n\n\n\n    dp = defaultdict(int)\n\n    dp[T[0]] = L[0]\n\n    for i in range(1,n):\n\n        for bit in list(dp.keys()):\n\n            if bit&T[i] == 0:\n\n                dp[bit|T[i]] = max(dp[bit|T[i]], dp[bit]+L[i])\n\n        dp[T[i]] = max(dp[T[i]], L[i])\n\n        \n\n    print(max(dp.values()))","model_generated_potentially_faster_code_col":"from collections import defaultdict\n\nwhile True:\n    n = int(input())\n    \n    if n == 0:\n        break\n    \n    L = [0] * n\n    D = [0] * n\n    \n    for man in range(n):\n        m, l = map(int, input().split())\n        L[man] = l\n        \n        # Precompute bit mask for each date range\n        bit_mask = 0\n        for _ in range(m):\n            s, e = map(int, input().split())\n            bit_mask |= (1 << (e - 7)) - (1 << (s - 6))\n        \n        D[man] = bit_mask\n    \n    dp = [defaultdict(int) for _ in range(n)]\n    dp[0][D[0]] = L[0]\n    \n    for i in range(1, n):\n        for bit in list(dp[i-1].keys()):\n            new_bit = bit | D[i]\n            dp[i][new_bit] = max(dp[i][new_bit], dp[i-1][bit] + L[i])\n            dp[i][bit] = max(dp[i][bit], dp[i-1][bit])\n    \n    ans = max(max(dp[i].values()) for i in range(n))\n    print(ans)"}
{"problem_id":"p02767","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nX = np.array(input().split()).astype(int)\n\nP = round(np.average(X))\n\nprint((int(np.sum((P-X)**2))))","reference_code_col":"n = int(eval(input()))\n\nx = [int(i) for i in input().split()]\n\nmin_x = round(sum(x) \/ n)\n\nans = sum([(min_x - i)**2 for i in x])\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN = int(input())\nX = list(map(int, input().split()))\n\n# Calculate mean and round it\nmean = sum(X) \/\/ N  # Integer division for faster computation\n\n# Compute squared differences from the rounded mean and sum them up\nresult = sum((x - mean) ** 2 for x in X)\n\nprint(result)"}
{"problem_id":"p02780","slow_code_col":"N, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\ns = [0] * 1000000\n\nfor i in range(N):\n\n    s[i+1] = s[i] + A[i]\n\n\n\nmax_s = 0\n\nfor i in range(N):\n\n    if max_s < s[i+K] - s[i]:\n\n        max_s = s[i+K] - s[i]\n\n\n\n\n\nprint(((max_s+K) \/ 2))","reference_code_col":"N, K = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\nm = [(e + 1) \/ 2 for e in p]\n\n\n\nt = sum(m[0:K])\n\nresult = t\n\nfor i in range(N - K):\n\n    t -= m[i]\n\n    t += m[i + K]\n\n    if t > result:\n\n        result = t\n\nprint(result)","model_generated_potentially_faster_code_col":"N, K = map(int, input().split())\nA = list(map(int, input().split()))\ns = [0] * (N + 1)\n\n# Calculate prefix sums\nfor i in range(1, N + 1):\n    s[i] = s[i - 1] + A[i - 1]\n\n# Find the maximum sum of any subarray of length K\nmax_sum = float('-inf')\nfor i in range(K, N + 1):\n    current_sum = s[i] - s[i - K]\n    max_sum = max(max_sum, current_sum)\n\n# Print the maximum average\nprint(max_sum \/ K)"}
{"problem_id":"p03208","slow_code_col":"N, K = list(map(int, input().split()))\n\n\n\nheight = []\n\nfor _ in range(N) :\n\n    height.append(int(eval(input())))\n\n\n\nheight.sort()\n\nans = float('inf')\n\n\n\nfor i in range(N-K+1) :\n\n    diff = height[i + K - 1] - height[i]\n\n    ans = min(ans, diff)\n\n\n\nprint(ans)","reference_code_col":"N, K = list(map(int, input().split()))\n\nH = [int(eval(input())) for _ in range(N)]\n\nH.sort()\n\n\n\nans = 10**18\n\nfor i in range(N - K + 1):\n\n    ans = min(ans, H[i + K - 1] - H[i])\n\nprint(ans)","model_generated_potentially_faster_code_col":"N, K = map(int, input().split())\n\nheight = [int(input()) for _ in range(N)]\n\nheight.sort()\n\nans = float('inf')\n\nfor i in range(N-K+1):\n    diff = height[i + K - 1] - height[i]\n    if diff < ans:\n        ans = diff\n\nprint(ans)"}
{"problem_id":"p03032","slow_code_col":"from collections import deque\n\n\n\nn, k = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor t in range(k\/\/2 + 1):\n\n    hand = deque(V[:k-t])\n\n    rest = deque(V[k-t:])\n\n    cur_sum = sum(hand)\n\n\n\n    for j in range(k-t+1):\n\n        put_back = 0\n\n        rev_hand = sorted(hand)\n\n\n\n        for i in range(t):\n\n            jewel = rev_hand[i]\n\n            if jewel < 0:\n\n                put_back -= jewel\n\n            else:\n\n                break\n\n\n\n        candidate = cur_sum + put_back\n\n        ans = max(candidate, ans)\n\n\n\n        to_rest = hand.pop()\n\n        rest.appendleft(to_rest)\n\n        to_hand = rest.pop()\n\n        hand.appendleft(to_hand)\n\n\n\n        cur_sum += to_hand - to_rest\n\n\n\nprint(ans)","reference_code_col":"n, k = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\n\n\ndef get_jewelries(box, left_pop, right_pop):\n\n    if left_pop + right_pop >= len(box):\n\n        return box[:]\n\n\n\n    left = box[:left_pop]\n\n    right = box[-right_pop:] if right_pop else []\n\n\n\n    return left + right\n\n\n\n\n\ncandidates = []\n\npop_max = min(k, n)\n\nfor pop_count in range(pop_max+1):\n\n    residue = k - pop_count\n\n\n\n    for left_pop in range(pop_count+1):\n\n        right_pop = pop_count - left_pop\n\n        jewelries = get_jewelries(V, left_pop, right_pop)\n\n        jewelries.sort(reverse=True)\n\n\n\n        for _ in range(residue):\n\n            if not jewelries:\n\n                break\n\n            if jewelries[-1] < 0:\n\n                jewelries.pop()\n\n\n\n        value = sum(jewelries)\n\n        candidates.append(value)\n\n\n\nprint((max(candidates)))\n","model_generated_potentially_faster_code_col":"from collections import deque\n\n\nn, k = map(int, input().split())\n\nV = list(map(int, input().split()))\n\n\ndef max_value(V, k):\n    n = len(V)\n    max_val = float('-inf')\n\n    # Calculate prefix sums\n    prefix_sums = [0] * (n + 1)\n    for i in range(n):\n        prefix_sums[i + 1] = prefix_sums[i] + V[i]\n\n\n    for start in range(n - k + 1):\n        end = start + k - 1\n\n        # Calculate the sum of the current window\n        window_sum = prefix_sums[end + 1] - prefix_sums[start]\n\n        # Find the maximum value in the current window\n        max_neg_val = float('-inf')\n        for i in range(start, end + 1):\n            if V[i] < 0:\n                max_neg_val = max(max_neg_val, V[i])\n\n\n        # Update the maximum value\n        max_val = max(max_val, window_sum + max_neg_val)\n\n\n    return max_val\n\n\n# Call the function and print the result\nprint(max_value(V, k))"}
{"problem_id":"p02863","slow_code_col":"n,t=list(map(int,input().split()))\n\nab=[list(map(int,input().split()))for _ in range(n)]\n\nab.sort()\n\ndp=[(6007)*[0]for _ in range(n+1)]\n\ndp[0][0]=0\n\nans=0\n\nfor i in range(n):\n\n  for j in range(6007):\n\n    dp[i+1][j]=max(dp[i+1][j],dp[i][j])\n\n    if j<t:dp[i+1][j+ab[i][0]]=max(dp[i][j]+ab[i][1],dp[i][j+ab[i][0]])\n\n    ans=max(ans,dp[i+1][j])\n\nprint(ans)\n","reference_code_col":"n,t=list(map(int,input().split()))\n\ndp=[[0]*(t+3001)for _ in range(n+1)]\n\nans=0\n\nab=[list(map(int,input().split()))for _ in range(n)]\n\nab.sort()\n\nfor i in range(1,n+1):\n\n    a,b=ab[i-1]\n\n    for j in range(t):\n\n        dp[i][j]=max(dp[i-1][j],dp[i][j])\n\n        dp[i][j+a]=dp[i-1][j]+b\n\n        ans=max(dp[i][j],dp[i][j+a],ans)\n\nprint(ans)   ","model_generated_potentially_faster_code_col":"import bisect\n\nn, t = map(int, input().split())\nab = [tuple(map(int, input().split())) for _ in range(n)]\nab.sort()\n\ndp = [[0] * (t + 1) for _ in range(n + 1)]\nans = 0\n\nfor i in range(n):\n    for j in range(t + 1):\n        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j])\n        k = bisect.bisect_right(ab, (j, float('inf')), key=lambda x: x[0])\n        if k > 0:\n            dp[i + 1][min(j + ab[k - 1][0], t)] = max(dp[i + 1][min(j + ab[k - 1][0], t)], dp[i][j] + ab[k - 1][1])\n    ans = max(ans, max(dp[i + 1]))\n\nprint(ans)"}
{"problem_id":"p03399","slow_code_col":"a, b, c, d = int(eval(input())), int(eval(input())), int(eval(input())), int(eval(input())),\n\nprint((min(a, b)+min(c, d)))","reference_code_col":"print((min(int(eval(input())), int(eval(input()))) + min(int(eval(input())), int(eval(input())))))","model_generated_potentially_faster_code_col":"a, b, c, d = map(int, input().split())\n\nprint(min(a, b) + min(c, d))"}
{"problem_id":"p02837","slow_code_col":"def popcount(x):\n\n  r = 0\n\n  while x:\n\n    if x & 1:\n\n      r += 1\n\n    x >>= 1\n\n  return r\n\n\n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [[0, 0] for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y] |= 1 << (x - 1)\n\n\n\nm = 0\n\nl = (1 << n) - 1\n\nfor x in range(1, l + 1):\n\n  if all(a[i][0] & x == a[i][1] & l - x == 0 for i in r if x >> i & 1):\n\n    m = max(m, popcount(x))\n\nprint(m)\n","reference_code_col":"from itertools import combinations\n\n \n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [(set(), set()) for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y].add(x - 1)\n\n \n\nfail = lambda x: not all(a[i][0].isdisjoint(x) and a[i][1] < x for i in x)\n\n \n\nwhile all(map(fail, list(map(set, combinations(r, n))))):\n\n  n -= 1\n\nprint(n)","model_generated_potentially_faster_code_col":"def popcount(x):\n    r = 0\n    while x:\n        if x & 1 != 0:\n            r += 1\n        x >>= 1\n    return r\n\nn = int(input())\nr = list(range(n))\na = [[0, 0] for _ in r]\nbitmasks = []\n\nfor i in r:\n    mask = 0\n    for _ in range(int(input())):\n        x, y = map(int, input().split())\n        mask |= 1 << (x - 1)\n    a[i][0], a[i][1] = mask, ~mask\n    bitmasks.append(mask | ~mask)\n\nm = 0\nl = (1 << n) - 1\nfor x in range(1, l + 1):\n    if all(a[i][0] & x == a[i][1] & l - x == 0 for i in r if x >> i & 1):\n        m = max(m, popcount(x))\n\nprint(m)"}
{"problem_id":"p03039","slow_code_col":"n, m, k = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\nMAX = n * m\n\n\n\n\n\nclass ModInt:\n\n    def __init__(self, num):\n\n        self.num = num\n\n\n\n    def __str__(self):\n\n        return str(self.num)\n\n\n\n    def __repr__(self):\n\n        return \"ModInt(num: {}, mod: {}\".format(self.num, mod)\n\n\n\n    def __add__(self, other):\n\n        ret = self.num + other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def __sub__(self, other):\n\n        ret = self.num - other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def __mul__(self, other):\n\n        ret = self.num * other.num\n\n        ret %= mod\n\n        return ModInt(ret)\n\n\n\n    def pow(self, times):\n\n        pw = pow(self.num, times, mod)\n\n        return ModInt(pw)\n\n\n\n    def inverse(self):\n\n        return ModInt(inv[self.num])\n\n\n\n    def __truediv__(self, other):\n\n        num = self * other.inverse()\n\n        return ModInt(num)\n\n\n\n\n\ndef comb(n, k):\n\n    return fact[n] * inv[n-k] * inv[k]\n\n\n\n\n\nfact = [None] * (MAX + 1)\n\nfact[0] = ModInt(1)\n\nfor i in range(1, MAX + 1):\n\n    fact[i] = fact[i-1] * ModInt(i)\n\n\n\ninv = [None] * (MAX + 1)\n\ninv[MAX] = fact[MAX].pow(mod - 2)\n\nfor i in range(MAX, 0, -1):\n\n    inv[i-1] = inv[i] * ModInt(i)\n\n\n\nans = ModInt(0)\n\nfor i in range(n):\n\n    for j in range(m):\n\n        add = ModInt(n - i) * ModInt(m - j) * ModInt(i + j)\n\n        if i != 0 and j != 0:\n\n            add *= ModInt(2)\n\n\n\n        ans += add\n\n\n\nans *= comb(n * m - 2, k - 2)\n\nprint(ans)\n","reference_code_col":"n, m, k = list(map(int, input().split()))\n\n\n\nmod = 10 ** 9 + 7\n\nMAX = n * m\n\n\n\nfact = [1] * (MAX + 1)\n\nfor i in range(1, MAX + 1):\n\n    fact[i] = (fact[i-1] * i) % mod\n\n\n\ninv = [1] * (MAX + 1)\n\ninv[MAX] = pow(fact[MAX], mod - 2, mod)\n\nfor i in range(MAX, 0, -1):\n\n    inv[i-1] = (inv[i] * i) % mod\n\n\n\n\n\ndef comb(n, k):\n\n    return fact[n] * inv[n-k] * inv[k] % mod\n\n\n\n\n\nans = 0\n\nfor i in range(n):\n\n    for j in range(m):\n\n        add = (n - i) * (m - j) * (i + j) % mod\n\n        if i != 0 and j != 0:\n\n            add *= 2\n\n            add %= mod\n\n\n\n        ans += add\n\n        ans %= mod\n\n\n\nans *= comb(MAX - 2, k - 2)\n\nans %= mod\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"n, m, k = map(int, input().split())\n\nmod = 10**9 + 7\n\nMAX = n * m\n\n# Function to calculate modular exponentiation\ndef mod_pow(base, exp):\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        exp \/\/= 2\n        base = (base * base) % mod\n    return result\n\n# Precompute factorials and their inverses\nfactorial = [1] * (MAX + 1)\ninverse_factorial = [1] * (MAX + 1)\n\nfor i in range(1, MAX + 1):\n    factorial[i] = (factorial[i - 1] * i) % mod\n    inverse_factorial[i] = mod_pow(factorial[i], mod - 2)\n\n# Function to calculate combination C(n, k)\ndef comb(n, k):\n    if k > n:\n        return 0\n    return (factorial[n] * inverse_factorial[k] * inverse_factorial[n - k]) % mod\n\n# Calculate the final answer\nans = 0\nfor i in range(n):\n    for j in range(m):\n        add = ((n - i) * (m - j) * (i + j)) % mod\n        if i != 0 and j != 0:\n            add = (add * 2) % mod\n        ans = (ans + add) % mod\n\nans = (ans * comb(n * m - 2, k - 2)) % mod\n\nprint(ans)"}
{"problem_id":"p02792","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\n# A\u306e\u5148\u982d\u306e\u6841\u3068\u672b\u5c3e\u306e\u6841\u306e\u7d44\u307f\u5408\u308f\u305b\u306f9*10=90\u901a\u308a\u3060\u3051\n\ntable = [[0] * 10 for i in range(10)]\n\nfor x in range(1, N+1):\n\n    x = str(x)\n\n    i = int(x[0])\n\n    j = int(x[-1])\n\n    table[i][j] += 1\n\n\n\ntable = np.array(table)\n\nanswer = (table * table.T).sum()\n\nprint(answer)\n","reference_code_col":"import sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\ncount = [[0] * 10 for _ in range(10)] # dp[head][tail]\n\nfor i in range(1, N+1):\n\n    s = str(i)\n\n    head = int(s[0]); tail = int(s[-1])\n\n    count[head][tail] += 1\n\n\n\nanswer = 0\n\nfor h in range(10):\n\n    for t in range(10):\n\n        answer += count[h][t] * count[t][h]\n\nprint(answer)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(input())\ndigits = [int(d) for d in str(N)]\ndigit_counts = [0]*10\nresult = 0\n\nfor d in digits:\n    digit_counts[d] += 1\n\nfor i in range(10):\n    result += digit_counts[i]**2\n\nprint(result)"}
{"problem_id":"p03241","slow_code_col":"N,M = list(map(int,input().split()))\n\nif N==1:\n\n    nmax=M\n\nelse:\n\n    nmax = 1\n\n    for i in range(2,int(M**0.5)+1):\n\n        if M%i==0 and M\/\/i>=N:\n\n            nmax = max(nmax,i)\n\n        if M%i==0 and i>=N:\n\n            nmax = max(nmax,M\/\/i)\n\nprint(nmax)","reference_code_col":"N,M = list(map(int,input().split()))\n\namax = 1\n\nfor i in range(1,int(M**0.5)+1):\n\n    if M%i==0:\n\n        a = i\n\n        b = M\/\/i\n\n        if b>=N:\n\n            amax = max(amax,a)\n\n        a,b = b,a\n\n        if b>=N:\n\n            amax = max(amax,a)\n\nprint(amax)","model_generated_potentially_faster_code_col":"import math\n\nN, M = map(int, input().split())\n\n# If N == 1, the answer is M itself because M is always divisible by 1\nif N == 1:\n    print(M)\nelse:\n    # Initialize nmax to 1, which is the smallest possible value\n    nmax = 1\n    \n    # Iterate only up to the square root of M\n    for i in range(2, int(math.sqrt(M)) + 1):\n        if M % i == 0:\n            # Check both divisors: i and M \/\/ i\n            divisor1 = i\n            divisor2 = M \/\/ i\n            \n            # Update nmax if either divisor meets the condition\n            if divisor1 >= N:\n                nmax = max(nmax, divisor1)\n            if divisor2 >= N:\n                nmax = max(nmax, divisor2)\n    \n    print(nmax)"}
{"problem_id":"p03162","slow_code_col":"import numpy as np\n\n\n\nN = int(eval(input()))\n\na = np.array([input().split() for i in range(N)], dtype=int)\n\n\n\ndp = np.zeros((N, 3), dtype=int)\n\ndp[0] = a[0]\n\n\n\nfor i in range(1, N):\n\n    dp[i] = [\n\n        a[i][0] + max(dp[i - 1][1], dp[i - 1][2]),\n\n        a[i][1] + max(dp[i - 1][2], dp[i - 1][0]),\n\n        a[i][2] + max(dp[i - 1][0], dp[i - 1][1]),\n\n    ]\n\n\n\nprint((np.max(dp[-1])))\n","reference_code_col":"N = int(eval(input()))\n\na = [list(map(int, input().split())) for _ in range(N)]\n\n\n\ndp = [[0, 0, 0] for _ in range(N+1)]\n\n\n\nfor i in range(N):\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j == k:\n\n                continue\n\n            dp[i+1][k] = max(dp[i+1][k], dp[i][j] + a[i][k])\n\n\n\nprint((max(dp[-1])))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n\nN = int(input())\na = np.array([list(map(int, input().split())) for _ in range(N)])\n\n\ndp = np.zeros((N, 3), dtype=np.int64)\ndp[0] = a[0]\n\n\nfor i in range(1, N):\n    dp[i] = [\n        a[i][0] + np.maximum(dp[i - 1, 1:], 0).sum(),\n        a[i][1] + np.maximum(dp[i - 1, 2:], 0).sum(),\n        a[i][2] + np.maximum(dp[i - 1, :2], 0).sum(),\n    ]\n\n\nprint(np.max(dp[-1]))"}
{"problem_id":"p02596","slow_code_col":"import sys\n\n\n\nreadline = sys.stdin.readline\n\nreadall = sys.stdin.read\n\nns = lambda: readline().rstrip()\n\nni = lambda: int(readline().rstrip())\n\nnm = lambda: map(int, readline().split())\n\nnl = lambda: list(map(int, readline().split()))\n\nprn = lambda x: print(*x, sep='\\n')\n\n\n\ndef solve():\n\n    d = dict()\n\n    k = ni()\n\n    c = 7 % k\n\n    x = d[c] = 1\n\n    while True:\n\n        c = (c * 10 + 7) % k\n\n        if c in d:\n\n            break\n\n        x += 1\n\n        d[c] = x\n\n    print(d.get(0, -1))\n\n    return\n\n\n\nsolve()\n","reference_code_col":"import sys\n\n\n\nreadline = sys.stdin.readline\n\nreadall = sys.stdin.read\n\nns = lambda: readline().rstrip()\n\nni = lambda: int(readline().rstrip())\n\nnm = lambda: map(int, readline().split())\n\nnl = lambda: list(map(int, readline().split()))\n\nprn = lambda x: print(*x, sep='\\n')\n\n\n\ndef solve():\n\n    k = ni()\n\n    c = 0\n\n    for i in range(k):\n\n        c = (c * 10 + 7) % k\n\n        if c == 0:\n\n            print(i+1)\n\n            break\n\n    else:\n\n        print(-1)\n\n    return\n\n\n\nsolve()\n","model_generated_potentially_faster_code_col":"import sys\n\nreadline = sys.stdin.readline\n\nns = lambda: readline().rstrip()\n\nni = lambda: int(readline().rstrip())\n\nnm = lambda: map(int, readline().split())\n\nnl = lambda: list(map(int, readline().split()))\n\nprn = lambda x: print(*x, sep='\\n')\n\n\ndef solve():\n    remainders = set()\n    k = ni()\n    c = 7 % k\n    x = 1\n    remainders.add(c)\n    \n    while True:\n        c = (c * 10 + 7) % k\n        \n        if c == 0:\n            print(0)\n            return\n        \n        if c in remainders:\n            break\n        \n        x += 1\n        remainders.add(c)\n\n    print(x)\n\n\nsolve()"}
{"problem_id":"p02959","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\nN = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\nbefore = sum(A)\n\n\n\nfor i in range(N):\n\n    nokori = B[i]\n\n    for j in range(i,i+2):\n\n        if nokori >= A[j]:\n\n            nokori -= A[j]\n\n            A[j] = 0\n\n        else:\n\n            A[j] -= nokori\n\n            nokori = 0\n\nafter = sum(A)\n\n\n\nprint((before - after))","reference_code_col":"N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\n\n\ncnt = 0\n\nfor i in range(N):\n\n    if B[i] >= A[i]:\n\n        cnt += A[i]\n\n        B[i] -= A[i]\n\n    else:\n\n        cnt += B[i]\n\n        B[i] = 0\n\n    if B[i] == 0:\n\n        continue\n\n    if B[i] >= A[i+1]:\n\n        cnt += A[i+1]\n\n        A[i+1] = 0\n\n    else:\n\n        cnt += B[i]\n\n        A[i+1] -= B[i]\n\n\n\nprint(cnt)","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\ntotal = sum(A)\ndiff = total\n\nfor i in range(N):\n    diff -= min(B[i], A[i])\n    A[i] -= min(B[i], A[i])\n\nprint(diff)"}
{"problem_id":"p03457","slow_code_col":"N = int(eval(input()))\n\ntxy = [(0, 0, 0)] + [tuple(map(int, input().split())) for _ in range(N)]\n\nfor i in range(N):\n\n    t1, x1, y1 = txy[i]\n\n    t2, x2, y2 = txy[i+1]\n\n    if abs(x2-x1) + abs(y2-y1) <= t2 - t1 and (x1+y1+x2+y2) % 2 == (t2-t1) % 2:\n\n        continue\n\n    else:\n\n        print('No')\n\n        exit()\n\nprint('Yes')","reference_code_col":"N = int(eval(input()))\n\nt0 = x0 = y0 = 0\n\nfor _ in range(N):\n\n    t1, x1, y1 = list(map(int, input().split()))\n\n    d = abs(x1 - x0) + abs(y1 - y0)\n\n    if d > t1 - t0 or d % 2 != (t1 - t0) % 2:\n\n        print('No')\n\n        exit()\n\n    t0, x0, y0 = t1, x1, y1\n\nprint('Yes')\n","model_generated_potentially_faster_code_col":"N = int(input())\n\ntxy = [(0, 0, 0)] + [tuple(map(int, input().split())) for _ in range(N)]\n\n# Precompute the differences between consecutive points\ndiffs = []\nfor i in range(1, N + 1):\n    t1, x1, y1 = txy[i - 1]\n    t2, x2, y2 = txy[i]\n    dt = t2 - t1\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    diffs.append((dt, dx, dy))\n\n# Check the conditions for each pair of consecutive points\nfor dt, dx, dy in diffs:\n    if dx + dy > dt or (dx + dy + dt) % 2 != dt % 2:\n        print('No')\n        exit()\n\nprint('Yes')"}
{"problem_id":"p02834","slow_code_col":"n,u,v=list(map(int,input().split()))\n\nanss=0\n\nu-=1\n\nv-=1\n\nd=[[]for _ in range(n)]\n\ninf=float('inf')\n\naoki=[inf]*n\n\nfor i in range(n-1):\n\n  a,b=list(map(int,input().split()))\n\n  a-=1\n\n  b-=1\n\n  d[a].append(b)\n\n  d[b].append(a)\n\nQ=d[v]\n\naoki[v]=0\n\ndis=1\n\nvisited={v}\n\nwhile Q:\n\n  P=[]\n\n  for i in Q:\n\n    visited.add(i)\n\n    for j in d[i]:\n\n      if j not in visited:P.append(j)\n\n    aoki[i]=dis\n\n  dis+=1\n\n  Q=P\n\nQ=d[u]\n\nchokudai=[-1]*n\n\nchokudai[u]=0\n\ndis=1\n\nvisited={u}\n\npoint=-1\n\nwhile Q:\n\n  P=[]\n\n  for i in Q:\n\n    visited.add(i)\n\n    for j in d[i]:\n\n      if aoki[j]<=dis+1:\n\n        if aoki[j]==dis+1:anss=1\n\n        if point<0:point=i\n\n        continue\n\n      if j not in visited:P.append(j)\n\n    chokudai[i]=dis\n\n  dis+=1\n\n  Q=P\n\nQ=d[point]\n\ndis=chokudai[point]+1\n\nvisited={point}\n\nwhile Q:\n\n  P=[]\n\n  for i in Q:\n\n    visited.add(i)\n\n    if chokudai[i]==-1:continue\n\n    chokudai[i]=max(dis,chokudai[i])\n\n    for j in d[i]:\n\n      if j not in visited:P.append(j)\n\n  dis+=1\n\n  Q=P\n\nans=0\n\nfor i in range(n):\n\n  if aoki[i]>chokudai[i]:ans=max(ans,chokudai[i])\n\nprint((ans+anss))\n\n#print(aoki)\n\n#print(chokudai)","reference_code_col":"n,u,v=list(map(int,input().split()))\n\nu-=1\n\nv-=1\n\ne=[[]for _ in range(n)]\n\nfor i in range(n-1):\n\n  a,b=list(map(int,input().split()))\n\n  a-=1\n\n  b-=1\n\n  e[a].append(b)\n\n  e[b].append(a)\n\ncho=[u]\n\ncho_dis=[10**7]*n\n\ncho_dis[u]=0\n\ncho_visited={u}\n\ncountt=1\n\nwhile cho:\n\n  CHO=[]\n\n  for i in cho:\n\n    for j in e[i]:\n\n      if j in cho_visited:continue\n\n      cho_visited.add(j)\n\n      CHO.append(j)\n\n      cho_dis[j]=countt\n\n  countt+=1\n\n  cho=CHO\n\naok=[v]\n\naok_dis=[10**7]*n\n\naok_dis[v]=0\n\naok_visited={v}\n\ncountt=1\n\nwhile aok:\n\n  AOK=[]\n\n  for i in aok:\n\n    for j in e[i]:\n\n      if j in aok_visited:continue\n\n      aok_visited.add(j)\n\n      AOK.append(j)\n\n      aok_dis[j]=countt\n\n  countt+=1\n\n  aok=AOK\n\nans=0\n\nfor i in range(n):\n\n  if cho_dis[i]<aok_dis[i]:ans=max(ans,aok_dis[i]-1)\n\nprint(ans)","model_generated_potentially_faster_code_col":"from collections import deque\n\ndef bfs(graph, start):\n    queue = deque([start])\n    visited = set()\n    dist = [-1] * len(graph)\n    dist[start] = 0\n    \n    while queue:\n        node = queue.popleft()\n        if node in visited:\n            continue\n        visited.add(node)\n        \n        for neighbor in graph[node]:\n            if dist[neighbor] == -1:\n                dist[neighbor] = dist[node] + 1\n                queue.append(neighbor)\n    \n    return dist\n\n# Input reading\nn, u, v = map(int, input().split())\nu -= 1\nv -= 1\n\ngraph = [[] for _ in range(n)]\ninf = float('inf')\n\n# Build the graph\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    graph[a].append(b)\n    graph[b].append(a)\n\n# Perform BFS from both u and v simultaneously\ndist_u = bfs(graph, u)\ndist_v = bfs(graph, v)\n\n# Find the maximum distance where dist_u > dist_v\nmax_distance = 0\nfor i in range(n):\n    if dist_u[i] > dist_v[i]:\n        max_distance = max(max_distance, dist_v[i])\n\n# Check if there exists a path between u and v that satisfies the condition\nhas_path = any(dist_u[i] <= dist_v[i] + 1 for i in range(n))\n\n# Output the result\nprint(max_distance + int(has_path))"}
{"problem_id":"p02537","slow_code_col":"d=[0]*6**8\n\nn,k,*a=list(map(int,open(0).read().split()+d))\n\nfor i in range(n):d[i]=max(d[j]for j in range(i-99,i+1)if abs(a[i]-a[j])<=k)+1\n\nprint((max(d)))","reference_code_col":"d=[0]*6**8\n\nn,k,*a=list(map(int,open(0).read().split()))\n\na=d+a\n\nwhile n:d[n]=max(d[j]for j in range(n,n+99)if abs(a[-n]-a[-j])<=k)+1;n-=1\n\nprint((max(d)))","model_generated_potentially_faster_code_col":"from collections import deque\n\n# Read input data\nn, k, *a = map(int, open(0).read().split())\n\n# Initialize variables\nd = [0] * n\nwindow = deque()\n\n# Process each element in the array\nfor i in range(n):\n    # Remove elements from the front of the window that are out of the current window range\n    while window and window[0] < i - 99:\n        window.popleft()\n    \n    # Find the maximum value within the current window\n    if window:\n        max_value = d[window[0]]\n    else:\n        max_value = 0\n    \n    # Update the result for the current index\n    d[i] = max_value + 1\n    \n    # Maintain the decreasing order of indices in the window based on the corresponding values in 'd'\n    while window and d[window[-1]] <= d[i]:\n        window.pop()\n    \n    # Add the current index to the end of the window\n    window.append(i)\n\n# Print the maximum value in the result array\nprint(max(d))"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\n# Me\n\n\n\n\n\ndef f():\n\n    i = int(eval(input()))\n\n    nums = np.array(list(map(int, input().split())))\n\n    # nums = [int(x) for x in input().split()]\n\n    c = 0\n\n    while True:\n\n        if any(nums % 2 == 1):\n\n            break\n\n        c += 1\n\n        nums = nums \/ 2\n\n    print(c)\n\n\n\n\n\nf()\n\n\n\n\n\n# Other\n","reference_code_col":"def divide_all(a):\n\n    success = True\n\n    for i, n in enumerate(a):\n\n        if n % 2 != 0:\n\n            success = False\n\n            break\n\n        a[i] = n \/ 2\n\n    if success is False:\n\n        return (a, False)\n\n    return (a, True)\n\n\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\nc = 0\n\nwhile True:\n\n    a, r = divide_all(a)\n\n    if r is False:\n\n        break\n\n    c += 1\n\n\n\n\n\nprint(c)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\ndef count_divisible_by_two():\n    i = int(eval(input()))\n    \n    # Read input as a space-separated string and convert to numpy array\n    nums = np.fromstring(input(), dtype=int, sep=' ')\n    \n    count = 0\n    \n    # Continue until all elements in nums are even\n    while np.any(nums % 2 == 1):\n        nums \/= 2\n        count += 1\n    \n    print(count)\n\ncount_divisible_by_two()"}
{"problem_id":"p03253","slow_code_col":"from math import floor, sqrt\n\nfrom collections import defaultdict\n\ndef factors(n):\n\n    d = defaultdict(int)\n\n    for i in range(2,floor(sqrt(n))+1):\n\n        while n % i == 0:\n\n            n \/\/= i\n\n            d[i] += 1\n\n        if n == 1:\n\n            break\n\n    if n != 1:\n\n        d[n] += 1\n\n    return d\n\ndef inv(x, mod):\n\n    k = mod - 2\n\n    ret = 1\n\n    while k > 0:\n\n        if k&1:\n\n            ret = (ret*x) % mod\n\n        x = (x*x) % mod\n\n        k >>= 1\n\n    return ret\n\nN, M = list(map(int,input().split()))\n\nmod = 10**9+7\n\ndic = factors(M)\n\nK = len(dic)\n\nSIZE = N+max(dic.values()) if list(dic.values()) else N\n\nfact = [None]*(SIZE+1)\n\nfinv = [None]*(SIZE+1)\n\nfact[0] = 1\n\nfor i in range(1,SIZE+1):\n\n    fact[i] = (fact[i-1]*i) % mod\n\nfinv[SIZE] = inv(fact[SIZE], mod=mod)\n\nfor i in range(SIZE, 0, -1):\n\n    finv[i-1] = (finv[i]*i) % mod\n\ndef comb(n,k):\n\n    tmp = (finv[k]*finv[n-k]) % mod\n\n    return (fact[n]*tmp) % mod\n\nans = 1\n\nfor p in dic:\n\n    ans = (ans*comb(dic[p]+N-1, dic[p])) % mod\n\nprint(ans)","reference_code_col":"from math import floor, sqrt\n\nfrom collections import defaultdict\n\nN,M = list(map(int,input().split()))\n\nd = defaultdict(int)\n\nfor i in range(2, floor(sqrt(M))+1):\n\n    while M % i == 0:\n\n        d[i] += 1\n\n        M \/\/= i\n\nif M != 1:\n\n    d[M] += 1\n\ndef comb(n,k):\n\n    if k == 0:\n\n        return 1\n\n    return comb(n-1,k-1) * n \/\/ k\n\nans = 1\n\nfor e in list(d.values()):\n\n    ans *= comb(N+e-1, e)\n\nprint((ans % (10**9+7)))","model_generated_potentially_faster_code_col":"import math\nfrom collections import defaultdict\n\ndef factors(n):\n    d = defaultdict(int)\n    for i in range(2, int(math.sqrt(n)) + 1):\n        while n % i == 0:\n            n \/\/= i\n            d[i] += 1\n        if n == 1:\n            break\n    if n != 1:\n        d[n] += 1\n    return d\n\ndef inv(x, mod):\n    k = mod - 2\n    ret = 1\n    while k > 0:\n        if k & 1:\n            ret = (ret * x) % mod\n        x = (x * x) % mod\n        k >>= 1\n    return ret\n\n# Input reading\nN, M = map(int, input().split())\nmod = 10**9 + 7\n\n# Calculate prime factors of M\ndic = factors(M)\nK = len(dic)\n\n# Determine the size for factorial array\nSIZE = N + max(dic.values())\n\n# Precompute factorials and their modular inverses\nfact = [0] * (SIZE + 1)\nfinv = [0] * (SIZE + 1)\nfact[0] = 1\nfor i in range(1, SIZE + 1):\n    fact[i] = (fact[i - 1] * i) % mod\nfinv[SIZE] = inv(fact[SIZE], mod=mod)\nfor i in range(SIZE, 0, -1):\n    finv[i - 1] = (finv[i] * i) % mod\n\n# Function to calculate combination nCr modulo mod\ndef comb(n, k):\n    if k > n:\n        return 0\n    return (fact[n] * finv[k] * finv[n - k]) % mod\n\n# Calculate the result\nans = 1\nfor p in dic:\n    ans = (ans * comb(dic[p] + N - 1, dic[p])) % mod\n\nprint(ans)"}
{"problem_id":"p03416","slow_code_col":"a , b = input().split()\n\na = int(a)\n\nb = int(b)\n\ncount=0\n\nfor i in range(a,b+1):\n\n    test = list(str(i))\n\n    if (test[0] == test[4]) and (test[1]==test[3]):\n\n        count=count+1\n\nprint(count)","reference_code_col":"A,B=list(map(int,input().split()))\n\nct=0\n\nfor i in range(A,B+1):\n\n    s=str(i)\n\n    if s==s[::-1]:\n\n        ct+=1\n\nprint(ct)","model_generated_potentially_faster_code_col":"a, b = map(int, input().split())\n\ncount = 0\n\nfor i in range(max(0, a - 999), min(10000, b + 1)):\n    if str(i)[0] == str(i)[-1] and str(i)[1] == str(i)[-2]:\n        count += 1\n\nprint(count)"}
{"problem_id":"p03034","slow_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport numpy as np\n\n\n\nN = int(readline())\n\nS = np.array(read().split(),np.int64)\n\n\n\ndef F(d):\n\n    # \u516c\u5dee\u3092\u56fa\u5b9a\n\n    L = S[:-d:d].cumsum()\n\n    R = S[::-1][:-d:d].cumsum()\n\n    if (N-1)%d == 0:\n\n        n = (N-1)\/\/d\n\n        x = np.arange(1,n+1)\n\n        bl = (x+x <= n+1)\n\n        L = L[bl]; R = R[bl]\n\n    return (L+R).max()\n\n\n\ndef G(n):\n\n    # \u9805\u6570n+1\u3092\u56fa\u5b9a\n\n    D = (N-1-n)\/\/n\n\n    L = np.zeros(D+1,np.int64)\n\n    R = np.zeros(D+1,np.int64)\n\n    for i in range(1,n+1):\n\n        L += S[:i*(D+1):i]\n\n        R += S[::-1][:i*(D+1):i]\n\n    ok = np.ones(D+1,np.bool)\n\n    overlap = (np.arange(D+1) * (n+n) >= N-1)\n\n    overlap[1:] &= ((N-1)%np.arange(1,D+1) == 0)\n\n    x = L+R\n\n    x[overlap] = 0\n\n    return x.max()\n\n\n\nL = int((N-1)**.5 + 10)\n\nL = min(N-1,L)\n\n\n\nx = max(F(n) for n in range(1,L+1))\n\ny = max(G(n) for n in range(1,L+1))\n\nanswer = max(x,y)\n\nprint(answer)","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\n\n\nN = int(readline())\n\nS = list(map(int,read().split()))\n\n\n\nanswer = 0\n\nfor d in range(1,N):\n\n    n = (N-1)\/\/d\n\n    if (N-1)%d == 0:\n\n        n = ((N-1)\/\/d+1)\/\/2\n\n    if n <= 1:\n\n        continue\n\n    x = max(itertools.accumulate(x+y for x,y in zip(S[d:d*n:d],S[N-1-d:N-1-d*n:-d])))\n\n    if answer < x:\n\n        answer = x\n\n\n\nprint(answer)","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Read input\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\nS = np.array(read().split(), dtype=np.int64)\n\ndef F(d):\n    L = S[:-d:d].cumsum()\n    R = S[::-1][:-d:d].cumsum()\n    \n    if (N - 1) % d == 0:\n        n = (N - 1) \/\/ d\n        x = np.arange(1, n + 1)\n        bl = (x + x <= n + 1)\n        L = L[bl]\n        R = R[bl]\n    \n    return (L + R).max()\n\ndef G(n):\n    D = (N - 1 - n) \/\/ n\n    L = np.zeros(D + 1, dtype=np.int64)\n    R = np.zeros(D + 1, dtype=np.int64)\n    \n    for i in range(1, n + 1):\n        L += S[:i * (D + 1):i]\n        R += S[::-1][:i * (D + 1):i]\n    \n    ok = np.ones(D + 1, dtype=bool)\n    overlap = (np.arange(D + 1) * (n + n) >= N - 1)\n    overlap[1:] &= ((N - 1) % np.arange(1, D + 1) == 0)\n    \n    x = L + R\n    x[overlap] = 0\n    \n    return x.max()\n\n# Determine the upper limit for L\nL = int((N - 1) ** 0.5 + 10)\nL = min(N - 1, L)\n\n# Compute the maximum value using both functions\nx = max(F(n) for n in range(1, L + 1))\ny = max(G(n) for n in range(1, L + 1))\n\n# Output the result\nprint(max(x, y))"}
{"problem_id":"p03835","slow_code_col":"K,S=list(map(int,input().split()))\n\nO=0\n\nfor X in range(K+1):\n\n  for Y in range(K+1):\n\n    Z=S-X-Y\n\n    if 0<=Z<=K:\n\n      O+=1\n\nprint(O)\n","reference_code_col":"K,S=list(map(int,input().split()))\n\nans=0\n\nfor X in range(K+1):\n\n    for Y in range(K+1):\n\n        Z=S-X-Y\n\n        if 0<=Z<=K:\n\n            ans+=1\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"K, S = map(int, input().split())\n\nO = 0\n\nfor X in range(min(S, K) + 1):\n    for Y in range(min(S - X, K) + 1):\n        Z = S - X - Y\n        if Z >= 0 and Z <= K:\n            O += 1\n\nprint(O)"}
{"problem_id":"p04020","slow_code_col":"import sys\n\nstdin = sys.stdin\n\n \n\nsys.setrecursionlimit(10**8) \n\n \n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x)-1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\n\n\nn = ni()\n\na = [ni() for _ in range(n)]\n\n\n\ncnt = {i+1: ai for i, ai in enumerate(a)}\n\n\n\nprev = -100\n\ncur = 0\n\nans = 0\n\nfor key in sorted(cnt.keys()):\n\n    if cnt[key] == 0:\n\n        continue\n\n    \n\n    if prev == -100:\n\n        prev = key\n\n    \n\n    if (key-prev) < 2:\n\n        cur += cnt[key]\n\n    else:\n\n        cur = cnt[key]\n\n        \n\n    ans += cur \/\/ 2\n\n    cur -= 2 * (cur\/\/2)\n\n    \n\n    prev = key\n\n        \n\nprint(ans)","reference_code_col":"import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\n\n\nans = 0\n\nplus = 0\n\na = [ni() for _ in range(n)]\n\n\n\nfor ai in a:\n\n    ans += ((ai+plus) \/\/ 2)\n\n    plus = (ai+plus) % 2 if ai > 0 else 0\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\n\n# Directly read from standard input\ninput = sys.stdin.read\ndata = input().split()\n\n# Read number of elements\nn = int(data[0])\n\n# Read the array elements\na = [int(data[i + 1]) for i in range(n)]\n\n# Create a dictionary to count occurrences of each element\ncnt = {}\nfor ai in a:\n    if ai not in cnt:\n        cnt[ai] = 0\n    cnt[ai] += 1\n\n# Initialize variables\nprev = -100\ncur = 0\nans = 0\n\n# Iterate over sorted keys in the dictionary\nfor key in sorted(cnt.keys()):\n    if cnt[key] == 0:\n        continue\n\n    if prev == -100:\n        prev = key\n\n    if (key - prev) < 2:\n        cur += cnt[key]\n    else:\n        cur = cnt[key]\n\n    ans += cur \/\/ 2\n    cur -= 2 * (cur \/\/ 2)\n\n    prev = key\n\nprint(ans)"}
{"problem_id":"p03164","slow_code_col":"def main():\n\n    N, W = list(map(int, input().split()))\n\n    w = [0] * N\n\n    v = [0] * N\n\n    for i in range(N):\n\n        w[i], v[i] = list(map(int, input().split()))\n\n\n\n    max_v = max(v)\n\n    dp = [[float('inf')] * (max_v * N + 5) for _ in range(N + 5)]\n\n\n\n    dp[0][0] = 0\n\n\n\n    for i in range(N):\n\n        for j in range(max_v * N):\n\n            if j + v[i] <= max_v * N:\n\n                dp[i+1][j + v[i]] = min(dp[i+1][j + v[i]], dp[i][j] + w[i])\n\n            dp[i+1][j] = min(dp[i+1][j], dp[i][j]) \n\n\n\n    ans = 0\n\n    for j in range(max_v * N + 1):\n\n        if dp[N][j] <= W:\n\n            ans = j\n\n\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()","reference_code_col":"def main():\n\n    N, W = list(map(int, input().split()))\n\n    weight = [0] * N\n\n    value = [0] * N\n\n    for i in range(N):\n\n        weight[i], value[i] = list(map(int, input().split()))\n\n    V = sum(value)\n\n    dp = [[float('inf')] * (V + 5) for _ in range(N + 5)]\n\n    dp[0][0] = 0\n\n    for i in range(N):\n\n        for v in range(V+1):\n\n            if v - value[i] >= 0:\n\n                dp[i+1][v] = min(dp[i][v-value[i]] + weight[i], dp[i][v])\n\n            else:\n\n                dp[i+1][v] = dp[i][v]\n\n    ans = 0\n\n    for v in range(V+1):\n\n        if dp[N][v] <= W:\n\n            ans = v\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()","model_generated_potentially_faster_code_col":"def main():\n    N, W = map(int, input().split())\n    \n    weights = []\n    values = []\n    \n    for _ in range(N):\n        w, v = map(int, input().split())\n        weights.append(w)\n        values.append(v)\n    \n    # Find the maximum value in the items\n    max_value = max(values)\n    \n    # Initialize dp array with a smaller size\n    dp = [float('inf')] * (W + 1)\n    dp[0] = 0\n    \n    # Fill the dp array\n    for v in values:\n        for w in range(W, v - 1, -1):\n            dp[w] = min(dp[w], dp[w - v] + weights[values.index(v)])\n    \n    # Find the maximum value that fits within the weight limit\n    ans = 0\n    for w in range(W + 1):\n        if dp[w] <= W:\n            ans = w\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03038","slow_code_col":"import numpy as np\n\nNM = list(map(int,input().split()))\n\nN = NM[0]\n\nM = NM[1]\n\nA = list(map(int,input().split()))\n\nlistBC =[]\n\nwhile True:\n\n    try:\n\n        listBC.append(list(map(int,input().split())))\n\n    except:\n\n        break;\n\nBC = np.array(listBC)\n\nBCnum = np.argsort(BC[:,1])[::-1]\n\nBC = BC[BCnum,:]\n\n\n\nA.sort()\n\nj=0\n\nfor i in range(len(A)):\n\n    times = BC[j,0]\n\n    if BC[j,0]==0:\n\n        j+=1\n\n        if j == BC.shape[0]:\n\n            break\n\n        times = BC[j,0]\n\n    if A[i]<BC[j,1]:\n\n        A[i]=BC[j,1]\n\n        BC[j,0] += -1\n\noutput = sum(A)\n\nprint(output)","reference_code_col":"N,M = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\nfrom collections import Counter\n\nD = dict(Counter(A))\n\n\n\nfor i in range(M):\n\n    B,C = list(map(int,input().split()))\n\n    D[C]=D.get(C,0)+B\n\n\n\nK = sorted(list(D.keys()),reverse=True)\n\n\n\nout = 0\n\ncnt = 0\n\nnow = 0\n\nwhile cnt<=N-1:\n\n    if D[K[now]]>0:\n\n        out += K[now]\n\n        D[K[now]] += -1\n\n        cnt+=1\n\n    else:\n\n        now+=1\n\nprint(out)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nNM = list(map(int, input().split()))\nN = NM[0]\nM = NM[1]\n\n# Read list A\nA = list(map(int, input().split()))\n\n# Read list BC\nlistBC = []\nwhile True:\n    try:\n        listBC.append(list(map(int, input().split())))\n    except EOFError:\n        break\n\nBC = np.array(listBC)\nBCnum = np.argsort(BC[:, 1])[::-1]\nBC = BC[BCnum, :]\n\n# Sort list A\nA.sort()\n\n# Initialize variables\nj = 0\noutput = 0\n\n# Process each element in A\nfor i in range(N):\n    if BC[j, 0] == 0:\n        j += 1\n        if j >= BC.shape[0]:\n            break\n    \n    while A[i] < BC[j, 1]:\n        A[i] = BC[j, 1]\n        BC[j, 0] -= 1\n        \n        # Check if we need to move to the next BC entry\n        if BC[j, 0] == 0:\n            j += 1\n            if j >= BC.shape[0]:\n                break\n\n# Calculate the final output\noutput = sum(A)\nprint(output)"}
{"problem_id":"p03309","slow_code_col":"n = int(eval(input()))\n\na = list(map(int,input().split()))\n\naa = []\n\nfor i in range(n):\n\n    aa.append(a[i]-(i+1))\n\nb = (sorted(aa)[n\/\/2])\n\n\n\nans = 0\n\nfor i in range(n):\n\n    ans += abs(a[i]-(b+i+1))\n\nprint(ans)","reference_code_col":"N= int(eval(input()))\n\nA = list(map(int,input().split()))\n\n\n\nB = []\n\nfor i in range(N):\n\n    B.append(A[i]-(i+1))\n\n#print(B)\n\nb= (sorted(B)[N\/\/2])\n\n#print(b)\n\nans = 0\n\nfor i in range(N):\n\n    ans += abs(B[i]-b)\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read input values\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate differences between elements and their positions\ndiffs = [a[i] - (i + 1) for i in range(n)]\n\n# Find the median of the differences\nb = sorted(diffs)[n \/\/ 2]\n\n# Calculate the total absolute difference from the median\nans = sum(abs(a[i] - (b + i + 1)) for i in range(n))\n\n# Print the result\nprint(ans)"}
{"problem_id":"p02794","slow_code_col":"N = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\n\n\nP = [-1] * N\n\nDE = [0] * N\n\nQ = [0]\n\nwhile Q:\n\n    i = Q.pop()\n\n    for a in X[i][::-1]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            DE[a] = DE[i] + 1\n\n            X[a].remove(i)\n\n            Q.append(a)\n\n\n\ndef lp(u, v):\n\n    t = 0\n\n    while u != v:\n\n        if DE[u] > DE[v]:\n\n            t += 1 << u-1\n\n            u = P[u]\n\n        elif DE[u] < DE[v]:\n\n            t += 1 << v-1\n\n            v = P[v]\n\n        else:\n\n            t += 1 << u-1\n\n            t += 1 << v-1\n\n            u = P[u]\n\n            v = P[v]\n\n    \n\n    return t\n\n\n\nY = []\n\nM = int(eval(input()))\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    a, b = a-1, b-1\n\n    Y.append(lp(a, b))\n\n\n\nD = {1<<i: i for i in range(50)}\n\nZ = [0] * (1<<M)\n\nans = 0\n\nCC = [0] * N\n\nBC = [0] * (1<<17)\n\nfor m in range(1, 1<<17):\n\n    a = m & (-m)\n\n    BC[m] = BC[m^a] + 1\n\nfor m in range(1<<M):\n\n    a = m & (-m)\n\n    if a == m:\n\n        if a == 0:\n\n            Z[m] = 0\n\n        else:\n\n            Z[m] = Y[D[a]]\n\n    else:\n\n        Z[m] = Z[m^a] | Y[D[a]]\n\n    \n\n    aa = Z[m]\n\n    bc = BC[aa % (1<<17)]\n\n    aa >>= 17\n\n    bc += BC[aa % (1<<17)]\n\n    aa >>= 17\n\n    bc += BC[aa]\n\n    CC[N - 1 - bc] += (1 if BC[m%1024] + BC[m>>10] & 1 == 0 else -1)\n\n\n\nprint((sum([2 ** i * CC[i] for i in range(N)])))","reference_code_col":"N = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\n\n\nP = [-1] * N\n\nDE = [0] * N\n\nQ = [0]\n\nwhile Q:\n\n    i = Q.pop()\n\n    for a in X[i][::-1]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            DE[a] = DE[i] + 1\n\n            X[a].remove(i)\n\n            Q.append(a)\n\n\n\ndef lp(u, v):\n\n    t = 0\n\n    while u != v:\n\n        if DE[u] > DE[v]:\n\n            t += 1 << u-1\n\n            u = P[u]\n\n        elif DE[u] < DE[v]:\n\n            t += 1 << v-1\n\n            v = P[v]\n\n        else:\n\n            t += 1 << u-1\n\n            t += 1 << v-1\n\n            u = P[u]\n\n            v = P[v]\n\n    \n\n    return t\n\n\n\nY = []\n\nM = int(eval(input()))\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    a, b = a-1, b-1\n\n    Y.append(lp(a, b))\n\n\n\ndef popcnt(n):\n\n    c = (n & 0x5555555555555555) + ((n>>1) & 0x5555555555555555)\n\n    c = (c & 0x3333333333333333) + ((c>>2) & 0x3333333333333333)\n\n    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c>>4) & 0x0f0f0f0f0f0f0f0f)\n\n    c = (c & 0x00ff00ff00ff00ff) + ((c>>8) & 0x00ff00ff00ff00ff)\n\n    c = (c & 0x0000ffff0000ffff) + ((c>>16) & 0x0000ffff0000ffff)\n\n    c = (c & 0x00000000ffffffff) + ((c>>32) & 0x00000000ffffffff)\n\n    return c\n\n\n\nD = {1<<i: i for i in range(50)}\n\nZ = [0] * (1<<M)\n\nans = 0\n\nCC = [0] * N\n\nfor m in range(1<<M):\n\n    a = m & (-m)\n\n    if a == m:\n\n        if a == 0:\n\n            Z[m] = 0\n\n        else:\n\n            Z[m] = Y[D[a]]\n\n    else:\n\n        Z[m] = Z[m^a] | Y[D[a]]\n\n    \n\n    CC[N - 1 - popcnt(Z[m])] += (1 if popcnt(m) & 1 == 0 else -1)\n\n\n\nprint((sum([2 ** i * CC[i] for i in range(N)])))","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Initialize adjacency list\nX = [[] for _ in range(N)]\n\n# Read edges and build graph\nfor _ in range(N - 1):\n    x, y = map(int, input().split())\n    X[x - 1].append(y - 1)\n    X[y - 1].append(x - 1)\n\n# Initialize parent and depth arrays\nP = [-1] * N\nDE = [0] * N\n\n# Perform BFS to find depths and parents\nfrom collections import deque\nQ = deque([0])\nwhile Q:\n    i = Q.popleft()\n    for a in X[i]:\n        if P[a] == -1:\n            P[a] = i\n            DE[a] = DE[i] + 1\n            Q.append(a)\n\n# Function to find least common ancestor (LCA)\ndef lca(u, v):\n    if DE[u] > DE[v]:\n        u, v = v, u\n    d = DE[v] - DE[u]\n    while d:\n        k = d.bit_length() - 1\n        v = P[v][k]\n        d -= 1 << k\n    if u == v:\n        return u\n    for k in range(16, -1, -1):\n        if P[u][k] != P[v][k]:\n            u, v = P[u][k], P[v][k]\n    return P[u][0]\n\n# Precompute LCA for all pairs\nlca_table = [[0] * 16 for _ in range(N)]\nfor i in range(N):\n    lca_table[i][0] = P[i]\nfor j in range(1, 16):\n    for i in range(N):\n        if lca_table[i][j - 1] == -1:\n            lca_table[i][j] = -1\n        else:\n            lca_table[i][j] = lca_table[lca_table[i][j - 1]][j - 1]\n\n# Function to calculate distance between two nodes\ndef lp(u, v):\n    anc = lca(u, v)\n    return DE[u] + DE[v] - 2 * DE[anc]\n\n# Read queries\nM = int(input())\nqueries = []\nfor _ in range(M):\n    a, b = map(int, input().split())\n    a, b = a - 1, b - 1\n    queries.append((a, b))\n\n# Process queries\nresults = []\nfor a, b in queries:\n    results.append(lp(a, b))\n\n# Output results\nfor result in results:\n    print(result)"}
{"problem_id":"p03720","slow_code_col":"import numpy as np\n\n\n\nncity, nlines = list(map(int, input().rstrip(\"\\n\").split()))\n\nmatrix = np.zeros((ncity, ncity), dtype=int)\n\nfor _ in range(nlines):\n\n    l, c = [int(x) - 1 for x in input().rstrip(\"\\n\").split()]\n\n    matrix[l][c] += 1\n\n    matrix[c][l] += 1\n\n\n\nfor list_ in matrix:\n\n    print((sum(list_)))","reference_code_col":"n, m = map(int, input().split())\n\nroads = [0] * n\n\n[exec(\"roads[%d] += 1; roads[%d] += 1\" % tuple(map(lambda c: int(c) - 1, input().split()))) for _ in range(m)]\n\nprint(*roads, sep=\"\\n\", end=\"\")\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n\nncity, nlines = map(int, input().rstrip(\"\\n\").split())\n\nmatrix = np.zeros((ncity, ncity), dtype=int)\n\nfor _ in range(nlines):\n    l, c = map(lambda x: int(x) - 1, input().rstrip(\"\\n\").split())\n    \n    matrix[l, c] += 1\n    matrix[c, l] += 1\n\n\nprint(np.sum(matrix, axis=1))"}
{"problem_id":"p03078","slow_code_col":"\n\nfrom heapq import heappop, heappush\n\n\n\nX, Y, Z, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nA.sort(reverse=True)\n\nB.sort(reverse=True)\n\nC.sort(reverse=True)\n\n\n\npq = []\n\nheappush(pq, (-A[0] - B[0] - C[0], 0, 0, 0))\n\nappeared = set((0, 0, 0))\n\n\n\nfor _ in range(K):\n\n    # Pop maximum value\n\n    val, i, j, k = heappop(pq)\n\n    print((-val))\n\n\n\n    # Add next value\n\n    if i + 1 < X and (i + 1, j, k) not in appeared:\n\n        heappush(pq, (-A[i + 1] - B[j] - C[k], i + 1, j, k))\n\n        appeared.add((i + 1, j, k))\n\n\n\n    if j + 1 < Y and (i, j + 1, k) not in appeared:\n\n        heappush(pq, (-A[i] - B[j + 1] - C[k], i, j + 1, k))\n\n        appeared.add((i, j + 1, k))\n\n\n\n    if k + 1 < Z and (i, j, k + 1) not in appeared:\n\n        heappush(pq, (-A[i] - B[j] - C[k + 1], i, j, k + 1))\n\n        appeared.add((i, j, k + 1))\n","reference_code_col":"\n\nX, Y, Z, K = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nA.sort(reverse=True)\n\nB.sort(reverse=True)\n\nC.sort(reverse=True)\n\n\n\nres = []\n\nfor i in range(X):\n\n    for j in range(Y):\n\n        for k in range(Z):\n\n            if (i + 1) * (j + 1) * (k + 1) <= K:\n\n                res.append(A[i] + B[j] + C[k])\n\n            else:\n\n                break\n\n\n\nres.sort(reverse=True)\n\nfor i in range(K):\n\n    print((res[i]))\n","model_generated_potentially_faster_code_col":"import heapq\n\n# Read input values\nX, Y, Z, K = map(int, input().split())\nA = sorted(map(int, input().split()), reverse=True)\nB = sorted(map(int, input().split()), reverse=True)\nC = sorted(map(int, input().split()), reverse=True)\n\n# Initialize heap with the first element of each array\nheap = [(-a - b - c, a, b, c) for a, b, c in zip(A, B, C)]\nheapq.heapify(heap)\n\n# Set to keep track of visited combinations\nvisited = set()\n\n# Extract the K largest sums\nfor _ in range(K):\n    # Pop the largest sum\n    val, a, b, c = heapq.heappop(heap)\n    print(-val)\n\n    # Add new possible sums to the heap\n    for x, y, z in [(a+1, b, c), (a, b+1, c), (a, b, c+1)]:\n        if 0 <= x < X and 0 <= y < Y and 0 <= z < Z and (x, y, z) not in visited:\n            visited.add((x, y, z))\n            heapq.heappush(heap, (-A[x] - B[y] - C[z], x, y, z))"}
{"problem_id":"p03371","slow_code_col":"a,b,c,x,y = list(map(int,input().split()))\n\nxy = max(x,y)*2+1\n\nprint((min([c*i + max(0,a*(x-i\/\/2)) +max(0,b*(y-i\/\/2)) for i in range(0,xy,2)])))","reference_code_col":"a,b,c,x,y = list(map(int,input().split()))\n\nif x < y:\n\n    a, b, x, y = b, a, y, x\n\nprint((min(a*x+b*y,2*c*y + a*(x-y),2*c*x)))","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\n\n# Calculate the maximum value of x and y multiplied by 2 plus 1\nxy = (max(x, y) * 2) + 1\n\n# Calculate the minimum value using a more efficient approach\nresult = float('inf')\nfor i in range(xy):\n    term = c * i + max(0, a * (x - i \/\/ 2)) + max(0, b * (y - i \/\/ 2))\n    if term < result:\n        result = term\n\nprint(result)"}
{"problem_id":"p02412","slow_code_col":"while True:\n\n    n, x = [int(i) for i in input().split()]\n\n\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    for s in range(1, n - 1):\n\n        for m in range(s + 1, n):\n\n            for e in range(m + 1, n + 1):\n\n                if x == sum([s, m, e]):\n\n                    count += 1\n\n\n\n    print(count)","reference_code_col":"while True:\n\n    n, x = [int(i) for i in input().split()]\n\n\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    for s in range(1, n - 1):\n\n        for m in range(s + 1, n):\n\n            for e in range(m + 1, n + 1):\n\n                if x == s+m+e:\n\n                    count += 1\n\n\n\n    print(count)","model_generated_potentially_faster_code_col":"import math\n\n# Precompute combinations lookup table\nmax_n = 1000  # Adjust this value based on your requirements\ncomb_table = [[0] * (i + 1) for i in range(max_n)]\nfor i in range(max_n):\n    comb_table[i][0] = comb_table[i][i] = 1\n    for j in range(1, i):\n        comb_table[i][j] = comb_table[i-1][j-1] + comb_table[i-1][j]\n\nwhile True:\n    n, x = map(int, input().split())\n    \n    if n == x == 0:\n        break\n    \n    count = 0\n    \n    # Iterate over all possible combinations of three numbers\n    for s in range(1, n - 1):\n        for m in range(s + 1, n):\n            e = n - s - m\n            if e > m and x == sum([s, m, e]):\n                count += comb_table[m-1][2]\n    \n    print(count)"}
{"problem_id":"p02837","slow_code_col":"n = int(eval(input()))\n\nv = [[tuple(map(int, input().split()))for i in range(int(eval(input())))]\n\n     for i in range(n)]\n\n\n\nans = 0\n\nfor i in range(2**n):\n\n    f = [False] * n\n\n    xy = []\n\n    for j in range(n):\n\n        if (i >> j) & 1:\n\n            f[j] = True\n\n            xy.append(v[j])\n\n    flag = True\n\n    for xyi in xy:\n\n        for x, y in xyi:\n\n            if f[x - 1] is not bool(y):\n\n                flag = False\n\n                break\n\n    if flag:\n\n        ans = max(ans, len(xy))\n\nprint(ans)\n","reference_code_col":"n = int(eval(input()))\n\nv = [[tuple(map(int, input().split()))for i in range(int(eval(input())))]\n\n     for i in range(n)]\n\n\n\nans = 0\n\nfor i in range(2**n):\n\n    f = [0] * n\n\n    xy = []\n\n    for j in range(n):\n\n        if (i >> j) & 1:\n\n            f[j] = 1\n\n            xy.append(v[j])\n\n    flag = True\n\n    for xyi in xy:\n\n        for x, y in xyi:\n\n            #print(f,x,y,bin(i))\n\n            if (i>>(x-1))&1 != y:\n\n                flag = False\n\n                break\n\n    if flag:\n\n        ans = max(ans, len(xy))\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"# Read input values directly without eval()\nn = int(input())\nv = [[[int(x), int(y)] for _ in range(int(input()))] for _ in range(n)]\n\nans = 0\n\nfor i in range(1 << n):\n    f = [bool((i >> j) & 1) for j in range(n)]\n    xy = [v[j] for j in range(n) if f[j]]\n    \n    valid = True\n    for xyi in xy:\n        for x, y in xyi:\n            if f[x - 1] != bool(y):\n                valid = False\n                break\n        if not valid:\n            break\n    \n    if valid:\n        ans = max(ans, len(xy))\n\nprint(ans)"}
{"problem_id":"p03000","slow_code_col":"N,X = list(map(int,input().split()))\n\nL = [0] + [int(x) for x in input().split()]\n\n\n\nD = [0] * (N+2)\n\nanswer = 1\n\nfor n in range(2,N+2):\n\n  D[n] = D[n-1] + L[n-1]\n\n  if D[n] <= X:\n\n    answer += 1\n\n    \n\nprint(answer)","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\n\n\nN,X,*L = list(map(int,read().split()))\n\n\n\nanswer = sum(x <= X for x in itertools.accumulate([0]+L))\n\nprint(answer)","model_generated_potentially_faster_code_col":"from bisect import bisect_right\n\n# Read input values\nN, X = map(int, input().split())\nL = [0] + [int(x) for x in input().split()]\n\n# Calculate prefix sums\nprefix_sums = [0]\ncurrent_sum = 0\nfor value in L:\n    current_sum += value\n    prefix_sums.append(current_sum)\n\n# Use binary search to find the maximum length of subarray with sum <= X\nleft, right = 0, N + 1\nwhile left < right:\n    mid = (left + right + 1) \/\/ 2\n    # Find the first index where prefix_sums[i] - prefix_sums[mid] > X\n    j = bisect_right(prefix_sums, prefix_sums[mid] + X)\n    if j >= len(prefix_sums):\n        right = mid - 1\n    else:\n        left = mid\n\n# The result is N - left\nprint(N - left)"}
{"problem_id":"p02983","slow_code_col":"mod = 2019\n\nl, r = list(map(int, input().split()))\n\n\n\nif r\/\/mod - l\/\/mod > 0:\n\n  print((0))\n\nelse:\n\n  l %= mod\n\n  r %= mod\n\n  ans = mod\n\n  for i in range(l+1, r+1):\n\n    for j in range(l, i):\n\n      ans = min(i*j%mod, ans)\n\n    if ans == 0:\n\n      break\n\n  print(ans)","reference_code_col":"mod = 2019\n\nl, r = list(map(int, input().split()))\n\n\n\nif r\/\/mod - l\/\/mod > 0:\n\n  print((0))\n\nelse:\n\n  l %= mod\n\n  r %= mod\n\n  ans = mod\n\n  for i in range(l, r):\n\n    for j in range(i+1, r+1):\n\n      ans = min(i*j%mod, ans)\n\n    if ans == 0:\n\n      break\n\n  print(ans)","model_generated_potentially_faster_code_col":"mod = 2019\n\n# Read input\nl, r = map(int, input().split())\n\n# Precompute the minimum product modulo mod for all pairs (i, j) where i <= j\nmin_product = [float('inf')] * (mod + 1)\nfor i in range(1, mod + 1):\n    for j in range(i, mod + 1):\n        min_product[i] = min(min_product[i], i * j % mod)\n\n# If r \/\/ mod - l \/\/ mod > 0, then the answer is 0\nif r \/\/ mod - l \/\/ mod > 0:\n    print(0)\nelse:\n    # Compute the answer using the precomputed values\n    l %= mod\n    r %= mod\n    ans = float('inf')\n    for i in range(l, r + 1):\n        ans = min(min_product[i], ans)\n    print(ans)"}
{"problem_id":"p00053","slow_code_col":"prim=[True]*1000000\n\nprim[0],prim[1]=False,False\n\nfor i in range(2,1000):\n\n    if prim[i]:\n\n        for j in range(i*2,1000000,i):\n\n            prim[j]=False\n\nprime=[i for i,j in enumerate(prim) if j==True]\n\n\n\nwhile True:\n\n    n=int(eval(input()))\n\n    if n==0:\n\n        break\n\n    print((sum(prime[:n])))","reference_code_col":"prim=[True]*1000000\n\nprim[0]=prim[1]=False\n\nfor i in range(2,350):\n\n    if prim[i]:\n\n        for j in range(i*2,110000,i):\n\n            prim[j]=False\n\nprime=[i for i,j in enumerate(prim) if j==True]\n\n\n\nwhile True:\n\n    n=int(eval(input()))\n\n    if n==0:\n\n        break\n\n    print((sum(prime[:n])))","model_generated_potentially_faster_code_col":"# Initialize the prime array with True values\nprim = [True] * (10**6 + 1)\n\n# Mark 0 and 1 as False (not prime)\nprim[0], prim[1] = False, False\n\n# Perform the Sieve of Eratosthenes\nfor i in range(2, int(10**6**0.5) + 1):\n    if prim[i]:\n        for j in range(i*i, 10**6 + 1, i):\n            prim[j] = False\n\n# Create a list of prime numbers up to 1,000,000\nprimes = []\nfor i in range(2, len(prim)):\n    if prim[i]:\n        primes.append(i)\n\n# Read input and calculate sums\nwhile True:\n    try:\n        n = int(input())\n        if n == 0:\n            break\n        print(sum(primes[:n]))\n    except EOFError:\n        break"}
{"problem_id":"p03037","slow_code_col":"n, m = list(map(int, input().split()))\n\ngate = []\n\nl, r = list(map(int, input().split()))\n\nfor i in range(1, m):\n\n    m, s = list(map(int, input().split()))\n\n    if l < m:\n\n        l = m\n\n    if s < r:\n\n        r = s\n\nprint((len([i for i in range(l, r + 1)])))","reference_code_col":"n, m = list(map(int, input().split()))\n\nl, r = [0] * m, [0] * m\n\nfor i in range(m):\n\n    l[i], r[i] = list(map(int, input().split()))\n\nprint((max(min(r) - max(l) + 1, 0)))","model_generated_potentially_faster_code_col":"n, m = map(int, input().split())\n\nl, r = map(int, input().split())\n\nfor _ in range(m - 1):\n    m, s = map(int, input().split())\n    \n    l = min(l, m)\n    r = max(r, s)\n\nprint(r - l + 1)"}
{"problem_id":"p02596","slow_code_col":"K=int(eval(input()))\n\n\n\nif K%2==0:\n\n    print((-1))\n\n    exit(0)\n\n    \n\nans=[0]*(pow(10,6)+1)\n\nans[0]=0\n\n\n\nfor i in range(1,pow(10,6)):\n\n    ans[i]=(ans[i-1]*10+7)%K\n\n    if ans[i]==0:\n\n        print(i)\n\n        exit(0)\n\n\n\nprint((-1))","reference_code_col":"import functools\n\n\n\nK=int(eval(input()))\n\n \n\nif K%2==0:\n\n    print((-1))\n\n    exit(0)\n\n\n\nmod=0\n\n\n\nfor i in range(1,pow(10,6)):\n\n    mod=(mod*10+7)%K\n\n    if mod==0:\n\n        print(i)\n\n        exit(0)\n\n        \n\nprint((-1))","model_generated_potentially_faster_code_col":"def find_smallest_n(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return -1\n    \n    remainder = 1\n    for n in range(1, 10**6 + 1):\n        if (remainder * 10) % K == 0:\n            return n\n        remainder = (remainder * 10) % K\n    \n    return -1\n\n# Input\nK = int(eval(input()))\n\nresult = find_smallest_n(K)\nprint(result)"}
{"problem_id":"p02537","slow_code_col":"def segfunc(x, y): return max(x, y)\n\n\n\nclass SegmentTree:\n\n    def __init__(self, arr):\n\n        size = len(arr)\n\n        n = 2 ** (size - 1).bit_length()\n\n        self.n = n\n\n        self.node = [0] * (2*n)\n\n        for i in range(size):\n\n            self.node[i+n-1] = arr[i]\n\n        for i in reversed(list(range(n-2))):\n\n            self.node[i] = segfunc(self.node[2*i+1], self.node[2*i+2])\n\n\n\n    def update(self, i, x):\n\n        i += self.n - 1\n\n        self.node[i] = x\n\n        while i > 0:\n\n            i = (i - 1) \/\/ 2\n\n            self.node[i] = segfunc(self.node[i * 2 + 1], self.node[i * 2 + 2])\n\n\n\n    def update(self, x, val):\n\n        x += (self.n - 1)\n\n        self.node[x] = val\n\n        while x > 0:\n\n            x = (x - 1) \/\/ 2\n\n            self.node[x] = segfunc(self.node[2 * x + 1], self.node[2 * x + 2])\n\n\n\n    def query(self, a, b):\n\n        res = 0\n\n        l = self.n - 1 + a\n\n        r = self.n - 1 + (b - 1)\n\n\n\n        while l <= r:\n\n            if l == r:\n\n                res = segfunc(res, self.node[l])\n\n                break\n\n\n\n            if l % 2 == 0:\n\n                res = segfunc(res, self.node[l])\n\n            if r % 2 == 1:\n\n                res = segfunc(res, self.node[r])\n\n            l = l \/\/ 2\n\n            r = r \/\/ 2 - 1\n\n\n\n        return res\n\n\n\nN, K = list(map(int, input().split()))\n\nINF = 0\n\nseg = SegmentTree([0] * 300000)\n\nfor i in range(N):\n\n    a = int(eval(input()))\n\n    tmp = seg.query(max(a - K, 0), min(a + K, 300000) + 1) + 1\n\n    seg.update(a, tmp)\n\nprint((seg.query(0, 300000)))\n","reference_code_col":"def segfunc(x, y): return max(x, y)\n\ndef update(i, x):\n\n    i += MAX_N-1\n\n    node[i] = x\n\n    while i:\n\n        i = (i-1)\/\/2\n\n        node[i] = segfunc(node[i*2+1], node[i*2+2])\n\n\n\ndef query(l, r):\n\n    L = l + MAX_N\n\n    R = r + MAX_N\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = segfunc(s, node[R - 1])\n\n        if L & 1:\n\n            s = segfunc(s, node[L - 1])\n\n            L += 1\n\n        L >>= 1\n\n        R >>= 1\n\n    return s\n\n\n\nN, K = list(map(int, input().split()))\n\nMAX_N = 2**(300005).bit_length()\n\na = [int(eval(input())) for _ in range(N)]\n\nnode = [0] * (2 * MAX_N)\n\nINF = 0\n\nans = 0\n\n\n\n#for i in range(N):\n\n#    update(i, a[i])\n\n\n\nfor i in a:\n\n    tmp = query(max(i - K, 0), min(300005, i + K) + 1)\n\n    update(i, tmp + 1)\n\n    ans = max(ans, tmp + 1)\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import sys\ninput = sys.stdin.read\ndata = input().split()\nN, K = int(data[0]), int(data[1])\nINF = float('-inf')\narr = [-INF] * 300000\nseg = SegmentTree(arr)\nfor i in range(N):\n    a = int(data[2 + i * 2])\n    tmp = seg.query(max(a - K, 0), min(a + K, 300000) + 1) + 1\n    seg.update(a, tmp)\nprint(seg.query(0, 300000))"}
{"problem_id":"p03037","slow_code_col":"N,M = list(map(int, input().split()))\n\nL = []\n\nR = []\n\nfor _ in range(M):\n\n  l,r = list(map(int, input().split()))\n\n  L.append(l)\n\n  R.append(r)\n\n\n\nans = min(R)-max(L)+1\n\nif ans < 0:\n\n  print((0))\n\nelse:\n\n  print(ans)\n\n  ","reference_code_col":"n,m = list(map(int, input().split()))\n\nmax_l = float(\"-inf\")\n\nmin_r = float(\"inf\")\n\nfor _ in range(m):\n\n  l,r = list(map(int, input().split()))\n\n  max_l = max(max_l, l)\n\n  min_r = min(min_r, r)\n\nans = min_r - max_l + 1\n\nif ans > 0:\n\n  print(ans)\n\nelse:\n\n  print((0))","model_generated_potentially_faster_code_col":"N, M = map(int, input().split())\n\nmin_r = float('inf')\nmax_l = float('-inf')\n\nfor _ in range(M):\n    l, r = map(int, input().split())\n    min_r = min(min_r, r)\n    max_l = max(max_l, l)\n\nans = min_r - max_l + 1\nprint(ans if ans > 0 else 0)"}
{"problem_id":"p02595","slow_code_col":"from decimal import *\n\ngetcontext().prec = 14\n\n\n\nN, D = list(map(int, input().split()))\n\n\n\n\n\ndef distance(x1, x2, y1, y2):\n\n    dx = x2-x1\n\n    dy = y2-y1\n\n    return (dx*dx + dy*dy).sqrt()\n\n\n\n\n\nX = [0] * N\n\nY = [0] * N\n\nans = 0\n\nfor i in range(N):\n\n    X[i], Y[i] = list(map(Decimal, input().split()))\n\n    if (distance(0, X[i], 0, Y[i]) <= D):\n\n        ans += 1\n\n\n\nprint(ans)\n","reference_code_col":"from decimal import *\n\ngetcontext().prec = 14  # \u3042\u3093\u307e\u308a\u5927\u304d\u3044\u3068\u8a08\u7b97\u9045\u3044\u304b\u3082\n\n\n\nN, D = list(map(int, input().split()))\n\n\n\ndef distance(x1, x2, y1, y2):\n\n    dx = x2-x1\n\n    dy = y2-y1\n\n    return (dx*dx + dy*dy).sqrt()\n\n\n\nans = 0\n\nfor i in range(N):\n\n    X, Y = list(map(Decimal, input().split()))\n\n    if (distance(0, X, 0, Y) <= D):\n\n        ans += 1\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"from decimal import Decimal, getcontext\n\n# Set precision\ngetcontext().prec = 14\n\n# Read input values\nN, D = map(int, input().split())\n\n# Initialize coordinates lists\nX = [Decimal(x) for x in input().split()]\nY = [Decimal(y) for y in input().split()]\n\n# Function to calculate distance\ndef distance(x1, x2, y1, y2):\n    dx = x2 - x1\n    dy = y2 - y1\n    squared_distance = dx * dx + dy * dy\n    return squared_distance.sqrt()\n\n# Count points within the circle\nans = sum(distance(0, X[i], 0, Y[i]) <= D for i in range(N))\n\n# Print result\nprint(ans)"}
{"problem_id":"p03325","slow_code_col":"N = int(eval(input()))\n\n\n\nseq = list(map(int, input().split()))\n\n\n\ncnt = 0\n\n\n\nfor num in seq:\n\n    while num % 2 == 0:\n\n        cnt += 1\n\n        num \/= 2\n\n\n\nprint(cnt)\n","reference_code_col":"n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nans = 0\n\nfor num in a:\n\n    ans += format(num, 'b')[::-1].find('1')\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(input())\nseq = list(map(int, input().split()))\ncnt = sum(bin(num).count('1') - 1 for num in seq)\nprint(cnt)"}
{"problem_id":"p03371","slow_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n# input = sys.stdin.readline    ####\n\nint1 = lambda x: int(x) - 1\n\ndef II(): return int(eval(input()))\n\n\n\ndef MI(): return list(map(int, input().split()))\n\ndef MI1(): return list(map(int1, input().split()))\n\n\n\ndef LI(): return list(map(int, input().split()))\n\ndef LI1(): return list(map(int1, input().split()))\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n\n\ndef printlist(lst, k='\\n'): print((k.join(list(map(str, lst)))))\n\nINF = float('inf')\n\n\n\ndef solve():\n\n    a, b, c, x, y = MI()\n\n\n\n    ans = INF\n\n    for k in range(100001):\n\n        yen = 2 * c * k + max(0, x-k) * a + max(0, y-k) * b\n\n        ans = min(ans, yen)\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n","reference_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n# input = sys.stdin.readline    ####\n\nint1 = lambda x: int(x) - 1\n\ndef II(): return int(eval(input()))\n\n\n\ndef MI(): return list(map(int, input().split()))\n\ndef MI1(): return list(map(int1, input().split()))\n\n\n\ndef LI(): return list(map(int, input().split()))\n\ndef LI1(): return list(map(int1, input().split()))\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n\n\ndef printlist(lst, k='\\n'): print((k.join(list(map(str, lst)))))\n\nINF = float('inf')\n\n\n\ndef solve():\n\n    a, b, c, x, y = MI()\n\n\n\n    ans = 0\n\n    if a + b <= 2 * c:\n\n        mn = min(x, y)\n\n        ans = a * mn + b * mn + max(0, x-mn) * min(a, 2*c) + max(0, y-mn) * min(b, 2*c)\n\n\n\n    else:\n\n        mn = min(x, y)\n\n        ans = mn * 2 * c + max(0, x-mn) * min(a, 2*c) + max(0, y-mn) * min(b, 2*c)\n\n\n\n    print(ans)\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n","model_generated_potentially_faster_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n# input = sys.stdin.readline    ####\n\nint1 = lambda x: int(x) - 1\n\ndef II(): return int(eval(input()))\n\n\n\ndef MI(): return list(map(int, input().split()))\n\ndef MI1(): return list(map(int1, input().split()))\n\n\n\ndef LI(): return list(map(int, input().split()))\n\ndef LI1(): return list(map(int1, input().split()))\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n\n\ndef printlist(lst, k='\\n'): print((k.join(list(map(str, lst)))))\n\nINF = float('inf')\n\ndef solve():\n    a, b, c, x, y = MI()\n    \n    # Find the minimum point of the cost function\n    k = min(x \/\/ a, y \/\/ b)\n    ans = 2 * c * k + max(0, x - k * a) * a + max(0, y - k * b) * b\n    \n    print(ans)\n\nif __name__ == '__main__':\n    solve()"}
{"problem_id":"p03796","slow_code_col":"import math\n\nn = int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))","reference_code_col":"n = int(eval(input()))\n\nans = 1\n\nmod = 10**9+7\n\nfor i in range(1, n+1):\n\n    ans *= i\n\n    ans %= mod\n\n\n\nans %= mod\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"def factorial_modulo(n):\n    MOD = 10 ** 9 + 7\n    fact = [0] * (n + 1)\n    fact[0] = 1\n    \n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n        \n    return fact[n]\n\nn = int(input())\nprint(factorial_modulo(n))"}
{"problem_id":"p03845","slow_code_col":"n,t=int(input()),list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n","reference_code_col":"input();t=list(map(int,input().split()));T=sum(t)\n\nprint(*[T-t[i-1]+j for i,j in [list(map(int,input().split())) for _ in range(int(input()))]],sep='\\n')\n","model_generated_potentially_faster_code_col":"import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the first line: number of elements and the list of elements\nn = int(data[0])\nt = list(map(int, data[1:n+1]))\nT = sum(t)\n\n# Parse the queries\nqueries = []\nfor i in range(n + 1, len(data), 2):\n    x = int(data[i])\n    y = int(data[i + 1])\n    queries.append((x, y))\n\n# Process each query using the cumulative sum\nresults = []\nfor x, y in queries:\n    result = T - t[x-1] + y\n    results.append(result)\n\n# Print the results\nprint('\\n'.join(map(str, results)))"}
{"problem_id":"p03363","slow_code_col":"n = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nS = [0]*(n+1)\n\nnum={}\n\nfor i in range(n):\n\n    S[i+1] = S[i] + A[i]\n\nfor i in S:\n\n    if str(i) in list(num.keys()):\n\n        num[str(i)] += 1\n\n    else:\n\n        num[str(i)] = 1\n\nout = [i*(i-1)\/\/2 for i in list(num.values()) if i>1]\n\nprint((sum(out)))","reference_code_col":"n = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nS = [0]*(n+1)\n\nnum = {}\n\nfor i in range(n):\n\n    S[i+1] = S[i] + A[i]\n\nfor i in S:\n\n    s = str(i)\n\n    num[s] = 1 if s not in list(num.keys()) else num[s]+1\n\nout = [i*(i-1)\/\/2 for i in list(num.values()) if i > 1]\n\nprint((sum(out)))","model_generated_potentially_faster_code_col":"# Read input\nn = int(input())\nA = list(map(int, input().split()))\n\n# Initialize prefix sum array\nS = [0] * (n + 1)\nprefix_sum_count = {}\n\n# Compute prefix sums and count occurrences\nfor i in range(n):\n    S[i + 1] = S[i] + A[i]\n    if S[i + 1] in prefix_sum_count:\n        prefix_sum_count[S[i + 1]] += 1\n    else:\n        prefix_sum_count[S[i + 1]] = 1\n\n# Calculate the number of valid pairs\nresult = 0\nfor count in prefix_sum_count.values():\n    if count > 1:\n        result += count * (count - 1) \/\/ 2\n\n# Output the result\nprint(result)"}
{"problem_id":"p02555","slow_code_col":"def resolve():\n\n  base = 10**9+7\n\n  S = int(eval(input()))\n\n  dp = [0] * (S+1)\n\n  dp[0] = 1\n\n\n\n  for i in range(1, S+1):\n\n    for u in range(i-2):\n\n      dp[i] += dp[u]\n\n      dp[i] %= base\n\n  # print(dp)\n\n  print((dp[S]%base))\n\n\n\nif __name__ == \"__main__\":\n\n  resolve()\n","reference_code_col":"def resolve():\n\n  base = 10**9+7\n\n  S = int(eval(input()))\n\n  dp = [0] * (S+1)\n\n  dp[0] = 1\n\n\n\n  for i in range(3, S+1):\n\n    dp[i] = dp[i-1] + dp[i-3]\n\n  # print(dp)\n\n  print((dp[S]%base))\n\n\n\nif __name__ == \"__main__\":\n\n  resolve()","model_generated_potentially_faster_code_col":"def resolve():\n    base = 10**9 + 7\n\n    S = int(input())\n\n    dp = [0] * (S + 1)\n    dp[0] = 1\n\n    for i in range(3, S + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % base\n\n    print(dp[S])\n\nif __name__ == \"__main__\":\n    resolve()"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nA = np.array(A)\n\ncount = 0\n\nwhile 1:\n\n    x = 0\n\n    for i in range(N):\n\n        if A[i] % 2 == 1:\n\n            x = 1\n\n    if x == 1:\n\n        break\n\n    else:\n\n        A = A \/ 2\n\n        count+=1\n\nprint(count)","reference_code_col":"import math\n\nn = eval(input())\n\na = list(map(int, input().split()))\n\nans = float('inf')\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind('1') - 1)\n\nprint((round(ans)))","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(eval(input()))\nA = np.array(list(map(int, input().split())))\n\n# Calculate number of odd numbers in array\nnum_odds = np.sum(A % 2 != 0)\n\ncount = 0\n\n# Divide all elements by 2 until there are no more odd numbers\nwhile num_odds > 0:\n    A \/= 2\n    A = A.astype(np.int64) # to avoid float values after division\n    num_odds = np.sum(A % 2 != 0)\n    count += 1\n\nprint(count)"}
{"problem_id":"p03796","slow_code_col":"n = int(eval(input()))\n\nres = 1\n\nfor num in range(1, n+1):\n\n  res = res * num\n\n  res = res % (pow(10,9) + 7)\n\nprint(res)","reference_code_col":"n = int(eval(input()))\n\nres = 1\n\nfor num in range(1, n+1):\n\n    res = res * num\n\n    res = res % (10**9 + 7)\n\nprint(res)\n","model_generated_potentially_faster_code_col":"n = int(eval(input()))\ndp = [0]*(n+1)\nmod = pow(10,9) + 7\n\ndp[0] = dp[1] = 1\nfor i in range(2,n+1):\n    dp[i] = (i*dp[i-1])%mod\n\nprint(dp[n])"}
{"problem_id":"p03371","slow_code_col":"#!\/usr\/bin\/env python3\n\nimport sys, math, fractions, itertools\n\n\n\n\n\ndef solve(A: int, B: int, C: int, X: int, Y: int):\n\n    mn = 1e9\n\n    for i in range(0, 2*(max(X, Y)+1), 2):\n\n        mn = min(mn, C*i+A*max(X-i\/\/2, 0)+B*max(Y-i\/\/2, 0))\n\n    print((int(mn)))\n\n    return\n\n\n\n\n\n# Generated by 1.1.4 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    A = int(next(tokens))  # type: int\n\n    B = int(next(tokens))  # type: int\n\n    C = int(next(tokens))  # type: int\n\n    X = int(next(tokens))  # type: int\n\n    Y = int(next(tokens))  # type: int\n\n    solve(A, B, C, X, Y)\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\n\n\n\n\n\ndef solve(A: int, B: int, C: int, X: int, Y: int):\n\n    c = 0\n\n    if (A + B < 2 * C):\n\n        c += min(X, Y) * (A + B)\n\n    else:\n\n        c += min(X, Y) * 2 * C\n\n    if X > Y:\n\n        c += (X - Y) * min(A, 2 * C)\n\n    else:\n\n        c += (Y - X) * min(B, 2 * C)\n\n    print(c)\n\n    return\n\n\n\n\n\n# Generated by 1.1.5 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    A = int(next(tokens))  # type: int\n\n    B = int(next(tokens))  # type: int\n\n    C = int(next(tokens))  # type: int\n\n    X = int(next(tokens))  # type: int\n\n    Y = int(next(tokens))  # type: int\n\n    solve(A, B, C, X, Y)\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env python3\n\nimport sys, math, fractions, itertools\n\ndef solve(A: int, B: int, C: int, X: int, Y: int):\n    mn = float('inf')\n\n    for i in range(0, max(X, Y) + 1, 1):  # Simplify the range to avoid redundant calculations\n        max_X_minus_i_over_2 = max(X - i \/\/ 2, 0)\n        max_Y_minus_i_over_2 = max(Y - i \/\/ 2, 0)\n        current_cost = C * i + A * max_X_minus_i_over_2 + B * max_Y_minus_i_over_2\n        mn = min(mn, current_cost)\n\n    print(int(mn))\n    return\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n\n    tokens = iterate_tokens()\n    A = int(next(tokens))  # type: int\n    B = int(next(tokens))  # type: int\n    C = int(next(tokens))  # type: int\n    X = int(next(tokens))  # type: int\n    Y = int(next(tokens))  # type: int\n    solve(A, B, C, X, Y)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02917","slow_code_col":"N = int(eval(input()))\n\nB =list(map(int,input().split()))\n\nA=[0]*N\n\n\n\nA[0]=B[0]\n\nfor i in range(1,N-1):\n\n    A[i]=min(B[i],B[i-1])\n\nA[-1]=B[-1]\n\nprint((sum(A)))","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N=I()\n\n    B=LI()\n\n    A=[0]*N\n\n    A[0]=B[0]\n\n    A[-1]=B[-1]\n\n    for i in range(N-2):\n\n        A[i+1]=min(B[i],B[i+1])\n\n        \n\n    print((sum(A)))\n\n\n\nmain()\n","model_generated_potentially_faster_code_col":"N = int(input())\n\nB = list(map(int, input().split()))\n\nA = [0] * N\n\nA[0] = B[0]\n\nfor i in range(1, N - 1):\n    A[i] = min(B[i], B[i - 1])\n\nA[-1] = B[-1]\n\nprint(sum(A))"}
{"problem_id":"p02700","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\nA, B, C, D = list(map(int, input().split()))\n\n\n\nwhile True:\n\n    C -= B\n\n    \n\n    if C<=0:\n\n        print('Yes')\n\n        exit()\n\n    \n\n    A -= D\n\n    \n\n    if A<=0:\n\n        print('No')\n\n        exit()","reference_code_col":"A, B, C, D = list(map(int, input().split()))\n\nc1 = (C+B-1)\/\/B\n\nc2 = (A+D-1)\/\/D\n\n\n\nif c1<=c2:\n\n    print('Yes')\n\nelse:\n\n    print('No')","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\nA, B, C, D = map(int, input().split())\n\nwhile True:\n    C -= B\n    if C <= 0:\n        print(f\"Yes\")\n        break\n    A -= D\n    if A <= 0:\n        print(f\"No\")\n        break"}
{"problem_id":"p03575","slow_code_col":"icase=0\n\nif icase==0:\n\n    n,m=list(map(int, input().split()))\n\n    a=[]\n\n    b=[]\n\n    for i in range(m):\n\n        ai,bi=list(map(int, input().split()))\n\n        a.append(ai)\n\n        b.append(bi)\n\nelif icase==1:\n\n    n=6\n\n    m=5\n\n#    a=[[1],[2],[3],[4],[5]]\n\n#    b=[[2],[3],[4],[5],[6]]\n\n    a=[1,2,3,4,5]\n\n    b=[2,3,4,5,6]\n\nelif icase==2:\n\n    n=7\n\n    m=7\n\n    a=[1,2,3,4,4,5,6]\n\n    b=[3,7,4,5,6,6,7]\n\n\n\n    \n\nvtx=[]\n\nfor i in range(n):\n\n    vtx.append([i+1])\n\nicnt=0\n\n\n\nfor j in range(m):    \n\n    vtx1=vtx.copy()\n\n    a1=a.copy()\n\n    b1=b.copy()\n\n    del a1[j]\n\n    del b1[j]\n\n    \n\n    for i in range(m-1):\n\n        for v1 in vtx1:\n\n            if a1[i] in v1:\n\n                if not b1[i] in v1:\n\n                    for v2 in vtx1:\n\n                        if v1!=v2:\n\n                            if b1[i] in v2:\n\n                                break\n\n                    vtx1.remove(v1)\n\n                    vtx1.remove(v2)\n\n                    v3=v1+v2\n\n                    vtx1.append(v3)\n\n#        print(a[i],b[i],len(vtx1),vtx1)\n\n#    print(len(vtx1),vtx1)\n\n    if len(vtx1)!=1:\n\n        icnt=icnt+1\n\nprint(icnt)        ","reference_code_col":"limit=50\n\ngraph=[[False]*limit for i in range(limit)]\n\nvisited=[]*limit\n\n\n\ndef dfs(v,n,graph,visited):\n\n    visited[v]=True\n\n    for v2 in range(n):\n\n        if graph[v][v2]==False:\n\n            continue\n\n        if visited[v2]==True:\n\n            continue\n\n        dfs(v2,n,graph,visited)\n\n\n\nn,m=list(map(int,input().split()))\n\na=[0]*m\n\nb=[0]*m\n\nfor i in range(m):\n\n    ai,bi=list(map(int,input().split()))\n\n    a[i]=ai-1\n\n    b[i]=bi-1\n\n    graph[a[i]][b[i]]=True\n\n    graph[b[i]][a[i]]=True\n\n    \n\nans=0 \n\nfor i in range(m):\n\n    graph[a[i]][b[i]]=False\n\n    graph[b[i]][a[i]]=False\n\n    visited=[False]*n\n\n    dfs(0,n,graph,visited)\n\n    bridge=False\n\n    for j in range(n):\n\n        if visited[j]==False:\n\n            bridge=True\n\n    if bridge:\n\n        ans+=1\n\n    graph[a[i]][b[i]]=True\n\n    graph[b[i]][a[i]]=True\n\n    \n\nprint(ans)","model_generated_potentially_faster_code_col":"icase = 0\n\nif icase == 0:\n    n, m = map(int, input().split())\n    a = []\n    b = []\n    for _ in range(m):\n        ai, bi = map(int, input().split())\n        a.append(ai)\n        b.append(bi)\nelif icase == 1:\n    n = 6\n    m = 5\n    a = [1, 2, 3, 4, 5]\n    b = [2, 3, 4, 5, 6]\nelif icase == 2:\n    n = 7\n    m = 7\n    a = [1, 2, 3, 4, 4, 5, 6]\n    b = [3, 7, 4, 5, 6, 6, 7]\n\nvtx = [[i + 1] for i in range(n)]\nicnt = 0\n\nfor j in range(m):\n    a1 = a[:]\n    b1 = b[:]\n    del a1[j]\n    del b1[j]\n\n    seen = set()\n    for i in range(m - 1):\n        if (a1[i], b1[i]) in seen:\n            continue\n        seen.add((a1[i], b1[i]))\n\n        for v1 in vtx:\n            if a1[i] in v1:\n                if b1[i] not in v1:\n                    found = False\n                    for v2 in vtx:\n                        if v1 != v2 and b1[i] in v2:\n                            found = True\n                            break\n                    if found:\n                        new_vtx = sorted(set(v1 + v2))\n                        if new_vtx not in vtx:\n                            vtx.remove(v1)\n                            vtx.remove(v2)\n                            vtx.append(new_vtx)\n                        seen.add((a1[i], b1[i]))\n                        break\n\n    if len(vtx) != 1:\n        icnt += 1\n\nprint(icnt)"}
{"problem_id":"p03060","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nV = np.array([int(i) for i in input().split(\" \")])\n\nC = np.array([int(i) for i in input().split(\" \")])\n\n\n\nvc = V-C\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    if vc[i]>0:\n\n        val+=vc[i]\n\nprint(val)","reference_code_col":"N = int(eval(input()))\n\nV = [int(i) for i in input().split(\" \")]\n\nC = [int(i) for i in input().split(\" \")]\n\n\n\nval = 0\n\n\n\nfor i in range(N):\n\n    vc=V[i]-C[i]\n\n    if vc>0:\n\n        val+=vc\n\nprint(val)","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nV = np.array([int(i) for i in input().split(\" \")])\n\nC = np.array([int(i) for i in input().split(\" \")])\n\nvc = V - C\n\n# Use np.sum() to sum up all positive values in one go\nval = np.sum(vc[vc > 0])\n\nprint(val)"}
{"problem_id":"p02394","slow_code_col":"a=input().split()\n\nb=list(map(int,a))\n\nW=b[0]\n\nH=b[1]\n\nx=b[2]\n\ny=b[3]\n\nr=b[4]\n\nif (r <= x <= (W - r)) and (r <= y <= (H - r)):\n\n  print('Yes')\n\nelse:\n\n  print('No')","reference_code_col":"W,H,x,y,r = [int(i) for i in input().split()]\n\nif (r <= x <= (W - r)) and (r <= y <= (H - r)):\n\n  print('Yes')\n\nelse:\n\n  print('No')","model_generated_potentially_faster_code_col":"a = input().split()\nb = [int(num) for num in a]  # Using list comprehension for mapping\n\nW = b[0]\nH = b[1]\nx = b[2]\ny = b[3]\nr = b[4]\n\n# Store redundant calculations in variables\nmax_x = W - r\nmax_y = H - r\n\nif (r <= x <= max_x) and (r <= y <= max_y):\n    print('Yes')\nelse:\n    print('No')"}
{"problem_id":"p02394","slow_code_col":"ia = [int(i) for i in input().split(\" \")]\n\nW=ia[0]\n\nH=ia[1]\n\nx=ia[2]\n\ny=ia[3]\n\nr=ia[4]\n\nprint((\"Yes\" if 0<=x-r and x+r<=W and 0<=y-r and y+r<=H else \"No\"))","reference_code_col":"# encoding:utf-8\n\n\n\ninput = list(map(int, input().split()))\n\nW, H, x, y, r = input\n\n\n\nif x - r < 0 or x + r > W:\n\n\tprint(\"No\")\n\nelif y - r < 0 or y + r > H:\n\n\tprint(\"No\")\n\nelse:\n\n\tprint(\"Yes\")","model_generated_potentially_faster_code_col":"ia = [int(i) for i in input().split()]\n\nW = ia[0]\nH = ia[1]\nx = ia[2]\ny = ia[3]\nr = ia[4]\n\nprint((\"Yes\" if (x - r)**2 + (y - r)**2 <= r**2 and 0 <= x <= W and 0 <= y <= H else \"No\"))"}
{"problem_id":"p03457","slow_code_col":"N=eval(input())\n\na=[]\n\nt=True\n\nfor _ in range(int(N)):\n\n    a+=[list(map(int,input().split()))]\n\nfor i in range(int(N)):\n\n    if a[i][0]%2==0:\n\n        if abs(a[i][1]+a[i][2])<=a[i][0] and (a[i][1]+a[i][2])%2==0:\n\n            continue\n\n        else:\n\n            print('No')\n\n            t=False\n\n            break\n\n    else:\n\n        if abs(a[i][1]+a[i][2]<=a[i][0]) and (a[i][1]+a[i][2])%2==1:\n\n            continue\n\n        else:\n\n            print('No')\n\n            t=False\n\n            break\n\nif t:\n\n    print('Yes')","reference_code_col":"import sys\n\nn=int(eval(input()))\n\nt=[]\n\nfor i in range(n):\n\n    t.append(list(map(int,input().split())))\n\nfor i,d in enumerate(t):\n\n    if i>0:\n\n        b=d[0]-a\n\n        c=abs(d[1]+d[2]-aa)\n\n    a=d[0]\n\n    aa=d[1]+d[2]\n\n    if i==0:\n\n        if not (a >= aa and a % 2 == aa % 2):\n\n            print('No')\n\n            sys.exit()\n\n        else:\n\n            continue\n\n    if not (b>=c and b%2==c%2):\n\n        print('No')\n\n        sys.exit()\n\nprint('Yes')","model_generated_potentially_faster_code_col":"N = eval(input())\na = []\n\n# Read input into list 'a'\nfor _ in range(N):\n    a.append(list(map(int, input().split())))\n\n# Check conditions for each pair in 'a' and store results in a list\nresults = []\nfor i in range(N):\n    x, y, z = a[i]\n    if (x % 2 == 0 and abs(y + z) <= x and (y + z) % 2 == 0) or \\\n       (x % 2 != 0 and abs(y + z) <= x and (y + z) % 2 != 0):\n        results.append(True)\n    else:\n        results.append(False)\n\n# Print 'Yes' if all pairs satisfy the conditions, otherwise 'No'\nprint('Yes' if all(results) else 'No')"}
{"problem_id":"p03371","slow_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\n\n\nyenmin=a*x+b*y\n\nfor zz in range(2*10**5+1):\n\n    xx=max(x-zz\/\/2,0)\n\n    yy=max(y-zz\/\/2,0)\n\n    yen=a*xx+b*yy+c*zz\n\n    if yen<yenmin:\n\n        yenmin=yen\n\nprint(yenmin)\n\n#print(xx,yy,zz)","reference_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\n\n\ncmax=max(x,y)*2\n\nzmin=(a+b)*10**5\n\nfor nc in range(0,cmax+1,2):\n\n    na=max(x-nc\/\/2,0)\n\n    nb=max(y-nc\/\/2,0)\n\n    z=a*na+b*nb+c*nc\n\n    zmin=min(zmin,z)\n\n    \n\nprint(zmin)\n","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\n\n# Calculate the constant part of the expression\nconstant_part = a * x + b * y\n\n# Determine the optimal value of z based on the sign of c\nif c > 0:\n    z = 2 * 10**5\nelse:\n    z = 0\n\n# Calculate the minimum value of the expression\nyenmin = constant_part + c * z\n\nprint(yenmin)"}
{"problem_id":"p02772","slow_code_col":"import sys\n\nimport numpy as np\n\nn = int(eval(input()))\n\ninput = sys.stdin.readline\n\na = np.array(list(map(int, input().split())))\n\nfor i in a:\n\n    if i % 2 == 0:\n\n        if i % 3 != 0 and i % 5 != 0:\n\n            print('DENIED')\n\n            exit()\n\nprint('APPROVED')\n","reference_code_col":"#import sys\n\n#import numpy as np\n\nn = int(eval(input()))\n\n#input = sys.stdin.readline\n\n#a = np.array(list(map(int, input().split())))\n\na = list(map(int, input().split()))\n\nfor i in a:\n\n    if i % 2 == 0:\n\n        if i % 3 != 0 and i % 5 != 0:\n\n            print('DENIED')\n\n            exit()\n\nprint('APPROVED')\n","model_generated_potentially_faster_code_col":"import numpy as np\n\nn = int(eval(input()))\na = np.array(list(map(int, input().split())))\n\n# Find indices where numbers are even and not divisible by 3 or 5\nindices = np.where((a % 2 == 0) & (a % 3 != 0) & (a % 5 != 0))[0]\n\nif len(indices) > 0:\n    print('DENIED')\nelse:\n    print('APPROVED')"}
{"problem_id":"p03837","slow_code_col":"import queue\n\n\n\nINF = 123456789\n\n\n\ndef main():\n\n    n,m = list(map(int,input().split()))\n\n\n\n    G = [[] for _ in range(n)]\n\n    for _ in range(m):\n\n        a,b,c = list(map(int,input().split()))\n\n        a -= 1\n\n        b -= 1\n\n        G[a].append((b,c))\n\n        G[b].append((a,c))\n\n\n\n    used = set()\n\n    for i in range(n):\n\n        d = [INF for _ in range(n)]\n\n        par = [-1 for _ in range(n)]\n\n\n\n        # dijkstra\n\n        que = queue.PriorityQueue()\n\n        d[i] = 0\n\n        que.put((0,i))\n\n        while not que.empty():\n\n            p = que.get()\n\n            v = p[1]\n\n            if d[v] < p[0]:\n\n                continue\n\n            for (to,cost) in G[v]:\n\n                if d[to] > d[v]+cost:\n\n                    d[to] = d[v]+cost\n\n                    par[to] = v\n\n                    que.put((d[to],to))\n\n\n\n        for j in range(n):\n\n            if i != j:\n\n                a,b = j,par[j]\n\n                if a>b:\n\n                    a,b = b,a\n\n                used.add((a,b))\n\n\n\n    print((m - len(used)))\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"INF = 123456789\n\n\n\ndef main():\n\n    n,m = list(map(int,input().split()))\n\n\n\n    d = [ [INF for i in range(n)] for j in range(n) ]\n\n    for i in range(n):\n\n        d[i][i] = 0\n\n\n\n    a = [0 for _ in range(m)]\n\n    b = [0 for _ in range(m)]\n\n    c = [0 for _ in range(m)]\n\n    for i in range(m):\n\n        a[i],b[i],c[i] = list(map(int,input().split()))\n\n        a[i] -= 1\n\n        b[i] -= 1\n\n        d[a[i]][b[i]] = min(d[a[i]][b[i]], c[i])\n\n        d[b[i]][a[i]] = min(d[b[i]][a[i]], c[i])\n\n\n\n    # Warshall-Floyd\n\n    for k in range(n):\n\n        for i in range(n):\n\n            for j in range(n):\n\n                d[i][j] = min(d[i][j], d[i][k]+d[k][j])\n\n\n\n    ans = 0\n\n    for i in range(m):\n\n        found = 1\n\n        for j in range(n):\n\n            if d[j][a[i]] + c[i] == d[j][b[i]]:\n\n                found = 0\n\n                break\n\n        ans += found\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import heapq\n\nINF = 123456789\n\ndef dijkstra(graph, start):\n    n = len(graph)\n    dist = [INF] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                heapq.heappush(pq, (distance, v))\n                \n    return dist\n\ndef main():\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n)]\n    \n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        a -= 1\n        b -= 1\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n    \n    # Run Dijkstra's algorithm from each node\n    distances = []\n    for i in range(n):\n        distances.append(dijkstra(graph, i))\n    \n    # Track edges that are part of the shortest paths\n    used_edges = set()\n    for i in range(n):\n        for j in range(i+1, n):\n            if min(distances[i][j], distances[j][i]) < INF:\n                used_edges.add(tuple(sorted([i, j])))\n    \n    print(m - len(used_edges))\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03416","slow_code_col":"a,b = list(map(int,input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    s = str(i)\n\n    l = len(s)\n\n    if all(s[j] == s[l-j-1] for j in range(l)):\n\n            count += 1\n\nprint(count)","reference_code_col":"a,b = list(map(int,input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    s = str(i)\n\n    if s == s[::-1]:\n\n         count += 1\n\nprint(count)","model_generated_potentially_faster_code_col":"a, b = map(int, input().split())\n\ncount = 0\n\nfor i in range(a, b + 1):\n    num_str = str(i)\n    length = len(num_str)\n    \n    # Check if the number is a palindrome\n    is_palindrome = True\n    for j in range(length \/\/ 2):\n        if num_str[j] != num_str[length - j - 1]:\n            is_palindrome = False\n            break\n    \n    if is_palindrome:\n        count += 1\n\nprint(count)"}
{"problem_id":"p03575","slow_code_col":"\n\nclass UnionFind:\n\n    def __init__(self, size):\n\n        self.table = [i for i in range(size)]\n\n\n\n    def find(self, x):\n\n        return self.table[x]\n\n\n\n    def union(self, x, y):\n\n        x1 = self.find(x)\n\n        y1 = self.find(y)\n\n\n\n        if x1 == y1:\n\n            return False\n\n\n\n        for i in range(len(self.table)):\n\n            if self.table[i] == y1:\n\n                self.table[i] = x1\n\n        return True\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nedges = []\n\nfor _ in range(M):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1])\n\n\n\nmat = [[0]*N for _ in range(N)]\n\nfor s, g in edges:\n\n    mat[s][g] = 1\n\n    mat[g][s] = 1\n\n\n\nans = 0\n\n\n\nfor i in range(M):\n\n    uni = UnionFind(N)\n\n\n\n    for j in range(M):\n\n        if i != j:\n\n            uni.union(edges[j][0], edges[j][1])\n\n\n\n    if not all(uni.find(0) == uni.find(x) for x in range(N)):\n\n        ans += 1\n\nprint(ans)\n","reference_code_col":"# python template for atcoder1\n\nimport sys\n\nsys.setrecursionlimit(10**9)\n\ninput = sys.stdin.readline\n\n\n\n\n\nclass UnionFind:\n\n    def __init__(self, size):\n\n        \"\"\"\n\n        size:\u9802\u70b9\u306e\u6570\n\n        \"\"\"\n\n        self.parent = [i for i in range(size)]\n\n        self.rank = [0 for _ in range(size)]\n\n\n\n    def find(self, x):\n\n        \"\"\"\n\n        x\u306eroot\u3092\u8fd4\u3059\n\n        \"\"\"\n\n        if self.parent[x] == x:\n\n            return x\n\n        else:\n\n            return self.find(self.parent[x])\n\n\n\n    def union(self, x, y):\n\n        \"\"\"\n\n        x,y\u3092\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u3068\u3057\u3066\u307e\u3068\u3081\u308b\n\n        \"\"\"\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n        if x == y:\n\n            return\n\n\n\n        if self.rank[x] < self.rank[y]:\n\n            self.parent[x] = y\n\n        else:\n\n            self.parent[y] = x\n\n            if self.rank[x] == self.rank[y]:\n\n                self.rank[x] += 1\n\n\n\n    def same(self, x, y):\n\n        \"\"\"\n\n        x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306a\u3089True\n\n        \"\"\"\n\n        return self.find(x) == self.find(y)\n\n\n\n    def component(self):\n\n        \"\"\"\n\n        \u5404\u9023\u7d50\u6210\u5206\u306eroot\u306e\u96c6\u5408\u3092\u8fd4\u3059\n\n        len()\u3092\u3068\u308c\u3070\u9023\u7d50\u6210\u5206\u306e\u6570\u304c\u6c42\u3081\u3089\u308c\u308b\n\n        return-> set()\n\n        \"\"\"\n\n        comp = set()\n\n        for i in self.parent:\n\n            p = self.find(i)\n\n            comp.add(p)\n\n        return comp\n\n\n\n    def __str__(self):\n\n        \"\"\"\n\n        for debug\n\n        \u30af\u30e9\u30b9\u306elist\u306e\u60c5\u5831\u3092\u51fa\u529b\n\n        \"\"\"\n\n        ret = \"parents\\n\"\n\n        ret += \" \".join(map(str, self.parent))\n\n        ret += '\\n'\n\n        ret += \" \".join(map(str, self.rank))\n\n        return ret\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\nedges = []\n\n\n\nfor _ in range(M):\n\n    a, b = [int(x)-1 for x in input().split()]\n\n    edges.append([a, b])\n\n\n\nans = 0\n\nfor e in edges:\n\n    Un = UnionFind(N)\n\n    for g in edges:\n\n        if e == g:\n\n            continue\n\n        else:\n\n            Un.union(g[0], g[1])\n\n    if not Un.same(e[0], e[1]):\n\n        ans += 1\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"class UnionFind:\n\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [1] * size\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])  # Path compression\n        return self.parent[x]\n\n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n\n        if rootX != rootY:\n            if self.rank[rootX] > self.rank[rootY]:\n                self.parent[rootY] = rootX\n            elif self.rank[rootX] < self.rank[rootY]:\n                self.parent[rootX] = rootY\n            else:\n                self.parent[rootY] = rootX\n                self.rank[rootX] += 1\n            return True\n        return False\n\n\ndef count_components_after_removal(N, M, edges):\n    uf = UnionFind(N)\n    \n    # Initialize the matrix and perform union operations\n    mat = [[0]*N for _ in range(N)]\n    for s, g in edges:\n        mat[s][g] = 1\n        mat[g][s] = 1\n        uf.union(s, g)\n        \n    # Count initial number of components\n    initial_components = sum(1 for i in range(N) if uf.find(i) == i)\n    \n    ans = 0\n    \n    # Remove each edge one by one and count components\n    for s, g in edges:\n        # Reset the edge\n        mat[s][g] = 0\n        mat[g][s] = 0\n        \n        # Perform union operations excluding the removed edge\n        uf.reset()\n        for s_prime, g_prime in edges:\n            if (s_prime, g_prime) != (s, g):\n                uf.union(s_prime, g_prime)\n        \n        # Count the number of components after removal\n        current_components = sum(1 for i in range(N) if uf.find(i) == i)\n        \n        # If the number of components changes, increment the answer\n        if current_components != initial_components:\n            ans += 1\n    \n    return ans\n\n\n# Input\nN, M = list(map(int, input().split()))\nedges = []\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    edges.append([a-1, b-1])\n\n# Output\nprint(count_components_after_removal(N, M, edges))"}
{"problem_id":"p02688","slow_code_col":"import numpy as np\n\nN, K = list(map(int, input().split()))\n\n \n\nA = np.zeros(N, dtype=int)\n\n \n\nfor _ in range(K):\n\n    eval(input())\n\n    for i in input().split():\n\n        A[int(i) - 1] += 1\n\n \n\nans = 0\n\nfor i in A:\n\n    if i == 0:\n\n        ans += 1\n\nprint(ans)\n\n ","reference_code_col":"N, K = list(map(int, input().split()))\n\n\n\nA = [0] * N\n\n\n\nfor _ in range(K):\n\n    eval(input())\n\n    for i in map(int, input().split()):\n\n        A[i - 1] += 1\n\n\n\nprint((A.count(0)))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN, K = map(int, input().split())\n\n# Initialize array with zeros\nA = np.zeros(N, dtype=int)\n\n# Process each update operation\nfor _ in range(K):\n    # Skip reading the \"update\" string\n    input()\n    \n    # Convert all indices to integers at once\n    indices = list(map(int, input().split()))\n    \n    # Increment the count for each index\n    np.add.at(A, indices - 1, 1)\n\n# Count how many elements are zero\nans = np.sum(A == 0)\nprint(ans)"}
{"problem_id":"p03575","slow_code_col":"import numpy as np\n\n\n\nn,m = list(map(int, input().split()))\n\n\n\nconnect = np.zeros((n,n))\n\n\n\nfor i in range(m):\n\n    a, b = list(map(int, input().split()))\n\n    connect[a-1, b-1] = 1\n\n    connect[b-1, a-1] = 1\n\n\n\nnotbridge = 0\n\n\n\n\n\nfor i in range(n):\n\n    for j in range(n):\n\n        if connect[i,j] == 1:\n\n            connect[i,j] = 0\n\n            connect[j,i] = 0\n\n            stack =[1]\n\n            visited = [1]\n\n            while stack:\n\n                p = stack.pop()\n\n                for k in range(n):\n\n                    if connect[p,k] == 1:\n\n                        if k not in visited:\n\n                            stack.append(k)\n\n                            visited.append(k)\n\n            if len(visited) == n:\n\n                notbridge += 1\n\n            connect[i,j] = 1\n\n            connect[j,i] = 1\n\n\n\n\n\n\n\nprint((m-notbridge\/\/2))\n\n\n\n\n","reference_code_col":"n,m = list(map(int, input().split()))\n\n\n\nconnect = [[0 for i in range(n)] for j in range(n)]\n\n\n\nfor i in range(m):\n\n    a, b = list(map(int, input().split()))\n\n    connect[a-1][b-1] = 1\n\n    connect[b-1][a-1] = 1\n\n\n\nnotbridge = 0\n\n\n\n\n\nfor i in range(n):\n\n    for j in range(n):\n\n        if connect[i][j] == 1:\n\n            connect[i][j] = 0\n\n            connect[j][i] = 0\n\n            stack =[1]\n\n            visited = [1]\n\n            while stack:\n\n                p = stack.pop()\n\n                for k in range(n):\n\n                    if connect[p][k] == 1:\n\n                        if k not in visited:\n\n                            stack.append(k)\n\n                            visited.append(k)\n\n            if len(visited) == n:\n\n                notbridge += 1\n\n            connect[i][j] = 1\n\n            connect[j][i] = 1\n\n\n\n\n\n\n\nprint((m-notbridge\/\/2))\n\n\n\n\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Input values\nn, m = map(int, input().split())\n\n# Initialize adjacency matrix\nconnect = np.zeros((n, n), dtype=int)\n\n# Read connections\nfor _ in range(m):\n    a, b = map(int, input().split())\n    connect[a-1, b-1] = 1\n    connect[b-1, a-1] = 1\n\n# Function to check if two nodes are connected\ndef dfs(i, j):\n    stack = [(i, j)]\n    visited = set()\n    while stack:\n        x, y = stack.pop()\n        if (x, y) not in visited:\n            visited.add((x, y))\n            for k in range(n):\n                if connect[x, k]:\n                    stack.append((k, y))\n    return len(visited) == n\n\n# Check each connection\nnotbridge = 0\nfor i in range(n):\n    for j in range(i+1, n):  # Avoid duplicate checks\n        if connect[i, j]:\n            connect[i, j] = 0\n            connect[j, i] = 0\n            if dfs(i, j):\n                notbridge += 1\n            connect[i, j] = 1\n            connect[j, i] = 1\n\n# Output result\nprint(m - notbridge \/\/ 2)"}
{"problem_id":"p03579","slow_code_col":"import sys\n\nsys.setrecursionlimit(100000)\n\nN, M = list(map(int, input().split()))\n\nedges = [list(map(int, input().split())) for _ in range(M)]\n\n\n\ngraph = [[] for _ in range(N)]\n\nfor x, y in edges:\n\n    graph[x - 1].append(y - 1)\n\n    graph[y - 1].append(x - 1)\n\n\n\ndef dfs(v, c):\n\n    # c: color = 1 or -1\n\n    node[v] = c\n\n    for i in graph[v]:\n\n        if node[i] == c:\n\n            return False\n\n        \n\n        if node[i] == 0 and not dfs(i, -c):\n\n            return False\n\n        \n\n    return True\n\n\n\nnode = [0] * N\n\nif dfs(0, 1):\n\n    x = sum(v + 1 for v in node) \/\/ 2\n\n    print((x * (N - x) - M))\n\nelse:\n\n    print((N * (N - 1) \/\/ 2 - M))\n","reference_code_col":"from collections import deque\n\nN, M = list(map(int, input().split()))\n\nedges = [list(map(int, input().split())) for _ in range(M)]\n\n\n\ngraph = [[] for _ in range(N)]\n\nfor x, y in edges:\n\n    graph[x - 1].append(y - 1)\n\n    graph[y - 1].append(x - 1)\n\n\n\ndef dfs(s, c):\n\n    q = deque()\n\n    q.append(s)\n\n    visited[s] = True\n\n    color[s] = c\n\n    \n\n    while len(q) > 0:\n\n        v = q.pop()\n\n        for i in graph[v]:\n\n            if visited[i] and color[i] == color[v]:\n\n                return False\n\n            \n\n            if not visited[i]:\n\n                visited[i] = True\n\n                color[i] = -color[v]\n\n                q.append(i)\n\n                \n\n    return True\n\n\n\nvisited = [False] * N\n\ncolor = [0] * N\n\n\n\nif dfs(0, 1):\n\n    x = sum(v + 1 for v in color) \/\/ 2\n\n    print((x * (N - x) - M))\n\nelse:\n\n    print((N * (N - 1) \/\/ 2 - M))\n\n    \n\n    ","model_generated_potentially_faster_code_col":"import sys\n\nN, M = map(int, input().split())\n\nedges = [tuple(map(int, input().split())) for _ in range(M)]\n\ngraph = [[] for _ in range(N)]\n\nfor x, y in edges:\n    graph[x - 1].append(y - 1)\n    graph[y - 1].append(x - 1)\n\n# Initialize color array\ncolors = [False] * N\n\ndef dfs(start):\n    stack = [(start, True)]\n    while stack:\n        vertex, color = stack.pop()\n        if colors[vertex] != color:\n            return False\n        colors[vertex] = color\n        for neighbor in graph[vertex]:\n            if not colors[neighbor]:\n                stack.append((neighbor, not color))\n    return True\n\nif dfs(0):\n    x = sum(colors)\n    print((x * (N - x) - M))\nelse:\n    print((N * (N - 1) \/\/ 2 - M))"}
{"problem_id":"p03457","slow_code_col":"def main():\n\n    import sys\n\n    input = sys.stdin.buffer.readline\n\n    N = int(input())\n\n    TXY = [[int(i) for i in input().split()] for j in range(N)]\n\n    time, px, py = 0, 0, 0\n\n    for t, x, y in TXY:\n\n        move = abs(x-px) + abs(y-py)\n\n        # print(move, t-time)\n\n        if (t - time) % 2 != move % 2 or t - time < move:\n\n            return print(\"No\")\n\n        time, px, py = t, x, y\n\n    print(\"Yes\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def main():\n\n    import sys\n\n    input = sys.stdin.buffer.readline\n\n    N = int(input())\n\n    TXY = [[int(i) for i in input().split()] for j in range(N)]\n\n    time = 0\n\n    px = 0\n\n    py = 0\n\n    for t, x, y in TXY:\n\n        move = abs(py-y) + abs(px - x)\n\n        if (t-time) < move or (t - time) % 2 != move % 2:\n\n            return print(\"No\")\n\n        time = t\n\n        px = x\n\n        py = y\n\n    print(\"Yes\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    import sys\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    TXY = []\n    for _ in range(N):\n        t = int(data[index])\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        TXY.append((t, x, y))\n        index += 3\n\n    time, px, py = 0, 0, 0\n\n    for t, x, y in TXY:\n        move = abs(x - px) + abs(y - py)\n\n        if (t - time) % 2 != move % 2 or t - time < move:\n            return print(\"No\")\n\n        time, px, py = t, x, y\n\n    print(\"Yes\")\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03309","slow_code_col":"import numpy as np\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmed = np.median(np.array(al))\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(a-med)\n\nprint((int(ans)))","reference_code_col":"import statistics\n\nn = int(eval(input()))\n\nal = list(map(int,input().split()))\n\n\n\nfor i in range(n):\n\n    al[i] -= i + 1\n\n\n\nmedian = statistics.median(al)\n\n\n\nans = 0\n\nfor a in al:\n\n    ans += abs(median - a)\n\n\n\nprint((int(ans)))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input\nn = int(input())\nal = np.array(list(map(int, input().split())))\n\n# Subtract indices from elements\nal -= np.arange(n) + 1\n\n# Calculate median\nmed = np.median(al)\n\n# Calculate sum of absolute deviations\nans = np.sum(np.abs(al - med))\n\n# Print result\nprint(int(ans))"}
{"problem_id":"p03287","slow_code_col":"import numpy as np\n\n(n, m) = list(map(int, input().split()))\n\na = np.array(list(map(int, input().split()))).astype(\"int64\") \n\na = np.cumsum(a)\n\na %= m\n\ncount = np.sum(a == 0)\n\na.sort()\n\ntc = 1\n\nfor i in range(1, n):\n\n    if a[i - 1] == a[i]:\n\n        tc += 1\n\n    else:\n\n        count += tc * (tc - 1) \/\/ 2\n\n        tc = 1\n\nelse:\n\n    count += tc * (tc - 1) \/\/ 2\n\nprint(count)","reference_code_col":"(n, m) = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nunique_a = {a[0] % m: 1}\n\nfor i in range(1, n):\n\n    a[i] += a[i - 1]\n\n    a[i] %= m\n\n    if a[i] in unique_a:\n\n        unique_a[a[i]] += 1\n\n    else:\n\n        unique_a[a[i]] = 1\n\ncount = 0\n\nif 0 in unique_a:\n\n    count += unique_a[0]\n\nfor k in unique_a:\n\n    count += unique_a[k] * (unique_a[k] - 1) \/\/ 2\n\nprint(count)","model_generated_potentially_faster_code_col":"import numpy as np\n\n(n, m) = map(int, input().split())\n\na = np.array(list(map(int, input().split()))).astype(\"int64\")\n\na = np.cumsum(a)\n\na %= m\n\nprefix_sum_freq = {}\n\ncount = 0\n\nfor s in a:\n    count += prefix_sum_freq.get(s, 0)\n    prefix_sum_freq[s] = prefix_sum_freq.get(s, 0) + 1\n\nprint(count)"}
{"problem_id":"p03553","slow_code_col":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\n\n\nsys.setrecursionlimit(10**7)\n\ninf = 10**20\n\neps = 1.0 \/ 10**15\n\nmod = 10**9+7\n\n\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\n\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\n\ndef LS(): return sys.stdin.readline().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef F(): return float(sys.stdin.readline())\n\ndef S(): return input()\n\ndef pf(s): return print(s, flush=True)\n\ndef divisions(n):\n\n    sq = int(math.sqrt(n)+1)\n\n    d = collections.defaultdict(int)\n\n    while n % 2 == 0:\n\n        n \/\/= 2\n\n        d[2] += 1\n\n    i = 3\n\n    while n > 1 and sq >= i:\n\n        if n % i == 0:\n\n            n \/\/= i\n\n            d[i] += 1\n\n        else:\n\n            i += 2\n\n\n\n    if n > 1:\n\n        d[n] += 1\n\n\n\n    r = [1]\n\n    for k, v in d.items():\n\n        for c in r[:]:\n\n            for i in range(1,v+1):\n\n                r.append(c*(k**i))\n\n\n\n    return sorted(r)\n\n\n\ndef main():\n\n    n = I()\n\n    a = LI()\n\n    s = set()\n\n    for i in range(n,0,-1):\n\n        d = divisions(i)\n\n        ld = len(d)\n\n        for j in range(1,2**ld):\n\n            c = []\n\n            ff = True\n\n            for k in range(ld):\n\n                if j & (1<<k):\n\n                    f = True\n\n                    for e in c:\n\n                        if d[k] % e == 0:\n\n                            f = False\n\n                            ff = False\n\n                            break\n\n                    if f:\n\n                        c.append(d[k])\n\n                if not ff:\n\n                    break\n\n            if ff:\n\n                s.add(tuple(c + [n+1]))\n\n    b = sorted(list(s), reverse=True)\n\n    for c in b:\n\n        t = 0\n\n        for j in range(1,n+1):\n\n            f = False\n\n            for e in c:\n\n                if j%e == 0:\n\n                    f = True\n\n                    break\n\n            if f:\n\n                t += a[j-1]\n\n        if t < 0:\n\n            for j in range(1,n+1):\n\n                f = False\n\n                for e in c:\n\n                    if j%e == 0:\n\n                        f = True\n\n                        break\n\n                if f:\n\n                    a[j-1] = 0\n\n\n\n    return sum(a)\n\n\n\n\n\n\n\nprint(main())\n\n\n\n\n","reference_code_col":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nimport time,random\n\n\n\nsys.setrecursionlimit(10**7)\n\ninf = 10**20\n\neps = 1.0 \/ 10**10\n\nmod = 10**9+7\n\nmod2 = 998244353\n\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\n\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\n\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\n\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\n\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\n\ndef LS(): return sys.stdin.readline().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef F(): return float(sys.stdin.readline())\n\ndef S(): return input()\n\ndef pf(s): return print(s, flush=True)\n\ndef pe(s): return print(str(s), file=sys.stderr)\n\ndef JA(a, sep): return sep.join(map(str, a))\n\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\n\n\n\nclass Flow():\n\n    def __init__(self, e, N):\n\n        self.E = e\n\n        self.N = N\n\n\n\n    def max_flow(self, s, t):\n\n        r = 0\n\n        e = self.E\n\n\n\n        def f(c, cap):\n\n            v = self.v\n\n            v[c] = 1\n\n            if c == t:\n\n                return cap\n\n            for i in range(self.N):\n\n                if v[i] or e[c][i] <= 0:\n\n                    continue\n\n                cp = min(cap, e[c][i])\n\n                k = f(i, cp)\n\n                if k > 0:\n\n                    e[c][i] -= k\n\n                    e[i][c] += k\n\n                    return k\n\n            return 0\n\n\n\n        while True:\n\n            self.v = [None] * self.N\n\n            fs = f(s, inf)\n\n            if fs == 0:\n\n                break\n\n            r += fs\n\n\n\n        return r\n\n\n\n\n\ndef main():\n\n    n = I()\n\n    a = LI()\n\n\n\n    s = n\n\n    t = n + 1\n\n    e = [[0] * (n+2) for _ in range(n+2)]\n\n    for i in range(n):\n\n        c = a[i]\n\n        if c < 0:\n\n            e[s][i] = -c\n\n            ii = i + 1\n\n            for j in range(ii*2, n+1, ii):\n\n                e[i][j-1] = inf\n\n        else:\n\n            e[i][t] = c\n\n\n\n\n\n    fl = Flow(e, n+2)\n\n    r = fl.max_flow(s,t)\n\n\n\n    return sum(map(lambda x: max(0,x), a)) - r\n\n\n\n# start = time.time()\n\nprint(main())\n\n# pe(time.time() - start)\n\n\n\n\n\n\n","model_generated_potentially_faster_code_col":"import math\n\ndef divisions(n):\n    d = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            d.add(i)\n            d.add(n \/\/ i)\n    return sorted(d)"}
{"problem_id":"p02881","slow_code_col":"N = int(eval(input()))\n\nans = N - 1\n\np = 1\n\nfor i in range(2, int((N ** 0.5) + 1)):\n\n    if p % 2 == 1 and i > (N ** 0.5):\n\n        break\n\n    if N % i == 0:\n\n        p = i\n\n        j = N \/\/ i\n\n        m = i + j - 2\n\n        if m < ans:\n\n            ans = m\n\n        else:\n\n            continue\n\n    else:\n\n        continue\n\nprint(ans)\n","reference_code_col":"N = int(eval(input()))\n\nans = N - 1\n\nfor i in range(2, int((N ** 0.5) + 1)):\n\n    if N % i == 0:\n\n        j = N \/\/ i\n\n        m = i + j - 2\n\n        ans = min(ans, m)\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import math\n\n# Read input and convert it to integer\nN = int(eval(input()))\n\n# Initialize ans with a large value\nans = float('inf')\n\n# Iterate from 2 to sqrt(N)\nfor i in range(2, int(math.sqrt(N)) + 1):\n    if N % i == 0:\n        # Calculate j\n        j = N \/\/ i\n        # Calculate m\n        m = i + j - 2\n        # Update ans if m is smaller\n        if m < ans:\n            ans = m\n\n# Print the result\nprint(ans)"}
{"problem_id":"p03078","slow_code_col":"import sys\n\nimport heapq\n\n\n\n\n\n# \\n\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\n\n\n\n\ndef main():\n\n    X, Y, Z, K = list(map(int, input().split()))\n\n    A = list(map(int, input().split()))\n\n    B = list(map(int, input().split()))\n\n    C = list(map(int, input().split()))\n\n\n\n    A.sort(reverse=True)\n\n    B.sort(reverse=True)\n\n    C.sort(reverse=True)\n\n\n\n    Q = []\n\n    S = set()\n\n    heapq.heapify(Q)\n\n    heapq.heappush(Q, (-A[0] - B[0] - C[0], 0, 0, 0))\n\n    for i in range(K):\n\n        m, a, b, c = heapq.heappop(Q)\n\n        print((-m))\n\n        if (a + 1, b, c) not in S and a + 1 < X:\n\n            heapq.heappush(Q, (-A[a + 1] - B[b] - C[c], a + 1, b, c))\n\n            S.add((a + 1, b, c))\n\n        if (a, b + 1, c) not in S and b + 1 < Y:\n\n            heapq.heappush(Q, (-A[a] - B[b + 1] - C[c], a, b + 1, c))\n\n            S.add((a, b + 1, c))\n\n        if (a, b, c + 1) not in S and c + 1 < Z:\n\n            heapq.heappush(Q, (-A[a ] - B[b] - C[c+1], a, b, c + 1))\n\n            S.add((a, b, c + 1))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"import sys\n\n\n\n\n\n# \\n\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\n\n\n\n\ndef main():\n\n    X, Y, Z, K = list(map(int, input().split()))\n\n    A = list(map(int, input().split()))\n\n    B = list(map(int, input().split()))\n\n    C = list(map(int, input().split()))\n\n\n\n    A.sort(reverse=True)\n\n    B.sort(reverse=True)\n\n    C.sort(reverse=True)\n\n\n\n    L = []\n\n\n\n    for i in range(X):\n\n        for j in range(min(Y, K \/\/ (i + 1) + 1)):\n\n            for k in range(min(Z, K \/\/ (i + 1) \/\/ (j + 1) + 1)):\n\n                L.append(A[i] + B[j] + C[k])\n\n\n\n    L.sort(reverse=True)\n\n\n\n    for i in range(K):\n\n        print((L[i]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import heapq\nfrom typing import List\n\ndef k_largest_sums(A: List[int], B: List[int], C: List[int], K: int) -> List[int]:\n    # Initialize heap with negative sum of first elements and indices\n    max_heap = [(-A[0] - B[0] - C[0], 0, 0, 0)]\n    \n    visited = set()\n    visited.add((0, 0, 0))\n    \n    result = []\n    \n    while len(max_heap) > 0 and len(result) < K:\n        neg_sum, i, j, k = heapq.heappop(max_heap)\n        \n        # Append positive sum to result\n        result.append(-neg_sum)\n        \n        # Explore next possible combinations\n        if i + 1 < len(A) and (i + 1, j, k) not in visited:\n            heapq.heappush(max_heap, (-A[i + 1] - B[j] - C[k], i + 1, j, k))\n            visited.add((i + 1, j, k))\n        \n        if j + 1 < len(B) and (i, j + 1, k) not in visited:\n            heapq.heappush(max_heap, (-A[i] - B[j + 1] - C[k], i, j + 1, k))\n            visited.add((i, j + 1, k))\n        \n        if k + 1 < len(C) and (i, j, k + 1) not in visited:\n            heapq.heappush(max_heap, (-A[i] - B[j] - C[k + 1], i, j, k + 1))\n            visited.add((i, j, k + 1))\n    \n    return result\n\n# Read input\nX, Y, Z, K = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\n\n# Call function and print results\nfor num in k_largest_sums(A, B, C, K):\n    print(num)"}
{"problem_id":"p03494","slow_code_col":"def two_count(x):\n\n\tif int(str(x)[-1]) % 2 == 0:\n\n\t\treturn 1 + two_count(x\/\/2)\n\n\telse:\n\n\t\treturn 0\n\n\n\nn = int(eval(input()))\n\nn_list = [int(n) for n in input().split(\" \")]\n\n\n\nn_two_count_list = [two_count(n) for n in n_list]\n\n\n\nprint((min(n_two_count_list)))","reference_code_col":"def two_count(x):\n\n\tif x % 2 == 0:\n\n\t\treturn 1 + two_count(x\/\/2)\n\n\telse:\n\n\t\treturn 0\n\n\n\nn = int(eval(input()))\n\nn_list = [int(n) for n in input().split(\" \")]\n\n\n\nn_two_count_list = [two_count(n) for n in n_list]\n\n\n\nprint((min(n_two_count_list)))","model_generated_potentially_faster_code_col":"def two_count(x, mem={}):\n\n    if x not in mem: \n\n        if int(str(x)[-1]) % 2 == 0:\n\n            mem[x] = 1 + two_count(x\/\/2, mem)\n\n        else:\n\n            mem[x] = 0\n\n    return mem[x]\n\n\nn = int(eval(input()))\nn_list = [int(n) for n in input().split(\" \")]\n\nn_two_count_list = [two_count(n) for n in n_list]\n\nprint(min(n_two_count_list))"}
{"problem_id":"p02883","slow_code_col":"import numpy as np\n\nN, K= list(map(int, input().split()))\n\nA=[int(i) for i in input().split()]\n\nF=[int(i) for i in input().split()]\n\n\n\nA=np.array(sorted(A, reverse=True))\n\nF=np.array(sorted(F))\n\n\n\nlower_bound=0\n\nupper_bound=np.max(A*F)\n\nK_tmp=0\n\n\n\nwhile upper_bound>=lower_bound:\n\n    mid=(lower_bound+upper_bound)\/\/2\n\n    K_tmp=np.sum(np.maximum(A-mid\/\/F, 0))\n\n    if K_tmp<=K:\n\n        upper_bound=mid-1\n\n    else:\n\n        lower_bound=mid+1\n\n\n\nprint(lower_bound)","reference_code_col":"n,k=list(map(int,input().split()))\n\n*a,= list(map(int,input().split()))\n\n*f,= list(map(int,input().split()))\n\na=sorted(a)\n\nf=sorted(f, reverse=True)\n\n\n\ndef is_ok(arg):\n\n    cnt=0\n\n    for i in range(n):\n\n        cnt+=max(a[i]-arg\/\/f[i], 0)\n\n    return cnt<=k\n\n\n\ndef meguru_bisect(ng, ok):\n\n    while (abs(ok - ng) > 1):\n\n        mid = (ok + ng) \/\/ 2\n\n        if is_ok(mid):\n\n            ok = mid\n\n        else:\n\n            ng = mid\n\n    return ok\n\n\n\nprint((meguru_bisect(-1, 10**12)))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN, K = map(int, input().split())\nA = np.array(list(map(int, input().split())))\nF = np.array(list(map(int, input().split())))\n\n# Sort arrays\nA = np.sort(A)[::-1]\nF = np.sort(F)\n\n# Initialize binary search bounds\nlower_bound = 0\nupper_bound = np.max(A * F)\n\n# Perform binary search\nwhile lower_bound <= upper_bound:\n    mid = (lower_bound + upper_bound) \/\/ 2\n    K_tmp = np.sum(np.maximum(A - mid \/\/ F, 0))\n    \n    if K_tmp <= K:\n        lower_bound = mid + 1\n    else:\n        upper_bound = mid - 1\n\n# Print result\nprint(lower_bound - 1)"}
{"problem_id":"p02635","slow_code_col":"def main():\n\n    mod = 998244353\n\n    s, k = input().split()\n\n    k = int(k)\n\n    n = len(s)\n\n\n\n    one = s.count(\"1\")\n\n\n\n    cnt = 0\n\n    zero_list = []\n\n    for i in range(n):\n\n        if s[i] == \"0\":\n\n            zero_list.append(cnt)\n\n            cnt = 0\n\n        else:\n\n            cnt += 1\n\n\n\n    z = 0\n\n    mm = min(one, k)\n\n\n\n    dp = [[0]*(one+1) for _ in [0]*(one+1)]\n\n    dp[0][0] = 1\n\n\n\n    for i in range(len(zero_list)):\n\n        dp2 = [[0]*(mm+1) for _ in [0]*(one+1)]\n\n        base = zero_list[i]\n\n        # j:\u4f55\u500b\u4eca\u307e\u3067\u306b\u5165\u308c\u305f\u304b\n\n        for j in range(one+1):\n\n            # l:\u4f55\u500b\u5165\u308c\u308b\u304b\n\n            for l in range(one+1-j):\n\n                if l < z+base-j:\n\n                    continue\n\n                ml = max(l-base, 0)\n\n                # p:\u3053\u308c\u307e\u3067\u306e\u30da\u30ca\u30eb\u30c6\u30a3\n\n                for p in range(min(one, k)+1):\n\n                    q = p+ml\n\n                    if q <= mm:\n\n                        dp2[j+l][q] = (dp2[j+l][q]+dp[j][p]) % mod\n\n                    else:\n\n                        break\n\n        z += base\n\n        dp = dp2\n\n    print((sum([sum(i) for i in dp]) % mod))\n\n\n\n\n\nmain()","reference_code_col":"def main():\n\n    mod = 998244353\n\n    s, k = input().split()\n\n    k, n, one, cnt, z, zero_list = int(k), len(s), s.count(\"1\")+1, 0, 0, []\n\n    for i in range(n):\n\n        if s[i] == \"0\":\n\n            zero_list.append(cnt)\n\n            cnt = 0\n\n        else:\n\n            cnt += 1\n\n    mm = min(one-1, k)\n\n\n\n    dp = [[0]*(mm+1) for _ in [0]*one]\n\n    dp[0][0] = 1\n\n\n\n    for i in zero_list:\n\n        dp2 = [[0]*(mm+1) for _ in [0]*one]\n\n        for j in range(one):\n\n            for l in range(max(z+i-j, 0), one-j):\n\n                ml = max(l-i, 0)\n\n                for p in range(min(j, mm-ml)+1):\n\n                    dp2[j+l][p+ml] = (dp2[j+l][p+ml]+dp[j][p]) % mod\n\n        z += i\n\n        dp = dp2\n\n    print((sum([sum(i) for i in dp]) % mod))\n\n\n\n\n\nmain()","model_generated_potentially_faster_code_col":"import numpy as np\n\ndef main():\n    mod = 998244353\n\n    s, k = input().split()\n\n    k = int(k)\n    n = len(s)\n\n    one = s.count(\"1\")\n    zero_list = [i - sum(1 for char in group if char == '1') + 1 for _, group in itertools.groupby(s)]\n    \n    dp = np.zeros((one + 1, one + 1), dtype=np.uint64)\n    dp[0, 0] = 1\n\n    for base in zero_list:\n        dp2 = np.zeros_like(dp)\n        \n        for j in range(one + 1):\n            for l in range(one - j + 1):\n                ml = max(l - base, 0)\n                for p in range(min(one, k) + 1):\n                    q = p + ml\n                    if q <= one:\n                        dp2[j + l, q] = (dp2[j + l, q] + dp[j, p]) % mod\n        \n        dp = dp2\n    \n    print(sum(sum(row) for row in dp) % mod)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    sys.stdin = io.StringIO(data[0])\n    main()"}
{"problem_id":"p02386","slow_code_col":"n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in('012345','152043','215304','302541','410352','514320'):\n\n    f=[d[int(k)]for k in p]\n\n    g=f[1:5]*2\n\n    for k in range(4):\n\n     if(g[k:k+4]==e[1:5])*(f[0]==e[0])*(f[5]==e[5]):return 'No'\n\n return 'Yes'\n\nprint((f()))\n","reference_code_col":"n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in('012345','152043','215304','302541','410352','514320'):\n\n    f=[d[int(k)]for k in p]\n\n    g=f[1:5]*2\n\n    for k in range(4):\n\n     if g[k:k+4]==e[1:5]:\n\n      if f[0]==e[0]:\n\n       if f[5]==e[5]:return 'No'\n\n return 'Yes'\n\nprint((f()))\n","model_generated_potentially_faster_code_col":"n = int(eval(input()))\na = [list(map(int, input().split())) for _ in range(n)]\npositions = {i: {} for i in range(n)}\nfor i in range(n):\n    for j in range(len(a[i])):\n        positions[i][a[i][j]] = j\ndef f():\n    for i in range(n - 1):\n        d = a[i][:]\n        d[3], d[4] = d[4], d[3]\n        for j in range(i + 1, n):\n            e = a[j][:]\n            e[3], e[4] = e[4], e[3]\n            for p in ('012345', '152043', '215304', '302541', '410352', '514320'):\n                f = [d[int(k)] for k in p]\n                g = f[1:5] * 2\n                if (g[:4] == e[1:5]) and (f[0] == e[0]) and (f[5] == e[5]):\n                    return 'No'\n    return 'Yes'\nprint(f())"}
{"problem_id":"p03038","slow_code_col":"import sys\n\ninput = lambda: sys.stdin.readline()[:-1]\n\nn,m=list(map(int,input().split()))\n\na0=list(map(int,input().split()))\n\ndata=[list(map(int,input().split())) for i in range(m)]\n\nfor i in a0:\n\n\tdata.append([1,i])\n\ndata.sort(key=lambda tup:-tup[1])\n\nans=0\n\nfor num,val in data:\n\n\tif n>=num:\n\n\t\tn-=num\n\n\t\tans+=val*num\n\n\telse:\n\n\t\tans+=val*n\n\n\t\tbreak\n\nprint(ans)\n","reference_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\n\nfrom collections import Counter\n\ninput = lambda: sys.stdin.readline()[:-1]\n\nsys.setrecursionlimit(10**8)\n\n\n\nans=0\n\nn,m=list(map(int,input().split()))\n\nA=list(map(int,input().split()))\n\nbc=[]\n\nfor i in range(m):\n\n    b,c=list(map(int,input().split()))\n\n    bc.append((c,b))\n\nC=Counter(A)\n\nbc+=list(C.items())\n\nbc.sort(key=lambda tup:-tup[0])\n\n# print(bc)\n\nfor c,b in bc:\n\n    if n>=b:\n\n        n-=b\n\n        ans+=c*b\n\n    else:\n\n        ans+=c*n\n\n        break\n\nprint(ans)\n\n\n","model_generated_potentially_faster_code_col":"import sys\n\ninput = lambda: sys.stdin.readline()[:-1]\n\nn, m = map(int, input().split())\na0 = list(map(int, input().split()))\ndata = [list(map(int, input().split())) for _ in range(m)]\n\n# Combine a0 and data into one sorted list based on value (descending)\ncombined_data = [(1, x) for x in a0] + data\ncombined_data.sort(key=lambda tup: -tup[1])\n\nans = 0\nfor num, val in combined_data:\n    if n >= num:\n        n -= num\n        ans += val * num\n    else:\n        ans += val * n\n        break\n\nprint(ans)"}
{"problem_id":"p03434","slow_code_col":"import numpy as np\n\n\n\nN = int(eval(input()))\n\na = np.array(list(map(int, input().split())))\n\n\n\na.sort()\n\na = a[::-1]\n\n\n\nprint((a[0::2].sum() - a[1::2].sum()))","reference_code_col":"n = int(eval(input()))\n\narr = list(map(int, input().split()))\n\n\n\narr.sort(reverse=True)\n\n\n\nprint((sum(arr[0::2]) - sum(arr[1::2])))","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(input())\n\na = np.array(list(map(int, input().split())))\n\na.sort()\na = a[::-1]\n\nprint((a[0::2].sum() - a[1::2].sum()))"}
{"problem_id":"p02780","slow_code_col":"class SegmentTree:\n\n    seg_len = 1\n\n    node = []\n\n    def __init__(self, n):\n\n        while self.seg_len < n:\n\n            self.seg_len <<= 1\n\n        self.node = [ 0 for _ in range(self.seg_len*2) ]\n\n\n\n    def add(self, idx, v):\n\n        idx += self.seg_len\n\n        self.node[idx] += v\n\n        while True:\n\n            idx \/\/= 2\n\n            if idx == 0:\n\n                break\n\n            self.node[idx] = self.node[idx*2] + self.node[idx*2+1]\n\n\n\n    def sum(self, l, r):\n\n        l += self.seg_len\n\n        r += self.seg_len\n\n        ret = 0\n\n        while l < r:\n\n            if l & 1 == 1:\n\n                ret += self.node[l]\n\n                l += 1\n\n            if r & 1 == 1:\n\n                ret += self.node[r-1]\n\n                r -= 1\n\n            l \/\/= 2; r \/\/= 2;\n\n        return ret\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\np = [ int(x) for x in input().split() ]\n\n\n\nseg_tree = SegmentTree(n)\n\nfor i in range(n):\n\n    seg_tree.add(i, (1+p[i])\/2)\n\n\n\nans = 0\n\nfor i in range(n-k+1):\n\n    ans = max(ans, seg_tree.sum(i, i+k))\n\n\n\nprint(ans)\n","reference_code_col":"class SegmentTree:\n\n    seg_len = 1\n\n    node = []\n\n    def __init__(self, n):\n\n        while self.seg_len < n:\n\n            self.seg_len <<= 1\n\n        self.node = [ 0 for _ in range(self.seg_len*2) ]\n\n\n\n    def add(self, idx, v):\n\n        idx += self.seg_len\n\n        self.node[idx] += v\n\n        while True:\n\n            idx >>= 1\n\n            if idx == 0:\n\n                break\n\n            self.node[idx] = self.node[idx*2] + self.node[idx*2+1]\n\n\n\n    def sum(self, l, r):\n\n        l += self.seg_len\n\n        r += self.seg_len\n\n        ret = 0\n\n        while l < r:\n\n            if l & 1 == 1:\n\n                ret += self.node[l]\n\n                l += 1\n\n            if r & 1 == 1:\n\n                ret += self.node[r-1]\n\n                r -= 1\n\n            l >>= 1; r >>= 1;\n\n        return ret\n\n\n\n\n\nn, k = list(map(int, input().split()))\n\np = [ int(x) for x in input().split() ]\n\n\n\nseg_tree = SegmentTree(n)\n\nfor i in range(n):\n\n    seg_tree.add(i, (1+p[i])\/2)\n\n\n\nans = 0\n\nfor i in range(n-k+1):\n\n    ans = max(ans, seg_tree.sum(i, i+k))\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"class SegmentTree:\n    def __init__(self, n):\n        self.seg_len = 1\n        while self.seg_len < n:\n            self.seg_len <<= 1\n        self.node = [0] * (self.seg_len * 2)\n\n    def add(self, idx, v):\n        idx += self.seg_len\n        self.node[idx] += v\n        while idx > 1:\n            idx \/\/= 2\n            self.node[idx] = self.node[idx * 2] + self.node[idx * 2 + 1]\n\n    def query(self, l, r):\n        l += self.seg_len\n        r += self.seg_len\n        ret = 0\n        while l < r:\n            if l & 1:\n                ret += self.node[l]\n                l += 1\n            if not r & 1:\n                ret += self.node[r - 1]\n                r -= 1\n            l \/\/= 2\n            r \/\/= 2\n        return ret\n\n\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\nseg_tree = SegmentTree(n)\nfor i in range(n):\n    seg_tree.add(i, (1 + p[i]) \/ 2)\n\nans = 0\nfor i in range(n - k + 1):\n    ans = max(ans, seg_tree.query(i, i + k))\n\nprint(ans)"}
{"problem_id":"p03723","slow_code_col":"import time\n\nt=time.time()\n\nA,B,C=list(map(int,input().split()))\n\ncnt=0\n\nwhile(A%2==B%2==C%2==0):\n\n    a,b,c=A,B,C\n\n    A=b\/\/2+c\/\/2;B=a\/\/2+c\/\/2;C=a\/\/2+b\/\/2\n\n    cnt+=1\n\n    if(time.time()-t>=1):\n\n        print((-1))\n\n        exit()\n\nprint(cnt)","reference_code_col":"A,B,C=list(map(int,input().split()))\n\ncnt=0\n\nif(A==B==C):\n\n    if A%2!=0:\n\n        print((0))\n\n    else:\n\n        print((-1))\n\n    exit()\n\nwhile(A%2==B%2==C%2==0):\n\n    a,b,c=A,B,C\n\n    A=b\/\/2+c\/\/2;B=a\/\/2+c\/\/2;C=a\/\/2+b\/\/2\n\n    cnt+=1\n\nprint(cnt)","model_generated_potentially_faster_code_col":"import time\n\nt = time.time()\n\nA, B, C = map(int, input().split())\n\ncnt = 0\n\nwhile A % 2 == B % 2 == C % 2 == 0 and (time.time() - t) < 1:\n\n    a, b, c = A, B, C\n\n    A = (b + c) \/\/ 2\n    B = (a + c) \/\/ 2\n    C = (a + b) \/\/ 2\n\n    cnt += 1\n\nif (time.time() - t) >= 1:\n    print(-1)\nelse:\n    print(cnt)"}
{"problem_id":"p03416","slow_code_col":"a,b = list(map(int, input().split()))\n\nn = 0\n\nfor i in range(a, b + 1):\n\n    f = True\n\n    s = str(i)\n\n    l = len(s)\n\n    for j in range(l\/\/2 + 1):\n\n        if s[j] != s[- j - 1]:\n\n            f = False\n\n            break\n\n    if f:\n\n        n += 1\n\nprint(n)","reference_code_col":"a,b = list(map(int, input().split()))\n\nn = 0\n\nfor i in range(1, 10):\n\n    for j in range(10):\n\n        for k in range(10):\n\n            s = 10000 * i + 1000 * j + 100 * k + 10 * j + i\n\n            if a <= s <= b:\n\n                n += 1\n\nprint(n)","model_generated_potentially_faster_code_col":"a, b = map(int, input().split())\n\nn = sum(1 for i in range(a, b + 1) if str(i) == str(i)[::-1])\n\nprint(n)"}
{"problem_id":"p03723","slow_code_col":"import numpy as np\n\ncookies = np.array([int(x) for x in input().split()])\n\n\n\nif any(cookies%2):\n\n  ans = 0\n\nelif cookies[0] == cookies[1] == cookies[2]:\n\n  ans = -1\n\nelse:\n\n  ans = 0\n\n  while True:\n\n    if not any(cookies%2):\n\n      cookies = cookies\/\/2\n\n      ans += 1\n\n      continue\n\n    if all(cookies%2):\n\n      ans += 1\n\n    break\n\nprint(ans)","reference_code_col":"a, b, c = list(map(int, input().split()))\n\nif a == b == c and a%2 == 0:\n\n  print((-1))\n\nelif a%2 or b%2 or c%2:\n\n  print((0))\n\nelse:\n\n  ans = 0\n\n  while a%2 == b%2 == c%2 == 0:\n\n    a, b, c = (b+c)\/\/2, (a+c)\/\/2, (a+b)\/\/2\n\n    ans += 1\n\n  print(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input and create numpy array\ncookies = np.fromiter(map(int, input().split()), dtype=int)\n\n# Check if there are any odd numbers in the array\nis_odd = any(cookies % 2)\n\nif is_odd:\n    # If there are odd numbers, no further operations are needed\n    ans = 0\nelif cookies[0] == cookies[1] == cookies[2]:\n    # If all three cookies are the same, return -1\n    ans = -1\nelse:\n    ans = 0\n    while True:\n        # Divide all even numbers by 2\n        cookies \/\/= 2\n        ans += 1\n        # If there are still odd numbers left, increment the answer and continue\n        if any(cookies % 2):\n            continue\n        # If all numbers are now even, break out of the loop\n        break\n\nprint(ans)"}
{"problem_id":"p03752","slow_code_col":"import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\n\n\n\n\ndef main():\n\n    N, K, *A = list(map(int, read().split()))\n\n\n\n    ans = INF\n\n    for bit in range(1 << N):\n\n        if (not (bit & 1)) or bin(bit).count('1') != K:\n\n            continue\n\n\n\n        total = 0\n\n        max_height = A[0]\n\n        for i, a in enumerate(A[1:], 1):\n\n            if a <= max_height:\n\n                if bit & (1 << i):\n\n                    total += max_height - a + 1\n\n                    max_height += 1\n\n            else:\n\n                max_height = a\n\n\n\n        if ans > total:\n\n            ans = total\n\n\n\n    print(ans)\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"import sys\n\nfrom itertools import combinations\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\n\n\n\n\ndef main():\n\n    N, K, *A = list(map(int, read().split()))\n\n\n\n    ans = INF\n\n    for comb in combinations(list(range(1, N)), K - 1):\n\n        included = [False] * N\n\n        for i in comb:\n\n            included[i] = True\n\n\n\n        total = 0\n\n        max_height = A[0]\n\n        for i, a in enumerate(A[1:], 1):\n\n            if a <= max_height:\n\n                if included[i]:\n\n                    total += max_height - a + 1\n\n                    max_height += 1\n\n            else:\n\n                max_height = a\n\n\n\n        if ans > total:\n\n            ans = total\n\n\n\n    print(ans)\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10**9)\nINF = 1<<60\ndef main():\n    N,K,*A = list(map(int,read().split()))\n    dp = [[INF]*(K+1) for _ in range(N)]\n    dp[0][1] = 0\n    for i,a in enumerate(A):\n        for j in range(K,0,-1):\n            if j==1:\n                dp[i][j] = min(dp[i][j],dp[i-1][j]+a-A[0])\n            else:\n                dp[i][j] = min(dp[i][j],dp[i-1][j]+max(a-A[j-1],0))\n    print(dp[-1][-1])\nif __name__=='__main__':\n    main()"}
{"problem_id":"p02952","slow_code_col":"import math\n\nn = int(eval(input()))\n\ncnt = 0\n\nfor i in range(1, n + 1):\n\n    if math.floor(math.log10(i) + 1) % 2:\n\n        cnt += 1\n\nprint(cnt)","reference_code_col":"n = int(eval(input()))\n\ncnt = 0\n\nfor i in range(1, n + 1):\n\n    if len(str(i)) % 2:\n\n        cnt += 1\n\nprint(cnt)","model_generated_potentially_faster_code_col":"import math\n\nn = int(eval(input()))\ncnt = 0\n\nfor i in range(int(math.log10(n)) + 1):\n    start = 10**i\n    end = 10**(i+1)\n    \n    # If i is even, there are (end - start)\/2 numbers with i+1 digits.\n    # If i is odd, there are ((end - start)\/\/2) + 1 numbers with i+1 digits.\n    cnt += ((end - start) \/\/ 2) + (i % 2)\n\nprint(cnt)"}
{"problem_id":"p03721","slow_code_col":"n,k = list(map(int,input().split()))\n\nl = [0]*(10**5+1)\n\nfor i in range(n):\n\n    ai,bi = list(map(int,input().split()))\n\n    l[ai]+=bi\n\nfor index,i in enumerate(l):\n\n    if i:\n\n        k-=i\n\n        if k<=0:\n\n            break\n\nprint(index)","reference_code_col":"from collections import defaultdict\n\nfrom sys import stdin\n\ninput = stdin.readline\n\nd = defaultdict(int)\n\nn,k = list(map(int,input().split()))\n\nfor _ in range(n):\n\n    a,b = list(map(int,input().split()))\n\n    d[a]+=b\n\nfor key in sorted(d.keys()):\n\n    v = d[key]\n\n    k-=v\n\n    if k <= 0:\n\n        break\n\nprint(key)","model_generated_potentially_faster_code_col":"n, k = map(int, input().split())\n\n# Create a prefix sum array with size 10^5 + 2 (to handle cases where k is larger than the sum of all values in l)\nprefix_sum = [0] * (10**5 + 2)\n\n# Iterate over the input and update the prefix sum array\nfor _ in range(n):\n    ai, bi = map(int, input().split())\n    prefix_sum[ai] += bi\n\n# Traverse the prefix sum array from left to right and subtract each value from k\nindex = 0\nwhile k > 0 and index < len(prefix_sum):\n    k -= prefix_sum[index]\n    index += 1\n\n# Print the result\nprint(index - 1)"}
{"problem_id":"p03416","slow_code_col":"A, B = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(A, B+1):\n\n    l = list(str(i))\n\n\n\n    if l == list(reversed(l)):\n\n        cnt += 1\n\n\n\nprint(cnt)\n","reference_code_col":"A, B = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(A, B+1):\n\n    l = str(i)\n\n    if l == l[::-1]:\n\n        cnt += 1\n\n\n\nprint(cnt)\n","model_generated_potentially_faster_code_col":"A, B = map(int, input().split())\n\ncnt = 0\n\nfor i in range(A, B + 1):\n    num_str = str(i)\n    n = len(num_str)\n    \n    # Check if the number is a palindrome by comparing digits around the center\n    is_palindrome = True\n    for j in range(n \/\/ 2):\n        if num_str[j] != num_str[n - j - 1]:\n            is_palindrome = False\n            break\n    \n    if is_palindrome:\n        cnt += 1\n\nprint(cnt)"}
{"problem_id":"p03363","slow_code_col":"n = int(eval(input()))\n\nary = list(map(int, input().split()))\n\n#print(n,ary)\n\n\n\nary_2 = [ary[0]]\n\nfor i in range(1, n):\n\n    ary_2.append(ary[i] + ary_2[i-1])\n\nary_2 = [0] + ary_2\n\n#print(ary_2)\n\n\n\nfrom collections import Counter\n\nc = Counter(ary_2)\n\nv = (list(c.values()))\n\n#print(v)\n\n\n\nfrom math import factorial\n\ndef combinations_count(n, r):\n\n    return factorial(n) \/\/ (factorial(n - r) * factorial(r))\n\n\n\nans = 0\n\nfor j in v:\n\n    if j >1:\n\n        ans += combinations_count(j,2)\n\n\n\nprint(ans)","reference_code_col":"n = int(eval(input()))\n\nary = list(map(int, input().split()))\n\n#print(n,ary)\n\n\n\nary_2 = [ary[0]]\n\nfor i in range(1, n):\n\n    ary_2.append(ary[i] + ary_2[i-1])\n\nary_2 = [0] + ary_2\n\n#print(ary_2)\n\n\n\nfrom collections import Counter\n\nc = Counter(ary_2)\n\nv = (list(c.values()))\n\n#print(v)\n\n\n\nans = 0\n\nfor j in v:\n\n    if j >1:\n\n        ans += j * (j-1) \/\/ 2\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"n = int(input())\nary = list(map(int, input().split()))\n\n# Calculate prefix sums\nprefix_sums = [0]\ncurrent_sum = 0\nfor num in ary:\n    current_sum += num\n    prefix_sums.append(current_sum)\n\n# Count occurrences of each prefix sum\nprefix_counts = {}\nfor value in prefix_sums:\n    if value in prefix_counts:\n        prefix_counts[value] += 1\n    else:\n        prefix_counts[value] = 1\n\n# Calculate number of pairs with equal prefix sums\nans = 0\nfor count in prefix_counts.values():\n    if count > 1:\n        ans += count * (count - 1) \/\/ 2\n\nprint(ans)"}
{"problem_id":"p02983","slow_code_col":"import numpy as np\n\n\n\ndef ABC133C(l, r):\n\n    Min = np.inf\n\n    for i in range(l, r):\n\n        for j in range(i+1, r+1):\n\n            a = (i * j) % 2019\n\n            if a < Min:\n\n                Min = a\n\n                if a == 0: # \u3053\u3053\u306b\u6ce8\u76ee\n\n                    print(Min)\n\n                    return\n\n    print(Min)\n\n\n\nl, r = list(map(int, input().split()))\n\nABC133C(l, r)\n","reference_code_col":"def ABC133C(l, r):\n\n    Min = 1e10\n\n    for i in range(l, r):\n\n        for j in range(i+1, r+1):\n\n            a = (i * j) % 2019\n\n            if a < Min:\n\n                Min = a\n\n                if a == 0: # \u3053\u3053\u306b\u6ce8\u76ee\n\n                    print(Min)\n\n                    return\n\n    print(Min)\n\n\n\nl, r = list(map(int, input().split()))\n\nABC133C(l, r)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n\ndef ABC133C(l, r):\n    Min = np.inf\n\n    for i in range(l, min(r, 2019)):\n        a = (i * (i + 1)) \/\/ 2 % 2019\n        if a < Min:\n            Min = a\n            if a == 0:\n                print(Min)\n                return\n    print(Min)\n\n\nl, r = list(map(int, input().split()))\nABC133C(l, r)"}
{"problem_id":"p02792","slow_code_col":"N = int(eval(input()))\n\nmem = [[0]*10 for i in range(10)]\n\n\n\nfor i in range(1,N+1):\n\n    a = int(str(i)[0])\n\n    b = int(str(i)[-1])\n\n    mem[a][b] += 1\n\n\n\nans = 0\n\nfor i in range(1,N+1):\n\n    a = int(str(i)[0])\n\n    b = int(str(i)[-1])\n\n    ans += mem[b][a]\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\n\n\nd = [[0]*10 for i in range(10)]\n\nfor n in range(1,N+1):\n\n    s = str(n)\n\n    d[int(s[0])][int(s[-1])] += 1\n\nans = 0\n\nfor i in range(10):\n\n    for j in range(10):\n\n        ans += d[i][j] * d[j][i]\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Initialize the memory matrix with zeros\nmem = [[0]*10 for _ in range(10)]\n\n# Populate the memory matrix\nfor i in range(1, N + 1):\n    a = i \/\/ 10 % 10  # Get the first digit\n    b = i % 10         # Get the last digit\n    mem[a][b] += 1\n\n# Calculate the answer using the populated memory matrix\nans = 0\nfor i in range(1, N + 1):\n    a = i \/\/ 10 % 10  # Get the first digit\n    b = i % 10         # Get the last digit\n    ans += mem[b][a]\n\nprint(ans)"}
{"problem_id":"p03796","slow_code_col":"N = int(eval(input()))\n\np = 1\n\nfor i in range(N):\n\n    p *= (i + 1)\n\n    p %= (1e9 + 7)\n\nprint((int(p)))","reference_code_col":"N = int(eval(input()))\n\np = 1\n\nfor i in range(N):\n\n    p = p * (i + 1) % (1e9 + 7)\n\nprint((int(p)))","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Initialize result to 1\nresult = 1\n\n# Loop from 1 to N (inclusive)\nfor i in range(1, N + 1):\n    # Multiply current value by i and take modulo 10^9 + 7\n    result = (result * i) % (10**9 + 7)\n\n# Print the final result\nprint(result)"}
{"problem_id":"p02725","slow_code_col":"k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\ndiff = []\n\n\n\nfor i in range(n - 1):\n\n    diff.append(a[i + 1] - a[i])\n\ndiff.append(k - a[-1] + a[0])\n\n\n\nprint((k - max(diff)))\n","reference_code_col":"k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\n\n\na.append(k + a[0])\n\ndiff = [a1 - a0 for a0, a1 in zip(a, a[1:])]\n\n\n\nprint((k - max(diff)))\n","model_generated_potentially_faster_code_col":"k, n = map(int, input().split())\na = list(map(int, input().split()))\n\nmin_val = min(a)\nmax_val = max(a)\n\n# Calculate the circular difference between the first and last elements\ncircular_diff = k - (max_val - min_val)\n\n# Find the maximum circular difference\nmax_circular_diff = max(circular_diff, abs(a[-1] - a[0]))\n\nprint(max_circular_diff)"}
{"problem_id":"p03253","slow_code_col":"class Calc:\n\n    def __init__(self, max_value, mod):\n\n        \"\"\"combination(max_value, all)\"\"\"\n\n        fact = [-1] * (max_value + 1)\n\n        fact[0] = 1\n\n        fact[1] = 1\n\n        for x in range(2, max_value + 1):\n\n            fact[x] = x * fact[x - 1] % mod\n\n\n\n        invs = [1] * (max_value + 1)\n\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n\n        for x in range(max_value - 1, 0, -1):\n\n            invs[x] = invs[x + 1] * (x + 1) % mod\n\n\n\n        self.fact = fact\n\n        self.invs = invs\n\n        self.mod = mod\n\n\n\n    def combination(self, n, r):\n\n        if n - r < r:\n\n            return self.combination(n, n - r)\n\n        if r < 0:\n\n            return 0\n\n        if r == 0:\n\n            return 1\n\n        if r == 1:\n\n            return n\n\n        return self.fact[n] * self.invs[r] * self.invs[n - r] % self.mod\n\n\n\n\n\ndef gen(n):\n\n    x = n\n\n    d = 2\n\n    cnt = 0\n\n    while x % d == 0:\n\n        x \/\/= d\n\n        cnt += 1\n\n    yield cnt\n\n\n\n    d = 3\n\n    ma = d * d\n\n    while ma <= n:\n\n        cnt = 0\n\n        while x % d == 0:\n\n            x \/\/= d\n\n            cnt += 1\n\n        yield cnt\n\n        ma += d * 4 + 4\n\n        d += 2\n\n\n\n    if x > 1:\n\n        yield 1\n\n\n\n\n\ndef main():\n\n    MOD = 10 ** 9 + 7\n\n\n\n    N, M = list(map(int, input().split()))\n\n\n\n    cal = Calc(max_value=N + 30, mod=MOD)\n\n\n\n    ans = 1\n\n    for cnt in gen(M):\n\n        ans = (ans * cal.combination(N + cnt - 1, cnt)) % MOD\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def gen(n):\n\n    x = n\n\n    d = 2\n\n    cnt = 0\n\n    while x % d == 0:\n\n        x \/\/= d\n\n        cnt += 1\n\n    yield cnt\n\n\n\n    d = 3\n\n    while d * d <= n:\n\n        cnt = 0\n\n        while x % d == 0:\n\n            x \/\/= d\n\n            cnt += 1\n\n        yield cnt\n\n        d += 2\n\n\n\n    if x > 1:\n\n        yield 1\n\n\n\n\n\ndef main():\n\n    MOD = 10 ** 9 + 7\n\n\n\n    N, M = list(map(int, input().split()))\n\n\n\n    ans = 1\n\n    for cnt in gen(M):\n\n        for d in range(cnt):\n\n            ans = (ans * (N - 1 + cnt - d) % MOD) * pow(d + 1, MOD - 2, MOD) % MOD\n\n            \n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"class Calc:\n\n    def __init__(self, max_value, mod):\n        self.max_value = max_value\n        self.mod = mod\n        self.fact = [0] * (max_value + 1)\n        self.inv_fact = [0] * (max_value + 1)\n\n        self.fact[0] = self.fact[1] = 1\n        for i in range(2, max_value + 1):\n            self.fact[i] = self.fact[i - 1] * i % mod\n\n        self.inv_fact[self.max_value] = pow(self.fact[self.max_value], mod - 2, mod)\n        for i in range(self.max_value - 1, 0, -1):\n            self.inv_fact[i] = self.inv_fact[i + 1] * (i + 1) % mod\n\n    def combination(self, n, k):\n        if k > n:\n            return 0\n        return self.fact[n] * self.inv_fact[k] * self.inv_fact[n - k] % self.mod\n\n\ndef gen(n):\n    cnt = 0\n    d = 2\n    while d * d <= n:\n        if n % d == 0:\n            cnt = 1\n            while n % d == 0:\n                n \/\/= d\n            yield cnt\n        d += 1\n    if n > 1:\n        yield 1\n\n\ndef main():\n    MOD = 10**9 + 7\n    N, M = map(int, input().split())\n    calc = Calc(max_value=N + 30, mod=MOD)\n    ans = 1\n    for cnt in gen(M):\n        ans = ans * calc.combination(N + cnt - 1, cnt) % MOD\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02983","slow_code_col":"def c_remainder_minimization_2019(L, R):\n\n    ans = float('inf')\n\n    for i in range(L, min(R, L + 2019)):\n\n        for j in range(i + 1, min(R + 1, L + 2020)):\n\n            ans = min(ans, (i * j) % 2019)\n\n    return ans\n\n\n\nL, R = [int(i) for i in input().split()]\n\nprint((c_remainder_minimization_2019(L, R)))","reference_code_col":"def c_remainder_minimization_2019(L, R):\n\n    ans = float('inf')\n\n    for i in range(L, min(R, L + 2019)):\n\n        for j in range(i + 1, min(R + 1, L + 2020)):\n\n            ans = min(ans, (i * j) % 2019)\n\n            if ans == 0:\n\n                return 0\n\n    return ans\n\n\n\nL, R = [int(i) for i in input().split()]\n\nprint((c_remainder_minimization_2019(L, R)))","model_generated_potentially_faster_code_col":"def c_remainder_minimization_2019(L, R):\n    ans = float('inf')\n    \n    # Iterate only until the remainder is less than or equal to 2018\n    for i in range(1, 2019):\n        if (L*i) % 2019 <= ans:\n            ans = (L*i) % 2019\n\n    return ans\n\n\nL, R = [int(i) for i in input().split()]\n\nprint(c_remainder_minimization_2019(L, R))"}
{"problem_id":"p03371","slow_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\nval = float('inf')\n\nfor k in range(10 ** 5 + 1):\n\n    val = min(val, 2 * c * k + max(x - k, 0) * a + max(y - k, 0) * b)\n\nprint(val)","reference_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = 0\n\nans += min(A + B, 2 * C) * min(X, Y)\n\nif X > Y:\n\n    ans += min(A, 2 * C) * (X - Y)\n\nelif X < Y:\n\n    ans += min(B, 2 * C) * (Y - X)\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\nk_values = [0, x\/\/a, y\/\/b]\nmin_val = float('inf')\nfor k in k_values:\n    val = 2*c*k + max(x-k, 0)*a + max(y-k, 0)*b\n    if val < min_val:\n        min_val = val\nprint(min_val)"}
{"problem_id":"p03796","slow_code_col":"from math import factorial as f\n\nn = int(eval(input()))\n\nprint((f(n) % (10 ** 9 + 7)))","reference_code_col":"n = int(eval(input()))\n\np = 1\n\nfor i in range(n):\n\n    p = (p * (i+1)) % (10 ** 9 + 7)\n\nprint(p)","model_generated_potentially_faster_code_col":"def factorial_modulo(n, mod):\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % mod\n    return result\n\nn = int(input())\nmod = 10**9 + 7\nprint(factorial_modulo(n, mod))"}
{"problem_id":"p03039","slow_code_col":"n,m,k=list(map(int,input().split()))\n\nmod=10**9+7\n\nf=[1]\n\nfor i in range(2*10**5+7):f+=[f[-1]*(i+1)%mod]\n\ndef comb(a,b):return f[a]*pow(f[b],mod-2,mod)*pow(f[a-b],mod-2,mod)%mod\n\nans=0\n\nfor i in range(1,n):\n\n  ans+=(i*(n-i)*m**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nfor i in range(1,m):\n\n  ans+=(i*(m-i)*n**2)*(comb(n*m-2,k-2))\n\n  ans%=mod\n\nprint(ans)","reference_code_col":"n,m,k=list(map(int,input().split()))\n\n\n\nmod = 10**9+7\n\nf = [1]\n\nfor i in range(n*m):\n\n  f += [f[-1]*(i+1) % mod]\n\ndef comb(a, b):\n\n  return f[a]*pow(f[b], mod-2, mod)*pow(f[a-b], mod-2, mod) % mod\n\n\n\nans=0\n\nfor dist in range(1,n):\n\n  c=n-dist\n\n  p=(c*m*m)%mod\n\n  ans+=p*dist\n\nfor dist in range(1,m):\n\n  c=m-dist\n\n  p=(c*n*n)%mod\n\n  ans+=p*dist\n\nans%=mod\n\nprint((ans*comb(n*m-2,k-2)%mod))","model_generated_potentially_faster_code_col":"n,m,k=list(map(int,input().split()))\nmod=10**9+7\ndp=[[0]*(k+1) for _ in range(n+m+1)]\ndp[0][0]=1\nfor i in range(n+m):\n    for j in range(min(i,k)+1):\n        dp[i+1][j]=(dp[i][j]+dp[i][j-1])%mod\ndef comb(a,b):return dp[a][b]\nans=0\nfor i in range(1,n):\n    ans+=(i*(n-i)*m**2)*(comb(n*m-2,k-2))\n    ans%=mod\nfor i in range(1,m):\n    ans+=(i*(m-i)*n**2)*(comb(n*m-2,k-2))\n    ans%=mod\nprint(ans)"}
{"problem_id":"p03796","slow_code_col":"import math\n\nprint((math.factorial(int(eval(input())))%(10**9+7)))","reference_code_col":"ans=1\n\nn=int(eval(input()))\n\nfor i in range(1,n+1):\n\n  ans*=i\n\n  ans=ans%(10**9+7)\n\nprint(ans)","model_generated_potentially_faster_code_col":"def factorial(n):\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result % (10**9+7)\n\nn = int(input())\nprint(factorial(n))"}
{"problem_id":"p03371","slow_code_col":"A, B, C, X, Y = [int(_) for _ in input().split()]\n\nans = A * X + B * Y\n\nfor i in range(max(X, Y) + 1):\n\n    cost = 2 * C * i\n\n    if X > i:\n\n        cost += A * (X - i)\n\n    if Y > i:\n\n        cost += B * (Y - i)\n\n    ans = min(ans, cost)\n\nprint(ans)","reference_code_col":"A, B, C, X, Y = [int(_) for _ in input().split()]\n\nM = max(X, Y)\n\nprint((min(2 * C * M, 2 * C * (X + Y - M) + A *\n\n          (M - Y) + B * (M - X), A * X + B * Y)))\n","model_generated_potentially_faster_code_col":"A, B, C, X, Y = map(int, input().split())\n\n# Initialize the minimum cost to a large number\nmin_cost = float('inf')\n\n# Iterate over all possible values of i from 0 to max(X, Y)\nfor i in range(max(X, Y) + 1):\n    # Calculate the cost for the current value of i\n    cost = 2 * C * i\n    \n    # If i is less than X, add the cost for the remaining units of A\n    if i < X:\n        cost += A * (X - i)\n    \n    # If i is less than Y, add the cost for the remaining units of B\n    if i < Y:\n        cost += B * (Y - i)\n    \n    # Update the minimum cost found so far\n    min_cost = min(min_cost, cost)\n\n# Print the minimum cost\nprint(min_cost)"}
{"problem_id":"p03371","slow_code_col":"import math\n\n\n\na,b,c,x,y = list(map(int,input().split()))\n\n\n\n# c\u3092\u5168\u63a2\u7d22\uff1f\n\nres = float('inf')\n\nfor i in range(max(x,y)*2+1):\n\n    money = i * c\n\n    if i\/2<x:\n\n        money += math.ceil(x-i\/2) * a\n\n    if i\/2<y:\n\n        money += math.ceil(y-i\/2) * b\n\n    res = min(res,money)\n\n\n\nprint(res)\n","reference_code_col":"res = 10**30\n\na,b,c,x,y = list(map(int,input().split()))\n\nfor i in range(0,max(x,y)+1):\n\n    # AB\u30922*i\u307e\u3044\u8cb7\u3046\n\n    tmp = 2 * i * c\n\n    xx,yy = x - i, y - i\n\n    tmp += max(0,xx) * a\n\n    tmp += max(0,yy) * b\n\n    res = min(res, tmp)\n\nprint(res)\n","model_generated_potentially_faster_code_col":"import math\n\n\na, b, c, x, y = map(int, input().split())\n\n# Precompute ceil((x - i \/ 2)) and ceil((y - i \/ 2)) for all possible values of i\nceil_x_values = [0] * (max(x, y) * 2 + 1)\nceil_y_values = [0] * (max(x, y) * 2 + 1)\n\nfor i in range(max(x, y) * 2 + 1):\n    ceil_x_values[i] = math.ceil((x - i \/ 2))\n    ceil_y_values[i] = math.ceil((y - i \/ 2))\n\nres = float('inf')\n\nfor i in range(max(x, y) * 2 + 1):\n    money = i * c\n    money += ceil_x_values[i] * a if i \/ 2 < x else 0\n    money += ceil_y_values[i] * b if i \/ 2 < y else 0\n    res = min(res, money)\n\nprint(res)"}
{"problem_id":"p03000","slow_code_col":"import numpy as np\n\n\n\ntemp=list(map(int, input().split()))\n\n\n\nN=temp[0]\n\nX=temp[1]\n\n\n\nL=list(map(int, input().split()))\n\n\n\nind=1\n\nwhile np.sum(L[:ind])<=X and ind<=N:\n\n  ind+=1\n\n  \n\nprint(ind)","reference_code_col":"N, X=list(map(int, input().split()))\n\nL=list(map(int, input().split()))\n\nL=[0]+L\n\n \n\nl=int(0)\n\ncounter=int(0)\n\nwhile l+L[counter]<=X and counter<=N:\n\n  l+=L[counter]\n\n  counter+=int(1)\n\n  if counter==N+1:\n\n    break\n\n  \n\nprint(counter)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Get input values\nN, X = map(int, input().split())\nL = list(map(int, input().split()))\n\n# Initialize variables\nsum_L = 0\nind = 0\n\n# Iterate over L and update sum_L and ind until sum_L >= X\nfor num in L:\n    if sum_L >= X:\n        break\n    sum_L += num\n    ind += 1\n\n# If we've reached end of L and still sum_L < X, set ind to N+1\nif sum_L < X:\n    ind = N + 1\n\nprint(ind)"}
{"problem_id":"p03558","slow_code_col":"import heapq\n\nK=int(eval(input()))\n\ndist=[10**15 for i in range(K)]\n\ndist[1]=1\n\nq=[]\n\nheapq.heappush(q,(0,1))\n\nwhile (len(q)!=0):\n\n    prc,src=heapq.heappop(q)\n\n    if dist[src]<prc:\n\n        continue\n\n    if dist[(src+1)%K]>dist[src]+1:\n\n        dist[(src+1)%K]=dist[src]+1\n\n        heapq.heappush(q,(dist[(src+1)%K],(src+1)%K))\n\n    if dist[(10*src)%K]>dist[src]:\n\n        dist[(10*src)%K]=dist[src]\n\n        heapq.heappush(q,(dist[(src*10)%K],(src*10)%K))\n\nprint((dist[0]))\n","reference_code_col":"from collections import deque\n\nK=int(eval(input()))\n\ndist=[10**15 for i in range(K)]\n\ndist[1]=1\n\nq=deque([1])\n\nwhile(len(q)>0):\n\n    r=q.popleft()\n\n    s=(r+1)%K\n\n    if dist[r]+1<dist[s]:\n\n        dist[s]=dist[r]+1\n\n        q.append(s)\n\n    t=(r*10)%K\n\n    if dist[r]<dist[t]:\n\n        dist[t]=dist[r]\n\n        q.appendleft(t)\n\nprint((dist[0]))\n","model_generated_potentially_faster_code_col":"import heapq\n\nK = int(eval(input()))\n\ndist = [10**15] * K\ndist[1] = 1\n\nq = [(0, 1)]\n\nwhile q:\n    prc, src = heapq.heappop(q)\n    \n    if dist[src] < prc:\n        continue\n    \n    next_node = (src + 1) % K\n    if dist[next_node] > dist[src] + 1:\n        dist[next_node] = dist[src] + 1\n        heapq.heappush(q, (dist[next_node], next_node))\n    \n    next_node = (src * 10) % K\n    if dist[next_node] > dist[src]:\n        dist[next_node] = dist[src]\n        heapq.heappush(q, (dist[next_node], next_node))\n\nprint(dist[0])"}
{"problem_id":"p02994","slow_code_col":"import numpy as np\n\nN,L = list(map(int, input().split()))\n\ntaste = np.array([L+i-1 for i in range(1,N+1)])\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min(np.abs(taste))))\n\nelse:\n\n  print((sum(taste) - min(np.abs(taste))))","reference_code_col":"N,L = list(map(int, input().split()))\n\ntaste = [L+i-1 for i in range(1,N+1)]\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min([abs(x) for x in taste])))\n\nelse:\n\n  print((sum(taste) - min([abs(x) for x in taste])))","model_generated_potentially_faster_code_col":"import numpy as np\n\nN, L = map(int, input().split())\n\n# Calculate the sum of taste values\ntaste_sum = N * (2*L - N + 1) \/\/ 2\n\n# Calculate the minimum absolute value\nmin_abs_taste = abs(L - 1)\n\n# Determine the result based on whether taste_sum is positive or negative\nresult = taste_sum + min_abs_taste if taste_sum < 0 else taste_sum - min_abs_taste\n\nprint(result)"}
{"problem_id":"p03371","slow_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\n\n\nans = float('inf')\n\n\n\nfor i in range(2 * 10**5 + 1):\n\n    ans = min(ans, a * max(x - i, 0) + b * max(y - i, 0) + 2 * c * i)\n\n\n\nprint(ans)","reference_code_col":"A,B,C,X,Y = list(map(int,input().split()))\n\nmin_xy = min(X,Y)\n\nmax_xy = max(X,Y)\n\nans1 = 2 * C * min_xy + A * (X-min_xy) + B * (Y-min_xy) # \u7121\u99c4\u306b\u306a\u3089\u306a\u3044\u7bc4\u56f2\u3067AB\u30d4\u30b6\u3092\u8cb7\u3044\u3001\u6b8b\u308a\u3092\u8cb7\u3046\n\nans2 = A*X + B*Y # AB\u30d4\u30b6\u3092\u8cb7\u308f\u306a\u3044\n\nans3 = 2 * C * max_xy # AB\u30d4\u30b6\u3060\u3051\u3092\u8cb7\u3046\n\nprint((min(ans1,ans2,ans3)))","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\n\n# Calculate the maximum distances from x and y to the point i\nmax_x_distance = max(x, 0)\nmax_y_distance = max(y, 0)\n\n# Calculate the minimum value using the simplified formula\nmin_value = a * max_x_distance + b * max_y_distance + 2 * c * (x + y) \/\/ 2\n\nprint(min_value)"}
{"problem_id":"p02792","slow_code_col":"n = int(eval(input()))\n\n\n\ncnt = 0\n\nfor i in range(1, n+1):\n\n    i_str = str(i)\n\n    if len(i_str) == 1:\n\n        cnt += 1\n\n        continue\n\n    if len(i_str) == 2:\n\n        if int(i_str[0]) == int(i_str[1]):\n\n            cnt += 3\n\n        elif int(i_str[1]) != 0 and int(i_str[0]) > int(i_str[1]):\n\n            cnt += 2\n\n        continue\n\n    if len(i_str) == 3:\n\n        if int(i_str[0]) == int(i_str[2]):\n\n            cnt += 4 + (2 * (int(i_str[1])+1) - 1)\n\n        elif int(i_str[2]) != 0 and int(i_str[0]) > int(i_str[2]):\n\n            cnt += 22\n\n        elif int(i_str[0]) < int(i_str[2]):\n\n            cnt += 2\n\n        continue\n\n    if len(i_str) == 4:\n\n        if int(i_str[0]) == int(i_str[3]):\n\n            cnt += 24 + 20 * int(i_str[1]) + 2 * (int(i_str[2])+1) - 1\n\n        elif int(i_str[3]) != 0 and int(i_str[0]) > int(i_str[3]):\n\n            cnt += 222\n\n        elif int(i_str[0]) < int(i_str[3]):\n\n            cnt += 22\n\n        continue\n\n    if len(i_str) == 5:\n\n        if int(i_str[0]) == int(i_str[4]):\n\n            cnt += 224 + 200 * int(i_str[1]) + 20 * int(i_str[2]) + 2 * (int(i_str[3])+1) - 1\n\n        elif int(i_str[4]) != 0 and int(i_str[0]) > int(i_str[4]):\n\n            cnt += 2222\n\n        elif int(i_str[0]) < int(i_str[4]):\n\n            cnt += 222\n\n        continue\n\n    if len(i_str) == 6:\n\n        if int(i_str[0]) == int(i_str[5]):\n\n            cnt += 2224 + 2000 * int(i_str[1]) + 200 * int(i_str[2]) + 20 * int(i_str[3]) + 2 * (int(i_str[4])+1) - 1\n\n        elif int(i_str[5]) != 0 and int(i_str[0]) > int(i_str[5]):\n\n            cnt += 22222\n\n        elif int(i_str[0]) < int(i_str[5]):\n\n            cnt += 2222\n\n        continue\n\n\n\nprint(cnt)","reference_code_col":"n = int(eval(input()))\n\n\n\nc = [[0 for _ in range(10)] for __ in range(10)]\n\nfor i in range(1, n+1):\n\n    str_i = str(i)\n\n    head = int(str_i[0])\n\n    tail = int(str_i[-1])\n\n    c[head][tail] += 1\n\n\n\ncnt = 0\n\nfor i in range(10):\n\n    for j in range(10):\n\n        cnt += c[i][j] * c[j][i]\n\n\n\nprint(cnt)","model_generated_potentially_faster_code_col":"n = int(input())\n\ncnt = 0\n\n# Count numbers with length 1\ncnt += n\n\n# Count numbers with length 2\ncnt += sum([min(int(str(i)[0]), int(str(i)[1])) for i in range(10, 100)])\n\n# Count numbers with length 3\ncnt += sum([min(int(str(i)[0]), int(str(i)[1]), int(str(i)[2])) for i in range(100, 1000)])\n\n# Count numbers with length 4\ncnt += sum([min(int(str(i)[0]), int(str(i)[1]), int(str(i)[2]), int(str(i)[3])) for i in range(1000, 10000)])\n\n# Count numbers with length 5\ncnt += sum([min(int(str(i)[0]), int(str(i)[1]), int(str(i)[2]), int(str(i)[3]), int(str(i)[4])) for i in range(10000, 100000)])\n\n# Count numbers with length 6\ncnt += sum([min(int(str(i)[0]), int(str(i)[1]), int(str(i)[2]), int(str(i)[3]), int(str(i)[4]), int(str(i)[5])) for i in range(100000, 1000000)])\n\nprint(cnt)"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nN = int(eval(input()))\n\nans = math.factorial(N) % (10**9 + 7)\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nmod = 10**9 + 7\n\nans = 1\n\nfor i in range(1, N + 1):\n\n    ans *= i\n\n    ans %= mod\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"N = int(eval(input()))\n\nMOD = 10**9 + 7\nans = 1\n\nfor i in range(2, N+1):\n    ans = (ans * i) % MOD\n\nprint(ans)"}
{"problem_id":"p03038","slow_code_col":"from heapq import heappop, heappush\n\n\n\nn, m = list(map(int, input().split()))\n\na = tuple(map(int, input().split()))\n\n\n\nhq = []\n\nfor aa in a:\n\n    heappush(hq, (-aa, 1))\n\n\n\nfor _ in range(m):\n\n    b, c = list(map(int, input().split()))\n\n    heappush(hq, (-c, b))\n\n\n\nrest = n\n\nans = 0\n\nwhile rest > 0:\n\n    num, cnt = heappop(hq)\n\n\n\n    num *= (-1)\n\n    use = min(rest, cnt)\n\n    ans += use * num\n\n    rest -= use\n\n\n\nprint(ans)\n","reference_code_col":"def main():\n\n    from collections import Counter\n\n    from operator import itemgetter\n\n\n\n    import sys\n\n    input = sys.stdin.readline\n\n\n\n    N, M = list(map(int, input().split()))\n\n    a = list(map(int, input().split()))\n\n\n\n    ctr = Counter(a)\n\n    for _ in range(M):\n\n        b, c = list(map(int, input().split()))\n\n        ctr[c] += b\n\n\n\n    ans = 0\n\n    rest = N\n\n    for integer, count in sorted(list(ctr.items()), key=itemgetter(0), reverse=True):\n\n        take = min(rest, count)\n\n        ans += take * integer\n\n        rest -= take\n\n        if not rest:\n\n            break\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n\n# import sys\n\n# input = sys.stdin.readline\n\n# \n\n# sys.setrecursionlimit(10 ** 7)\n\n# \n\n# (int(x)-1 for x in input().split())\n\n# rstrip()\n","model_generated_potentially_faster_code_col":"from heapq import heappop, heappush\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\nhq = []\nfor aa in a:\n    heappush(hq, (-aa, 1))\n\nfor _ in range(m):\n    b, c = map(int, input().split())\n    heappush(hq, (-c, b))\n\nrest = n\nans = 0\n\nwhile hq and rest > 0:\n    num, cnt = heappop(hq)\n    num *= -1\n    use = min(rest, cnt)\n    ans += use * num\n    rest -= use\n\nprint(ans)"}
{"problem_id":"p03837","slow_code_col":"import numpy as np\n\n\n\nn, m = list(map(int, input().split()))\n\n\n\nd = np.ones((n, n)) * 1001\n\n\n\nes = []\n\nfor i in range(m):\n\n    es.append(list(map(int, input().split())))\n\n\n\nfor (i, j, w) in es:\n\n    d[i - 1][j - 1] = w\n\n    d[j - 1][i - 1] = w\n\n\n\n\n\nfor k in range(n):\n\n    for i in range(n):\n\n        for j in range(n):\n\n            l = d[i][k] + d[k][j]\n\n            if d[i][j] > l:\n\n                d[i][j] = l\n\n\n\nc = 0\n\nfor (i, j, w) in es:\n\n    if d[i - 1][j - 1] < w:\n\n        c += 1\n\n\n\nprint(c)\n","reference_code_col":"n, m = list(map(int, input().split()))\n\n\n\nd = [[1001] * n for i in range(n)]\n\n\n\nes = []\n\nfor i in range(m):\n\n    es.append(list(map(int, input().split())))\n\n\n\nfor (i, j, w) in es:\n\n    d[i - 1][j - 1] = w\n\n    d[j - 1][i - 1] = w\n\n\n\n\n\nfor k in range(n):\n\n    for i in range(n):\n\n        for j in range(n):\n\n            l = d[i][k] + d[k][j]\n\n            if d[i][j] > l:\n\n                d[i][j] = l\n\n\n\nc = 0\n\nfor (i, j, w) in es:\n\n    if d[i - 1][j - 1] < w:\n\n        c += 1\n\n\n\nprint(c)","model_generated_potentially_faster_code_col":"import numpy as np\n\nn, m = map(int, input().split())\n\n# Initialize the distance matrix with a large value\nd = np.full((n, n), np.inf)\nnp.fill_diagonal(d, 0)\n\n# Set the edge weights\nfor _ in range(m):\n    i, j, w = map(int, input().split())\n    d[i-1, j-1] = d[j-1, i-1] = w\n\n# Apply Floyd-Warshall algorithm\nfor k in range(n):\n    d = np.minimum(d, d[:, None, :] + d[None, :, :])\n\n# Count the number of edges that can be shortened\nc = np.sum(np.any(d != np.full_like(d, np.inf), axis=0))\nprint(c)"}
{"problem_id":"p03371","slow_code_col":"A,B,C,X,Y = list(map(int,input().split()))\n\nl = []\n\nfor i in range(max(X,Y)+1):\n\n    T = i * C * 2\n\n    if i < X: \n\n        T += (X-i)*A\n\n    if i < Y:\n\n        T += (Y-i)*B\n\n    l.append(T)\n\nl.sort()\n\nprint((l[0]))","reference_code_col":"A,B,C,X,Y = list(map(int,input().split()))\n\nans = 0\n\nif 2*C <= A+B:\n\n    Z = min(X,Y)\n\n    ans = 2*C*Z\n\n    X -= Z\n\n    Y -= Z\n\nans += min(2*C*X,A*X)\n\nans += min(2*C*Y,B*Y)\n\nprint(ans)","model_generated_potentially_faster_code_col":"A, B, C, X, Y = map(int, input().split())\n\n# Initialize the minimum value to a large number\nmin_value = float('inf')\n\n# Calculate the minimum value based on the conditions\nif X <= Y:\n    min_value = C * 2 * X + (Y - X) * B\nelse:\n    min_value = C * 2 * Y + (X - Y) * A\n\nprint(min_value)"}
{"problem_id":"p02983","slow_code_col":"# \u53c2\u8003 https:\/\/atcoder.jp\/contests\/abc133\/submissions\/7966658\n\n\n\nimport numpy as np\n\n\n\ndef abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    if R - L > 673: return 0\n\n    x = np.arange(L, R+1, dtype=np.int64)\n\n    #y = x[:, None] * x[None, :] % 2019\n\n    y = x.reshape(-1, 1) * x.reshape(1, -1)  # \u533a\u9593\u5185\u306e\u3059\u3079\u3066\u306e\u7d44\u5408\u305b\u306e\u7a4d\n\n    y %= 2019\n\n    np.fill_diagonal(y, 2019)  # \u5bfe\u89d2\u6210\u5206\u306f\u7121\u8996\u3059\u308b (\u540c\u3058\u6570\u30922\u56de\u9078\u3079\u306a\u3044) \u306e\u3067inf\u5024\u3067\u57cb\u3081\u308b\n\n    return y.min()\n\n\n\nprint((abc133_c()))","reference_code_col":"def abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    # \u533a\u9593\u306e\u5e45\u304c673\u3042\u308c\u3070\u3001673\u306e\u500d\u6570\u30683\u306e\u500d\u6570\u304c\u542b\u307e\u308c\u3066\u30012019\u306e\u500d\u6570\u304c\u4f5c\u308c\u308b\n\n    if R - L > 673: return 0\n\n    # \u305d\u308c\u4ee5\u5916\u306f\u8a66\u3059\n\n    ans = 2019\n\n    for i in range(L, R+1):\n\n        for j in range(L, i):\n\n            m = i * j % 2019\n\n            ans = min(m, ans)\n\n    return ans\n\n\n\nprint((abc133_c()))","model_generated_potentially_faster_code_col":"def abc133_c():\n    L, R = map(int, input().split())\n\n    if R - L > 673: \n        return 0\n\n    min_product = float('inf')\n\n    for i in range(L, R + 1):\n        for j in range(i + 1, R + 1):\n            product = (i * j) % 2019\n            if product != 0 and product < min_product:\n                min_product = product\n\n    return min_product\n\nprint(abc133_c())"}
{"problem_id":"p03835","slow_code_col":"#ABC951B\/Sum_of_Three_Integers\n\n\n\nK, S = list(map(int, input().split()))\n\nans = 0\n\nfor x in range(0, K+1):\n\n    for y in range(0, K+1):\n\n        z = S - x - y\n\n        if 0 <= z and z <= K:\n\n            ans += 1\n\nprint(ans)","reference_code_col":"K, S = list(map(int, input().split()))\n\nans = 0\n\nfor X in range(K+1):\n\n    for Y in range(K+1):\n\n        Z = S - X - Y\n\n        if Z >= 0 and Z <= K:\n\n            ans += 1\n\nprint(ans)       ","model_generated_potentially_faster_code_col":"# ABC951B\/Sum_of_Three_Integers\n\nK, S = map(int, input().split())\n\nif S < 3 or S > 3 * K:\n    print(0)\nelse:\n    ans = (S - 3) \/\/ 2 + max(0, min(S - K, K) - (S - 2 * K))\n    print(ans)"}
{"problem_id":"p02276","slow_code_col":"n=int(eval(input()))-1\n\nA=list(map(int,input().split()))\n\ni=0\n\nfor j in range(n):\n\n if A[j]<=A[-1]:A[i],A[j]=A[j],A[i];i+=1\n\nA[i],A[n]=A[n],A[i]\n\nprint((\" \".join(map(str,A[:i]))+\" [\"+str(A[i])+\"] \"+\" \".join(map(str,A[i+1:]))))\n","reference_code_col":"def s():\n\n n=int(eval(input()))-1\n\n A=list(map(int,input().split()))\n\n i=0\n\n for j in range(n):\n\n  if A[j]<=A[-1]:A[i],A[j]=A[j],A[i];i+=1\n\n A[i],A[n]=A[n],A[i]\n\n print((\" \".join(map(str,A[:i]))+\" [\"+str(A[i])+\"] \"+\" \".join(map(str,A[i+1:]))))\n\nif'__main__'==__name__:s()\n","model_generated_potentially_faster_code_col":"def partition(arr):\n    n = len(arr)\n    i = -1  # Index of smaller element\n    pivot = arr[n - 1]  # Pivot element\n    \n    for j in range(n - 1):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    arr[i + 1], arr[n - 1] = arr[n - 1], arr[i + 1]\n    return i + 1\n\n# Input\nn = int(input()) - 1\nA = list(map(int, input().split()))\n\n# Partitioning\npivot_index = partition(A)\n\n# Output\nresult = \" \".join(map(str, A[:pivot_index])) + \" [\" + str(A[pivot_index]) + \"] \" + \" \".join(map(str, A[pivot_index + 1:]))\nprint(result)"}
{"problem_id":"p02792","slow_code_col":"N = int(eval(input()))\n\nmem = [[0]*10 for _ in range(10)]\n\n\n\nfor i in range(1,N+1):\n\n    a = int(str(i)[0])\n\n    b = int(str(i)[-1])\n\n    mem[a][b] += 1\n\n\n\nans = 0\n\nfor i in range(1,N+1):\n\n    a = int(str(i)[0])\n\n    b = int(str(i)[-1])\n\n    ans += mem[b][a]\n\nprint(ans)\n","reference_code_col":"N = int(eval(input()))\n\nmem=[[0] * 10 for _ in range(10)]\n\n\n\nfor i in range(1, N+1):\n\n    s = str(i)\n\n    mem[int(s[0])][int(s[-1])] += 1 \n\n    \n\nans = 0\n\nfor i in range(1, 10):\n\n    for j in range(1, 10):\n\n        ans += mem[i][j] * mem[j][i]\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(eval(input()))\n\n# Initialize mem array with zeros\nmem = [[0]*10 for _ in range(10)]\n\n# Iterate over all numbers from 1 to N\nfor i in range(1, N+1):\n    # Extract first and last digit\n    a = int(str(i)[0])\n    b = int(str(i)[-1])\n    \n    # Increment count in mem array\n    mem[a][b] += 1\n\n# Calculate the answer using a single loop\nans = 0\nfor i in range(10):\n    for j in range(10):\n        ans += mem[i][j] * mem[j][i]\n\nprint(ans)"}
{"problem_id":"p03416","slow_code_col":"a, b = list(map(int, input().split()))\n\ntmp=str(a)\n\nc=0\n\nfor i in range(a,b+1):\n\n    tmp=str(i)\n\n    tmp2=\"\"\n\n    for s in range(len(tmp)):\n\n        tmp2=tmp2+tmp[len(tmp)-1-s]\n\n    if tmp==tmp2:\n\n        c=c+1\n\nprint(c)","reference_code_col":"def main():\n\n    #1. input\n\n    a, b = list(map(int, input().split()))\n\n\n\n    ans = 0\n\n\n\n    #2. from A to B\n\n    for i in range(a, b+1):\n\n        #2.1. judge if the number is palindromic\n\n        if (str(i)[0]==str(i)[4]) and (str(i)[1]==str(i)[3]):\n\n            ans = ans+1\n\n\n\n    #3. output\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"def count_palindromes(start, end):\n    count = 0\n    for num in range(start, end + 1):\n        str_num = str(num)\n        if str_num == str_num[::-1]:\n            count += 1\n    return count\n\n# Input\na, b = map(int, input().split())\n\n# Output\nprint(count_palindromes(a, b))"}
{"problem_id":"p03835","slow_code_col":"k,s=list(map(int,input().split()))\n\nans=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        z=s-i-j\n\n        if 0<=z<=k:\n\n            ans+=1\n\nprint(ans)\n","reference_code_col":"k,s=list(map(int,input().split()))\n\nans=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        if 0<=s-i-j<=k:\n\n            ans+=1\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"from math import comb\n\ndef count_solutions(s, k):\n    if s > 3 * k:\n        return 0\n    \n    # Calculate the number of solutions using the stars and bars method\n    total_ways = comb(s + 2, 2)\n    \n    # Subtract the cases where one or more variables exceed k\n    subtract_cases = 0\n    for x in range(1, 4):  # We need to consider 1, 2, and 3 variables exceeding k\n        for y in range(x + 1, 4):\n            z = s - (x * k) - (y * k)\n            if z >= 0 and z < k:\n                subtract_cases += comb(2, y - 1)\n    \n    return total_ways - subtract_cases\n\n# Read input\nk, s = map(int, input().split())\n\n# Print the result\nprint(count_solutions(s, k))"}
{"problem_id":"p03078","slow_code_col":"import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\n\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left, insort, insort_left\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce, lru_cache\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(input())\n\ndef MAP(): return map(int, input().split())\n\ndef LIST(): return list(map(int, input().split()))\n\ndef TUPLE(): return tuple(map(int, input().split()))\n\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7 \n\n#mod = 998244353\n\nfrom decimal import *\n\n#import numpy as np\n\n#decimal.getcontext().prec = 10\n\n\n\nX, Y, Z, K = MAP()\n\nA = sorted(LIST(), reverse = True)\n\nB = sorted(LIST(), reverse = True)\n\nC = sorted(LIST(), reverse = True)\n\n\n\nAB = []\n\nfor i in range(X):\n\n\tfor j in range(Y):\n\n\t\tAB.append(A[i]+B[j])\n\n\n\nAB.sort(reverse = True)\n\nAB = AB[:3000]\n\nABC = sorted([C[0]+AB[i] for i in range(min(3000, X*Y))], reverse = True)\n\n\n\nfor j in range(1, Z):\n\n\tABC_tmp = sorted([C[j]+AB[i] for i in range(min(3000, X*Y))])\n\n\tABC += ABC_tmp\n\n\tABC.sort(reverse = True)\n\n\tABC = ABC[:3000]\n\n\n\nprint(*ABC[:K], sep= \"\\n\")\n\n\n","reference_code_col":"import sys, re\n\nfrom collections import deque, defaultdict, Counter\n\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\n\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\n\nfrom operator import itemgetter, mul\n\nfrom copy import deepcopy\n\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\nfrom bisect import bisect, bisect_left, insort, insort_left\n\nfrom heapq import heappush, heappop\n\nfrom functools import reduce, lru_cache\n\ndef input(): return sys.stdin.readline().strip()\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef TUPLE(): return tuple(map(int, input().split()))\n\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nmod = 10 ** 9 + 7 \n\n#mod = 998244353\n\nfrom decimal import *\n\n#import numpy as np\n\n#decimal.getcontext().prec = 10\n\n\n\nX, Y, Z, K = MAP()\n\nA = sorted(LIST(), reverse = True)\n\nB = sorted(LIST(), reverse = True)\n\nC = sorted(LIST(), reverse = True)\n\n\n\nans = []\n\nfor i in range(X):\n\n\tfor j in range(Y):\n\n\t\tfor k in range(Z):\n\n\t\t\tif (i+1)*(j+1)*(k+1) <= K:\n\n\t\t\t\tans.append(A[i]+B[j]+C[k])\n\n\t\t\telse:\n\n\t\t\t\tbreak\n\n\n\nfor a in sorted(ans)[::-1][:K]:\n\n\tprint(a)\n","model_generated_potentially_faster_code_col":"import sys, re\nfrom collections import deque\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce, lru_cache\n\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nX, Y, Z, K = map(int, input().split())\nA = sorted(map(int, input().split()), reverse=True)\nB = sorted(map(int, input().split()), reverse=True)\nC = sorted(map(int, input().split()), reverse=True)\n\nAB = []\nfor i in range(X):\n    for j in range(Y):\n        AB.append(A[i] + B[j])\nAB.sort(reverse=True)\nAB = AB[:3000]\n\nABC = deque()\nfor i in range(min(3000, X * Y)):\n    ABC.append(C[0] + AB[i])\nABC.sort(reverse=True)\nABC = deque(ABC[:3000])\n\nfor j in range(1, Z):\n    ABC_tmp = deque()\n    for i in range(min(3000, X * Y)):\n        ABC_tmp.append(C[j] + AB[i])\n    ABC_tmp.sort(reverse=True)\n    ABC_tmp = deque(ABC_tmp[:3000])\n    ABC.extendleft(reversed(ABC_tmp))\n\nprint(*list(ABC)[:K], sep=\"\\n\")"}
{"problem_id":"p00174","slow_code_col":"while True:\n\n    try:\n\n        for i in range(3):\n\n            line = input().strip()\n\n            if line == '0':\n\n                raise Exception\n\n\n\n            a = b = 0\n\n            for i, s in enumerate(line):\n\n                if i != 0:\n\n                    if s == 'A':\n\n                        a += 1\n\n                    else:\n\n                        b += 1\n\n            if a > b:\n\n                a += 1\n\n            else:\n\n                b += 1\n\n            print(a, b)\n\n\n\n    except:\n\n        break","reference_code_col":"while True:\n\n    try:\n\n        for i in range(3):\n\n            line = input().strip()\n\n            if line == '0':\n\n                raise Exception\n\n\n\n            if line[0] == 'A':\n\n                a = -1\n\n                b = 0\n\n            else:\n\n                a = 0\n\n                b = -1\n\n            for i, s in enumerate(line):\n\n                if s == 'A':\n\n                    a += 1\n\n                else:\n\n                    b += 1\n\n            if a > b:\n\n                a += 1\n\n            else:\n\n                b += 1\n\n            print(a, b)\n\n\n\n    except:\n\n        break","model_generated_potentially_faster_code_col":"def process_lines(lines):\n    for line in lines:\n        if line == '0':\n            return\n\n        a = b = 0\n        max_count = 0\n        current_count = 0\n\n        for char in line:\n            if char == 'A':\n                a += 1\n                current_count += 1\n            elif char == 'B':\n                b += 1\n                current_count -= 1\n\n            max_count = max(max_count, current_count)\n\n        if max_count > 0:\n            a += 1\n        else:\n            b += 1\n\n        print(a, b)\n\nif __name__ == \"__main__\":\n    import sys\n    lines = [line.strip() for line in sys.stdin.readlines()]\n    process_lines(lines)"}
{"problem_id":"p03559","slow_code_col":"from bisect import *\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\nb = list(map(int,input().split()))\n\nc = list(map(int,input().split()))\n\n\n\na = sorted(a)\n\nc = sorted(c)\n\n\n\nrec = 0\n\nfor i in range(n):\n\n    temp = b[i]\n\n    l = bisect_left(a, temp)\n\n    r = bisect_right(c, temp)\n\n    rec += l * (n - r)\n\nprint(rec)","reference_code_col":"from bisect import *\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\nb = list(map(int,input().split()))\n\nc = list(map(int,input().split()))\n\n\n\na.sort()\n\nc.sort()\n\nres = 0\n\nfor i in b:\n\n    temp_a = bisect_left(a, i)\n\n    temp_c = n - bisect_right(c, i)\n\n    res += temp_a*temp_c\n\nprint(res)","model_generated_potentially_faster_code_col":"from bisect import *\n\nn = int(input())\n\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\na.sort()\nc.sort()\n\ni, j, k = 0, n-1, n-1\nrec = 0\n\nwhile i < n and j >= 0:\n    if a[i] <= b[j]:\n        rec += (k-j+1) * (j-i+1)\n        i += 1\n    else:\n        j -= 1\n\nprint(rec)"}
{"problem_id":"p02837","slow_code_col":"N=int(eval(input()))\n\n\n\nS=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  A=int(eval(input()))\n\n  for _ in range(A):\n\n    x, y=list(map(int, input().split()))\n\n    S[i][x-1]=y\n\nans=0   \n\nfor s in range(2**N):\n\n  ok=True\n\n  for i in range(N):\n\n    #\u6b63\u76f4\u8005\u306b\u3064\u3044\u3066\u898b\u3066\u3044\u304f\n\n    if (s>>i&1)==1:\n\n      for j in range(N):\n\n        #\u305d\u308c\u305e\u308c\u6b63\u76f4\u8005\u306e\u8a3c\u8a00\u304c\u77db\u76fe\u306a\u3044\u304b\n\n        if S[i][j]!=-1 and (s>>j&1)!=S[i][j]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(s).count(\"1\"))\n\n    \n\nprint(ans)\n","reference_code_col":"N=int(eval(input()))\n\n\n\nA=[[-1]*N for _ in range(N)]\n\nfor i in range(N):\n\n  a=int(eval(input()))\n\n  for j in range(a):\n\n    x,y=list(map(int, input().split()))\n\n    A[i][x-1]=y\n\n#\u6b63\u76f4\u8005\u304c\u6b63\u76f4\u8005\u306b\u4e0d\u89aa\u5207\u3068\u8a00\u308f\u308c\u3066\u3044\u306a\u3044\n\n#\u2192\u6b63\u76f4\u3082\u306e\u304c\u4e0d\u89aa\u5207\u3092\u6b63\u76f4\u8005\u3068\u8a00\u3063\u3066\u3044\u306a\u3044\u304b\n\nans=0\n\nfor i in range(2**N):\n\n  ok=True\n\n  for j in range(N):\n\n    if (i>>j&1)==1:\n\n      for k in range(N):\n\n        if A[j][k]!=-1 and (i>>k&1)!=A[j][k]:\n\n          ok=False\n\n  if ok:\n\n    ans=max(ans, bin(i).count(\"1\"))\n\n  \n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(eval(input()))\nS = [[-1] * N for _ in range(N)]\ndp = [0] * (2 ** N)\nfor i in range(N):\n    A = int(eval(input()))\n    for _ in range(A):\n        x, y = list(map(int, input().split()))\n        S[i][x - 1] = y\nfor s in range(2 ** N):\n    ok = True\n    for i in range(N):\n        if (s >> i & 1) == 1:\n            for j in range(N):\n                if S[i][j] != -1 and (s >> j & 1) != S[i][j]:\n                    ok = False\n    if ok:\n        dp[s] = bin(s).count(\"1\")\nfor i in range(2 ** N):\n    for j in range(i):\n        if (i & j) == j:\n            dp[i] = max(dp[i], dp[j] + dp[i ^ j])\nprint(max(dp))"}
{"problem_id":"p02899","slow_code_col":"import numpy as np\n\nfrom copy import deepcopy\n\n\n\nN = int(eval(input()))\n\nA = []\n\nA.append(list(map(int, input().split())))\n\na = deepcopy(A[0])\n\na.sort()\n\nA.append(a)\n\nA_t = np.array(A).T.tolist()\n\nA_t.sort()\n\n\n\nout = []\n\nfor i in range(N):\n\n    out.append(str(A_t[i][1]))\n\nprint((\" \".join(out)))\n","reference_code_col":"N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nrev = [\"\"] * N\n\nfor i in range(N):\n\n    rev[A[i]-1] = str(i+1)\n\nprint((\" \".join(rev)))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(input())\n\n# Read the input matrix\nmatrix = [list(map(int, input().split())) for _ in range(N)]\n\n# Sort the first row of the matrix\nsorted_row = sorted(matrix[0])\n\n# Append the sorted row to the matrix\nmatrix.append(sorted_row)\n\n# Convert the matrix to a NumPy array and take its transpose\ntransposed_matrix = np.array(matrix).T.tolist()\n\n# Sort the transposed matrix by the second column\ntransposed_matrix.sort(key=lambda x: x[1])\n\n# Extract the values from the second column of the sorted transposed matrix\noutput = [str(row[1]) for row in transposed_matrix]\n\n# Print the output\nprint(\" \".join(output))"}
{"problem_id":"p03592","slow_code_col":"N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        t = i*M + j*N - i*j*2\n\n        if t==K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')","reference_code_col":"N,M,K = list(map(int,input().split()))\n\n\n\nfor i in range(N+1):\n\n    for j in range(M+1):\n\n        if i*(M-j) + j*(N-i) == K:\n\n            print('Yes')\n\n            exit()\n\nprint('No')","model_generated_potentially_faster_code_col":"N, M, K = map(int, input().split())\n\n# Check if there exists integers x and y such that x * M + y * N - 2 * x * y = K\nif (K % (M + N)) == 0 and K >= 0:\n    print('Yes')\nelse:\n    print('No')"}
{"problem_id":"p00542","slow_code_col":"a,b,c,d,e,f=[int(eval(input())) for _ in range(6)]\n\nprint((sum([a,b,c,d,max(e,f)])-min([a,b,c,d])))","reference_code_col":"print((sum(sorted(int(eval(input())) for _ in range(4))[1:])+max([int(eval(input())) for _ in range(2)])))","model_generated_potentially_faster_code_col":"a, b, c, d, e, f = map(int, input().split())\n\n# Calculate the sum of maximum and minimum values\nmax_val = max(a, b, c, d, e, f)\nmin_val = min(a, b, c, d)\n\n# Calculate the final result\nresult = (max_val + min_val) - (max(a, b, c, d))\n\nprint(result)"}
{"problem_id":"p03371","slow_code_col":"# AtCoder Beginner Contest 095 C - Half and Half\n\nimport sys\n\n\n\nA, B, C, X, Y = list(map(int, sys.stdin.readline().strip().split()))\n\n\n\nans = A * X + B * Y\n\nfor z in range(2, 2 * 10 ** 5 + 1, 2):\n\n    x = max(X - int(z \/ 2), 0)\n\n    y = max(Y - int(z \/ 2), 0)\n\n\n\n    price = A * x + B * y + C * z\n\n    ans = min(price, ans)\n\n\n\nprint(ans)\n","reference_code_col":"# AtCoder Beginner Contest 095 C - Half and Half\n\nimport sys\n\n\n\nA, B, C, X, Y = list(map(int, sys.stdin.readline().strip().split()))\n\n\n\n\"\"\"\n\nans = A * X + B * Y\n\nfor z in range(2, 2 * 10 ** 5 + 1, 2):\n\n    x = max(X - int(z \/ 2), 0)\n\n    y = max(Y - int(z \/ 2), 0)\n\n\n\n    price = A * x + B * y + C * z\n\n    ans = min(price, ans)\n\n\n\nprint(ans)\n\n\"\"\"\n\n\n\nprice1 = A * X + B * Y\n\nprice2 = C * 2 * X + B * max(Y - X, 0)\n\nprice3 = A * max(X - Y, 0) + C * 2 * Y\n\nprint((min(price1, price2, price3)))\n\n\n","model_generated_potentially_faster_code_col":"import sys\n# read input\nA, B, C, X, Y = map(int, sys.stdin.readline().strip().split())\n# calculate maximum number of items that can be bought without any discount\nmax_items = min(X, Y)\n# calculate remaining items after buying maximum number of items without discount\nremaining_X = X - max_items\nremaining_Y = Y - max_items\n# calculate minimum cost\nmin_cost = A * remaining_X + B * remaining_Y + C * 2 * max_items\n# print result\nprint(min_cost)"}
{"problem_id":"p03037","slow_code_col":"N,M = list(map(int,input().split()))\n\nL,R = [],[]\n\nfor i in range(M):\n\n    l,r = list(map(int,input().split()))\n\n    L.append(l)\n\n    R.append(r)\n\nans = min(R)-max(L)+1\n\nprint((ans if ans >= 0 else 0))","reference_code_col":"# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, M = lr()\n\nL = 0; R = 10 ** 6\n\nfor _ in range(M):\n\n    l, r = lr()\n\n    if l > L:\n\n        L = l\n\n    if r < R:\n\n        R = r\n\n\n\nanswer = max(0, R - L + 1)\n\nprint(answer)\n","model_generated_potentially_faster_code_col":"N, M = map(int, input().split())\n\nmin_right = float('inf')\nmax_left = float('-inf')\n\nfor _ in range(M):\n    l, r = map(int, input().split())\n    max_left = max(max_left, l)\n    min_right = min(min_right, r)\n\nans = min_right - max_left + 1\n\nprint(ans if ans >= 0 else 0)"}
{"problem_id":"p02555","slow_code_col":"MOD = 1000000007\n\n\n\n\n\nS = int(eval(input()))\n\n\n\n#dp[i]:=i\u6841\u306e\u6570\u5217\u3067\u6761\u4ef6\u3092\u6e80\u305f\u3059\u3082\u306e\u306e\u6570\n\ndp = [0]*(S+1)\n\n\n\nfor i in range(3,S+1):\n\n    #dp[i]=sum(dp[0],..,dp[i-3])+1\n\n    for j in range(i-3+1):\n\n        dp[i] = (dp[i]+dp[j])%MOD\n\n    dp[i] = (dp[i]+1)%MOD\n\n\n\nprint((dp[S]))","reference_code_col":"MOD = 1000000007\n\n\n\n\n\nS = int(eval(input()))\n\n\n\n#dp[i]:=i\u6841\u306e\u6570\u5217\u3067\u6761\u4ef6\u3092\u6e80\u305f\u3059\u3082\u306e\u306e\u6570\n\ndp = [0]*(S+1)\n\ndp_sum = [0]*(S+1)\n\n\n\nfor i in range(3,S+1):\n\n    #dp[i]=sum(dp[0],..,dp[i-3])+1\n\n    \n\n    dp[i] = (dp_sum[i-3]+1)%MOD\n\n    dp_sum[i] = (dp[i]+dp_sum[i-1])%MOD\n\n\n\nprint((dp[S]))","model_generated_potentially_faster_code_col":"MOD = 1000000007\n\n# Precompute factorials and their modular inverses\nfactorial = [1]\ninverse_factorial = [1]\nfor i in range(1, 1001):\n    factorial.append((factorial[-1] * i) % MOD)\n    inverse_factorial.append(pow(factorial[-1], MOD - 2, MOD))\n\ndef nCr(n, r):\n    return (factorial[n] * inverse_factorial[r] * inverse_factorial[n - r]) % MOD\n\nS = int(input())\n\n# dp[i]: i-digit numbers where the sum is divisible by 3\ndp = [0] * (S + 1)\n\nfor i in range(S + 1):\n    dp[i] = pow(2, i, MOD)\n    if i >= 3:\n        dp[i] = (dp[i] - nCr(i, 3) + MOD) % MOD\n\nprint(dp[S])"}
{"problem_id":"p02881","slow_code_col":"n = int(eval(input()))\n\nl = []\n\nfor i in range(1,1000001):\n\n    a = n \/ i\n\n    if a.is_integer():\n\n        l.append(i+n\/i)\n\nprint((int(min(l)-2)))","reference_code_col":"n = int(eval(input()))\n\na = 10**20\n\nfor i in range(1,int(n**0.5)+1):\n\n    if n%i==0:\n\n        a = min(a,i+n\/\/i)\n\nprint((a-2))","model_generated_potentially_faster_code_col":"import math\n\n# Get the input as an integer\nn = int(input())\n\n# Initialize a list to store the values of i + n\/i\nvalues = []\n\n# Iterate up to the square root of n\nfor i in range(1, int(math.sqrt(n)) + 1):\n    if n % i == 0:  # Check if i is a divisor of n\n        values.append(i + n \/\/ i)\n        if i != n \/\/ i:  # Avoid adding the same pair twice\n            values.append(n \/\/ i + i)\n\n# Find the minimum value and subtract 2\nmin_value = min(values) - 2\n\n# Print the result\nprint(int(min_value))"}
{"problem_id":"p02881","slow_code_col":"n = int(eval(input()))\n\nimport math\n\nm = int(math.sqrt(n))+1\n\nanss = []\n\nfor x in range(1, m+1):\n\n  y = n\/\/x\n\n  z = n%x\n\n  if z == 0:\n\n    anss.append(abs(x-1)+abs(y-1))\n\nprint((min(anss)))\n","reference_code_col":"n = int(eval(input()))\n\ndef make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append(i)\n\n            if i != n \/\/ i:\n\n                divisors.append(n\/\/i)\n\n\n\n    #divisors.sort(reverse=True)\n\n    return divisors\n\n\n\nl = make_divisors(n)\n\nmin_ = float('inf')\n\nfor i in range(len(l)):\n\n    min_ = min(min_, l[i]-1+n\/\/l[i]-1)\n\nprint(min_)\n","model_generated_potentially_faster_code_col":"# Get user input as an integer\nn = int(input())\n\nimport math\n\n# Calculate the upper limit for the loop\nm = int(math.sqrt(n)) + 1\n\n# Initialize the list to store results\nanss = []\n\n# Loop through possible divisors\nfor x in range(1, m):\n    # Calculate the quotient and remainder\n    y = n \/\/ x\n    z = n % x\n    \n    # Check if x is a divisor\n    if z == 0:\n        # Append the sum of absolute differences\n        anss.append(abs(x - 1) + abs(y - 1))\n\n# Print the minimum value from the list\nprint(min(anss))"}
{"problem_id":"p02994","slow_code_col":"import numpy as np\n\nN,L = list(map(int,input().split()))\n\napple = np.array(list(range(N))) + 1\n\ntaste = apple + L - 1\n\ntaste_applepie = sum(taste)\n\nif L <= 0 and abs(N) > abs(L):\n\n    print(taste_applepie)\n\nelif L > 0:\n\n    print((taste_applepie - L))\n\nelse:\n\n    print((taste_applepie - (N+L-1)))","reference_code_col":"N,L = list(map(int,input().split()))\n\nt = [L+i-1 for i in range(1,N+1)]\n\nabst = list(map(abs,t))\n\nminind = abst.index(min(abst))\n\nprint((sum(t)-t[minind]))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN, L = map(int, input().split())\n\n# Create array 'apple' from 1 to N\napple = np.arange(1, N + 1)\n\n# Calculate 'taste'\ntaste = apple + L - 1\n\n# Calculate the sum of 'taste' array\ntaste_applepie = taste.sum()\n\n# Determine the output based on conditions\nif L <= 0 and abs(N) > abs(L):\n    result = taste_applepie\nelif L > 0:\n    result = taste_applepie - L\nelse:\n    result = taste_applepie - (N + L - 1)\n\n# Print the result\nprint(result)"}
{"problem_id":"p03774","slow_code_col":"import numpy as np\n\nN,M=list(map(int, input().split()))\n\nhuman=[]\n\nfor i in range(N):\n\n  a,b=list(map(int, input().split()))\n\n  human.append((a,b))\n\nC=[]\n\nfor i in range(M):\n\n  c,d=list(map(int, input().split()))\n\n  C.append((c,d))\n\n  \n\nfor h in human:\n\n  a,b=h\n\n  now=0\n\n  mini=np.inf\n\n  for i,ch in enumerate(C):\n\n    c,d=ch\n\n    L=abs(a-c)+abs(b-d)\n\n    if mini>L:\n\n      mini=L\n\n      now=i+1\n\n  print(now)","reference_code_col":"N,M=list(map(int, input().split()))\n\nS=[]\n\nfor i in range(N):\n\n    a,b=list(map(int, input().split()))\n\n    S.append((a,b))\n\n\n\nC=[]\n\nfor i in range(M):\n\n    c,d=list(map(int, input().split()))\n\n    C.append((c,d,i+1))\n\n#print(C)\n\nfor s in S:\n\n    a,b=s\n\n    now=0\n\n    dis=10**9\n\n\n\n    for t in C:\n\n        c,d,n=t\n\n        D=abs(c-a)+abs(d-b)\n\n        \n\n        if D<dis:\n\n            dis=D\n\n            now=n\n\n    print(now)","model_generated_potentially_faster_code_col":"import heapq\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\n\nhuman = []\nindex = 2\nfor _ in range(N):\n    a = int(data[index])\n    b = int(data[index + 1])\n    human.append((a, b))\n    index += 2\n\nC = []\nindex = N * 2 + 2\nfor _ in range(M):\n    c = int(data[index])\n    d = int(data[index + 1])\n    C.append((c, d))\n    index += 2\n\n# Create a min-heap based on distance from each human to all cities\nmin_heap = []\nfor i, (a, b) in enumerate(human):\n    distances = [(abs(a - c) + abs(b - d), j) for j, (c, d) in enumerate(C)]\n    heapq.heapify(distances)\n    heapq.heappush(min_heap, (distances[0], i))\n\n# Output the closest city for each human\nwhile min_heap:\n    _, i = heapq.heappop(min_heap)\n    print(i + 1)"}
{"problem_id":"p03455","slow_code_col":"a, b = list(map(int, input().split()))\n\nif a*b%2 == 1:\n\n    print(\"Odd\")\n\nelse:\n\n    print(\"Even\")","reference_code_col":"a, b = list(map(int, input().split()))\n\nprint(('Odd'if a&b&1 else 'Even'))","model_generated_potentially_faster_code_col":"a, b = map(int, input().split())\n\nif a % 2 != 0 or b % 2 != 0:\n    print(\"Odd\")\nelse:\n    print(\"Even\")"}
{"problem_id":"p02555","slow_code_col":"import sys, os, math, bisect, itertools, collections, heapq, queue, copy, array\n\n\n\n# from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n# from decimal import Decimal\n\n# from collections import defaultdict, deque\n\n\n\nsys.setrecursionlimit(10000000)\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\nfl = lambda: list(map(float, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nsl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\nlcm = lambda x, y: (x * y) \/\/ math.gcd(x, y)\n\n\n\nMOD = 10 ** 9 + 7\n\nINF = float('inf')\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    S = ii()\n\n    dp = [0] * (S + 1)\n\n\n\n    dp[0] = 1\n\n    # 0 <= i <= S\u306e\u7bc4\u56f2\u3092\u63a2\u7d22\n\n    for i in range(1, S + 1):\n\n        # 0 <= j <= i - 3\u306e\u7bc4\u56f2\u3067\u3001\n\n        # \u9593\u4ed5\u5207\u308a\u3092\u7f6e\u304f\u3053\u3068\u304c\u3067\u304d\u308b\u500b\u6570\u306e\u5408\u8a08\u3092\u96c6\u8a08\n\n        for j in range(0, i - 3 + 1):\n\n            dp[i] += dp[j]\n\n            dp[i] %= MOD\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"import sys, os, math, bisect, itertools, collections, heapq, queue, copy, array\n\n\n\n# from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n\n# from decimal import Decimal\n\n# from collections import defaultdict, deque\n\n\n\nsys.setrecursionlimit(10000000)\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\nfl = lambda: list(map(float, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nsl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\nlcm = lambda x, y: (x * y) \/\/ math.gcd(x, y)\n\n\n\nMOD = 10 ** 9 + 7\n\nINF = float('inf')\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    S = ii()\n\n    dp = [0] * (S + 1)\n\n\n\n    dp[0] = 1\n\n    # 0 <= i <= S\u306e\u7bc4\u56f2\u3092\u63a2\u7d22\n\n    for i in range(1, S + 1):\n\n        # 0 <= j <= i - 3\u306e\u7bc4\u56f2\u3067\u3001\n\n        # \u9593\u4ed5\u5207\u308a\u3092\u7f6e\u304f\u3053\u3068\u304c\u3067\u304d\u308b\u500b\u6570\u306e\u5408\u8a08\u3092\u96c6\u8a08\n\n        if i > 2:\n\n            dp[i] = sum(dp[0:i - 2])\n\n            dp[i] %= MOD\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\nsys.setrecursionlimit(10**6)\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\nMOD = 10**9 + 7\n\n\n@functools.lru_cache(None)\ndef count_partitions(n):\n    if n < 0:\n        return 0\n    elif n == 0:\n        return 1\n    else:\n        return sum(count_partitions(n - i) for i in range(3, n + 1)) % MOD\n\n\ndef main():\n    if os.getenv(\"LOCAL\"):\n        sys.stdin = open(\"input.txt\", \"r\")\n\n    S = ii()\n    result = count_partitions(S)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02555","slow_code_col":"n = int(eval(input()))\n\nm = 10**9 + 7\n\n# ans = [0] * (n + 1)\n\nans = [0] * 2200\n\nans[0] = 1\n\n# ans[3] = 1\n\n# ans[4] = 1\n\n# ans[5] = 1\n\nfor i in range(3, n + 1):\n\n    for j in range(i - 2):\n\n        ans[i] += ans[j]\n\n        ans[i] %= m\n\nprint((ans[n]))\n\n# print(ans[:10])\n","reference_code_col":"n = int(eval(input()))\n\nm = 10**9 + 7\n\n# ans = [0] * (n + 1)\n\nans = [0] * 2200\n\nans[0] = 1\n\n# ans[3] = 1\n\n# ans[4] = 1\n\n# ans[5] = 1\n\nfor i in range(3, n + 1):\n\n    ans[i] = ans[i - 1] + ans[i - 3]\n\n    ans[i] %= m\n\n    # for j in range(i - 2):\n\n    #     ans[i] += ans[j]\n\n    #     ans[i] %= m\n\nprint((ans[n]))\n\n# print(ans[:10])\n","model_generated_potentially_faster_code_col":"n = int(eval(input()))\nm = 10**9 + 7\n\n# Initialize the DP array with a size of n+1\nans = [0] * (n + 1)\nans[0] = 1\n\n# Fill the DP array using the bottom-up approach\nfor i in range(3, n + 1):\n    for j in range(i - 2):\n        ans[i] += ans[j]\n        ans[i] %= m\n\nprint(ans[n])"}
{"problem_id":"p03608","slow_code_col":"N, M, R = list(map(int, input().split()))\n\nr = list(map(int, input().split()))\n\nd = [[float('inf')]*N for _ in range(N)]\n\nfor i in range(M): #\u3072\u3068\u307e\u305a\u679d\u304c\u3042\u308b\u30da\u30a2\u306f\u679d\u306e\u9577\u3055\u3092\u30bb\u30c3\u30c8\n\n  a,b,t = list(map(int, input().split()))\n\n  d[a-1][b-1] = t\n\n  d[b-1][a-1] = t\n\n\n\nfor i in range(N):\n\n  d[i][i] = 0 #\u81ea\u8eab\u3078\u306e\u6700\u77ed\u7d4c\u8def\u306f0\n\n#\u4e09\u91cd\u30eb\u30fc\u30d7\n\nfor k in range(N):\n\n  for i in range(N):\n\n    for j in range(N):\n\n      d[i][j] = min(d[i][j], d[i][k]+d[k][j])\n\n\n\nfrom itertools import groupby, accumulate, product, permutations, combinations\n\n\n\nans = float('inf')\n\nfor p in permutations(r,R):\n\n  cnt = 0\n\n  for i in range(1,R):\n\n    cnt += d[p[i-1]-1][p[i]-1]\n\n  ans = min(ans,cnt)\n\nprint(ans)","reference_code_col":"N, M, r = list(map(int, input().split()))\n\nR = list([int(x)-1 for x in input().split()])\n\nd = [[1<<30]*N for _ in range(N)]\n\nfor i in range(M): #\u3072\u3068\u307e\u305a\u679d\u304c\u3042\u308b\u30da\u30a2\u306f\u679d\u306e\u9577\u3055\u3092\u30bb\u30c3\u30c8\n\n  a,b,t = list(map(int, input().split()))\n\n  d[a-1][b-1] = t\n\n  d[b-1][a-1] = t\n\n\n\nfor i in range(N):\n\n  d[i][i] = 0 #\u81ea\u8eab\u3078\u306e\u6700\u77ed\u7d4c\u8def\u306f0\n\n#\u4e09\u91cd\u30eb\u30fc\u30d7\n\nfor k in range(N):\n\n  for i in range(N):\n\n    for j in range(N):\n\n      d[i][j] = min(d[i][j], d[i][k]+d[k][j])\n\nfrom itertools import groupby, accumulate, product, permutations, combinations\n\nans = 1<<30\n\nfor per in permutations(R,r):\n\n  cnt = 0\n\n  for i in range(r-1):\n\n    cnt += d[per[i]][per[i+1]]\n\n  ans = min(ans, cnt)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nR = int(data[2])\n\nr = [int(x) - 1 for x in data[3:3+R]]\n\nedges = []\nindex = 3 + R\nfor _ in range(M):\n    a = int(data[index]) - 1\n    b = int(data[index + 1]) - 1\n    t = int(data[index + 2])\n    edges.append((a, b, t))\n    edges.append((b, a, t))\n    index += 3\n\nINF = float('inf')\ndp = [[INF] * N for _ in range(1 << R)]\nfor mask in range(1 << R):\n    dp[mask][0] = 0\n\nfor mask in range(1 << R):\n    for i in range(R):\n        if (mask >> i) & 1:\n            prev_mask = mask ^ (1 << i)\n            for j in range(N):\n                if dp[prev_mask][j] != INF:\n                    for a, b, t in edges:\n                        if (a == j and b == r[i]) or (a == r[i] and b == j):\n                            dp[mask][i] = min(dp[mask][i], dp[prev_mask][j] + t)\n\nans = INF\nfor mask in range(1 << R):\n    if sum((mask >> i) & 1 for i in range(R)) == R:\n        ans = min(ans, dp[mask][-1])\n\nprint(ans)"}
{"problem_id":"p02615","slow_code_col":"import numpy as np\n\nimport heapq\n\n\n\nN = int(eval(input()))\n\nA =  np.sort([int(x) for x in input().split(\" \")])[::-1]\n\n\n\nq = [(-A[1], (0, 1)), (-A[1], (0, 1))]\n\nconfort = A[0]\n\nheapq.heapify(q)\n\n\n\ni = 2\n\nwhile N > i:\n\n    m = heapq.heappop(q)\n\n    # print(f\"{m[1][0]}\u3068{m[1][1]}\u306e\u9593\u306b\u5272\u308a\u8fbc\u3080. \u6c17\u6301\u3061\u826f\u3055 {-m[0]}\")\n\n    confort -= m[0]\n\n    heapq.heappush(q, (-A[i], (i, m[1][0])))\n\n    heapq.heappush(q, (-A[i], (i, m[1][1])))\n\n    i += 1\n\nprint(confort)\n","reference_code_col":"N = int(eval(input()))\n\nA = sorted([int(x) for x in input().split(\" \")])[::-1]\n\n\n\nN -= 2\n\nS = A[0]\n\n\n\ni = 1\n\nwhile 1:\n\n    if N == 0:\n\n        break \n\n    if N == 1:\n\n        S += A[i]\n\n        break\n\n    S += 2 * A[i]\n\n    N -= 2\n\n    i += 1\n\nprint(S)","model_generated_potentially_faster_code_col":"import numpy as np\nimport heapq\n\n# Read input\nN = int(eval(input()))\nA = np.sort([int(x) for x in input().split()])[::-1]\n\n# Initialize the heap with the first two elements\nq = [(-A[0], -A[1])]\nheapq.heapify(q)\n\n# Calculate initial comfort\nconfort = A[0] + A[1]\n\n# Iterate through the rest of the elements\nfor i in range(2, N):\n    m = heapq.heappop(q)\n    discomfort = -m[0]\n    confort -= discomfort\n    heapq.heappush(q, (-A[i], -discomfort))\n\nprint(confort)"}
{"problem_id":"p04021","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nread = sys.stdin.read\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, read().split()))\n\nL = sorted([(j, i) for i, j in enumerate(A)])\n\ncount = 0\n\nfor i in range(n):\n\n  if (L[i][1]-i)%2:\n\n    count += 1\n\nans = (count+1) \/\/ 2\n\nprint(ans)","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\nread = sys.stdin.read\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, read().split()))\n\nL = sorted([(j, i) for i, j in enumerate(A)])\n\ncount = 0\n\nfor i in range(n):\n\n  count += (L[i][1]-i)%2\n\nans = (count+1) \/\/ 2\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\nread = sys.stdin.read\n\nn = int(input())\nA = list(map(int, read().split()))\nindices = [i for i in range(n)]\nindices.sort(key=A.__getitem__)\n\ncount = 0\n\nfor i in range(n):\n  if (indices[i] - i) % 2:\n    count += 1\n\nans = (count + 1) \/\/ 2\nprint(ans)"}
{"problem_id":"p02378","slow_code_col":"# Acceptance of input\n\n\n\nimport sys\n\n\n\nfile_input = sys.stdin\n\n\n\nX, Y, E = list(map(int, file_input.readline().split()))\n\n\n\nv_num = X + Y + 2\n\n\n\nadj_mat = [[0] * (v_num) for i in range(v_num)]\n\n\n\nfor line in file_input:\n\n    x, y = list(map(int, line.split()))\n\n    adj_mat[x][X + y] = 1\n\n\n\ns = X + Y\n\nt = s + 1\n\n\n\nfor i in range(X):\n\n    adj_mat[s][i] = 1\n\n\n\nfor i in range(X, s):\n\n    adj_mat[i][t] = 1\n\n\n\n# Dinic's algorithm\n\n\n\nimport collections\n\n\n\n# BFS for residual capacity network to construct level graph\n\ndef bfs(start, goal, parent):\n\n    unvisited = [True] * v_num\n\n    queue = collections.deque()\n\n    queue.append(start)\n\n    unvisited[start] = False\n\n    while queue:\n\n        u = queue.popleft()\n\n        for v, r_capacity in enumerate(adj_mat[u]):\n\n            if unvisited[v] and (r_capacity > 0):\n\n                parent[v].append(u)\n\n                queue.append(v)\n\n                unvisited[v] = False\n\n    return unvisited[goal]\n\n\n\n# DFS for level graph and construct blocking flow\n\ndef dfs(goal, path, parent, blocking_flow):\n\n    v = path[-1]\n\n    if v == goal:\n\n        aug_path_flow = 10000\n\n        for x, y in zip(path[1:], path[:-1]):\n\n            aug_path_flow = min(aug_path_flow, adj_mat[x][y])\n\n        for x, y in zip(path[1:], path[:-1]):\n\n            adj_mat[x][y] -= aug_path_flow\n\n            adj_mat[y][x] += aug_path_flow\n\n        blocking_flow[0] += aug_path_flow\n\n    else:\n\n        for u in parent[v]:\n\n            path.append(u)\n\n            dfs(goal, path, parent, blocking_flow)\n\n            path.pop()\n\n\n\ndef dinic(source, sink):\n\n    max_flow = 0\n\n    parent = [[] for i in range(v_num)]\n\n    while not bfs(source, sink, parent):\n\n        blocking_flow = [0]\n\n        path = [sink]\n\n        # search in reverse direction from sink\n\n        dfs(source, path, parent, blocking_flow)\n\n        max_flow += blocking_flow[0]\n\n        parent = [[] for i in range(v_num)]\n\n    return max_flow\n\n\n\n# output\n\nprint((dinic(s, t)))","reference_code_col":"# Acceptance of input\n\n\n\nimport sys\n\n\n\nfile_input = sys.stdin\n\n\n\nX, Y, E = list(map(int, file_input.readline().split()))\n\n\n\nv_num = X + Y + 2\n\n\n\nadj_mat = [[0] * (v_num) for i in range(v_num)]\n\n\n\nfor line in file_input:\n\n    x, y = list(map(int, line.split()))\n\n    adj_mat[x][X + y] = 1\n\n\n\ns = X + Y\n\nt = s + 1\n\n\n\nfor i in range(X):\n\n    adj_mat[s][i] = 1\n\n\n\nfor i in range(X, s):\n\n    adj_mat[i][t] = 1\n\n\n\n# Dinic's algorithm\n\n\n\nimport collections\n\n\n\n# BFS for residual capacity network to construct level graph\n\ndef bfs(start, goal, parent):\n\n    level = [v_num] * v_num\n\n    unvisited = [True] * v_num\n\n    queue = collections.deque()\n\n    queue.append(start)\n\n    level[start] = 0\n\n    unvisited[start] = False\n\n    while queue:\n\n        u = queue.popleft()\n\n        next_level = level[u] + 1\n\n        for v, r_capacity in enumerate(adj_mat[u]):\n\n            if (level[v] >= next_level) and (r_capacity > 0):\n\n                level[v] = next_level\n\n                parent[v].append(u)\n\n                if unvisited[v]:\n\n                    queue.append(v)\n\n                    unvisited[v] = False\n\n    return level[goal]\n\n\n\n# DFS for level graph and construct blocking flow\n\ndef dfs(goal, path, parent, blocking_flow):\n\n    v = path[-1]\n\n    if v == goal:\n\n        aug_path_flow = 10000\n\n        for x, y in zip(path[1:], path[:-1]):\n\n            aug_path_flow = min(aug_path_flow, adj_mat[x][y])\n\n        for x, y in zip(path[1:], path[:-1]):\n\n            adj_mat[x][y] -= aug_path_flow\n\n            adj_mat[y][x] += aug_path_flow\n\n        blocking_flow[0] += aug_path_flow\n\n    else:\n\n        for u in parent[v]:\n\n            path.append(u)\n\n            dfs(goal, path, parent, blocking_flow)\n\n            path.pop()\n\n\n\ndef dinic(source, sink):\n\n    max_flow = 0\n\n    parent = [[] for i in range(v_num)]\n\n    while bfs(source, sink, parent) != v_num:\n\n        blocking_flow = [0]\n\n        path = [sink]\n\n        # search in reverse direction from sink\n\n        dfs(source, path, parent, blocking_flow)\n\n        max_flow += blocking_flow[0]\n\n        parent = [[] for i in range(v_num)]\n\n    return max_flow\n\n\n\n# output\n\nprint((dinic(s, t)))","model_generated_potentially_faster_code_col":"import sys\nfrom collections import deque, defaultdict\n\nfile_input = sys.stdin\n\nX, Y, E = map(int, file_input.readline().split())\n\nv_num = X + Y + 2\n\nadj_list = defaultdict(list)\nreverse_adj_list = defaultdict(list)\n\nfor _ in range(E):\n    x, y = map(int, file_input.readline().split())\n    adj_list[X + y].append(x)\n    reverse_adj_list[x].append(X + y)\n\ns = X + Y\nt = s + 1\n\nfor i in range(X):\n    adj_list[s].append(i)\n    reverse_adj_list[i].append(s)\n\nfor i in range(X, s):\n    adj_list[i].append(t)\n    reverse_adj_list[t].append(i)\n\n# Dinic's algorithm\n\n# BFS for residual capacity network to construct level graph\ndef bfs(start, goal):\n    unvisited = set(range(v_num))\n    queue = deque([start])\n    unvisited.remove(start)\n    parent = {u: [] for u in range(v_num)}\n    \n    while queue:\n        u = queue.popleft()\n        for v in adj_list[u]:\n            if v in unvisited:\n                parent[v].append(u)\n                queue.append(v)\n                unvisited.remove(v)\n    \n    return goal in unvisited\n\n# DFS for level graph and construct blocking flow\ndef dfs(goal, path, parent, blocking_flow):\n    v = path[-1]\n    if v == goal:\n        aug_path_flow = float('inf')\n        for x, y in zip(path[1:], path[:-1]):\n            aug_path_flow = min(aug_path_flow, adj_list[x][y])\n        for x, y in zip(path[1:], path[:-1]):\n            adj_list[x][y] -= aug_path_flow\n            reverse_adj_list[y].remove(x)\n            reverse_adj_list[x].add(y)\n            adj_list[y][x] += aug_path_flow\n        blocking_flow[0] += aug_path_flow\n    else:\n        for u in parent[v]:\n            path.append(u)\n            dfs(goal, path, parent, blocking_flow)\n            path.pop()\n\ndef dinic(source, sink):\n    max_flow = 0\n    parent = {u: [] for u in range(v_num)}\n    \n    while bfs(source, sink):\n        blocking_flow = [0]\n        path = [sink]\n        \n        # search in reverse direction from sink\n        dfs(source, path, parent, blocking_flow)\n        max_flow += blocking_flow[0]\n    \n    return max_flow\n\n# Output\nprint(dinic(s, t))"}
{"problem_id":"p03752","slow_code_col":"import numpy as np\n\nfrom itertools import combinations \n\nINF = int(1e9)*15\n\ndef main():\n\n    n, k = list(map(int, input().split())) \n\n    a = np.array(input().split(), np.int32)\n\n    c = np.array([int(i) for i in range(1, n)])\n\n    ans = INF\n\n    for comb in combinations(c, k-1):\n\n        s = set(comb)\n\n        mx = a[0]\n\n        cost = 0\n\n        for i in range(n):\n\n            if i in s:\n\n                if a[i] > mx:\n\n                    mx = a[i]\n\n                    continue\n\n                else:\n\n                    mx += 1\n\n                    cost += mx-a[i] \n\n                    continue\n\n            mx = max(mx, a[i])\n\n        ans = min(cost, ans)\n\n    print(ans)\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"from itertools import combinations \n\nINF = int(1e9)*15\n\ndef main():\n\n    n, k = list(map(int, input().split())) \n\n    a = [int(i) for i in input().split()]\n\n    c = [int(i) for i in range(1, n)]\n\n    ans = INF\n\n    for comb in combinations(c, k-1):\n\n        s = set(comb)\n\n        mx = a[0]\n\n        cost = 0\n\n        for i in range(n):\n\n            if i in s:\n\n                if a[i] > mx:\n\n                    mx = a[i]\n\n                    continue\n\n                else:\n\n                    mx += 1\n\n                    cost += mx-a[i] \n\n                    continue\n\n            mx = max(mx, a[i])\n\n        ans = min(cost, ans)\n\n    print(ans)\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import numpy as np\n\nINF = int(1e9)*15\n\ndef main():\n    n, k = map(int, input().split())\n    a = np.array(sorted(input().split(), key=int, reverse=True), dtype=np.int32)\n    \n    ans = INF\n    \n    for i in range(k):\n        ans = min(ans, sum(max(a[j], a[i]+j-i) - a[j] for j in range(i+1)))\n        \n    print(ans)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02772","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nA = np.array(lr())\n\nA = A[A%2==0].tolist()\n\nbool = True\n\nfor a in A:\n\n    if a%3 != 0 and a%5 != 0:\n\n        bool = False\n\n\n\nprint(('APPROVED' if bool else 'DENIED'))\n","reference_code_col":"# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nA = lr()\n\nbl = all(x % 3 == 0 or x % 5 == 0 for x in A if x % 2 == 0)\n\nprint(('APPROVED' if bl else 'DENIED'))\n","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    N = int(sys.stdin.read().strip())\n    \n    A = [int(x) for x in sys.stdin.read().strip().split()]\n    A = [a for a in A if a % 2 == 0]\n    \n    if any(a % 3 != 0 and a % 5 != 0 for a in A):\n        print('DENIED')\n    else:\n        print('APPROVED')\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02851","slow_code_col":"from collections import defaultdict\n\n\n\nN, K, *A = list(map(int, open(0).read().split()))\n\n\n\nS = [0] * (N + 1)\n\nfor i in range(N):\n\n    S[i + 1] = S[i] + A[i]\n\n\n\nd = defaultdict(int)\n\nans = 0\n\nfor j in range(N + 1):\n\n    v = (S[j] - j) % K\n\n    ans += d[v]\n\n    d[v] += 1\n\n    if j >= K - 1:\n\n        d[(S[j - K + 1] - (j - K + 1)) % K] -= 1\n\n        \n\nprint(ans)\n","reference_code_col":"from collections import defaultdict\n\n\n\nN, K, *A = list(map(int, open(0).read().split()))\n\n\n\nx = [0] * (N + 1)\n\nfor i in range(N):\n\n    x[i + 1] = x[i] + A[i]\n\n    \n\ny = [(x[i] - i) % K for i in range(N + 1)]\n\n\n\nctr = defaultdict(int)\n\nans = 0\n\nfor j in range(N + 1):\n\n    ans += ctr[y[j]]\n\n    ctr[y[j]] += 1\n\n    if j - K + 1 >= 0:\n\n        ctr[y[j - K + 1]] -= 1\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"from collections import defaultdict\n\nN, K, *A = map(int, input().split())\n\nprefix_sum_mod_k = defaultdict(int)\nprefix_sum_mod_k[0] = 1  # Initialize with remainder 0 having one occurrence\n\ncurrent_sum = 0\ncount = 0\n\nfor num in A:\n    current_sum += num\n    count += prefix_sum_mod_k[current_sum % K]\n    prefix_sum_mod_k[current_sum % K] += 1\n\nprint(count)"}
{"problem_id":"p02767","slow_code_col":"n=int(eval(input()))\n\nx=list(map(int,input().split()))\n\n\n\nx.sort()\n\n\n\nfor p in range(x[0],x[len(x)-1]+1):\n\n    psum=0\n\n    for i in range(len(x)):\n\n        psum=psum+(x[0]-x[i])**2\n\n#    print(psum)\n\n    pmin=psum    \n\n    for j in range(x[0]+1,x[len(x)-1]):\n\n        psum=0\n\n        for i in range(len(x)):\n\n            psum=psum+(j-x[i])**2\n\n#        print(psum)\n\n        if pmin>psum:\n\n            pmin=psum\n\nprint(pmin)    ","reference_code_col":"n=int(eval(input()))\n\nx=list(map(int,input().split()))\n\n\n\nx.sort()\n\n\n\npsum=0\n\nfor i in range(len(x)):\n\n    psum=psum+(x[0]-x[i])**2\n\n#    print(psum)\n\npmin=psum    \n\nfor j in range(x[0]+1,x[len(x)-1]):\n\n    psum=0\n\n    for i in range(len(x)):\n\n        psum=psum+(j-x[i])**2\n\n#        print(psum)\n\n    if pmin>psum:\n\n        pmin=psum\n\nprint(pmin)            \n","model_generated_potentially_faster_code_col":"n = int(input())\nx = list(map(int, input().split()))\nx.sort()\n\n# Calculate the sum of squares for the smallest value in x\npmin = sum((x[0] - xi)**2 for xi in x)\n\n# Iterate only over the possible values within the range of x\nfor j in range(x[0] + 1, x[-1]):\n    psum = pmin\n    for i in range(n):\n        psum += 2 * (x[i] - j)\n    if psum < pmin:\n        pmin = psum\n\nprint(pmin)"}
{"problem_id":"p02880","slow_code_col":"N = int(eval(input()))\n\n# N>81\u306e\u3068\u304d\u306fn*n\u3067\u8868\u305b\u306a\u3044\u306e\u3067\u4e0d\u6575\n\nif N>81:\n\n    print('No')\n\nelse:\n\n    import numpy as np\n\n    n=np.array([1,2,3,4,5,6,7,8,9])\n\n    amari=N%n\n\n    shou=N\/\/n\n\n    if np.any((amari==0)*(shou<=9)):\n\n        print('Yes')\n\n    else:\n\n        print('No')\n","reference_code_col":"N = int(eval(input()))\n\nfor i in range(1,10):\n\n    if not N%i == 0:\n\n        continue\n\n    rest = N\/i\n\n    if rest<10:\n\n        print('Yes')\n\n        exit()\n\n\n\nprint('No')","model_generated_potentially_faster_code_col":"N = int(input())\n\n# N > 81 \u306e\u3068\u304d\u306f n*n \u3067\u8868\u305b\u306a\u3044\u306e\u3067\u4e0d\u6575\nif N > 81:\n    print('No')\nelse:\n    for i in range(1, 10):\n        if N % i == 0 and N \/\/ i <= 9:\n            print('Yes')\n            break\n    else:\n        print('No')"}
{"problem_id":"p02880","slow_code_col":"import numpy as np\n\nimport math\n\n\n\ndef bigger_devisor(n):\n\n  s = np.sqrt(n)\n\n  i = math.ceil(s)\n\n  while(n % i != 0):\n\n    i += 1\n\n  return i\n\n\n\nn = int(eval(input()))\n\nif bigger_devisor(n) > 9:\n\n  print('No')\n\nelse:\n\n  print('Yes')","reference_code_col":"n = int(eval(input()))\n\nans = 0\n\nfor i in range(1, 10):\n\n  if n % i == 0:\n\n    if n \/ i < 10:\n\n      ans = 1\n\nif ans == 0:\n\n  print('No')\n\nelse:\n\n  print('Yes')","model_generated_potentially_faster_code_col":"import numpy as np\nimport math\n\ndef bigger_devisor(n):\n    s = np.sqrt(n)\n    for i in range(2, math.ceil(s)+1):\n        if n % i == 0:\n            return max(i, n\/\/i)\n    return 1\n\nn = int(eval(input()))\nif bigger_devisor(n) > 9:\n    print('No')\nelse:\n    print('Yes')"}
{"problem_id":"p03172","slow_code_col":"n, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\n\n\ndp = [[0] * (k + 1) for _ in range(n + 1)]\n\ndp[0][0] = 1\n\nfor i in range(n):\n\n    dp[i + 1][0] = dp[i][0]\n\n    for j in range(1, k+1):\n\n        dp[i + 1][j] = (dp[i + 1][j - 1] + dp[i][j]) % mod\n\n    for j in range(k, a[i], -1):\n\n        dp[i + 1][j] = (dp[i + 1][j] - dp[i + 1][j - a[i] - 1]) % mod\n\nprint((dp[n][-1]))","reference_code_col":"n, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\n\n\nf = [0] * (k + 1)\n\nf[0] = 1\n\nfor i in range(n):\n\n    for j in range(1, k+1):\n\n        f[j] = (f[j] + f[j - 1]) % mod # 1\/(1-x):\u7d2f\u7a4d\u548c\n\n    for j in range(k, a[i], -1): # 1-x^(a[i]+1) a[i]+1\u6b21\u3057\u305f\u306e\u9805\u3092\u5f15\u304f\n\n        f[j] = (f[j] - f[j - a[i] - 1]) % mod\n\nprint((f[-1]))","model_generated_potentially_faster_code_col":"n, k = map(int, input().split())\n\na = list(map(int, input().split()))\n\nmod = 10 ** 9 + 7\n\ndp = [0] * (k + 1)\n\ndp[0] = 1\n\nfor num in a:\n\n    for j in range(k, num - 1, -1):\n        dp[j] = (dp[j] - dp[j - num - 1]) % mod\n\n    for j in range(num):\n        dp[j] = (dp[j] + dp[j - 1]) % mod\n\nprint(dp[-1])"}
{"problem_id":"p02792","slow_code_col":"import itertools\n\nN = int(eval(input()))\n\nNketa = len(str(N))\n\n\n\nrange_count = [[0 for j in range(10)]for i in range(10)]\n\n\n\n\n\nfor p in range(1,N+1):\n\n    mae = int(str(p)[0])\n\n    ato = int(str(p)[-1])\n\n    range_count[mae][ato] += 1\n\n\n\n    \n\n\n\ncount = 0\n\nfor j in range(1,N+1):\n\n    a_mae = int(str(j)[0])\n\n    a_ato = int(str(j)[-1])\n\n    \n\n    b_mae = a_ato\n\n    b_ato = a_mae\n\n    \n\n    if b_mae == 0:\n\n        continue\n\n    else:\n\n        count += range_count[b_mae][b_ato]\n\nprint(count)\n\n  ","reference_code_col":"n = int(eval(input()))\n\n\n\nall_count = 0\n\noptions = [str(i) for i in range(10)]\n\n\n\nmaeato = [[0 for i in range(10)] for j in range(10)]\n\n\n\nfor i in range(n+1):\n\n    checking = str(i)\n\n    maeato[int(checking[0])][int(checking[-1])]+=1\n\nall_count = 0\n\nfor i in range(1,10):\n\n    for j in range(1,10):\n\n        for k in range(1,10):\n\n            for p in range(1,10):\n\n                if i == p and j == k:\n\n                    all_count+=maeato[i][j]*maeato[k][p]\n\nprint(all_count)","model_generated_potentially_faster_code_col":"N = int(input())\n\ndigits = [0]*N\nfor i in range(N):\n    digits[i] = (i\/\/10) % 10, i%10\n\nrange_count = [[0 for _ in range(10)] for _ in range(10)]\n\nfor mae, ato in digits:\n    range_count[mae][ato] += 1\n\ncount = 0\nfor mae, ato in digits:\n    b_mae, b_ato = ato, mae\n    if b_mae != 0:\n        count += range_count[b_mae][b_ato]\n\nprint(count)"}
{"problem_id":"p02916","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nA = list(np.array(A) - 1)\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nsum_ = 0\n\ndiff = list(np.array(A[1:]) - np.array(A[:-1]))\n\ndiff.insert(0, -1)\n\nfor i in range(N):\n\n  sum_ += B[A[i]]\n\n  \n\n  if diff[i] == 1:\n\n    sum_ += C[A[i-1]]\n\n  \n\nprint(sum_)","reference_code_col":"N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nB = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor i in range(len(A)):\n\n  ans += B[A[i]-1]\n\n\n\n  if i != 0:\n\n    if A[i-1] + 1 == A[i]:\n\n      ans += C[A[i-1]-1]\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(eval(input()))\nA = np.array(list(map(int, input().split()))) - 1\nB = np.array(list(map(int, input().split())))\nC = np.array(list(map(int, input().split())))\n\nsum_ = B[A].sum()\ndiff = np.diff(A)\ndiff = np.insert(diff, 0, -1)\n\nsum_ += (diff == 1) * C[A[:-1]].sum()\n\nprint(sum_)"}
{"problem_id":"p02863","slow_code_col":"N, W = list(map(int, input().split()))\n\nitems = sorted([list(map(int, input().split())) for i in range(N)])\n\n\n\n# dp1[i][j] := \u5546\u54c10 ~ i \u304c\u5bfe\u8c61\n\ndp = [[0] * (W + 1) for i in range(N + 1)]\n\n\n\n# dp\u30c6\u30fc\u30d6\u30eb\u3092\u57cb\u3081\u308b\n\nfor i in range(N):\n\n    wi, vi = items[i]\n\n    for j in range(W + 1):\n\n        if j + wi <= W:\n\n            dp[i + 1][j + wi] = max(dp[i + 1][j + wi], dp[i][j] + vi)\n\n        dp[i + 1][j] = max(dp[i][j], dp[i + 1][j])\n\n\n\n\n\nans = 0\n\nfor i, (wi, vi) in enumerate(items):\n\n    for j in range(W):\n\n        ans = max(ans, dp[i][j] + vi)\n\n\n\nprint(ans)\n","reference_code_col":"N, W = list(map(int, input().split()))\n\nitems = sorted([list(map(int, input().split())) for i in range(N)])\n\n\n\n# dp1[i][j] := \u5546\u54c10 ~ i \u304c\u5bfe\u8c61\n\ndp = [[0] * (W + 1) for i in range(N + 1)]\n\n\n\n# dp\u30c6\u30fc\u30d6\u30eb\u3092\u57cb\u3081\u308b\n\nfor i in range(N):\n\n    wi, vi = items[i]\n\n    for j in range(W + 1):\n\n        if j + wi <= W:\n\n            dp[i + 1][j + wi] = max(dp[i + 1][j + wi], dp[i][j] + vi)\n\n        dp[i + 1][j] = max(dp[i][j], dp[i + 1][j])\n\n\n\n\n\nans = 0\n\nfor i, (wi, vi) in enumerate(items):\n\n    ans = max(ans, dp[i][W - 1] + vi)\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"N, W = map(int, input().split())\n\nitems = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Initialize DP table with -1 to indicate unvisited states\ndp = [[-1] * (W + 1) for _ in range(N + 1)]\n\ndef knapSack(i, w):\n    # Base case: no more items or weight limit reached\n    if i == N or w == 0:\n        return 0\n    \n    # If already computed, return stored value\n    if dp[i][w] != -1:\n        return dp[i][w]\n    \n    # Option 1: Exclude current item and take maximum from remaining items\n    exclude = knapSack(i + 1, w)\n    \n    # Option 2: Include current item if it fits within weight limit and add its value\n    include = float('-inf')\n    if w >= items[i][0]:\n        include = items[i][1] + knapSack(i + 1, w - items[i][0])\n    \n    # Store the maximum of both options in DP table\n    dp[i][w] = max(exclude, include)\n    return dp[i][w]\n\n# Call the function starting from item 0 and full weight limit\nans = knapSack(0, W)\n\nprint(ans)"}
{"problem_id":"p03013","slow_code_col":"# https:\/\/atcoder.jp\/contests\/abc129\/tasks\/abc129_c\n\n# \u5178\u578b\u7684\u306aDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]\u3092i\u6bb5\u76ee\u307e\u3067\u306e\u901a\u308a\u306e\u6570\u3068\u3059\u308b\u3002\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False, dtype=bool)\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # \u5e8a\u304c\u629c\u3051\u3066\u3044\u308b\u3068\u3053\u308d\n\n\n\n# dp\u30c6\u30fc\u30d6\u30eb\u306e\u7528\u610f\n\ndp = np.full((N + 1), -1, dtype='int64')\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n","reference_code_col":"# https:\/\/atcoder.jp\/contests\/abc129\/tasks\/abc129_c\n\n# \u5178\u578b\u7684\u306aDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]\u3092i\u6bb5\u76ee\u307e\u3067\u306e\u901a\u308a\u306e\u6570\u3068\u3059\u308b\u3002\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False).tolist()\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # \u5e8a\u304c\u629c\u3051\u3066\u3044\u308b\u3068\u3053\u308d\n\n\n\n# dp\u30c6\u30fc\u30d6\u30eb\u306e\u7528\u610f\n\ndp = np.full((N + 1), -1).tolist()\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\nN, M = map(int, input().split())\n\nto_zero = [False] * (N + 1)\n\nfor _ in range(M):\n    to_zero[int(eval(input()))] = True  # \u5e8a\u304c\u629c\u3051\u3066\u3044\u308b\u3068\u3053\u308d\n\n# dp\u30c6\u30fc\u30d6\u30eb\u306e\u7528\u610f\ndp = [-1] * (N + 1)\ndp[0] = 1\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n    if dp[i] > MOD:\n        dp[i] %= MOD\n\nprint(dp[-1])"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\neval(input())\n\nx = np.array(input().split(),dtype=np.int32)\n\n\n\nans = 0\n\nwhile (x%2 == 0).all():\n\n  x = x\/\/2\n\n  ans += 1\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nA = [int(x) for x in input().split()]\n\nresult = float('inf')\n\nfor i in range(N):\n\n  r=0\n\n  while A[i]%2==0:\n\n    A[i]=A[i]\/2\n\n    r +=1\n\n  result=min(result,r)\n\nprint(result)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read the input values and convert them into a numpy array.\nx = np.fromstring(input(), dtype=int, sep=' ')\n\nans = 0\n\n# Continue dividing by 2 while all elements are even.\nwhile (x % 2 == 0).all():\n    x \/\/= 2\n    ans += 1\n\n# Print the final result.\nprint(ans)"}
{"problem_id":"p03416","slow_code_col":"N = {} #10000\u4ee5\u4e0akey\u4ee5\u4e0b\u306e\u56de\u6587\u6570\u306e\u500b\u6570\n\ncnt = 0\n\nfor i in range(10000, 100000):\n\n    L = list(str(i))\n\n    if L == list(reversed(L)):\n\n        cnt += 1\n\n    N[i] = cnt\n\nA, B = list(map(int, input().split()))\n\nprint((N[B]-N[A-1] if A > 10000 else N[B]))","reference_code_col":"A, B =list(map(int, input().split()))\n\nnum_palin = [0] * (B+1)\n\nfor i in range(1,B+1):\n\n    if str(i) == str(i)[::-1]:\n\n        num_palin[i] = num_palin[i-1] + 1\n\n    else:\n\n        num_palin[i] = num_palin[i-1]\n\nprint((num_palin[B]-num_palin[A-1]))\n","model_generated_potentially_faster_code_col":"def count_palindromes(n):\n    # Convert n to string once\n    s = str(n)\n    return s == s[::-1]\n\n# Precompute the cumulative counts of palindromes up to 99999\nmax_value = 99999\npalindrome_counts = [0] * (max_value + 1)\n\ncnt = 0\nfor i in range(10000, max_value + 1):\n    if count_palindromes(i):\n        cnt += 1\n    palindrome_counts[i] = cnt\n\n# Read input\nA, B = map(int, input().split())\n\n# Output the result\nresult = palindrome_counts[B] - (palindrome_counts[A - 1] if A > 10000 else 0)\nprint(result)"}
{"problem_id":"p03835","slow_code_col":"k,s=list(map(int,input().split()))\n\ncnt=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        if 0 <= s-i-j <= k:\n\n            cnt+=1\n\nprint(cnt)","reference_code_col":"k,s=list(map(int,input().split()))\n\na=0\n\nfor i in range(0,k+1):\n\n    for j in range(0,k+1):\n\n        if 0<=s-i-j<=k:\n\n            a+=1\n\nprint(a)","model_generated_potentially_faster_code_col":"k, s = map(int, input().split())\n\ncnt = 0\n\nfor m in range(k + 1):\n    cnt += min(m, k - m) + 1\n\nprint(cnt)"}
{"problem_id":"p03806","slow_code_col":"N,Ma,Mb = list(map(int, input().split()))\n\narr=[list(map(int,input().split())) for _ in range(N)]\n\ndp=[[[5000]*401 for _ in range(401)] for _ in range(41)]\n\ndp[0][0][0] = 0\n\nfor i in range(N):\n\n    a,b,c=arr[i]\n\n    for j in range(10*N+1):\n\n        for k in range(10*N+1):\n\n            if dp[i][j][k] == 5000:\n\n                continue\n\n            dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k])\n\n            dp[i+1][j+a][k+b]=min(dp[i+1][j+a][k+b],dp[i][j][k]+c)\n\n\n\nans=5000\n\nfor i in range(1,401):\n\n        if i*Ma>400 or i*Mb>400:\n\n            break\n\n        ans = min(ans, dp[N][i*Ma][i*Mb])\n\nif ans == 5000:\n\n    print((-1))\n\nelse:\n\n    print(ans)","reference_code_col":"def calc():\n\n    N,Ma,Mb = list(map(int, input().split()))\n\n    arr=[list(map(int,input().split())) for _ in range(N)]\n\n    dp=[[[5000]*401 for _ in range(401)] for _ in range(41)]\n\n    dp[0][0][0] = 0\n\n    for i in range(N):\n\n        a,b,c=arr[i]\n\n        for j in range(10*N+1):\n\n            for k in range(10*N+1):\n\n                if dp[i][j][k] == 5000:\n\n                    continue\n\n                dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k])\n\n                dp[i+1][j+a][k+b]=min(dp[i+1][j+a][k+b],dp[i][j][k]+c)\n\n\n\n    ans=5000\n\n    for i in range(1,401):\n\n            if i*Ma>400 or i*Mb>400:\n\n                break\n\n            ans = min(ans, dp[N][i*Ma][i*Mb])\n\n    if ans == 5000:\n\n        print((-1))\n\n    else:\n\n        print(ans)\n\n\n\ncalc()","model_generated_potentially_faster_code_col":"N, Ma, Mb = map(int, input().split())\n\narr = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Initialize the DP table with infinity\ndp = [[float('inf')] * (10 * N + 1) for _ in range(10 * N + 1)]\ndp[0][0] = 0\n\nfor a, b, c in arr:\n    new_dp = [[float('inf')] * (10 * N + 1) for _ in range(10 * N + 1)]\n    for j in range(10 * N + 1):\n        for k in range(10 * N + 1):\n            if dp[j][k] == float('inf'):\n                continue\n            new_dp[j][k] = min(new_dp[j][k], dp[j][k])\n            if j + a <= 10 * N and k + b <= 10 * N:\n                new_dp[j + a][k + b] = min(new_dp[j + a][k + b], dp[j][k] + c)\n    dp = new_dp\n\nans = float('inf')\nfor i in range(1, 401):\n    if i * Ma > 400 or i * Mb > 400:\n        break\n    if dp[i * Ma][i * Mb] < float('inf'):\n        ans = min(ans, dp[i * Ma][i * Mb])\n\nprint(-1 if ans == float('inf') else ans)"}
{"problem_id":"p03038","slow_code_col":"from heapq import *\n\n\n\n\n\nn, m = list(map(int, input().split()))\n\nPAIRS = [[-a, -1] for a in map(int, input().split())]\n\nheapify(PAIRS)\n\n\n\nfor _ in range(m):\n\n    b, c = list(map(int, input().split()))\n\n    heappush(PAIRS, [-c, -b])\n\n\n\nanswer = 0\n\nfor _ in range(n):\n\n    pair = heappop(PAIRS)\n\n    answer += -pair[0]\n\n    pair[1] += 1\n\n    if pair[1] != 0:\n\n        heappush(PAIRS, pair)\n\n\n\nprint(answer)\n","reference_code_col":"n, m = list(map(int, input().split()))\n\nPAIRS = [(a, 1) for a in map(int, input().split())]\n\n\n\nfor _ in range(m):\n\n    b, c = list(map(int, input().split()))\n\n    PAIRS.append((c, b))\n\nPAIRS.sort(reverse = True)\n\n\n\nanswer, count = 0, 0\n\nfor pair in PAIRS:\n\n    answer += pair[0] * pair[1]\n\n    count += pair[1]\n\n    if count > n:\n\n        answer -= pair[0] * (count - n)\n\n        break\n\n\n\nprint(answer)\n","model_generated_potentially_faster_code_col":"from heapq import *\n\ndef optimize_pairs(n, m, pairs):\n    # Create a dictionary to keep track of the counts of each element\n    count_dict = {}\n    \n    # Initialize the heap with the given pairs\n    for a in pairs:\n        if a not in count_dict:\n            count_dict[a] = 0\n        count_dict[a] += 1\n    \n    # Convert the dictionary to a heap\n    heap = [(-count_dict[a], a) for a in count_dict]\n    heapify(heap)\n    \n    answer = 0\n    \n    for _ in range(n):\n        # Pop the smallest element (with the highest negative count)\n        neg_count, a = heappop(heap)\n        \n        # Add the value of the element to the answer\n        answer -= neg_count\n        \n        # Decrement the count\n        count_dict[a] -= 1\n        \n        # If the count is still positive, push the updated element back into the heap\n        if count_dict[a] > 0:\n            heappush(heap, (-count_dict[a], a))\n    \n    return answer\n\n# Read input\nn, m = map(int, input().split())\npairs = list(map(int, input().split()))\nm_queries = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Process each query\nfor b, c in m_queries:\n    pairs.append(c)\n    print(optimize_pairs(n, len(pairs), pairs))"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nn = int(eval(input()))\n\nans = math.factorial(n) % (pow(10, 9) + 7)\n\nprint(ans)","reference_code_col":"n = int(eval(input()))\n\nans = 1\n\nmod = 10 ** 9 + 7\n\nfor i in range(1, n + 1):\n\n    ans = (ans * i % mod) % mod\n\nprint(ans)","model_generated_potentially_faster_code_col":"import math\n\ndef fact_mod(n, mod):\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % mod\n    return result\n\nn = int(input())\nmod = 10**9 + 7\nans = fact_mod(n, mod)\n\nprint(ans)"}
{"problem_id":"p02596","slow_code_col":"k = int(eval(input()))\n\nx = 1\n\n\n\nif k%7 != 0:\n\n    mod = 9*k\n\nelse:\n\n    mod = 9*k\/\/7\n\n\n\nfor i in range(10**6):\n\n    x = x*10%mod\n\n    if x == 1:\n\n        print((i + 1))\n\n        exit()\n\n\n\nprint((-1))","reference_code_col":"k = int(eval(input()))\n\na = 0\n\n\n\nfor i in range(k + 10):\n\n    a = (a*10 + 7)%k\n\n    if a == 0:\n\n        print((i + 1))\n\n        exit()\n\nprint((-1))","model_generated_potentially_faster_code_col":"import math\n\ndef smallest_power_of_10_mod_m(m):\n    # Find the smallest positive integer n such that 10^n \u2261 1 (mod m)\n    n = 1\n    while True:\n        if pow(10, n, m) == 1:\n            return n\n        n += 1\n\nk = int(eval(input()))\nm = 9 * k \/\/ 7 if k % 7 == 0 else 9 * k\nprint(smallest_power_of_10_mod_m(m))"}
{"problem_id":"p00053","slow_code_col":"import math\n\ndef pri(n):\n\n    if n < 2:\n\n        return False\n\n    elif n == 2:\n\n        return True\n\n    elif n % 2 == 0:\n\n        return False\n\n\n\n    i = 3\n\n    while i <= math.sqrt(n):\n\n        if n % i == 0:\n\n            return False\n\n        i += 2\n\n    return True\n\n\n\nl=[i for i in range(110000)if pri(i) ]\n\n\n\nwhile True:\n\n    n = int(eval(input()))\n\n    if n == 0: break\n\n    print((sum(l[:n])))","reference_code_col":"import math\n\ndef pri(n):\n\n    l =[True] * n\n\n    l[0] = l[1] = False\n\n    for i in range(2,n):\n\n        if l[i]:\n\n            for j in range(i*2, n, i):\n\n                l[j] = False\n\n    return l\n\nn=105000\n\ns=pri(n)\n\nl=[i for i in range(n) if s[i]]\n\nwhile True:\n\n    n = int(eval(input()))\n\n    if n == 0: break\n\n    print((sum(l[:n])))","model_generated_potentially_faster_code_col":"import math\n\n# Function to check if a number is prime\ndef pri(n):\n    if n < 2:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n\n    i = 3\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            return False\n        i += 2\n    return True\n\n# Generate list of prime numbers up to 110000\nprimes = [i for i in range(110001) if pri(i)]\n\n# Pre-calculate sum of primes up to 110000\nsum_primes = sum(primes)\n\n# Main loop to handle user input\nwhile True:\n    n = int(eval(input()))\n    if n == 0:\n        break\n    print(sum_primes)"}
{"problem_id":"p02988","slow_code_col":"n = int(eval(input()))\n\nl = list(map(int, input().split()))\n\nprint((sum(l[i]<l[i+1]<l[i+2] or l[i]>l[i+1]>l[i+2] for i in range(n-2))))","reference_code_col":"n=int(eval(input()))\n\nl=list(map(int,input().split()))\n\na=0\n\nfor i in range(n-2):\n\n  p,q,r=l[i:i+3]\n\n  if p<q<r or r<q<p: a+=1\n\nprint(a)","model_generated_potentially_faster_code_col":"n = int(input())\nl = [int(x) for x in input().split()]\n\ncount = 0\nfor i in range(1, n - 1):\n    if (l[i-1] < l[i] > l[i+1]) or (l[i-1] > l[i] < l[i+1]):\n        count += 1\n\nprint(count)"}
{"problem_id":"p02661","slow_code_col":"from numpy import*\n\na,b=median(t:=loadtxt(open(0),skiprows=1),0)\n\nprint((int((a-b)*~(~len(t)%2))+1))","reference_code_col":"from statistics import*\n\n(n,),*t=[list(map(int,t.split()))for t in open(0)]\n\na,b=list(map(median,list(zip(*t))))\n\nprint((int((b-a)*(2-n%2))+1))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read the data from stdin\ndata = np.loadtxt(np.stdin, skiprows=1)\n\n# Calculate the median along axis 0\nmedians = np.median(data, axis=0)\n\n# Calculate the difference between medians\ndiff = medians[0] - medians[1]\n\n# Determine the result based on the length of the data\nresult = int(diff * (len(data) % 2 != 0)) + 1\n\n# Print the result\nprint(result)"}
{"problem_id":"p04021","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\"\"\"\n\n\u5947\u6570\u756a\u76ee\u96c6\u5408\u3001\u5076\u6570\u756a\u76ee\u96c6\u5408\u306e\u4e2d\u3067\u81ea\u7531\u306b\u3067\u304d\u308b\u306e\u304c\u64cd\u4f5c2\uff0e\n\n\u64cd\u4f5c1\u3067\u96c6\u5408\u9593\u306e\u3084\u308a\u3068\u308a\u3092\u3059\u308b\n\n\"\"\"\n\n\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.fromstring(sys.stdin.read(),dtype=np.int64,sep='\\n')\n\n\n\nB = np.sort(A)\n\n\n\nanswer = len(np.setdiff1d(A[::2],B[::2]))\n\nprint(answer)","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n\"\"\"\n\n\u30fb\u5076\u6570\u756a\u53f7\u3001\u5947\u6570\u756a\u53f7\u306e\u4e2d\u3067\u306f\u5165\u308c\u66ff\u3048\u653e\u984c\n\n\u30fb\u5076\u3001\u5947\u306e\u9593\uff1a\u4e26\u3079\u3066\u304b\u3089\u30b9\u30ef\u30c3\u30d7\u3002\u64cd\u4f5c2\u30921\u56de\u3067\u3001\u6b63\u3057\u3044\u3082\u306e\u30922\u3064\u5897\u3084\u305b\u308b\n\n\"\"\"\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nx_to_i = {x:i for i,x in enumerate(sorted(A))}\n\nrank = [x_to_i[x] for x in A]\n\n\n\nanswer = sum((x^i) & 1 for i,x in enumerate(rank)) \/\/ 2\n\nprint(answer)","model_generated_potentially_faster_code_col":"import sys\nfrom typing import List\n\n\ndef main() -> None:\n    input = sys.stdin.read().split()\n    N: int = int(input.pop(0))\n    A: List[int] = list(map(int, input))\n\n    B: List[int] = sorted(A)\n\n    answer: int = sum(a != b for a, b in zip(A[::2], B[::2]))\n    print(answer)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\n\n\nx = int(eval(input()))\n\ny = input().split()\n\ny = [int(i) for i in y]\n\ny = np.array(y)\n\ncount = 0\n\nwhile sum([y[i] % 2 for i in range(len(y))]) == 0:\n\n    y = y\/2\n\n    count += 1\n\nprint(count)","reference_code_col":"N = int(eval(input()))\n\nA = input().split()\n\nA = [int(i) for i in A]\n\n\n\nc = 0 \n\n\n\nwhile True:\n\n  exist_odd = False\n\n  for a in A:\n\n    if a % 2 != 0:\n\n      exist_odd = True\n\n    \n\n  if exist_odd: break\n\n\n\n  for i in range(N):\n\n    A[i] = A[i] \/ 2\n\n  \n\n  c = c + 1\n\nprint(c)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Get user input and convert it into a NumPy array\ny = np.array(list(map(int, input().split())))\n\ncount = 0\n\n# Continue looping until any element becomes odd\nwhile not (y & 1).any():\n    # Halve all elements in the array using integer division\n    y \/\/= 2\n    count += 1\n\nprint(count)"}
{"problem_id":"p03363","slow_code_col":"N = int(input())\n\nA = list(map(int, input().split()))\n\n\n\nans, s = 0, 0\n\nd = {0:1}\n\n\n\nfor i in A:\n\n    s += i\n\n    ans += d.get(s, 0)\n\n    d[s] = d.get(s, 0) + 1\n\n\n\nprint(ans)","reference_code_col":"#!\/usr\/bin\/env python3\n\n\n\nfrom collections import defaultdict\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nd = defaultdict(int)\n\nd[0] = 1\n\n\n\ns, ans = 0, 0\n\n\n\nfor a in A:\n\n    s += a\n\n    ans += d[s]\n\n    d[s] += 1\n\n\n\nprint (ans)","model_generated_potentially_faster_code_col":"N = int(input())\nA = list(map(int, input().split()))\n\nans, s = 0, 0\nd = {0: 1}\n\nfor i in A:\n    s += i\n    count = d.get(s, 0)\n    ans += count\n    d[s] = count + 1\n\nprint(ans)"}
{"problem_id":"p03162","slow_code_col":"import numpy as np\n\nn=int(eval(input()))\n\nABC=[list(map(int,input().split())) for _ in range(n)]\n\n\n\ndp=np.zeros((n,3),int)\n\nfor i in range(3):\n\n  dp[0][i]=ABC[0][i]\n\nfor i in range(n-1):\n\n  for j in range(3):\n\n    dp[i+1][j]=max(dp[i][(j+1)%3]+ABC[i+1][j], dp[i][(j+2)%3]+ABC[i+1][j])\n\nprint((max(dp[-1])))","reference_code_col":"import numpy as np\n\nn=int(eval(input()))\n\nABC=[list(map(int,input().split())) for _ in range(n)]\n\n\n\ndp=np.zeros((n,3),int)\n\nfor i in range(3):\n\n  dp[0,i]=ABC[0][i]\n\nfor i in range(1,n):\n\n  for j in range(3):\n\n    dp[i,j]=max(dp[i-1,(j+1)%3]+ABC[i][j],dp[i-1,(j+2)%3]+ABC[i][j])\n\nprint((max(dp[-1])))","model_generated_potentially_faster_code_col":"import numpy as np\n\nn = int(eval(input()))\nABC = [list(map(int, input().split())) for _ in range(n)]\n\ndp = np.zeros((n, 3), dtype=int)\ndp[0] = ABC[0]\n\nfor i in range(1, n):\n    dp[i][0] = max(dp[i - 1][1] + ABC[i][0], dp[i - 1][2] + ABC[i][0])\n    dp[i][1] = max(dp[i - 1][0] + ABC[i][1], dp[i - 1][2] + ABC[i][1])\n    dp[i][2] = max(dp[i - 1][0] + ABC[i][2], dp[i - 1][1] + ABC[i][2])\n\nprint(max(dp[-1]))"}
{"problem_id":"p03162","slow_code_col":"N = int(eval(input()))\n\nl = [list(map(int, input().split())) for _ in range(N)]\n\n\n\ndp = [[0 for i in range(3)] for j in range(N+1)]\n\n\n\n\n\nfor i in range(1, N+1):\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j != k:\n\n                dp[i][j] = max(dp[i][j], dp[i-1][k]+l[i-1][k])\n\n\n\nprint((max(dp[N][0], dp[N][1], dp[N][2])))\n\n\n","reference_code_col":"N = int(eval(input()))\n\ndp = [[0 for i in range(3)] for j in range(N+1)]\n\n\n\nfor i in range(1, N+1):\n\n    hapiness = list(map(int, input().split()))\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j != k:\n\n                dp[i][j] = max(dp[i][j], dp[i-1][k] + hapiness[k])\n\n\n\nprint((max(dp[N][0], dp[N][1], dp[N][2])))","model_generated_potentially_faster_code_col":"N = int(eval(input()))\n\n# Read the list of lists directly into l without using eval\nl = [list(map(int, input().split())) for _ in range(N)]\n\n# Initialize dp array with zeros\ndp = [[0 for i in range(3)] for j in range(N+1)]\n\n# Fill the dp array\nfor i in range(1, N+1):\n    for j in range(3):\n        # Instead of iterating over all possible previous trips,\n        # only consider the previous day's maximum profit excluding the current trip type.\n        dp[i][j] = max(dp[i-1]) + l[i-1][j]\n\n# Print the maximum profit among the last day's choices\nprint(max(dp[N]))"}
{"problem_id":"p02899","slow_code_col":"import sys\n\n\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    ans = 0\n\n    n = int(input())\n\n    o = list(map(int, input().split()))\n\n    l = [0]*n\n\n    for i in range(n):\n\n        l[o[i]-1] = i+1\n\n    for i in range(len(l)):\n\n        if  i != len(l)-1:\n\n            print(\"{} \".format(l[i]), end='')\n\n        else:\n\n            print(l[i])\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"import sys\n\n\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    ans = 0\n\n    n = int(eval(input()))\n\n    o = list(map(int, input().split()))\n\n    l = [0]*n\n\n    for i in range(n):\n\n        l[o[i]-1] = i+1\n\n    print((\" \".join(map(str,l))))\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"import sys\n\n\ninput = sys.stdin.readline\n\n\ndef main():\n    ans = 0\n\n    n = int(input())\n    o = list(map(int, input().split()))\n    d = {i: j for j, i in enumerate(o)}\n\n    for i in range(1, n + 1):\n        print(d.get(i, -1), end=\" \")\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02994","slow_code_col":"N,L = list(map(int, input().split()))\n\ntaste = [L+i-1 for i in range(1,N+1)]\n\nif taste[-1] < 0:\n\n  print((sum(taste) + min([abs(x) for x in taste])))\n\nelse:\n\n  print((sum(taste) - min([abs(x) for x in taste])))","reference_code_col":"N, L = list(map(int, input().split()))\n\n\n\ntaste = [L+i-1 for i in range(1, N+1)]\n\n\n\nif 0 in taste:\n\n    select = 0\n\nelse:\n\n    select_with_ind = min(enumerate(taste), key = lambda x: abs(x[1]))\n\n    select = select_with_ind[1]\n\n    \n\nprint((sum(taste) - select))","model_generated_potentially_faster_code_col":"N, L = map(int, input().split())\n\n# Calculate the sum using the formula for the sum of an arithmetic series\nsum_taste = (N * (2 * L + N - 1)) \/\/ 2\n\n# Calculate the minimum absolute value\nmin_abs_value = min(abs(L + i - 1) for i in range(N))\n\n# Add or subtract the minimum absolute value from the sum based on whether the last element is negative or not\nresult = sum_taste + min_abs_value if (L + N - 1) < 0 else sum_taste - min_abs_value\n\nprint(result)"}
{"problem_id":"p03416","slow_code_col":"# ABC090B - Palindromic Numbers\n\na, b = list(map(int, input().rstrip().split()))\n\ncount = 0\n\nfor i in range(a, b + 1):\n\n    lst = list(map(int, list(str(i))))\n\n    if lst[0] == lst[4] and lst[1] == lst[3]:\n\n        count += 1\n\nprint(count)","reference_code_col":"# ABC090B - Palindromic Numbers\n\ndef main():\n\n    a, b = list(map(int, input().rstrip().split()))\n\n    cnt = 0\n\n    for i in range(a, b + 1):\n\n        s = str(i)\n\n        if s == s[::-1]:\n\n            cnt += 1\n\n    print(cnt)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()","model_generated_potentially_faster_code_col":"# ABC090B - Palindromic Numbers\n\na, b = map(int, input().strip().split())\n\ncount = 0\n\ndef is_palindrome(num):\n    str_num = str(num)\n    return str_num == str_num[::-1]\n\nfor num in range(a, b + 1):\n    if is_palindrome(num):\n        count += 1\n\nprint(count)"}
{"problem_id":"p03720","slow_code_col":"n, m = list(map(int, input().split()))\n\ndp = [0] * n\n\nfor i in range(m):\n\n    x, y = list(map(int, input().split()))\n\n    dp[x - 1] += 1\n\n    dp[y - 1] += 1\n\nfor i in range(n):\n\n    print((dp[i]))","reference_code_col":"n, m = list(map(int, input().split()))\n\nA = [0] * n\n\nfor i in range(m):\n\n    a, b = list(map(int, input().split()))\n\n    A[a - 1] += 1\n\n    A[b - 1] += 1\n\n    \n\nfor i in range(n):\n\n    print((A[i]))","model_generated_potentially_faster_code_col":"n, m = map(int, input().split())\n\ndp = [0] * n\n\nfor _ in range(m):\n    x, y = map(int, input().split())\n    dp[x - 1] += 1\n    dp[y - 1] += 1\n\nfor count in dp:\n    print(count)"}
{"problem_id":"p03558","slow_code_col":"import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\n\n\nfrom collections import deque\n\ndef resolve():\n\n    k=int(eval(input()))\n\n    E=[[] for _ in range(k)]\n\n    for i in range(k):\n\n        E[i].append(((i+1)%k,1))\n\n        E[i].append(((10*i)%k,0))\n\n\n\n    # 0-1 BFS\n\n    dist=[INF]*k\n\n    dist[1]=0\n\n    Q=deque([1])\n\n    while(Q):\n\n        v=Q.popleft()\n\n        for nv,w in E[v]:\n\n            if(dist[nv]<=dist[v]+w): continue\n\n            dist[nv]=dist[v]+w\n\n            if(w==0): Q.appendleft(nv)\n\n            else: Q.append(nv)\n\n    print((dist[0]+1))\n\nresolve()","reference_code_col":"import sys\n\nINF = 1 << 60\n\nMOD = 10**9 + 7 # 998244353\n\nsys.setrecursionlimit(2147483647)\n\ninput = lambda:sys.stdin.readline().rstrip()\n\nfrom collections import deque\n\ndef resolve():\n\n    k = int(eval(input()))\n\n    dist = [INF] * k\n\n    dist[1] = 1\n\n    queue = deque([1])\n\n\n\n    while queue:\n\n        v = queue.pop()\n\n        if dist[10 * v % k] > dist[v]:\n\n            dist[10 * v % k] = dist[v]\n\n            queue.appendleft(10 * v % k)\n\n        if dist[(v + 1) % k] > dist[v] + 1:\n\n            dist[(v + 1) % k] = dist[v] + 1\n\n            queue.append((v + 1) % k)\n\n\n\n    print((dist[0]))\n\nresolve()","model_generated_potentially_faster_code_col":"import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF = float(\"inf\")\nMOD = 10**9 + 7\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nfrom collections import deque\n\ndef resolve():\n    k = int(eval(input()))\n    E = [[] for _ in range(k)]\n    for i in range(k):\n        E[i].append(((i+1) % k, 1))\n        E[i].append(((10 * i) % k, 0))\n\n    # 0-1 BFS\n    dist = [INF] * k\n    dist[1] = 0\n    Q = deque([1])\n    while Q:\n        v = Q.popleft()\n        for nv, w in E[v]:\n            if dist[nv] <= dist[v] + w:\n                continue\n            dist[nv] = dist[v] + w\n            if w == 0:\n                Q.appendleft(nv)\n            else:\n                Q.append(nv)\n\n    print((dist[0] + 1))\n\nresolve()"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nn = int(eval(input()))\n\n\n\nprint((math.factorial(n) % (10**9 + 7)))\n","reference_code_col":"n = int(eval(input()))\n\n\n\nans = 1\n\n\n\nfor i in range(1, n+1):\n\n    ans *= i\n\n    ans %= 10**9 + 7\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import math\n\ndef factorial_mod(n):\n    MOD = 10 ** 9 + 7\n    fact = [0] * (n+1)\n    fact[0] = 1\n    for i in range(1,n+1):\n        fact[i] = (fact[i-1]*i)%MOD\n    return fact[n]\n\nn = int(input())\nprint(factorial_mod(n))"}
{"problem_id":"p03839","slow_code_col":"N,K = list(map(int,input().split()))\n\nsrc = list(map(int,input().split()))\n\n\n\ncums = [0]\n\ncump = [0]\n\nfor a in src:\n\n    cums.append(cums[-1] + a)\n\n    cump.append(cump[-1] + max(0,a))\n\n\n\nans = 0\n\nfor i in range(N-K+1):\n\n    tmp = cump[i]\n\n    tmp += max(0, cums[i+K] - cums[i])\n\n    tmp += cump[N] - cump[i+K]\n\n    ans = max(tmp, ans)\n\nprint(ans)\n","reference_code_col":"N,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\ncums = [0]\n\ncums_p = [0]\n\nfor a in A:\n\n    cums.append(cums[-1] + a)\n\n    cums_p.append(cums_p[-1] + max(0,a))\n\n\n\nans = -float('inf')\n\nfor l in range(N-K+1):\n\n    free = cums_p[l] + cums_p[-1] - cums_p[l+K]\n\n    cont = cums[l+K] - cums[l]\n\n    ans = max(ans, free, free+cont)\n\nprint(ans)","model_generated_potentially_faster_code_col":"N, K = map(int, input().split())\nsrc = list(map(int, input().split()))\n\n# Initialize cumulative sums and positive cumulative sums\ncums = [0]\ncump = [0]\n\n# Compute cumulative sums\nfor a in src:\n    cums.append(cums[-1] + a)\n    cump.append(cump[-1] + max(0, a))\n\n# Initialize the answer\nans = 0\n\n# Iterate through possible starting points for the subarray\nfor i in range(N - K + 1):\n    # Calculate the sum of the current subarray\n    subarray_sum = cums[i + K] - cums[i]\n    \n    # Add the maximum positive prefix sum before the subarray\n    prefix_max = cump[i]\n    \n    # Add the maximum positive suffix sum after the subarray\n    suffix_max = cump[-1] - cump[i + K]\n    \n    # Update the answer with the maximum value\n    ans = max(ans, prefix_max + subarray_sum + suffix_max)\n\nprint(ans)"}
{"problem_id":"p03796","slow_code_col":"def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r *= n\n\n        power_r %= 10**9+7\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))","reference_code_col":"def factorial(N):\n\n    power_r = 1\n\n    for n in range(2,N+1):\n\n        power_r = power_r*n % (10**9+7)\n\n    return power_r\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))","model_generated_potentially_faster_code_col":"def factorial(N):\n    MOD = 10**9 + 7\n    \n    result = 1\n    for n in range(2, N + 1):\n        result = (result * n) % MOD\n    \n    return result\n\nif __name__ == '__main__':\n    N = int(input())  # Use input() instead of eval()\n    print(factorial(N))"}
{"problem_id":"p02596","slow_code_col":"import sys\n\nK = int(eval(input()))\n\n\n\npower = 7\n\nSUM = 0\n\n\n\nfor i in range(1, 10 ** 6):\n\n    SUM += power\n\n    if SUM % K == 0:\n\n        print(i)\n\n        sys.exit()\n\n    power *= 10\n\n    power %= K\n\n\n\nprint((-1))","reference_code_col":"import sys\n\nK = int(eval(input()))\n\n\n\nL = 9 * K\n\n\n\nif K % 7 == 0:\n\n    L \/\/= 7\n\n\n\npower = 1\n\n\n\nfor i in range(1, 10 ** 6):\n\n    power *= 10\n\n    power %= L\n\n    if power == 1:\n\n        print(i)\n\n        sys.exit()\n\n\n\nprint((-1))","model_generated_potentially_faster_code_col":"import sys\n\ndef mod_exp(base, exp, mod):\n    result = 1\n    base = base % mod\n    while exp > 0:\n        if (exp & 1) == 1:  # If exp is odd, multiply result with base\n            result = (result * base) % mod\n        exp = exp >> 1  # Divide exp by 2\n        base = (base * base) % mod  # Square the base\n    return result\n\n\nK = int(eval(input()))\n\npower = 7\nSUM = 0\n\ni = 1\nwhile True:\n    SUM = (SUM + power) % K\n    if SUM == 0:\n        print(i)\n        sys.exit()\n    power = mod_exp(10, i+1, K)\n    i += 1\n\nprint((-1))"}
{"problem_id":"p02780","slow_code_col":"import numpy as np\n\nimport sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN, K = list(map(int, readline().split()))\n\nA = np.array(readline().split(), dtype=np.int64) + 1\n\n\n\n\n\nAcum = np.zeros(N+1, np.float64)\n\nAcum[1:] = A.cumsum()\n\n\n\nx = Acum[K:] - Acum[:-K]\n\nprint((x.max()\/2))\n","reference_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 7)\n\nread = sys.stdin.buffer.read \n\ninput = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines  \n\n\n\nfrom itertools import accumulate\n\n\n\nN, K = list(map(int, input().split()))\n\nP = list(map(int, input().split()))\n\nPcum = list(accumulate([0] + [(1+p)\/2 for p in P]))\n\n\n\nans = max(right - left for left, right in zip(Pcum, Pcum[K:]))\n\nprint(ans)  ","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input from standard input\nN, K = map(int, input().split())\nA = np.fromstring(input(), dtype=int, sep=' ') + 1\n\n# Calculate cumulative sums\nAcum = np.cumsum(A)\n\n# Calculate the maximum average subarray sum\nmax_avg = (Acum[N] - Acum[K-1]) \/ K\n\nprint(max_avg)"}
{"problem_id":"p02982","slow_code_col":"import numpy as np\n\nn,d=list(map(int,input().split()))\n\nx=[list(map(int,input().split())) for i in range(n)]\n\ncount=0\n\nfor i in range(n-1):\n\n    for j in range(i+1,n):\n\n        a=np.array(x[i])\n\n        b=np.array(x[j])\n\n        ab=sum(np.power((a-b),2))**0.5\n\n        if ab%1==0:\n\n            count+=1\n\nprint(count)","reference_code_col":"n,d=list(map(int,input().split()))\n\nL=[list(map(int,input().split())) for i in range(n)]\n\nans=0\n\nfor i in range(n-1):\n\n    for j in range(i+1,n):\n\n        a=0\n\n        for k in range(d):\n\n            a+=(L[i][k]-L[j][k])**2\n\n        if int(a**0.5)==a**0.5:\n\n            ans+=1\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Get input values\nn, d = map(int, input().split())\n\n# Read all points into a numpy array\npoints = np.array([tuple(map(int, input().split())) for _ in range(n)])\n\n# Initialize counter\ncount = 0\n\n# Iterate over all pairs of points\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Calculate Euclidean distance between points\n        dist_squared = sum((points[i] - points[j]) ** 2)\n        \n        # Check if distance is integer\n        if np.isclose(dist_squared, int(dist_squared)):\n            count += 1\n\nprint(count)"}
{"problem_id":"p00003","slow_code_col":"for n in range(eval(input())):\n\n  a,b,c=sorted(map(int,input().split()))\n\n  s=\"YES\" if a*a+b*b==c*c else \"NO\"\n\n  print(s)","reference_code_col":"for n in range(eval(input())):\n\n  a,b,c=sorted(map(int,input().split()))\n\n  print(\"YES\" if a*a + b*b == c*c else \"NO\")","model_generated_potentially_faster_code_col":"n = int(input())\n\nfor _ in range(n):\n    a, b, c = sorted(map(int, input().split()))\n    \n    s = \"YES\" if a * a + b * b == c * c else \"NO\"\n    \n    print(s)"}
{"problem_id":"p02821","slow_code_col":"#E\n\nfrom itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=10**10+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)\/\/2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()","reference_code_col":"from itertools import accumulate\n\nfrom bisect import bisect_left\n\ndef main():\n\n    n,m=list(map(int,input().split()))\n\n    A=list(map(int,input().split()))\n\n    A.sort()\n\n    \n\n    def count(k):\n\n        cnt=0\n\n        for a in A:\n\n            cnt+=bisect_left(A,k-a)\n\n        return cnt\n\n    \n\n    ok=0\n\n    ng=2*10**5+1\n\n    while ng-ok>1:\n\n        mid=(ok+ng)\/\/2\n\n        if count(mid)<n**2-m:\n\n            ok=mid\n\n        else:\n\n            ng=mid\n\n    border=ok\n\n    \n\n    k=n**2-count(border)\n\n    Acc=[0]+list(accumulate(A))\n\n    s=Acc[-1]\n\n    ans=0\n\n    for a in A:\n\n        idx=bisect_left(A,border-a)\n\n        ans+=a*(n-idx)+(s-Acc[idx])\n\n    ans-=border*(k-m)\n\n    print(ans)\n\n    \n\nif __name__=='__main__':\n\n    main()","model_generated_potentially_faster_code_col":"from itertools import accumulate\nfrom bisect import bisect_left\n\ndef main():\n    n, m = map(int, input().split())\n    A = sorted(map(int, input().split()))\n    \n    def count(k):\n        cnt = 0\n        i = 0\n        j = len(A) - 1\n        while i < j:\n            if A[i] + A[j] <= k:\n                cnt += j - i\n                i += 1\n            else:\n                j -= 1\n        return cnt\n    \n    low, high = 0, 10**10 + 1\n    while high - low > 1:\n        mid = (low + high) \/\/ 2\n        if count(mid) < n**2 - m:\n            low = mid\n        else:\n            high = mid\n    \n    border = low\n    k = n**2 - count(border)\n    acc = [0] + list(accumulate(A))\n    total_sum = acc[-1]\n    \n    ans = 0\n    for a in A:\n        idx = bisect_left(A, border - a)\n        ans += a * (n - idx) + (total_sum - acc[idx])\n    \n    ans -= border * (k - m)\n    print(ans)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03634","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nn = int(eval(input()))\n\nv = [[0]+[]*(n+1) for i in range(n+1)]\n\nfor i in range(n-1):\n\n    a,b,c = list(map(int,input().split()))\n\n    v[a].append([b,c])\n\n    v[b].append([a,c])\n\n\n\nq,k = list(map(int,input().split()))\n\nl = [k]\n\nwhile l:\n\n    now = l.pop()\n\n    for i in v[now][1:]:\n\n        if v[i[0]][0] == 0:\n\n            v[i[0]][0] = i[1]+v[now][0]\n\n            l.append(i[0])\n\n\n\nfor i in range(q):\n\n    x,y = list(map(int,input().split()))\n\n    print((v[x][0]+v[y][0]))","reference_code_col":"import sys\n\ndef main():\n\n    input = sys.stdin.readline\n\n    n = int(eval(input()))\n\n    v = [[0]+[]*(n+1) for i in range(n+1)]\n\n    for i in range(n-1):\n\n        a,b,c = list(map(int,input().split()))\n\n        v[a].append([b,c])\n\n        v[b].append([a,c])\n\n\n\n    q,k = list(map(int,input().split()))\n\n    l = [k]\n\n    while l:\n\n        now = l.pop()\n\n        for i in v[now][1:]:\n\n            if v[i[0]][0] == 0:\n\n                v[i[0]][0] = i[1]+v[now][0]\n\n                l.append(i[0])\n\n\n\n    for i in range(q):\n\n        x,y = list(map(int,input().split()))\n\n        print((v[x][0]+v[y][0]))\n\n\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"import heapq\nimport sys\n\ninput = sys.stdin.readline\n\nn = int(eval(input()))\nv = [[] for _ in range(n + 1)]\n\nfor _ in range(n - 1):\n    a, b, c = map(int, input().split())\n    v[a].append((b, c))\n    v[b].append((a, c))\n\nq, k = map(int, input().split())\n\ndist = [float('inf')] * (n + 1)\ndist[k] = 0\nheap = [(0, k)]\n\nwhile heap:\n    d, u = heapq.heappop(heap)\n    if d > dist[u]:\n        continue\n    for v, w in v[u]:\n        if dist[u] + w < dist[v]:\n            dist[v] = dist[u] + w\n            heapq.heappush(heap, (dist[v], v))\n\nfor _ in range(q):\n    x, y = map(int, input().split())\n    print(dist[x] + dist[y])"}
{"problem_id":"p02767","slow_code_col":"import numpy as np\n\n\n\nN = int(eval(input()))\n\nX = np.array(list(map(int, input().split())))\n\ncost = float(\"inf\")\n\nfor i in range(max(X) - min(X) + 1):\n\n    p = min(X) + i\n\n    cost = min(np.sum((X - p) ** 2), cost)\n\nprint(cost)","reference_code_col":"N = int(eval(input()))\n\nX = sorted(list(map(int, input().split())))\n\nif N == 1:\n\n    print((0))\n\nelse:\n\n    r = X[-1] - X[0]\n\n    ans = float(\"inf\")\n\n    for i in range(r + 1):\n\n        R = X[0] + i\n\n        hp = 0\n\n        for j in range(N):\n\n            hp = hp + (R - X[j]) ** 2\n\n\n\n        ans = min(hp, ans)\n\n\n\n    print(ans)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(eval(input()))\nX = np.array(list(map(int, input().split())))\n\n# Calculate the mean (which is the optimal p for minimizing the cost)\noptimal_p = np.mean(X)\n\n# Calculate the cost using the optimal p\ncost = np.sum((X - optimal_p) ** 2)\n\nprint(cost)"}
{"problem_id":"p03568","slow_code_col":"from functools import reduce\n\nfrom itertools import product\n\n\n\nN = int(eval(input()))\n\n*A, = list(map(int, input().split()))\n\nans = 0\n\nfor t in product([-1, 0, 1], repeat=N):\n\n    prod = reduce(lambda x, y: x*y, [a + t[i] for i, a in enumerate(A)])\n\n    if prod % 2 == 0: ans += 1\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\n*A, = list(map(int, input().split()))\n\nevens = 0\n\nfor a in A:\n\n    if a % 2 == 0: evens += 1\n\nans = 3**N - 2**evens\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(eval(input()))\nA = list(map(int, input().split()))\n\n# Count the number of odd elements in A\nodd_count = sum(a % 2 != 0 for a in A)\n\n# Calculate the number of tuples with at least one odd element\nans = 3**N - 2**N\n\nprint(ans)"}
{"problem_id":"p02748","slow_code_col":"a, b, m = list(map(int,input().split()))\n\ndr = list(map(int,input().split()))\n\nwa = list(map(int,input().split()))\n\nxyc = [list(map(int,input().split())) for i in range(m)]\n\nlow = 200001\n\n\n\nfor i in range(m):\n\n    f = xyc[i][0] - 1\n\n    d = xyc[i][1] - 1\n\n    if low >= dr[f]+wa[d]-xyc[i][2]:\n\n        low = dr[f]+wa[d]-xyc[i][2]\n\n\n\ndr.sort()\n\nwa.sort()\n\n\n\nif low >= (dr[0] + wa[0]):\n\n    print((dr[0] + wa[0]))\n\nelse:\n\n    print(low)","reference_code_col":"a, b, m = list(map(int,input().split()))\n\nal = list(map(int,input().split()))\n\nbl = list(map(int,input().split()))\n\nlow = min(al)+min(bl)\n\nx = [0] * m\n\ny = [0] * m\n\nc = [0] * m\n\n\n\nfor i in range(m):\n\n    x[i],y[i],c[i] = list(map(int, input().split()))\n\n    x[i] -= 1\n\n    y[i] -= 1\n\n \n\nfor i in range(m):\n\n    low = min(low,al[x[i]]+bl[y[i]]-c[i])\n\n\n\nprint(low)","model_generated_potentially_faster_code_col":"a, b, m = map(int, input().split())\n\ndr = list(map(int, input().split()))\nwa = list(map(int, input().split()))\n\nxyc = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Initialize the lowest value to a very high number\nlow = float('inf')\n\n# Iterate through each point in xyc\nfor f, d, c in xyc:\n    # Calculate the current distance\n    dist = dr[f-1] + wa[d-1] - c\n    # Update the lowest value if the current distance is lower\n    if dist < low:\n        low = dist\n\n# Sort the lists only once before checking the minimum distance\ndr.sort()\nwa.sort()\n\n# Check if the lowest calculated distance is greater than or equal to the sum of the smallest elements in dr and wa\nif low >= (dr[0] + wa[0]):\n    result = dr[0] + wa[0]\nelse:\n    result = low\n\nprint(result)"}
{"problem_id":"p03835","slow_code_col":"K, S = [int(i) for i in input().split()]\n\n\n\nc = 0\n\nfor X in range(K + 1):\n\n    for Y in range(K + 1):\n\n        Z = S - X - Y\n\n        if 0 <= Z <= K:\n\n            c += 1\n\n\n\nprint(c)","reference_code_col":"K, S = [int(i) for i in input().split()]\n\n\n\nans = 0\n\n# X <= Y <= Z\u3068\u3057\u3066\u3082\u4e00\u822c\u6027\u3092\u5931\u308f\u306a\u3044\n\nfor x in range(K + 1):\n\n    for y in range(x, K + 1):\n\n        z = S - x - y\n\n        if z < y:\n\n            break\n\n        if z <= K:\n\n            if x == y == z:\n\n                ans += 1\n\n            elif x == y or y == z or z == x:\n\n                ans += 3\n\n            else:\n\n                ans += 6\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"K, S = map(int, input().split())\n\n# Calculate the number of non-negative integer solutions to X + Y + Z = S where 0 <= X, Y, Z <= K\nif S > 3 * K:\n    # If S is greater than three times K, there are no valid solutions\n    print(0)\nelse:\n    # Use the formula for the number of non-negative integer solutions to a linear equation\n    # The formula is (S + K choose K)\n    from math import comb\n    result = comb(S + K, K)\n    \n    # Subtract the invalid cases where one or more variables exceed K\n    result -= comb(S + K - 1, K) if S >= K else 0\n    result -= comb(S + K - 1, K) if S >= K else 0\n    \n    # Add back the case where two variables exceed K (over-subtracted twice)\n    result += comb(S + K - 2, K) if S >= 2 * K else 0\n    \n    print(result)"}
{"problem_id":"p03126","slow_code_col":"import numpy as np\n\nN, M = list(map(int, input().split()))\n\nmenu = np.array([])\n\nfor i in range(N):\n\n  a = np.array(input().split())\n\n  menu = np.append(menu, a[1:])\n\nmenu = np.array(menu).astype(int).ravel()\n\ncount = 0\n\nfor i in range(1, M+1):\n\n  if np.sum(menu == i) == N:\n\n    count += 1\n\nprint(count)","reference_code_col":"# coding: utf-8\n\nn, m = list(map(int, input().split()))\n\nll = [0] * m\n\nfor i in range(n):\n\n    l = list(map(int, input().split()))\n\n    for j in range(l[0]):\n\n        ll[l[j+1] - 1] += 1\n\nprint((ll.count(max(ll)) if max(ll)==n else 0))","model_generated_potentially_faster_code_col":"import numpy as np\n\nN, M = map(int, input().split())\nmenu = []\n\nfor _ in range(N):\n  menu.extend(list(map(int, input().split()))[1:])\n\nmenu = np.array(menu)\n\nunique_items, counts = np.unique(menu, return_counts=True)\n\nprint((counts == N).sum())"}
{"problem_id":"p02983","slow_code_col":"l, r=list(map(int, input().split()))\n\nif r-l>672:\n\n\tp=0\n\nelse:\n\n\tp=2019\n\n\tfor i in range(l, r):\n\n\t\tfor j in range(i+1, r+1):\n\n\t\t\tp=min(p, (((i%2019)*(j%2019))%2019))\n\n\t\t\tif not p:\n\n\t\t\t\tbreak\n\n\t\tif not p:\n\n\t\t\tbreak\n\nprint(p)","reference_code_col":"l, r=list(map(int, input().split()))\n\nif r-l>672:\n\n\tp=0\n\nelse:\n\n\tp=2019\n\n\tfor i in range(l, r):\n\n\t\tfor j in range(i+1, r+1):\n\n\t\t\tp=min(p, (i*j%2019))\n\n\t\t\tif not p:\n\n\t\t\t\tbreak\n\n\t\tif not p:\n\n\t\t\tbreak\n\nprint(p)","model_generated_potentially_faster_code_col":"l, r = list(map(int, input().split()))\n\nif r - l > 672:\n    p = 0\nelse:\n    p = 2019\n    mod = 2019\n    \n    # Precompute the modulo values for i and j\n    i_mods = [i % mod for i in range(l, r)]\n    j_mods = [j % mod for j in range(l + 1, r + 1)]\n    \n    for i in range(l, r):\n        for j in range(i + 1, r + 1):\n            product_mod = (i_mods[i - l] * j_mods[j - l - 1]) % mod\n            p = min(p, product_mod)\n            \n            if not p:\n                break\n        \n        if not p:\n            break\n\nprint(p)"}
{"problem_id":"p03371","slow_code_col":"a,b,c,x,y = list(map(int,input().split()))\n\nprice = 10**10\n\nfor k in range(10**5+1):\n\n    re = 2*c*k + max(0,x-k)*a + max(0,y-k)*b\n\n    price = min(re,price)\n\nprint(price)","reference_code_col":"a,b,c,x,y = list(map(int,input().split()))\n\na1 = a*x + b*y\n\na2 = max(x,y) * 2*c\n\nif y >= x:\n\n    a3 = 2*c*x + (y-x)*b\n\nelse:\n\n    a3 = 2*c*y + (x-y)*a\n\nprint((min(a1,a2,a3)))","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\n\n# Find the maximum of x and y\noptimal_k = max(x, y)\n\n# Calculate the minimum price using the optimal value of k\nprice = 2 * c * optimal_k + max(0, x - optimal_k) * a + max(0, y - optimal_k) * b\n\nprint(price)"}
{"problem_id":"p04021","slow_code_col":"import numpy as np\n\nN=int(eval(input()))\n\nA=[int(eval(input())) for i in range(N)]\n\nB=list(np.argsort(np.array(A)))\n\nX=[[0,0],[0,0]]\n\nfor i in range(N):\n\n    X[i%2][B[i]%2]+=1\n\nprint((X[0][1]))\n","reference_code_col":"N=int(eval(input()))\n\nA=[int(eval(input())) for i in range(N)]\n\nAT=[(A[i],i) for i in range(N)]\n\nAT.sort()\n\nB=[AT[i][1] for i in range(N)]\n\nX=[[0,0],[0,0]]\n\nfor i in range(N):\n\n    X[i%2][B[i]%2]+=1\n\nY=[X[0][1],X[1][0]]\n\nprint((min(Y)))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read N\nN = int(eval(input()))\n\n# Read A\nA = np.array([int(eval(input())) for _ in range(N)])\n\n# Sort A and get the sorted indices\nsorted_indices = np.argsort(A)\n\n# Initialize X\nX = [[0, 0], [0, 0]]\n\n# Count occurrences based on the sorted indices\nfor i, idx in enumerate(sorted_indices):\n    X[i % 2][idx % 2] += 1\n\n# Print the result\nprint(X[0][1])"}
{"problem_id":"p02996","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\nab = sorted([list(map(int, input().split()))[::-1] for _ in range(n)])\n\n\n\ncnt = 0\n\nfor b, a in ab:\n\n    cnt += a\n\n    if cnt > b:\n\n        print('No')\n\n        break\n\nelse:\n\n    print('Yes')\n","reference_code_col":"n = int(eval(input()))\n\nab = [list(map(int, input().split())) for _ in range(n)]\n\nab = sorted(ab, key=lambda x: x[1])\n\n\n\nt = 0\n\nfor a, b in ab:\n\n    t += a\n\n    if t > b:\n\n        print('No')\n\n        break\n\nelse:\n\n    print('Yes')\n","model_generated_potentially_faster_code_col":"import sys\n\nreadline = sys.stdin.readline\n\n# Read n as an integer\nn = int(readline())\n\n# Read the pairs and sort them based on the second element in descending order\npairs = sorted((map(int, readline().split()) for _ in range(n)), key=lambda x: -x[1])\n\n# Initialize the count\ncount = 0\n\n# Check the condition\nfor second, first in pairs:\n    count += first\n    if count > second:\n        print('No')\n        break\nelse:\n    print('Yes')"}
{"problem_id":"p03828","slow_code_col":"from collections import Counter\n\nN = int(eval(input()))\n\ndiv = []\n\nfor i in range(2,N+1):\n\n    while i != 1:\n\n        for d in range(2,i+1):\n\n            while i%d==0:\n\n                i = i\/\/d\n\n                div.append(d)\n\nC = Counter(div).most_common()\n\nAns = 1\n\nfor k,v in C:\n\n    Ans = Ans*(v+1) % (10**9+7)\n\n\n\nprint(Ans)\n","reference_code_col":"from collections import defaultdict\n\nN = int(eval(input()))\n\n\n\nF = [True]*(N+1)\n\nF[0]=F[1]=False\n\nP = []\n\n\n\nfor i in range(2,N+1):\n\n    if F[i]==True:\n\n        P.append(i)\n\n        for j in range(i*2,N+1,i):\n\n            F[j]=False\n\n\n\ndic = defaultdict(int)\n\nfor i in range(2,N+1):\n\n    for p in P:\n\n        while i%p==0:\n\n            dic[p] += 1\n\n            i = i\/\/p\n\n        if i==1:\n\n            break\n\n\n\nans = 1\n\nmodulo = 10**9+7\n\nfor v in list(dic.values()):\n\n    ans *= (v+1)\n\n    ans %= modulo\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"from collections import defaultdict\n\nN = int(input())\n\n# Create a list to store the smallest prime factors of all numbers up to N\nsmallest_prime_factors = [i for i in range(N + 1)]\n\n# Use the Sieve of Eratosthenes algorithm to find the smallest prime factors\nfor i in range(2, int(N ** 0.5) + 1):\n    if smallest_prime_factors[i] == i:  # i is a prime number\n        for j in range(i * i, N + 1, i):\n            if smallest_prime_factors[j] > i:  # i is the smallest prime factor of j\n                smallest_prime_factors[j] = i\n\n# Count the occurrences of each prime factor\nprime_count = defaultdict(int)\nfor i in range(2, N + 1):\n    while i > 1:\n        prime_count[smallest_prime_factors[i]] += 1\n        i \/\/= smallest_prime_factors[i]\n\n# Calculate the answer using the formula (p1^e1 + 1)(p2^e2 + 1)...(pk^ek + 1) mod (10^9 + 7)\nans = 1\nmod = 10 ** 9 + 7\nfor count in prime_count.values():\n    ans = ans * (count + 1) % mod\n\nprint(ans)"}
{"problem_id":"p02245","slow_code_col":"from collections import deque\n\nfrom copy import deepcopy, copy\n\ndy = [-1, 0, 0, 1]\n\ndx = [0, -1, 1, 0]\n\nN = 3\n\ndef g(i, j, a):\n\n    t = a \/\/ (10 ** j) % 10\n\n    return a - t * (10 ** j) + t * (10 ** i)\n\ndef MAIN():\n\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    start = 8 - MAP.find(\"0\")\n\n    MAP = int(MAP)\n\n    goal = ('1', '2', '3', '4', '5', '6', '7', '8', '0')\n\n    goal = 123456780\n\n    dp = deque([(0, start, MAP)])\n\n    LOG = {MAP}\n\n    while dp:\n\n        cnt, yx, M = dp.popleft()\n\n        if M == goal:\n\n            print(cnt)\n\n            break\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            CM = g(yx, nyx, M)\n\n            if not CM in LOG:\n\n                dp.append((cnt, nyx, CM))\n\n                LOG.add(CM)\n\nMAIN()\n\n\n","reference_code_col":"from collections import deque\n\nfrom copy import deepcopy, copy\n\nN = 3\n\ndef g(i, j, a):\n\n    if i > j:\n\n        i, j = j, i\n\n    return a[:i] + a[j] + a[i + 1:j] + a[i] + a[j + 1:]\n\ndef MAIN():\n\n    m = {8:{7, 5}, 7:{8, 6, 4}, 6:{7, 3}, 5:{8, 4, 2}, 4:{7, 5, 3, 1}, 3:{6, 4, 0}, 2:{5, 1}, 1:{4, 2, 0}, 0:{3, 1}}\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    start = MAP.find(\"0\")\n\n    goal = \"123456780\"\n\n    dp = deque([(0, start, MAP)])\n\n    LOG = {MAP}\n\n    while dp:\n\n        cnt, yx, M = dp.popleft()\n\n        if M == goal:\n\n            print(cnt)\n\n            break\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            CM = g(yx, nyx, M)\n\n            if not CM in LOG:\n\n                dp.append((cnt, nyx, CM))\n\n                LOG.add(CM)\n\nMAIN()\n\n\n","model_generated_potentially_faster_code_col":"from collections import deque\n\ndy = [-1, 0, 0, 1]\ndx = [0, -1, 1, 0]\nN = 3\n\ndef g(i, j, a):\n    t = a \/\/ (10 ** j) % 10\n    return a - t * (10 ** j) + t * (10 ** i)\n\ndef find_zero_position(MAP):\n    return MAP.index('0')\n\ndef find_moves(m, yx):\n    return m[yx]\n\ndef MAIN():\n    m = {8: {7, 5}, 7: {8, 6, 4}, 6: {7, 3}, 5: {8, 4, 2}, 4: {7, 5, 3, 1}, 3: {6, 4, 0}, 2: {5, 1}, 1: {4, 2, 0}, 0: {3, 1}}\n    \n    MAP = input().replace(\" \", \"\")\n    start = find_zero_position(MAP)\n    MAP = int(MAP)\n    \n    goal_str = '123456780'\n    goal = int(goal_str)\n    \n    dp = deque([(0, start, MAP)])\n    visited = set([MAP])\n    \n    while dp:\n        cnt, yx, M = dp.popleft()\n        \n        if M == goal:\n            print(cnt)\n            break\n        \n        cnt += 1\n        \n        for nyx in find_moves(m, yx):\n            CM = g(yx, nyx, M)\n            \n            if CM not in visited:\n                dp.append((cnt, nyx, CM))\n                visited.add(CM)\n\nif __name__ == \"__main__\":\n    MAIN()"}
{"problem_id":"p03416","slow_code_col":"# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        s = str(i)\n\n        r = \"\".join(reversed(list(s)))\n\n        if s == r:\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"# vim: fileencoding=utf-8\n\n\n\n\n\ndef main():\n\n    a, b = list(map(int, input().split()))\n\n    c = 0\n\n    for i in range(a, b + 1):\n\n        #     s = str(i)\n\n        #     r = \"\".join(reversed(list(s)))\n\n        #     if s == r:\n\n        #         c += 1\n\n        if (i % 10) == (i \/\/ 10000 % 10) and (i \/\/ 10 % 10) == (i \/\/ 1000 % 10):\n\n            c += 1\n\n    print(c)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    a, b = map(int, input().split())\n    \n    def is_palindrome(num):\n        num_str = str(num)\n        return all(num_str[i] == num_str[-i - 1] for i in range(len(num_str) \/\/ 2))\n    \n    count = sum(is_palindrome(i) for i in range(a, b + 1))\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03371","slow_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = float('inf')\n\n\n\nfor i in range(10 ** 5 + 1):\n\n    ans = min(ans, A * max(X - i, 0) + B * max(Y - i, 0) + 2 * C * i)\n\nprint(ans)","reference_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n# ans = float('inf')\n\n\n\n# for i in range(10 ** 5 + 1):\n\n#     ans = min(ans, A * max(X - i, 0) + B * max(Y - i, 0) + 2 * C * i)\n\n# print(ans)\n\n\n\nmin_xy = min(X, Y)\n\nmax_xy = max(X, Y)\n\nans1 = 2 * C * min_xy + A * (X - min_xy) + B * (Y - min_xy)\n\nans2 = A * X + B * Y\n\nans3 = 2 * C * max_xy\n\nprint((min(ans1, ans2, ans3)))","model_generated_potentially_faster_code_col":"A, B, C, X, Y = map(int, input().split())\n\n# Calculate the cost at i = min(X, Y)\ni_min = min(X, Y)\ncost_at_i_min = A * (X - i_min) + B * (Y - i_min) + 2 * C * i_min\n\n# Calculate the cost at i = min(X, Y) + 1\ncost_at_next_i = 2 * C * (i_min + 1)\n\n# The minimum of these two costs is the answer\nans = min(cost_at_i_min, cost_at_next_i)\n\nprint(ans)"}
{"problem_id":"p02555","slow_code_col":"def getN():\n\n    return int(eval(input()))\n\ndef getNM():\n\n    return list(map(int, input().split()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\ndef getArray(intn):\n\n    return [int(eval(input())) for i in range(intn)]\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\ndef rand_N(ran1, ran2):\n\n    return random.randint(ran1, ran2)\n\ndef rand_List(ran1, ran2, rantime):\n\n    return [random.randint(ran1, ran2) for i in range(rantime)]\n\ndef rand_ints_nodup(ran1, ran2, rantime):\n\n  ns = []\n\n  while len(ns) < rantime:\n\n    n = random.randint(ran1, ran2)\n\n    if not n in ns:\n\n      ns.append(n)\n\n  return sorted(ns)\n\n\n\ndef rand_query(ran1, ran2, rantime):\n\n  r_query = []\n\n  while len(r_query) < rantime:\n\n    n_q = rand_ints_nodup(ran1, ran2, 2)\n\n    if not n_q in r_query:\n\n      r_query.append(n_q)\n\n  return sorted(r_query)\n\n\n\nfrom collections import defaultdict, deque, Counter\n\nfrom sys import exit\n\nfrom decimal import *\n\nfrom heapq import heapify, heappop, heappush\n\nimport math\n\nimport random\n\nimport string\n\nfrom copy import deepcopy\n\nfrom itertools import combinations, permutations, product\n\nfrom operator import mul, itemgetter\n\nfrom functools import reduce\n\nfrom bisect import bisect_left, bisect_right\n\n\n\nimport sys\n\nsys.setrecursionlimit(1000000000)\n\nmod = 10 ** 9 + 7\n\n\n\n#############\n\n# Main Code #\n\n#############\n\n\n\nS = getN()\n\n\n\n# \u9006\u5143\u4e8b\u524d\u51e6\u7406ver\n\n# n\u304c\u5c0f\u3055\u3044\u5834\u5408\u306b\n\nlim = 10 ** 5 + 1\n\nfact = [1, 1]\n\nfactinv = [1, 1]\n\ninv = [0, 1]\n\n\n\nfor i in range(2, lim + 1):\n\n    fact.append((fact[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod \/\/ i)) % mod)\n\n    # \u7d2f\u8a08\n\n    factinv.append((factinv[-1] * inv[-1]) % mod)\n\n\n\ndef cmb(n, r):\n\n    if (r < 0) or (n < r):\n\n        return 0\n\n    r = min(r, n - r)\n\n    return fact[n] * factinv[r] * factinv[n - r] % mod\n\n\n\nans = 0\n\n# \u9577\u3055N\u306e\u6642\u6700\u4f4e\u3067\u30823 * N\u4f7f\u3046\n\n# \u6b8b\u308a\u306f\u5206\u914d\u3059\u308b\n\nfor i in range(1, 2001):\n\n    s = S - (3 * i)\n\n    if s < 0:\n\n        break\n\n    # s\u3092N\u500b\u306b\u5206\u914d\u3059\u308b\u901a\u308a\u304c\u3044\u304f\u3064\u3042\u308b\u304b\n\n    # \u91cd\u8907\u7d44\u307f\u5408\u308f\u305b\n\n    # \u4ed5\u5207\u308a\u306e\u6570\u306fi - 1\u500b\n\n    ans += cmb(s + i - 1, i - 1)\n\nprint((ans % mod))","reference_code_col":"def getN():\n\n    return int(eval(input()))\n\ndef getNM():\n\n    return list(map(int, input().split()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\ndef getArray(intn):\n\n    return [int(eval(input())) for i in range(intn)]\n\ndef input():\n\n    return sys.stdin.readline().rstrip()\n\ndef rand_N(ran1, ran2):\n\n    return random.randint(ran1, ran2)\n\ndef rand_List(ran1, ran2, rantime):\n\n    return [random.randint(ran1, ran2) for i in range(rantime)]\n\ndef rand_ints_nodup(ran1, ran2, rantime):\n\n  ns = []\n\n  while len(ns) < rantime:\n\n    n = random.randint(ran1, ran2)\n\n    if not n in ns:\n\n      ns.append(n)\n\n  return sorted(ns)\n\n\n\ndef rand_query(ran1, ran2, rantime):\n\n  r_query = []\n\n  while len(r_query) < rantime:\n\n    n_q = rand_ints_nodup(ran1, ran2, 2)\n\n    if not n_q in r_query:\n\n      r_query.append(n_q)\n\n  return sorted(r_query)\n\n\n\nfrom collections import defaultdict, deque, Counter\n\nfrom sys import exit\n\nfrom decimal import *\n\nfrom heapq import heapify, heappop, heappush\n\nimport math\n\nimport random\n\nimport string\n\nfrom copy import deepcopy\n\nfrom itertools import combinations, permutations, product\n\nfrom operator import mul, itemgetter\n\nfrom functools import reduce\n\nfrom bisect import bisect_left, bisect_right\n\n\n\nimport sys\n\nsys.setrecursionlimit(1000000000)\n\nmod = 10 ** 9 + 7\n\n\n\n#############\n\n# Main Code #\n\n#############\n\n\n\nN = getN()\n\nlogk = N.bit_length()\n\n\n\n# \u6f38\u5316\u5f0f\u306b\u3067\u304d\u308b\u306a\u3089\u884c\u5217\u8a08\u7b97\u306b\u843d\u3068\u3057\u8fbc\u3081\u308b\n\n# A[n] = A[n - 1] + A[n - 3]\u306a\u306e\u3067\n\n# [a2, a1, a0] = [0, 0, 1]\n\n# [[1, 1, 0], [0, 0, 1], [1, 0, 0]]\u306eN\u4e57\u3092\u3059\u308c\u3070\n\n# [an+2, an+1, an] \u304c\u51fa\u308b\n\n\n\ndp = [[[0, 0, 0] for i in range(3)] for i in range(logk)]\n\ndp[0] = [\n\n[1, 1, 0],\n\n[0, 0, 1],\n\n[1, 0, 0]\n\n]\n\n\n\n# \u884c\u5217\u639b\u3051\u7b97 O(n3)\u304b\u304b\u308b\n\ndef array_cnt(ar1, ar2):\n\n    h = len(ar1)\n\n    w = len(ar2[0])\n\n    row = ar1\n\n    col = []\n\n    for j in range(w):\n\n        opt = []\n\n        for i in range(len(ar2)):\n\n            opt.append(ar2[i][j])\n\n        col.append(opt)\n\n\n\n    res = [[[0, 0] for i in range(w)] for i in range(h)]\n\n    for i in range(h):\n\n        for j in range(w):\n\n            cnt = 0\n\n            for x, y in zip(row[i], col[j]):\n\n                cnt += x * y\n\n            res[i][j] = cnt\n\n            res[i][j] %= mod\n\n    return res\n\n\n\nfor i in range(1, logk):\n\n    dp[i] = array_cnt(dp[i - 1], dp[i - 1])\n\n\n\nans = [[0, 0, 1]]\n\nfor i in range(logk):\n\n    if N & (1 << i):\n\n        ans = array_cnt(ans, dp[i])\n\nprint((ans[0][2] % mod))","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\n\ndef comb(n, k):\n    \"\"\"Calculate combination C(n, k) modulo MOD.\"\"\"\n    if k > n:\n        return 0\n    res = 1\n    for i in range(k):\n        res = res * (n - i) * pow(i + 1, MOD - 2, MOD) % MOD\n    return res\n\n\nS = int(input())\nans = 0\n\n# Iterate over possible values of N\nfor N in range(1, S \/\/ 3 + 1):\n    remaining = S - 3 * N\n    if remaining >= 0:\n        # Calculate the number of ways to distribute remaining items\n        ans += comb(remaining + N - 1, N - 1)\n        ans %= MOD\n\nprint(ans)"}
{"problem_id":"p03037","slow_code_col":"k,m=list(map(int,input().split()))\n\nl=[0 for i in range(k+1)]\n\nfor i in range(m):\n\n  a,s=list(map(int,input().split()))\n\n  l[a-1]+=1;l[s]-=1\n\nans=0\n\nf=0\n\nfor j in range(k):\n\n  l[j]+=f\n\n  f=l[j]\n\nprint((len([1 for i in l if i==m])))","reference_code_col":"n,m=list(map(int,input().split()))\n\ntable=[0]*(n+2)\n\nfor i in range(m):\n\n    l,r=list(map(int,input().split()))\n\n    table[l]+=1\n\n    table[r+1]-=1\n\nfrom itertools import accumulate\n\nfrom collections import Counter as co\n\nvar=co((accumulate(table)))\n\n\n\nif m not in var:print((0))\n\nelse:print((var[m]))\n\n\n\n\n","model_generated_potentially_faster_code_col":"k, m = map(int, input().split())\na, s = [0] * (k + 2)\n\nfor _ in range(m):\n    x, y = map(int, input().split())\n    a[x] += 1\n    a[y + 1] -= 1\n\nfor i in range(1, k + 2):\n    a[i] += a[i - 1]\n\ncount = a.count(m)\nprint(count)"}
{"problem_id":"p02982","slow_code_col":"import numpy as np\n\n\n\nN, D = list(map(int, input().split()))\n\npoints = [list(map(int, input().split())) for _ in range(N)]\n\ncount = 0\n\nfor i in range(N):\n\n    for j in range(N):\n\n        if j == i:\n\n            continue\n\n        dist = np.sqrt(sum([(points[i][d] - points[j][d]) ** 2 for d in range(D)]))\n\n        if dist.is_integer():\n\n            count += 1\n\nprint((count \/\/ 2))","reference_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n\n\n\n\ndef calc_dist(x, y):\n\n    dist = 0\n\n    for xi, yi in zip(x, y):\n\n        dist += (yi - xi) ** 2\n\n    return dist ** (1\/2)\n\n\n\n\n\ndef main():\n\n    N, D = list(map(int, sys.stdin.readline().rstrip().split()))\n\n    X = [list(map(int, sys.stdin.readline().rstrip().split())) for _ in range(N)]\n\n\n\n    ans = 0\n\n    for i in range(N):\n\n        for j in range(i+1, N):\n\n            dist = calc_dist(X[i], X[j])\n\n            if dist.is_integer():\n\n                ans += 1\n\n    \n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"import numpy as np\n\n\nN, D = map(int, input().split())\n\npoints = np.array([map(int, input().split()) for _ in range(N)])\n\ndistances = np.sqrt(np.sum((points[:, np.newaxis, :] - points[np.newaxis, :, :])**2, axis=2))\n\nis_integer = np.isclose(distances, distances.astype(int), atol=1e-6)\n\ncount = np.sum(is_integer & (np.triu(is_integer) != 1).astype(bool))\n\nprint(count)"}
{"problem_id":"p02983","slow_code_col":"def abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    # \u533a\u9593\u306e\u5e45\u304c673\u3042\u308c\u3070\u3001673\u306e\u500d\u6570\u30683\u306e\u500d\u6570\u304c\u542b\u307e\u308c\u3066\u30012019\u306e\u500d\u6570\u304c\u4f5c\u308c\u308b\n\n    if R - L > 673: return 0\n\n    # \u305d\u308c\u4ee5\u5916\u306f\u8a66\u3059\n\n    ans = 2019\n\n    for i in range(L, R+1):\n\n        for j in range(L, i):\n\n            m = i * j % 2019\n\n            ans = min(m, ans)\n\n    return ans\n\n\n\nprint((abc133_c()))","reference_code_col":"def abc133_c():\n\n    L, R = list(map(int, input().split()))\n\n    # \u533a\u9593\u306e\u5e45\u304c673\u3042\u308c\u3070\u3001673\u306e\u500d\u6570\u30683\u306e\u500d\u6570\u304c\u542b\u307e\u308c\u3066\u30012019\u306e\u500d\u6570\u304c\u4f5c\u308c\u308b\n\n    if R - L > 673: return 0\n\n    # \u305d\u308c\u4ee5\u5916\u306f\u8a66\u3059\n\n    ans = 2019\n\n    for i in range(L, R+1):\n\n        for j in range(L, i):\n\n            m = i * j % 2019\n\n            ans = min(m, ans)\n\n            if ans == 1: return 1\n\n    return ans\n\n\n\nprint((abc133_c()))","model_generated_potentially_faster_code_col":"def abc133_c():\n    L, R = map(int, input().split())\n\n    remainders = [-1] * 2019\n\n    for i in range(1, 2019):\n        for j in range(i, R + 1, i):\n            if remainders[j % 2019] == -1:\n                remainders[j % 2019] = j\n\n    return min(remainders[L % 2019] if remainders[L % 2019] <= R else float('inf'), 2019)\n\nprint(abc133_c())"}
{"problem_id":"p02792","slow_code_col":"N = int(eval(input()))\n\ncount = [[0 for _ in range(9)] for _ in range(9)]\n\nfor i in range(1, N + 1):\n\n    if str(i)[0] != \"0\" and str(i)[-1] != \"0\":\n\n        count[int(str(i)[0]) - 1][int(str(i)[-1]) - 1] += 1\n\nans = 0\n\nfor i in range(0, 9):\n\n    for k in range(0, 9):\n\n        ans += count[i][k] * count[k][i]\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nnums = [0 for i in range(100)]\n\nfor i in range(1, N + 1):\n\n    i = str(i)\n\n    nums[int(i[0] + i[-1])] += 1\n\nans = 0\n\nfor i in range(1, 10):\n\n    for j in range(i, 10):\n\n        i = str(i)\n\n        j = str(j)\n\n        if i != j:\n\n            ans += nums[int(i + j)] * nums[int(j + i)] * 2\n\n        else:\n\n            n = nums[int(i + j)]\n\n            ans += n * (n - 1)\n\n            ans += n\n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read input directly as an integer\nN = int(input())\n\n# Initialize count matrix\ncount = [[0 for _ in range(9)] for _ in range(9)]\n\n# Precompute the first and last digits for each number from 1 to N\nfirst_digit = [0] * (N + 1)\nlast_digit = [0] * (N + 1)\n\nfor i in range(1, N + 1):\n    str_i = str(i)\n    first_digit[i] = int(str_i[0])\n    last_digit[i] = int(str_i[-1])\n\n# Fill the count matrix\nfor i in range(1, N + 1):\n    if first_digit[i] != 0 and last_digit[i] != 0:\n        count[first_digit[i] - 1][last_digit[i] - 1] += 1\n\n# Calculate the answer\nans = 0\nfor i in range(0, 9):\n    for k in range(0, 9):\n        ans += count[i][k] * count[k][i]\n\nprint(ans)"}
{"problem_id":"p03078","slow_code_col":"# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x \/\/ y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nMOD = 10 ** 9 + 7\n\n\n\nX,Y,Z,K=MAP()\n\nA=sorted(LIST(), reverse=True)\n\nB=sorted(LIST(), reverse=True)\n\nC=sorted(LIST(), reverse=True)\n\n\n\nABC=[]\n\nfor i in range(X):\n\n    for j in range(Y):\n\n        if (i+1)*(j+1)>K:\n\n            break\n\n        for k in range(Z):\n\n            if (i+1)*(j+1)*(k+1)>K:\n\n                break\n\n            ABC.append(A[i]+B[j]+C[k])\n\nABC.sort(reverse=True)\n\nfor i in range(K):\n\n    print((ABC[i]))\n\n\n","reference_code_col":"# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\nfrom heapq import heappush, heappop\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x \/\/ y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(): return list(map(int, input().split()))\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nMOD = 10 ** 9 + 7\n\n\n\nX,Y,Z,K=MAP()\n\nA=sorted(LIST(), reverse=True)\n\nB=sorted(LIST(), reverse=True)\n\nC=sorted(LIST(), reverse=True)\n\n\n\n\n\nque=[]\n\nheappush(que, (-(A[0]+B[0]+C[0]), 0, 0, 0))\n\nS={(0,0,0)}\n\nfor i in range(K):\n\n    ans=heappop(que)\n\n    print((-ans[0]))\n\n    a,b,c=ans[1:]\n\n    if a+1<X and (a+1,b,c) not in S:\n\n        heappush(que, (-(A[a+1]+B[b]+C[c]), a+1, b, c))\n\n        S.add((a+1,b,c))\n\n    if b+1<Y and (a,b+1,c) not in S:\n\n        heappush(que, (-(A[a]+B[b+1]+C[c]), a, b+1, c))\n\n        S.add((a,b+1,c))\n\n    if c+1<Z and (a,b,c+1) not in S:\n\n        heappush(que, (-(A[a]+B[b]+C[c+1]), a, b, c+1))\n\n        S.add((a,b,c+1))\n","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x \/\/ y))\ndef INT(): return int(eval(input()))\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nX, Y, Z, K = MAP()\nA = sorted(LIST(), reverse=True)\nB = sorted(LIST(), reverse=True)\nC = sorted(LIST(), reverse=True)\n\nABC = []\nfor i in range(min(X, K)):\n    for j in range(min(Y, K \/\/ (i + 1))):\n        if (i + 1) * (j + 1) > K:\n            break\n        for k in range(min(Z, K \/\/ ((i + 1) * (j + 1)))):\n            if (i + 1) * (j + 1) * (k + 1) > K:\n                break\n            ABC.append(A[i] + B[j] + C[k])\n\nABC.sort(reverse=True)\nfor i in range(K):\n    print(ABC[i])"}
{"problem_id":"p02560","slow_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nINF = 10 ** 9 + 1  # sys.maxsize # float(\"inf\")\n\nMOD = 10 ** 9 + 7\n\n\n\n\n\ndef floor_sum(n, m, a, b):\n\n    ret = 0\n\n    if a >= m:\n\n        ret += (n - 1) * n * (a \/\/ m) \/\/ 2\n\n        a %= m\n\n    if b >= m:\n\n        ret += n * (b \/\/ m)\n\n        b %= m\n\n    y_max = (a * n + b) \/\/ m\n\n    x_max = y_max * m - b\n\n    if y_max == 0:\n\n        return ret\n\n    ret += (n - (x_max + a - 1) \/\/ a) * y_max\n\n    ret += floor_sum(y_max, a, m, (a - x_max % a) % a)\n\n    return ret\n\n\n\n\n\ndef debug(*x):\n\n    print(*x, file=sys.stderr)\n\n\n\n\n\ndef solve(SOLVE_PARAMS):\n\n    pass\n\n\n\n\n\ndef main():\n\n    # parse input\n\n    T = int(input())\n\n    for _t in range(T):\n\n        N, M, A, B = map(int, input().split())\n\n        print(floor_sum(N, M, A, B))\n\n\n\n\n\n# tests\n\nT1 = \"\"\"\n\n5\n\n4 10 6 3\n\n6 5 4 3\n\n1 1 0 0\n\n31415 92653 58979 32384\n\n1000000000 1000000000 999999999 999999999\n\n\"\"\"\n\nTEST_T1 = \"\"\"\n\n>>> as_input(T1)\n\n>>> main()\n\n3\n\n13\n\n0\n\n314095480\n\n499999999500000000\n\n\"\"\"\n\n\n\n\n\ndef _test():\n\n    import doctest\n\n    doctest.testmod()\n\n    g = globals()\n\n    for k in sorted(g):\n\n        if k.startswith(\"TEST_\"):\n\n            doctest.run_docstring_examples(g[k], g, name=k)\n\n\n\n\n\ndef as_input(s):\n\n    \"use in test, use given string as input file\"\n\n    import io\n\n    f = io.StringIO(s.strip())\n\n    g = globals()\n\n    g[\"input\"] = lambda: bytes(f.readline(), \"ascii\")\n\n    g[\"read\"] = lambda: bytes(f.read(), \"ascii\")\n\n\n\n\n\ninput = sys.stdin.buffer.readline\n\nread = sys.stdin.buffer.read\n\n\n\nif sys.argv[-1] == \"-t\":\n\n    print(\"testing\")\n\n    _test()\n\n    sys.exit()\n\n\n\nmain()\n","reference_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nINF = 10 ** 9 + 1  # sys.maxsize # float(\"inf\")\n\nMOD = 10 ** 9 + 7\n\n\n\n\n\ndef floor_sum_1(n, m, a, b):\n\n    ret = 0\n\n    if a >= m:\n\n        ret += (n - 1) * n * (a \/\/ m) \/\/ 2\n\n        a %= m\n\n    if b >= m:\n\n        ret += n * (b \/\/ m)\n\n        b %= m\n\n    y_max = (a * n + b) \/\/ m\n\n    x_max = y_max * m - b\n\n    if y_max == 0:\n\n        return ret\n\n    ret += (n - (x_max + a - 1) \/\/ a) * y_max\n\n    ret += floor_sum(y_max, a, m, (a - x_max % a) % a)\n\n    return ret\n\n\n\n\n\ndef floor_sum(n, m, a, b):\n\n    ret = 0\n\n    while True:\n\n        if a >= m:\n\n            ret += (n - 1) * n * (a \/\/ m) \/\/ 2\n\n            a %= m\n\n        if b >= m:\n\n            ret += n * (b \/\/ m)\n\n            b %= m\n\n        y_max = (a * n + b) \/\/ m\n\n        x_max = y_max * m - b\n\n        if y_max == 0:\n\n            return ret\n\n        ret += (n - (x_max + a - 1) \/\/ a) * y_max\n\n        n = y_max\n\n        m, a, b = a, m, (a - x_max % a) % a\n\n\n\n\n\ndef debug(*x):\n\n    print(*x, file=sys.stderr)\n\n\n\n\n\ndef solve(SOLVE_PARAMS):\n\n    pass\n\n\n\n\n\ndef main():\n\n    # parse input\n\n    T = int(input())\n\n    for _t in range(T):\n\n        N, M, A, B = map(int, input().split())\n\n        print(floor_sum(N, M, A, B))\n\n\n\n\n\n# tests\n\nT1 = \"\"\"\n\n5\n\n4 10 6 3\n\n6 5 4 3\n\n1 1 0 0\n\n31415 92653 58979 32384\n\n1000000000 1000000000 999999999 999999999\n\n\"\"\"\n\nTEST_T1 = \"\"\"\n\n>>> as_input(T1)\n\n>>> main()\n\n3\n\n13\n\n0\n\n314095480\n\n499999999500000000\n\n\"\"\"\n\n\n\n\n\ndef _test():\n\n    import doctest\n\n    doctest.testmod()\n\n    g = globals()\n\n    for k in sorted(g):\n\n        if k.startswith(\"TEST_\"):\n\n            doctest.run_docstring_examples(g[k], g, name=k)\n\n\n\n\n\ndef as_input(s):\n\n    \"use in test, use given string as input file\"\n\n    import io\n\n    f = io.StringIO(s.strip())\n\n    g = globals()\n\n    g[\"input\"] = lambda: bytes(f.readline(), \"ascii\")\n\n    g[\"read\"] = lambda: bytes(f.read(), \"ascii\")\n\n\n\n\n\ninput = sys.stdin.buffer.readline\n\nread = sys.stdin.buffer.read\n\n\n\nif sys.argv[-1] == \"-t\":\n\n    print(\"testing\")\n\n    _test()\n\n    sys.exit()\n\n\n\nmain()\n","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nINF = 10 ** 9 + 1  # sys.maxsize # float(\"inf\")\nMOD = 10 ** 9 + 7\n\ndef floor_sum(n, m, a, b):\n    ret = 0\n    \n    def add_to_ret(val):\n        nonlocal ret\n        ret = (ret + val) % MOD\n    \n    if a >= m:\n        quotient = n - 1\n        remainder = a % m\n        add_to_ret(quotient * n * (a \/\/ m) \/\/ 2)\n        a = remainder\n    \n    if b >= m:\n        quotient = n\n        add_to_ret(quotient * (b \/\/ m))\n        b = b % m\n    \n    y_max = (a * n + b) \/\/ m\n    x_max = y_max * m - b\n    \n    if y_max == 0:\n        return ret\n    \n    quotient = n - (x_max + a - 1) \/\/ a\n    add_to_ret(quotient * y_max)\n    \n    return floor_sum(y_max, a, m, (a - x_max % a) % a)\n\ndef debug(*x):\n    print(*x, file=sys.stderr)\n\ndef solve(SOLVE_PARAMS):\n    pass\n\ndef main():\n    # parse input\n    T = int(input())\n    for _t in range(T):\n        N, M, A, B = map(int, input().split())\n        print(floor_sum(N, M, A, B))\n\n# tests\nT1 = \"\"\"\n5\n4 10 6 3\n6 5 4 3\n1 1 0 0\n31415 92653 58979 32384\n1000000000 1000000000 999999999 999999999\n\"\"\"\n\nTEST_T1 = \"\"\"\n>>> as_input(T1)\n>>> main()\n3\n13\n0\n314095480\n499999999500000000\n\"\"\"\n\ndef _test():\n    import doctest\n    doctest.testmod()\n    g = globals()\n    for k in sorted(g):\n        if k.startswith(\"TEST_\"):\n            doctest.run_docstring_examples(g[k], g, name=k)\n\ndef as_input(s):\n    \"use in test, use given string as input file\"\n    import io\n    f = io.StringIO(s.strip())\n    g = globals()\n    g[\"input\"] = lambda: bytes(f.readline(), \"ascii\")\n    g[\"read\"] = lambda: bytes(f.read(), \"ascii\")\n\ninput = sys.stdin.buffer.readline\nread = sys.stdin.buffer.read\n\nif sys.argv[-1] == \"-t\":\n    print(\"testing\")\n    _test()\n    sys.exit()\n\nmain()"}
{"problem_id":"p03060","slow_code_col":"import numpy as np\n\nn = int(eval(input()))\n\nvalue = np.array(tuple(map(int, input().split())))\n\ncost = np.array(tuple(map(int, input().split())))\n\nxy = value - cost\n\nans = 0\n\nfor i in range(n):\n\n    if xy[i] < 0:\n\n        continue\n\n    else:\n\n        ans += xy[i]\n\nprint(ans)","reference_code_col":"n = int(eval(input()))\n\nvalue = tuple(map(int, input().split()))\n\ncost = tuple(map(int, input().split()))\n\n# i\u3053\u3081\u307e\u3067\u306ex\u30fcy\u306e\u6700\u5927\u5024\n\ninf = -100\n\ndp = [inf] * (n+1)\n\ndp[1] = max(0, value[0]-cost[0])\n\nfor i in range(2, n+1):\n\n    dp[i] = max(dp[i-1], dp[i-1]+value[i-1]-cost[i-1])\n\n\n\nprint((dp[n]))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn = int(input())\nvalue = np.array(list(map(int, input().split())))\ncost = np.array(list(map(int, input().split())))\n\n# Calculate the difference array\nxy = value - cost\n\n# Use NumPy's boolean indexing to select only non-negative elements and calculate their sum\npositive_diffs = xy[xy >= 0]\nans = np.sum(positive_diffs)\n\nprint(ans)"}
{"problem_id":"p02881","slow_code_col":"import math\n\nN = int(eval(input()))\n\nans = 10**12\n\nfor i in range(1,10**6+1):\n\n  j = math.ceil(N\/(i+1))\n\n  if (1+i)*j == N:\n\n    ans = min(i+j-1,ans)\n\n  if i == 10**6 and ans == 10**12:\n\n    ans = N-1\n\n    break\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nans = 10**12\n\nfor i in range(1,10**6+1):\n\n  j = N\/\/i\n\n  if i*j == N:\n\n    ans = min(i+j-2,ans)\n\n  if i == 10**6 and ans == 10**12:\n\n    ans = N-1\n\n    break\n\nprint(ans)","model_generated_potentially_faster_code_col":"import math\n\n# Read input value\nN = int(input())\n\n# Initialize answer to maximum possible value\nans = N - 1\n\n# Iterate over possible values of i from 1 to sqrt(N)\nfor i in range(1, int(math.sqrt(N)) + 1):\n    # Calculate j as ceiling of N divided by (i + 1)\n    j = math.ceil(N \/ (i + 1))\n    \n    # Check if the product of (1 + i) and j equals N\n    if (1 + i) * j == N:\n        # Update answer with minimum value between current answer and (i + j - 1)\n        ans = min(ans, i + j - 1)\n\n# Print the final answer\nprint(ans)"}
{"problem_id":"p03434","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nvalue = list(map(int,input().split()))\n\nvalue=np.sort(value)[::-1]\n\n#print(N,value)\n\na = np.sum(value[::2])\n\nb = np.sum(value[1::2])\n\nprint((a-b))","reference_code_col":"n = int(eval(input()))\n\na = sorted(list(map(int, input().split())), reverse=True)\n\nprint((sum(a[::2]) - sum(a[1::2])))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read N directly\nN = int(input())\n\n# Read all values at once and convert them to a NumPy array\nvalues = np.array(list(map(int, input().split())))\n\n# Sort the array in descending order\nvalues = np.sort(values)[::-1]\n\n# Calculate the sums of elements at even and odd indices\na = np.sum(values[::2])\nb = np.sum(values[1::2])\n\n# Print the difference\nprint(a - b)"}
{"problem_id":"p02758","slow_code_col":"mod = 998244353\n\nN = int(eval(input()))\n\nX = []\n\nfor _ in range(N):\n\n    x, d = list(map(int, input().split()))\n\n    X.append((x, x + d))\n\n\n\nX = sorted(X, key = lambda x: x[0])\n\nL = [(0, -(10**9+1), 10**9+1)]\n\nP = [-1] * (N+1)\n\nfor i, (x, y) in enumerate(X):\n\n    while L[-1][2] <= y:\n\n        if L[-1][2] > x and P[i+1] < 0:\n\n            P[i+1] = L[-1][0]\n\n        L.pop()\n\n    if P[i+1] < 0:\n\n        P[i+1] = L[-1][0]\n\n    L.append((i+1, x, y))\n\n\n\nC = [[] for _ in range(N+1)]\n\nfor i, p in enumerate(P):\n\n    if p >= 0:\n\n        C[p].append(i)\n\n\n\nY = [1] * (N+1)\n\nfor i in range(N+1)[::-1]:\n\n    s = 1\n\n    for j in C[i]:\n\n        s = s * (Y[j] + 1) % mod\n\n    Y[i] = s\n\n\n\nprint((Y[0]))","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nmod = 998244353\n\nN = int(eval(input()))\n\nX = []\n\nfor _ in range(N):\n\n    x, d = list(map(int, input().split()))\n\n    X.append((x, x + d))\n\n\n\nX = sorted(X, key = lambda x: x[0])\n\nL = [(0, -(10**9+1), 10**9+1)]\n\nP = [-1] * (N+1)\n\nfor i, (x, y) in enumerate(X):\n\n    while L[-1][2] <= y:\n\n        if L[-1][2] > x and P[i+1] < 0:\n\n            P[i+1] = L[-1][0]\n\n        L.pop()\n\n    if P[i+1] < 0:\n\n        P[i+1] = L[-1][0]\n\n    L.append((i+1, x, y))\n\n\n\nC = [[] for _ in range(N+1)]\n\nfor i, p in enumerate(P):\n\n    if p >= 0:\n\n        C[p].append(i)\n\n\n\nY = [1] * (N+1)\n\nfor i in range(N+1)[::-1]:\n\n    s = 1\n\n    for j in C[i]:\n\n        s = s * (Y[j] + 1) % mod\n\n    Y[i] = s\n\n\n\nprint((Y[0]))","model_generated_potentially_faster_code_col":"mod = 998244353\n\nN = int(eval(input()))\n\nX = []\n\nfor _ in range(N):\n    x, d = list(map(int, input().split()))\n    X.append((x, x + d))\n\nX = sorted(X, key=lambda x: x[0])\n\nL = [(0, -(10**9+1), 10**9+1)]\nP = [-1] * (N+1)\n\nfor i, (x, y) in enumerate(X):\n    left, right = 0, len(L)-1\n    \n    while left <= right:\n        mid = (left + right) \/\/ 2\n        \n        if L[mid][2] <= y:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    if left > 0 and P[i+1] < 0:\n        P[i+1] = L[left-1][0]\n    \n    L.insert(left, (i+1, x, y))\n\nC = [[] for _ in range(N+1)]\n\nfor i, p in enumerate(P):\n    if p >= 0:\n        C[p].append(i)\n\nY = [1] * (N+1)\n\nfor i in range(N+1)[::-1]:\n    s = 1\n    for j in C[i]:\n        s = s * (Y[j] + 1) % mod\n    Y[i] = s\n\nprint(Y[0])"}
{"problem_id":"p02994","slow_code_col":"n,a=list(map(int,input().split()))\n\n\n\nl=[a+i-1 for i in range(1,n+1)]\n\n\n\nimport numpy as np\n\nb=min(np.abs(l))\n\n\n\nif b==0:\n\n  l.remove(0)\n\nelif b in l:\n\n  l.remove(b)\n\nelif -b in l:\n\n  l.remove(-b)\n\n  \n\nprint((sum(l)))","reference_code_col":"n,a=list(map(int,input().split()))\n\n\n\napples=[a+i for i in range(n)]\n\neat=min(apples,key=lambda x:abs(x))\n\nres=sum(apples)-eat\n\n\n\nprint(res)","model_generated_potentially_faster_code_col":"n, a = map(int, input().split())\nl = [a + i - 1 for i in range(1, n + 1)]\n\n# Remove duplicates to avoid redundant checks later\nl = list(set(l))\n\n# Calculate the minimum absolute value only once\nmin_abs = min(abs(x) for x in l)\n\n# Remove the smallest number if it exists\nif min_abs == 0:\n    l.remove(0)\nelse:\n    l.remove(min_abs)\n\nprint(sum(l))"}
{"problem_id":"p02767","slow_code_col":"n = int(eval(input()))\n\nx = [int(i) for i in input().split()]\n\np = 10000000\n\nfor i in range(100):\n\n    pi = 0\n\n    for j in range(n):\n\n        pi += (x[j] - (i + 1))**2\n\n    if pi < p:\n\n        p = pi\n\n    # else:\n\n    #     break\n\n        # p[i] += (x[j]-(i+1))**2\n\nprint(p)","reference_code_col":"n = int(eval(input()))\n\nx = [int(i) for i in input().split()]\n\np = 10000000\n\nfor i in range(100):\n\n    pi = 0\n\n    for j in range(n):\n\n        pi += (x[j] - (i + 1))**2\n\n    if pi < p:\n\n        p = pi\n\n    else:\n\n        break\n\n        # p[i] += (x[j]-(i+1))**2\n\nprint(p)","model_generated_potentially_faster_code_col":"import numpy as np\n\nn = int(eval(input()))\nx = np.array([int(i) for i in input().split()])\n\n# Calculate the mean of x\nmean_x = np.mean(x)\n\n# Calculate the variance of x\nvariance_x = np.var(x)\n\n# Print the minimum variance\nprint(variance_x)"}
{"problem_id":"p03680","slow_code_col":"N=int(eval(input()))\n\n\n\n\n\na = []\n\n\n\nfor i in range(N):\n\n    a.append(int(eval(input())))\n\n# a=[0]*N\n\n# for i in range(N):\n\n#   a[i]=int(input())\n\ncount=0\n\n\n\n#loop\u306e\u5b9a\u7fa9\u2192\u540c\u3058\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u4f7f\u7528\u3057\u305f\u3089loop\u5224\u5b9a\n\n#in \u306e\u51e6\u7406\u3092\u7206\u901f\u3067\u5b9f\u884c\u3059\u308b\u305f\u3081\u306bset\u3092\u4f7f\u7528\u3059\u308b\n\n#loop=[]\n\nloop=set()\n\n\n\ntmp=1\n\nwhile True:  \n\n  tmp=a[tmp-1]\n\n  count+=1\n\n  if tmp==2:\n\n    print(count)\n\n    exit()\n\n  if tmp-1 in loop:\n\n    print((-1))\n\n    exit()\n\n  #loop.append(tmp-1)\n\n  loop.add(tmp-1)","reference_code_col":"N=int(eval(input()))\n\n#\u8907\u6570\u884c\u306e\u5165\u529b\u3092\u9ad8\u901f\u5316\n\n#a=[0]*N\n\n#for i in range(N):\n\n#  a[i]=int(input())\n\nimport sys\n\na=[int(i) for i in sys.stdin]\n\n\n\ncount=0\n\n\n\n#loop\u306e\u5b9a\u7fa9\u2192\u540c\u3058\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u4f7f\u7528\u3057\u305f\u3089loop\u5224\u5b9a\n\n#in \u306e\u51e6\u7406\u3092\u7206\u901f\u3067\u5b9f\u884c\u3059\u308b\u305f\u3081\u306bset\u3092\u4f7f\u7528\u3059\u308b\n\n#loop=[]\n\nloop=set()\n\n\n\ntmp=1\n\nwhile True:  \n\n  tmp=a[tmp-1]\n\n  count+=1\n\n  if tmp==2:\n\n    print(count)\n\n    exit()\n\n  if tmp-1 in loop:\n\n    print((-1))\n\n    exit()\n\n  #loop.append(tmp-1)\n\n  loop.add(tmp-1)","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Create the list with the given size and read inputs\na = [int(input()) for _ in range(N)]\n\n# Set to keep track of visited indices\nvisited_indices = set()\n\n# Start at index 0 (or any other starting point, as per problem requirements)\ncurrent_index = 0\nstep_count = 0\n\nwhile True:\n    current_value = a[current_index]\n    \n    if current_value == 2:\n        print(step_count + 1)  # +1 because we need to include the current step\n        break\n    \n    next_index = current_value - 1\n    \n    if next_index in visited_indices:\n        print(-1)\n        break\n    \n    visited_indices.add(next_index)\n    current_index = next_index\n    step_count += 1"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\nn = int(eval(input()))\n\nballs = np.array(list(map(int, input().split())))\n\ntime = 0\n\nwhile np.all(balls % 2 == 0) and np.all(balls > 0):\n\n    time += 1\n\n    balls = balls \/ 2\n\nprint(time)","reference_code_col":"import math\n\nn = eval(input())\n\na = list(map(int, input().split()))\n\nans = float(\"inf\")\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind(\"1\") - 1)\n\nprint((round(ans)))","model_generated_potentially_faster_code_col":"import numpy as np\n\nn = int(input())\nballs = list(map(int, input().split()))\n\ntime = 0\n\nwhile all(ball % 2 == 0 for ball in balls) and all(ball > 0 for ball in balls):\n    time += 1\n    balls = [ball \/\/ 2 for ball in balls]\n\nprint(time)"}
{"problem_id":"p03608","slow_code_col":"n, m, r = list(map(int, input().split()))\n\nrs = list(map(int, input().split()))\n\n# construct map\n\nimport numpy as np\n\ndists = np.ones((n + 1, n + 1)) * float('inf')\n\nfor _ in range(m):\n\n    a, b, c = list(map(int, input().split()))\n\n    dists[a, b] = dists[b, a] = c\n\nfor i in range(1, n + 1):\n\n    dists[i, i] = 0\n\n\n\nfrom itertools import product, permutations\n\nfor i, j in product(list(range(1, 1 + n)), repeat=2):\n\n    dists[j] = np.minimum(dists[j], dists[i] + dists[j, i])\n\n\n\nans = float('inf')\n\nfor path in permutations(rs):\n\n    val = sum(dists[i, j] for i, j in zip(path, path[1:]))\n\n    val = int(val)\n\n    if val < ans:\n\n        ans = val\n\n\n\nprint(ans)","reference_code_col":"n, m, r = list(map(int, input().split()))\n\nrs = list(map(int, input().split()))\n\n# construct map\n\nimport numpy as np\n\ndists = np.ones((n + 1, n + 1)) * float('inf')\n\nfor _ in range(m):\n\n    a, b, c = list(map(int, input().split()))\n\n    dists[a, b] = dists[b, a] = c\n\nfor i in range(1, n + 1):\n\n    dists[i, i] = 0\n\n\n\nfrom itertools import permutations\n\nfor i in range(1, 1 + n):\n\n    dists = np.minimum(dists, dists[i: i + 1] + dists[:, i: i + 1])\n\n\n\nans = float('inf')\n\nfor path in permutations(rs):\n\n    val = sum(dists[i, j] for i, j in zip(path, path[1:]))\n\n    val = int(val)\n\n    if val < ans:\n\n        ans = val\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\ndef floyd_warshall(n, dists):\n    for k in range(1, n + 1):\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                dists[i, j] = min(dists[i, j], dists[i, k] + dists[k, j])\n    return dists\n\ndef min_cost_path(n, m, rs, dists):\n    dp = [[float('inf')] * (1 << n) for _ in range(n + 1)]\n    \n    # Initialize base case: visiting only one city\n    for i in range(1, n + 1):\n        dp[i][1 << (i - 1)] = 0\n    \n    for mask in range(1 << n):\n        for i in range(1, n + 1):\n            if mask & (1 << (i - 1)):\n                prev_mask = mask ^ (1 << (i - 1))\n                for j in range(1, n + 1):\n                    if prev_mask & (1 << (j - 1)):\n                        dp[i][mask] = min(dp[i][mask], dp[j][prev_mask] + dists[j][i])\n    \n    ans = float('inf')\n    full_mask = (1 << n) - 1\n    for i in range(1, n + 1):\n        ans = min(ans, dp[i][full_mask] + dists[i][rs[0]])\n    \n    return ans\n\n# Input reading\nn, m, r = list(map(int, input().split()))\nrs = list(map(int, input().split()))\n\n# Construct distance matrix\ndists = np.ones((n + 1, n + 1)) * float('inf')\nfor _ in range(m):\n    a, b, c = list(map(int, input().split()))\n    dists[a, b] = dists[b, a] = c\n\n# Compute shortest paths using Floyd-Warshall\ndists = floyd_warshall(n, dists)\n\n# Find the minimum cost path\nmin_cost = min_cost_path(n, m, rs, dists)\nprint(min_cost)"}
{"problem_id":"p02952","slow_code_col":"N = int(eval(input()))\n\nans = 0\n\nfor i in range(1, N + 1):\n\n    if len(str(i)) % 2 == 1:\n\n        ans += 1\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nprint((len(list([x for x in range(1, N + 1) if len(str(x)) % 2 == 1]))))","model_generated_potentially_faster_code_col":"N = int(input())\n\nans = 0\n\n# Calculate the number of digits in N\nnum_digits = len(str(N))\n\n# Count numbers with an odd number of digits\nif num_digits % 2 == 1:\n    ans += (N \/\/ 10**((num_digits - 1) \/\/ 2) * 2 + min(2 * (N \/\/ 10**((num_digits - 1) \/\/ 2)), N % 10**((num_digits - 1) \/\/ 2) + 1))\nelse:\n    ans += (N \/\/ 10**(num_digits \/\/ 2) * 2)\n\nprint(ans)"}
{"problem_id":"p02693","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\nK = int(eval(input()))\n\nA, B = list(map(int, input().split()))\n\n\n\nfor i in range(A, B+1):\n\n    if i%K==0:\n\n        print('OK')\n\n        exit()\n\n    \n\nprint('NG')","reference_code_col":"K = int(eval(input()))\n\nA, B = list(map(int, input().split()))\n\n\n\nif (A-1)\/\/K!=B\/\/K:\n\n    print('OK')\n\nelse:\n\n    print('NG')","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\nK = int(eval(input()))\nA, B = map(int, input().split())\n\n# Find the first multiple of K greater than or equal to A\nfirst_multiple = ((A + K - 1) \/\/ K) * K\n\nif first_multiple <= B:\n    print('OK')\nelse:\n    print('NG')"}
{"problem_id":"p03162","slow_code_col":"# coding: utf-8\n\nimport numpy as np\n\n\n\nn = int(eval(input()))\n\ndp = np.zeros((n+10, 3))\n\n\n\ndef cmax(a,b):\n\n    if a>b:\n\n        return a\n\n    else: \n\n        return b\n\n        \n\nfor i in range(1, n+1):\n\n    a, b, c = list(map(int, input().split()))\n\n    # a\n\n    dp[i][0] = cmax(dp[i-1][1]+a, dp[i-1][2]+a)\n\n    # b\n\n    dp[i][1] = cmax(dp[i-1][0]+b, dp[i-1][2]+b)\n\n    # c\n\n    dp[i][2] = cmax(dp[i-1][0]+c, dp[i-1][1]+c)\n\n\n\nprint((int(max(dp[i,:]))))","reference_code_col":"# coding: utf-8\n\n# Your code here!\n\n\n\n\n\nN = int(eval(input()))\n\n\n\ndp = [[0]*3 for _ in range(N+1)]\n\n\n\nfor i in range(1, N+1):\n\n    a, b, c = list(map(int, input().split()))\n\n    dp[i][0] = max(dp[i-1][1], dp[i-1][2]) + a\n\n    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + b\n\n    dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + c\n\n    \n\nprint((max(dp[N])))","model_generated_potentially_faster_code_col":"# coding: utf-8\n\nimport numpy as np\n\nn = int(eval(input()))\ndp = [0] * 3\n\ndef cmax(a, b):\n    return max(a, b)\n\nfor _ in range(n):\n    a, b, c = map(int, input().split())\n    dp[0], dp[1], dp[2] = cmax(dp[1] + a, dp[2] + a), cmax(dp[0] + b, dp[2] + b), cmax(dp[0] + c, dp[1] + c)\n\nprint(max(dp))"}
{"problem_id":"p03060","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nVlist = np.array(list(map(int,input().split())))\n\nClist = np.array(list(map(int,input().split())))\n\n\n\nDlist = Vlist-Clist\n\n\n\nsum_ = 0\n\nfor d in Dlist:\n\n    if d >= 0:\n\n        sum_ += d\n\n\n\nprint(sum_)\n","reference_code_col":"# \u5165\u529b\n\nN = int(eval(input()))\n\nVlist = list(map(int, input().split()))\n\nClist = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor i in range(N):\n\n    Z = Vlist[i] - Clist[i]\n\n    if Z > 0:\n\n        ans += Z\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nVlist = np.array(list(map(int, input().split())))\nClist = np.array(list(map(int, input().split())))\n\n# Use NumPy's where function to handle the condition and sum simultaneously\nDlist = Vlist - Clist\npositive_differences = np.where(Dlist >= 0, Dlist, 0)\nsum_ = np.sum(positive_differences)\n\nprint(sum_)"}
{"problem_id":"p02780","slow_code_col":"import numpy as np\n\nN,K=list(map(int,input().split()))\n\nP=list(map(int,input().split()))\n\nQ=[0]\n\ndef ex(A):\n\n  return (1+A)\/2.0\n\nfor i in range(N):\n\n  Q.append(ex(P[i]))\n\nQ=np.array(Q)\n\nR=Q.cumsum()\n\nans=0\n\nfor i in range(K,N+1):\n\n  S=R[i]-R[i-K]\n\n  if ans<S:\n\n    ans=S\n\nprint(ans)","reference_code_col":"#ika tako\n\nn, k = list(map(int, input().split()))\n\nppp = list(map(int, input().split()))\n\ntot = sum(ppp[:k])#\u307e\u305a\u3001\u5148\u982dK\u500b\u306e\u5408\u8a08\u3092\u6c42\u3081\u308b\n\nans = tot#\u4eee\u306e\u7b54\u3068\u3057\u3066\u304a\u304f\n\nfor i in range(k, n):#for\u6587\u30670-index\u3067k+1\u756a\u76ee\u304b\u3089\u6700\u5f8c\u307e\u3067\u30c1\u30a7\u30c3\u30af\n\n    tot += ppp[i] - ppp[i - k]#\u65b0\u3057\u304fi\u756a\u76ee\u3092\u8db3\u3057\u3066\u3001\u4e00\u756a\u53e4\u3044\u3082\u306e\u3092\u5f15\u304f\n\n    ans = max(ans, tot)#\u65b0\u3057\u3044\u7b54\u304c\u5927\u304d\u3044\u306a\u3089\u66f4\u65b0\u3059\u308b\n\nprint(((ans + k) \/ 2))#K\u500b\u5206\u306e\u30b5\u30a4\u30b3\u30ed\u306e\u671f\u5f85\u5024\u3092\u51fa\u529b\u3059\u308b","model_generated_potentially_faster_code_col":"import numpy as np\n\nN, K = map(int, input().split())\nP = np.array(list(map(int, input().split())))\n\n# Calculate the exponential values using vectorization\nex_values = (1 + P) \/ 2.0\n\n# Cumulative sum of the exponential values\nR = np.cumsum(ex_values)\n\n# Compute the maximum difference using vectorization\nS = R[K:] - R[:-K]\nans = S.max()\n\nprint(ans)"}
{"problem_id":"p03806","slow_code_col":"n, ma, mb = list(map(int, input().split()))\n\nU = 400\n\ndp = [[[float(\"inf\")]*(U+1) for _ in range(U+1)] for i in range(n+1)]\n\ndp[0][0][0] = 0\n\nfor i in range(n):\n\n  a, b, c = list(map(int, input().split()))\n\n  for j in range(U+1):\n\n    for k in range(U+1):\n\n      if j<a or k<b:\n\n        dp[i+1][j][k] = dp[i][j][k]\n\n      else:\n\n        dp[i+1][j][k] = min(dp[i][j][k], dp[i][j-a][k-b]+c)\n\nans = float(\"inf\")\n\nfor i in range(1, 1+U\/\/max(ma, mb)):\n\n  na, nb = i*ma, i*mb\n\n  ans = min(ans, dp[-1][na][nb])\n\nif ans == float(\"inf\"):\n\n  print((-1))\n\nelse:\n\n  print(ans)","reference_code_col":"import numpy as np\n\n\n\nn, ma, mb = list(map(int, input().split()))\n\nU = 400\n\ndp = np.full((U+1, U+1), float(\"inf\"))\n\ndp[0, 0] = 0\n\nfor i in range(n):\n\n  a, b, c = list(map(int, input().split()))\n\n  np.minimum(dp[a:, b:], dp[:-a, :-b]+c, out=dp[a:, b:])\n\nans = float(\"inf\")\n\nfor i in range(1, 1+U\/\/max(ma, mb)):\n\n  na, nb = i*ma, i*mb\n\n  ans = min(ans, dp[na, nb])\n\nif ans == float(\"inf\"):\n\n  print((-1))\n\nelse:\n\n  print((int(ans)))","model_generated_potentially_faster_code_col":"n, ma, mb = map(int, input().split())\n\nU = 400\n\n# Initialize DP table with infinity\ndp = [[float(\"inf\")] * (U + 1) for _ in range(U + 1)]\ndp[0][0] = 0\n\n# Perform operations\nfor _ in range(n):\n    a, b, c = map(int, input().split())\n    \n    # Create a temporary DP table to store new states\n    temp_dp = [[float(\"inf\")] * (U + 1) for _ in range(U + 1)]\n    \n    for j in range(U + 1):\n        for k in range(U + 1):\n            if j < a or k < b:\n                temp_dp[j][k] = dp[j][k]\n            else:\n                temp_dp[j][k] = min(dp[j][k], dp[j - a][k - b] + c)\n    \n    # Update the DP table with the new states\n    dp = temp_dp\n\n# Find the minimum cost to reach the target state\nans = float(\"inf\")\nmin_m = min(ma, mb)\nfor i in range(min_m + 1):\n    na, nb = i * ma, i * mb\n    if dp[na][nb] != float(\"inf\"):\n        ans = min(ans, dp[na][nb])\n        break\n\nif ans == float(\"inf\"):\n    print(-1)\nelse:\n    print(ans)"}
{"problem_id":"p02767","slow_code_col":"n,*x=list(map(int,open(0).read().split()))\n\n\n\nimport numpy as np\n\n\n\nxar=np.array(x)\n\n\n\nans=float(\"inf\")\n\nfor p in range(0,101):\n\n    tmp=sum((xar-p)**2)\n\n    ans=min(ans,tmp)\n\n    \n\nprint((int(ans)))","reference_code_col":"n,*x=list(map(int,open(0).read().split()))\n\nans=float(\"inf\")\n\nfor p in range(0,101):\n\n  s=0\n\n  for xi in x:\n\n    s+=(xi-p)**2\n\n  ans=min(ans,s)\n\nprint((int(ans)))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input data\nn, *x = list(map(int, open(0).read().split()))\n\n# Convert to NumPy array\nxar = np.array(x)\n\n# Calculate the mean of xar\nmean_xar = np.mean(xar)\n\n# Calculate the sum of squared differences from the mean\nsum_squared_diff = np.sum((xar - mean_xar) ** 2)\n\n# Print the result\nprint(int(sum_squared_diff))"}
{"problem_id":"p03164","slow_code_col":"import numpy as np\n\n\n\nN, W = list(map(int, input().split()))\n\nitems = []\n\nfor _ in range(N):\n\n    items.append(tuple(map(int, input().split())))\n\nv_max = sum([i[1] for i in items])\n\nINF = 10**12\n\ndp = np.array([[INF for j in range(v_max+1)] for _ in range(N+1)])\n\ndp[0, 0] = 0\n\nfor i in range(1, N+1):\n\n    w, v = items[i-1]\n\n    dp[i, :v] = dp[i-1, :v]\n\n    dp[i, v:] = np.minimum(dp[i-1, :-v] + w, dp[i-1, v:])\n\nans = 0\n\nfor v in range(v_max, -1, -1):\n\n    if dp[N][v] <= W:\n\n        ans = v\n\n        break\n\nprint(ans)","reference_code_col":"N, W = list(map(int, input().split()))\n\nitems = []\n\nINF = 10**12\n\nfor _ in range(N):\n\n    items.append(tuple(map(int, input().split())))\n\nMAX_V = sum([v for _, v in items])\n\ndp = [[INF for j in range(MAX_V+1)] for i in range(N+1)]\n\ndp[0][0] = 0\n\nfor i in range(1, N+1):\n\n    w, v = items[i-1]\n\n    for j in range(MAX_V+1):\n\n        if j - v >= 0:\n\n            dp[i][j] = min(dp[i-1][j-v] + w, dp[i-1][j])\n\n        else:\n\n            dp[i][j] = dp[i-1][j]\n\nfor v in range(MAX_V, -1, -1):\n\n    if dp[N][v] <= W:\n\n        break\n\nprint(v)","model_generated_potentially_faster_code_col":"import numpy as np\n\nN, W = map(int, input().split())\n\nitems = [tuple(map(int, input().split())) for _ in range(N)]\n\nINF = np.inf\n\ndp = np.full((N+1, W+1), INF)\ndp[:, 0] = 0\n\nfor i, (w, v) in enumerate(items):\n    dp[i+1, v:] = np.minimum(dp[i, v:], dp[i, :-v] + w)\n\nans = next((v for v in range(W, -1, -1) if dp[-1, v] <= W), 0)\n\nprint(ans)"}
{"problem_id":"p02850","slow_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN = int(readline())\n\nAB = [list(map(int,readline().split())) for i in range(N-1)]\n\n\n\ngraph = [[] for _ in range(N+1)] #\u96a3\u63a5\u30ea\u30b9\u30c8\n\nfor a,b in AB:\n\n    graph[a].append(b)\n\n    graph[b].append(a)\n\n\n\n#\u89aa\u306e\u30ce\u30fc\u30c9\u306b\u5b50\u3092\u5165\u308c\u3066\u304fdfs\n\nstack = [1]\n\nparent = [0]*(N+1)\n\norder = []\n\nwhile stack:\n\n    x = stack.pop()\n\n    order.append(x)\n\n    for i in graph[x]:\n\n        if i == parent[x]:\n\n            continue\n\n        parent[i] = x\n\n        stack.append(i)\n\n\n\n#\u5404\u5b50\u306e\u8272\u3092\u6c7a\u3081\u3066\u3044\u304f\u3002\n\ncolor = [-1]*(N+1)\n\nfor x in order:\n\n    ng = color[x]\n\n    c = 1\n\n    for y in graph[x]:\n\n        if parent[x] == y:\n\n            continue\n\n        if c == ng:\n\n            c += 1\n\n        color[y] = c\n\n        c += 1\n\n\n\nans = []\n\nfor a,b in AB:\n\n    if parent[a] == b: #\u5b50\u306e\u9802\u70b9\u306e\u8272\u3092\u5165\u308c\u308b\n\n        ans.append(color[a])\n\n    else:\n\n        ans.append(color[b])\n\n\n\nprint((max(ans)))\n\nfor i in ans:\n\n    print(i)\n\n        \n","reference_code_col":"import sys\n\nfrom collections import deque\n\nreadline = sys.stdin.buffer.readline\n\ndef even(n): return 1 if n%2==0 else 0\n\nn = int(readline())\n\ng = [[] for _ in range(n)] #\u96a3\u63a5\u30ea\u30b9\u30c8\n\nab = []\n\nfor i in range(n-1):\n\n    a,b = list(map(int,readline().split()))\n\n    a,b = a-1,b-1\n\n    ab.append((a,b))\n\n    g[a].append(b)\n\n    g[b].append(a)\n\n\n\nroot = 0\n\nparent = [0]*n\n\ndeq = deque([root])\n\norder = [root]\n\n\n\ncolor = [-1]*n\n\ndeq = deque([root])\n\nwhile deq:\n\n    fr = deq.pop()\n\n    ng = color[fr]\n\n    c = 0\n\n    for go in g[fr]:\n\n        if go == parent[fr]:\n\n            continue\n\n        if c == ng:\n\n            c += 1\n\n        parent[go] = fr\n\n        color[go] = c\n\n        c += 1\n\n        deq.append(go)\n\n        order.append(go)\n\nrank = [0]*n\n\nfor i,j in enumerate(order):\n\n    rank[j] = i\n\nprint((max(color)+1))\n\nfor a,b in ab:\n\n    if rank[a] < rank[b]:\n\n        print((color[b]+1))\n\n    else:\n\n        print((color[a]+1))","model_generated_potentially_faster_code_col":"import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nindex = 1\nAB = []\nfor _ in range(N - 1):\n    a = int(data[index])\n    b = int(data[index + 1])\n    AB.append([a, b])\n    index += 2\n\n# Build adjacency list\ngraph = [[] for _ in range(N + 1)]\nfor a, b in AB:\n    graph[a].append(b)\n    graph[b].append(a)\n\n# Perform DFS to find parent-child relationships\nstack = [1]\nparent = [0] * (N + 1)\norder = []\n\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if y != parent[x]:\n            parent[y] = x\n            stack.append(y)\n\n# Assign colors to nodes\ncolor = [-1] * (N + 1)\nfor x in order:\n    ng = color[x]\n    c = 1\n    for y in graph[x]:\n        if parent[x] == y:\n            continue\n        if c == ng:\n            c += 1\n        color[y] = c\n        c += 1\n\n# Print results\nmax_color = max(color)\nprint(max_color)\nfor a, b in AB:\n    if parent[a] == b:\n        print(color[a])\n    else:\n        print(color[b])"}
{"problem_id":"p03013","slow_code_col":"n, m = list(map(int, input().split()))\n\na = []\n\nfor i in range(m):\n\n  a.append(int(eval(input())))\n\nans = 0\n\nflag = 0\n\na = set(a)\n\n\n\n#\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u5217\u306e\u521d\u671f\u5024\u3092\u8abf\u7bc0\n\ndp = [0] * (n+1)\n\ndp[0] = 1\n\nif 1 in a:\n\n  dp[1] = 0\n\nelse:\n\n  dp[1] = 1\n\n  \n\nfor i in range(2, n+1):\n\n  if dp[i-2] == 0 and dp[i-1] == 0:\n\n    ans = 0\n\n    flag = 1\n\n    break\n\n  elif i in a:\n\n    continue\n\n  else:\n\n    dp[i] = dp[i-1] + dp[i-2]\n\nif flag == 0:\n\n  ans = dp[n]\n\nprint((ans%(10**9+7)))","reference_code_col":"n, m = list(map(int, input().split()))\n\na = []\n\nfor i in range(m):\n\n  a.append(int(eval(input())))\n\nans = 0\n\nflag = 0\n\na = set(a)\n\n\n\n#\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u5217\u306e\u521d\u671f\u5024\u3092\u8abf\u7bc0\n\ndp = [0] * (n+1)\n\ndp[0] = 1\n\nif 1 in a:\n\n  dp[1] = 0\n\nelse:\n\n  dp[1] = 1\n\n  \n\nfor i in range(2, n+1):\n\n  if dp[i-2] == 0 and dp[i-1] == 0:\n\n    ans = 0\n\n    flag = 1\n\n    break\n\n  elif i in a:\n\n    continue\n\n  else:\n\n    dp[i] = dp[i-1] + dp[i-2]\n\n    dp[i] = dp[i] % (10**9+7)\n\nif flag == 0:\n\n  ans = dp[n]\n\nprint(ans)","model_generated_potentially_faster_code_col":"n, m = map(int, input().split())\n\na = set(map(int, (eval(input()) for _ in range(m))))\n\ndp = [0] * (n + 1)\ndp[0] = 1\ndp[1] = int(1 not in a)\n\nfor i in range(2, n + 1):\n    if dp[i - 2] == 0 and dp[i - 1] == 0 or i in a:\n        dp[i] = 0\n    else:\n        dp[i] = dp[i - 1] + dp[i - 2]\n\nprint(dp[n] % (10 ** 9 + 7))"}
{"problem_id":"p02780","slow_code_col":"import numpy as np\n\n\n\nN, K = list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\n\n\ns = np.cumsum(p)\n\n# print(p, s)\n\n\n\nm = []\n\n\n\n\n\ndef partsum(s, x):\n\n    global K\n\n    if x == K - 1:\n\n        return s[x]\n\n    return s[x] - s[x - K]\n\n\n\n\n\nfor i in range(K - 1, N):\n\n    m.append(partsum(s, i))\n\n# print(m)\n\n\n\nidx = m.index(max(m))\n\n# print(idx)\n\n\n\nans = 0\n\nfor j in range(idx, idx + K):\n\n    ans += (p[j] + 1) \/ 2\n\nprint(ans)\n","reference_code_col":"from collections import deque\n\n\n\nN, K = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\nmx = 0\n\ns = 0\n\nq = deque()\n\n\n\nfor i in range(N):\n\n    p[i] += 1\n\n\n\nfor i in range(N):\n\n    s += p[i]\n\n    q.append(p[i])\n\n    if len(q) > K:\n\n        s -= q.popleft()\n\n    if len(q) == K:\n\n        mx = max(mx, s)\n\n\n\nprint((mx \/ 2))\n\n\n","model_generated_potentially_faster_code_col":"import numpy as np\n\nN, K = map(int, input().split())\np = np.array(list(map(int, input().split())))\ns = np.cumsum(p)\nmax_sum = float('-inf')\nstart_idx = 0\nend_idx = K-1\n\nwhile end_idx < N:\n    current_sum = s[end_idx]\n    if start_idx > 0:\n        current_sum -= s[start_idx-1]\n    max_sum = max(max_sum, current_sum)\n    start_idx += 1\n    end_idx += 1\n\nidx = np.argmax(np.convolve(p, np.ones(K), 'valid')) + K - 1\nans = 0\nfor j in range(idx, idx + K):\n    ans += (p[j] + 1) \/ 2\nprint(ans)"}
{"problem_id":"p03126","slow_code_col":"import numpy as np\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nlike_total = np.zeros(M)\n\ncnt = 0\n\nfor _ in range(N):\n\n    l = [v for v in map(int, input().split())]\n\n    #print(l)\n\n    for i in range(1, l[0]+1, 1):\n\n        like_total[l[i]-1] += 1\n\n\n\n#print(like_total, N)\n\n#print(like_total[4], like_total[9], like_total[-1])\n\nans = len(np.where(like_total==N)[0])\n\n\n\nprint(ans)\n","reference_code_col":"N, M = list(map(int, input().split()))\n\n\n\nlike_total = [0]*M\n\ncnt = 0\n\nfor _ in range(N):\n\n    l = list(map(int, input().split()))\n\n    for i in range(1, l[0]+1, 1):\n\n        like_total[l[i]-1] += 1\n\n\n\nfor v in like_total:\n\n    cnt += v==N\n\nprint(cnt)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\nN, M = map(int, input().split())\n\n# Create a boolean array to keep track of liked items\nliked_items = np.zeros(M, dtype=bool)\n\n# Iterate over each person's likes\nfor _ in range(N):\n    _, *likes = map(int, input().split())\n    # Mark the liked items as True\n    liked_items[likes-1] = True\n\n# Count the number of items that were liked by all people\nans = np.sum(liked_items)\n\nprint(ans)"}
{"problem_id":"p03200","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nstdin = sys.stdin\n\n \n\nri = lambda: int(rs())\n\nrl = lambda: list(map(int, stdin.readline().split()))\n\nrs = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\n\n\nS = list(rs())\n\nW = [0] * len(S)\n\nfor i in range(len(S)):\n\n    if S[i] == 'W':\n\n        W[i] = 1\n\nW = np.array(W[::-1])\n\nW_cum = W.cumsum()[::-1]\n\nW_cum = W_cum.tolist()\n\nanswer = 0\n\nfor i in range(len(S)):\n\n    if S[i] == 'B':\n\n        answer += W_cum[i]\n\n\n\nprint(answer)","reference_code_col":"import sys\n\nimport numpy as np\n\n\n\nstdin = sys.stdin\n\n \n\nri = lambda: int(rs())\n\nrl = lambda: list(map(int, stdin.readline().split()))\n\nrs = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\n\n\nS = list(rs())\n\ncnt_B = 0\n\nanswer = 0\n\nfor s in S:\n\n    if s == 'B':\n\n        cnt_B += 1\n\n    else:\n\n        answer += cnt_B\n\nprint(answer)\n","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Read input from standard input\nstdin = sys.stdin\n\n# Define helper functions\nri = lambda: int(stdin.readline())\nrl = lambda: list(map(int, stdin.readline().split()))\nrs = lambda: stdin.readline().strip()  # Remove trailing whitespace\n\n# Read the string S\nS = rs()\n\n# Initialize weight array\nW = np.zeros(len(S), dtype=int)\n\n# Assign weights to 'W' characters\nfor i, char in enumerate(S):\n    if char == 'W':\n        W[i] = 1\n\n# Reverse the weight array and calculate cumulative sum\nW_cum = np.cumsum(W[::-1])[::-1].tolist()\n\n# Calculate the final answer by summing weights for 'B' characters\nanswer = sum(W_cum[i] for i, char in enumerate(S) if char == 'B')\n\n# Print the result\nprint(answer)"}
{"problem_id":"p03126","slow_code_col":"import numpy as np\n\nN,M=list(map(int,input().split()))\n\nA=np.zeros((N+1,M+1))\n\nA[0]=np.ones(M+1)\n\nfor i in range(1,N+1):\n\n    B=list(map(int,input().split()))\n\n    for m in range(1,B[0]+1):\n\n        A[i][B[m]]=A[i-1][B[m]]\n\na=sum(A[N])\n\nprint((int(a)))","reference_code_col":"N,M=list(map(int,input().split()))\n\nA = [[1 for _ in range(M)]]+[[0 for _ in range(M)] for _ in range(N)]\n\nfor i in range(1,N+1):\n\n    B=list(map(int,input().split()))\n\n    Ai=B[1:]\n\n    for m in Ai:\n\n        A[i][m-1]=A[i-1][m-1]\n\na=sum(A[N])\n\nprint((int(a)))","model_generated_potentially_faster_code_col":"import numpy as np\n\nN, M = map(int, input().split())\n\n# Initialize A with ones for the first row and zeros elsewhere\nA = np.ones((N + 1, M + 1))\nA[1:, :] = 0\n\nfor i in range(1, N + 1):\n    B = list(map(int, input().split()))\n    \n    # Use advanced indexing to update A[i] based on A[i-1]\n    A[i, B[1:]] = A[i - 1, B[1:]]\n\n# Sum the last row of A and print the result\nresult = int(np.sum(A[-1]))\nprint(result)"}
{"problem_id":"p03558","slow_code_col":"from heapq import heappush, heappop\n\nk = int(eval(input()))\n\n\n\nheap = [(1,1)]\n\ndist = [float(\"inf\")]*k\n\nwhile heap:\n\n    cost, cur = heappop(heap)\n\n    if dist[cur] <= cost:\n\n        continue\n\n    dist[cur] = cost\n\n    # +1\n\n    nxt = (cur+1)%k\n\n    heappush(heap, (cost+1, nxt))\n\n    # *10\n\n    nxt = cur*10 % k\n\n    heappush(heap, (cost, nxt))\n\n\n\nprint((dist[0]))","reference_code_col":"from collections import deque\n\nk = int(eval(input()))\n\n\n\nque = deque()\n\nque.append((1,1))\n\ndist = [float(\"inf\")]*k\n\nwhile que:\n\n    cost, cur = que.popleft()\n\n    if dist[cur] <= cost:\n\n        continue\n\n    dist[cur] = cost\n\n    # +1\n\n    nxt = (cur+1)%k\n\n    que.append((cost+1,nxt))\n\n    # *10\n\n    nxt = cur*10 % k\n\n    que.appendleft((cost, nxt))\n\nprint((dist[0]))","model_generated_potentially_faster_code_col":"from heapq import heappush, heappop\n\nk = int(eval(input()))\n\nheap = [(0, 1)]  # Start from vertex 1 with initial cost 0\nvisited = {1}\n\nwhile heap:\n    cost, cur = heappop(heap)\n\n    if cur == 0:  # We have reached the target vertex\n        break\n\n    # +1 operation\n    nxt = (cur + 1) % k\n    if nxt not in visited:\n        visited.add(nxt)\n        heappush(heap, (cost + 1, nxt))\n\n    # *10 operation\n    nxt = (cur * 10) % k\n    if nxt not in visited:\n        visited.add(nxt)\n        heappush(heap, (cost, nxt))\n\nprint(cost)"}
{"problem_id":"p03371","slow_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nmax_iter = max(X, Y) * 2\n\nans = float(\"inf\")\n\nfor i in range(max_iter):\n\n    a = max(X - i, 0)\n\n    b = max(Y - i, 0)\n\n    price = 2*C * i + A * a + B * b\n\n    ans = min(ans, price)\n\n\n\nprint(ans)","reference_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = float(\"inf\")\n\nfor i in range(max(X, Y)+1):\n\n    x = max(X - i, 0)\n\n    y = max(Y - i, 0)\n\n    cost = 2*C * i + A * x + B * y\n\n    ans = min(ans, cost)\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"A, B, C, X, Y = map(int, input().split())\n\n# Determine the maximum number of iterations needed\nmax_iter = min(X, Y)\n\nans = float(\"inf\")\n\nfor i in range(max_iter + 1):\n    a = max(X - i, 0)\n    b = max(Y - i, 0)\n    price = 2 * C * i + A * a + B * b\n    ans = min(ans, price)\n\nprint(ans)"}
{"problem_id":"p02780","slow_code_col":"import numpy as np\n\nn,k=list(map(int, input().split()))\n\nexp=list([(int(x)+1)\/2 for x in input().split()]) # \u5165\u529b\u3068\u540c\u6642\u306b\u671f\u5f85\u5024\u8a08\u7b97\n\n\n\nl=np.cumsum(exp) # \u7d2f\u7a4d\u548c\u306e\u8a08\u7b97\n\n\n\nans=l[k-1]\n\nfor i in range(n-k):\n\n    ans=max(ans,l[i+k]-l[i])\n\n    \n\nprint(ans)","reference_code_col":"n,k=list(map(int, input().split()))\n\nexp=list([(int(x)+1)\/2 for x in input().split()]) # \u5165\u529b\u3068\u540c\u6642\u306b\u671f\u5f85\u5024\u8a08\u7b97\n\n\n\nl=[0]*n\n\nsum1=0\n\nfor i in range(n):# \u7d2f\u7a4d\u548c\u306e\u8a08\u7b97\n\n    sum1+=exp[i]\n\n    l[i]=sum1 \n\n\n\nans=l[k-1]\n\nfor i in range(n-k):\n\n    ans=max(ans,l[i+k]-l[i])\n\n    \n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\nn, k = map(int, input().split())\n\nexp = np.array([(int(x) + 1) \/ 2 for x in input().split()])\n\n# Calculate cumulative sum\ncum_sum = np.cumsum(exp)\n\n# Find the maximum expected value\nmax_exp = cum_sum[-1] - cum_sum[:-k].max()\n\nprint(max_exp)"}
{"problem_id":"p03309","slow_code_col":"import math\n\nimport statistics\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\na = [aa-i-1 for i, aa in enumerate(a)]\n\nanswer = n*10**20\n\nmedian_low = statistics.median_low(a)\n\nmedian_high = statistics.median_high(a)\n\n\n\nfor m in (median_low,median_high):\n\n  ans=0\n\n  for aa in a:\n\n    ans += abs(aa-m)\n\n  answer = min(ans,answer)\n\nprint(answer)\n","reference_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\n\n\n\n\n\ndef solve(N: int, A: \"List[int]\"):\n\n    difA = [0]*N\n\n\n\n    for i in range(N):\n\n        difA[i] = A[i]-(i+1)\n\n\n\n    difA.sort()\n\n    if N%2 == 0:\n\n        g1 = difA[N\/\/2]\n\n        g2 = difA[N\/\/2-1]\n\n        a1 = 0\n\n        a2 = 0\n\n        for i in range(N):\n\n            a1 += abs(difA[i]-g1)\n\n            a2 += abs(difA[i]-g2)\n\n        print((min(a1,a2)))\n\n            \n\n    else:\n\n        g = difA[N\/\/2]\n\n        a = 0\n\n        for i in range(N):\n\n            a += abs(difA[i]-g)\n\n        print(a)\n\n    return\n\n\n\n\n\ndef main():\n\n    def iterate_tokens():\n\n        for line in sys.stdin:\n\n            for word in line.split():\n\n                yield word\n\n    tokens = iterate_tokens()\n\n    N = int(next(tokens))  # type: int\n\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n\n    solve(N, A)\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import math\n\nimport statistics\n\nn = int(input())\na = list(map(int, input().split()))\na = [aa - i - 1 for i, aa in enumerate(a)]\n\n# Calculate the median only once\nmedian = statistics.median(a)\n\n# Initialize the minimum sum of absolute differences\nmin_diff_sum = float('inf')\n\n# Iterate over the array to find the minimum sum of absolute differences\nfor i in range(n):\n    diff_sum = sum(abs(x - median) for x in a)\n    if diff_sum < min_diff_sum:\n        min_diff_sum = diff_sum\n\nprint(min_diff_sum)"}
{"problem_id":"p03170","slow_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat Apr 25 18:20:35 2020\n\n\"\"\"\n\n\n\nimport sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 9)\n\ndef input():\n\n    return sys.stdin.readline()[:-1]\n\nmod = 10**9+7\n\n\n\n#N = int(input())\n\nN, K = list(map(int,input().split()))\n\nA = np.array(list(map(int,input().split())))\n\n#N, K, *A = map(int, open(0).read().split())\n\n\n\ndp = [True for i in range(K + A[-1] + 1)]\n\nfor i in range(K):\n\n    if dp[i]:\n\n        for a in A:\n\n            dp[i + a] = False\n\n\n\n#    print(i, dp[i],A+i,dp[A+i])\n\n#print(dp)\n\n\n\nif dp[K]:\n\n    ans = 'Second'\n\nelse:\n\n    ans = 'First'\n\nprint(ans)","reference_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat Apr 25 18:20:35 2020\n\n\"\"\"\n\n\n\nimport sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 9)\n\n#def input():\n\n#    return sys.stdin.readline()[:-1]\n\nmod = 10**9+7\n\n\n\n#N = int(input())\n\nN, K = list(map(int,input().split()))\n\n#A = np.array(list(map(int,input().split())))\n\nA = list(map(int,input().split()))\n\n\n\ndp = [True for i in range(K + A[-1] + 1)]\n\nfor i in range(K):\n\n    if dp[i]:\n\n        for a in A:\n\n            dp[i + a] = False\n\n\n\n#    print(i, dp[i],A+i,dp[A+i])\n\n#print(dp)\n\n\n\nif dp[K]:\n\n    ans = 'Second'\n\nelse:\n\n    ans = 'First'\n\nprint(ans)","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nimport sys\nimport numpy as np\n\nsys.setrecursionlimit(10 ** 9)\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\nmod = 10**9 + 7\n\nN, K = map(int, input().split())\nA = np.array(list(map(int, input().split())))\n\n# Initialize dp array to keep track of possible sums\ndp = [False] * (K + 1)\ndp[0] = True\n\n# Use a set to store reachable sums\nreachable_sums = {0}\n\nfor a in A:\n    new_reachable_sums = set()\n    for s in reachable_sums:\n        if s + a <= K:\n            new_reachable_sums.add(s + a)\n    reachable_sums.update(new_reachable_sums)\n\n# Check if K is in the set of reachable sums\nif K in reachable_sums:\n    ans = 'Second'\nelse:\n    ans = 'First'\n\nprint(ans)"}
{"problem_id":"p02837","slow_code_col":"def main():\n\n    from itertools import product\n\n\n\n    N = int(eval(input()))\n\n\n\n    g = []\n\n    for _ in range(N):\n\n        a = int(eval(input()))\n\n        t = []\n\n        for _ in range(a):\n\n            x, y = list(map(int, input().split()))\n\n            x -= 1\n\n            t.append((x, y))\n\n        g.append(t)\n\n\n\n    def is_ok(prd):\n\n        for j, bl in enumerate(prd):\n\n            if bl:\n\n                for x, y in g[j]:\n\n                    if prd[x] != y:\n\n                        return False\n\n        return True\n\n\n\n    ans = 0\n\n    for prd in product([0, 1], repeat=N):\n\n        *prd, = prd  # list\u5316\n\n        if is_ok(prd):\n\n            ans = max(ans, prd.count(1))\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n\n# bit\u6f14\u7b97\u3057\u3088\u3046\u3068\u3057\u3066\u306f\u307e\u3063\u305f\n","reference_code_col":"def main():\n\n    from itertools import product\n\n\n\n    N = int(eval(input()))\n\n\n\n    g = []\n\n    for _ in range(N):\n\n        a = int(eval(input()))\n\n        t = []\n\n        for _ in range(a):\n\n            x, y = list(map(int, input().split()))\n\n            t.append((x - 1, y))\n\n        g.append(t)\n\n\n\n    def is_ok(prd):\n\n        for j, bl in enumerate(prd):\n\n            if bl:\n\n                for x, y in g[j]:\n\n                    if prd[x] != y:\n\n                        return False\n\n        return True\n\n\n\n    ans = 0\n\n    for prd in product([0, 1], repeat=N):\n\n        if is_ok(prd):\n\n            ans = max(ans, prd.count(1))\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n\n# bit\u6f14\u7b97\u3057\u3088\u3046\u3068\u3057\u3066\u306f\u307e\u3063\u305f\n","model_generated_potentially_faster_code_col":"def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    N = int(data[index])\n    index += 1\n\n    g = []\n    for _ in range(N):\n        a = int(data[index])\n        index += 1\n        t = []\n        for _ in range(a):\n            x = int(data[index]) - 1\n            y = int(data[index + 1])\n            index += 2\n            t.append((x, y))\n        g.append(t)\n\n    def is_ok(prd):\n        for j, bl in enumerate(prd):\n            if bl:\n                for x, y in g[j]:\n                    if prd[x] != y:\n                        return False\n        return True\n\n    ans = 0\n    for prd in range(1 << N):  # Generate all possible binary sequences using bit manipulation\n        prd_list = [(prd >> i) & 1 for i in range(N)]  # Convert binary sequence to list\n        if is_ok(prd_list):\n            ans = max(ans, prd_list.count(1))\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03371","slow_code_col":"a,b,c,x,y = list(map(int,input().split()))\n\nans = a*x + b*y\n\nfor i in range(max(x,y) + 1):\n\n\tmoney = max(0,(x-i)*a) + max(0,(y-i)*b) + 2*i*c\n\n\tif money <= ans:\n\n\t\tans = money\n\nprint(ans)","reference_code_col":"a,b,c,x,y = list(map(int,input().split()))\n\nif a + b >= 2*c:\n\n\tif x >= y:\n\n\t\tans = 2*y*c + (x-y)*min(a,2*c)\n\n\telse:\n\n\t\tans = 2*x*c + (y-x)*min(b,2*c)\n\nelse:\n\n\tans = (x*a + y*b)\n\nprint(ans)","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\n\nans = a * x + b * y\n\nfor i in range(max(x, y) + 1):\n    dx, dy = x - i, y - i\n    money = max(0, dx * a) + max(0, dy * b) + 2 * i * c\n    \n    if money <= ans:\n        ans = money\n\nprint(ans)"}
{"problem_id":"p02680","slow_code_col":"import sys\n\n# from itertools import chain, accumulate\n\n\n\nn, m, *abcdef = list(map(int, sys.stdin.buffer.read().split()))\n\n\n\nver_lines = []\n\nhor_lines = []\n\nx_list = set()\n\ny_list = set()\n\nn3 = n * 3\n\nfor a, b, c in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n\n    y_list.add(a)\n\n    y_list.add(b)\n\n    x_list.add(c)\n\n    ver_lines.append((a, b, c))\n\n\n\nfor d, e, f in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n\n    y_list.add(d)\n\n    x_list.add(e)\n\n    x_list.add(f)\n\n    hor_lines.append((d, e, f))\n\nx_list.add(0)\n\ny_list.add(0)\n\n\n\nx_list = sorted(x_list)\n\ny_list = sorted(y_list)\n\nx_dict = {x: i for i, x in enumerate(x_list, start=1)}\n\ny_dict = {y: i for i, y in enumerate(y_list, start=1)}\n\nrow_real = len(x_list)\n\ncol_real = len(y_list)\n\nrow = row_real + 2\n\ncol = col_real + 2\n\nbanned_up_ij = [[0] * row for _ in range(col)]\n\nbanned_down_ij = [[0] * row for _ in range(col)]\n\nbanned_left_ij = [[0] * col for _ in range(row)]\n\nbanned_right_ij = [[0] * col for _ in range(row)]\n\nfor a, b, c in ver_lines:\n\n    if a > b:\n\n        a, b = b, a\n\n    ai = y_dict[a]\n\n    bi = y_dict[b]\n\n    j = x_dict[c]\n\n    banned_left_ij[j][ai] += 1\n\n    banned_left_ij[j][bi] -= 1\n\n    banned_right_ij[j - 1][ai] += 1\n\n    banned_right_ij[j - 1][bi] -= 1\n\nfor d, e, f in hor_lines:\n\n    if e > f:\n\n        e, f = f, e\n\n    i = y_dict[d]\n\n    ej = x_dict[e]\n\n    fj = x_dict[f]\n\n    banned_up_ij[i][ej] += 1\n\n    banned_up_ij[i][fj] -= 1\n\n    banned_down_ij[i - 1][ej] += 1\n\n    banned_down_ij[i - 1][fj] -= 1\n\n\n\nbanned_up = [0] * (row * col)\n\nbanned_down = [0] * (row * col)\n\nbanned_left = [0] * (row * col)\n\nbanned_right = [0] * (row * col)\n\nfor i in range(col):\n\n    ru = banned_up_ij[i]\n\n    rd = banned_down_ij[i]\n\n    ri = row * i\n\n    banned_up[ri] = ru[0]\n\n    banned_down[ri] = rd[0]\n\n    for j in range(1, row):\n\n        banned_up[ri + j] = banned_up[ri + j - 1] + ru[j]\n\n        banned_down[ri + j] = banned_down[ri + j - 1] + rd[j]\n\nfor j in range(row):\n\n    rl = banned_left_ij[j]\n\n    rr = banned_right_ij[j]\n\n    banned_left[j] = rl[0]\n\n    banned_right[j] = rr[0]\n\n    for i in range(1, col):\n\n        ri0 = (i - 1) * row\n\n        ri1 = i * row\n\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\n\n\n\n# banned_up = list(chain.from_iterable(map(accumulate, banned_up_ij)))\n\n# banned_down = list(chain.from_iterable(map(accumulate, banned_down_ij)))\n\n# banned_left = list(chain.from_iterable(zip(*map(accumulate, banned_left_ij))))\n\n# banned_right = list(chain.from_iterable(zip(*map(accumulate, banned_right_ij))))\n\n\n\n# for i in range(col):\n\n#     print(walls[i * row:(i + 1) * row])\n\n\n\ns = row * y_dict[0] + x_dict[0]\n\nenable = [-1] * row + ([-1] + [0] * (row - 2) + [-1]) * (col - 2) + [-1] * row\n\n\n\n# for i in range(col):\n\n#     print(enable[i * row:(i + 1) * row])\n\n\n\nq = [s]\n\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\n\nwhile q:\n\n    c = q.pop()\n\n    if enable[c] == 1:\n\n        continue\n\n    elif enable[c] == -1:\n\n        print('INF')\n\n        exit()\n\n    enable[c] = 1\n\n    for dc, banned in moves:\n\n        if banned[c]:\n\n            continue\n\n        nc = c + dc\n\n        if enable[nc] == 1:\n\n            continue\n\n        q.append(nc)\n\n# for i in range(col):\n\n#     print(enable[i * row:(i + 1) * row])\n\n\n\n\n\nans = 0\n\nfor i in range(col):\n\n    ri = i * row\n\n    for j in range(row):\n\n        if enable[ri + j] != 1:\n\n            continue\n\n        t = y_list[i - 1]\n\n        b = y_list[i]\n\n        l = x_list[j - 1]\n\n        r = x_list[j]\n\n        ans += (b - t) * (r - l)\n\nprint(ans)\n","reference_code_col":"import sys\n\n\n\n# from itertools import chain, accumulate\n\n\n\nn, m, *abcdef = list(map(int, sys.stdin.buffer.read().split()))\n\n\n\nver_lines = []\n\nhor_lines = []\n\nx_list = set()\n\ny_list = set()\n\nn3 = n * 3\n\nfor a, b, c in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n\n    y_list.add(a)\n\n    y_list.add(b)\n\n    x_list.add(c)\n\n    ver_lines.append((a, b, c))\n\n\n\nfor d, e, f in zip(abcdef[n3 + 0::3], abcdef[n3 + 1::3], abcdef[n3 + 2::3]):\n\n    y_list.add(d)\n\n    x_list.add(e)\n\n    x_list.add(f)\n\n    hor_lines.append((d, e, f))\n\nx_list.add(0)\n\ny_list.add(0)\n\n\n\nx_list = sorted(x_list)\n\ny_list = sorted(y_list)\n\nx_dict = {x: i for i, x in enumerate(x_list, start=1)}\n\ny_dict = {y: i for i, y in enumerate(y_list, start=1)}\n\nrow_real = len(x_list)\n\ncol_real = len(y_list)\n\nrow = row_real + 2\n\ncol = col_real + 2\n\n\n\nbanned_up = [0] * (row * col)\n\nbanned_down = [0] * (row * col)\n\nbanned_left = [0] * (row * col)\n\nbanned_right = [0] * (row * col)\n\nfor a, b, c in ver_lines:\n\n    if a > b:\n\n        a, b = b, a\n\n    ai = y_dict[a] * row\n\n    bi = y_dict[b] * row\n\n    j = x_dict[c]\n\n    banned_left[ai + j] += 1\n\n    banned_left[bi + j] -= 1\n\n    banned_right[ai + j - 1] += 1\n\n    banned_right[bi + j - 1] -= 1\n\nfor d, e, f in hor_lines:\n\n    if e > f:\n\n        e, f = f, e\n\n    ri = y_dict[d] * row\n\n    ej = x_dict[e]\n\n    fj = x_dict[f]\n\n    banned_up[ri + ej] += 1\n\n    banned_up[ri + fj] -= 1\n\n    banned_down[ri - row + ej] += 1\n\n    banned_down[ri - row + fj] -= 1\n\n\n\nfor i in range(1, col):\n\n    ri0 = row * (i - 1)\n\n    ri1 = row * i\n\n    for j in range(1, row):\n\n        banned_up[ri1 + j] += banned_up[ri1 + j - 1]\n\n        banned_down[ri1 + j] += banned_down[ri1 + j - 1]\n\n        banned_left[ri1 + j] += banned_left[ri0 + j]\n\n        banned_right[ri1 + j] += banned_right[ri0 + j]\n\n\n\n# banned_up = list(chain.from_iterable(map(accumulate, banned_up_ij)))\n\n# banned_down = list(chain.from_iterable(map(accumulate, banned_down_ij)))\n\n# banned_left = list(chain.from_iterable(zip(*map(accumulate, banned_left_ij))))\n\n# banned_right = list(chain.from_iterable(zip(*map(accumulate, banned_right_ij))))\n\n\n\n# for i in range(col):\n\n#     print(walls[i * row:(i + 1) * row])\n\n\n\ns = row * y_dict[0] + x_dict[0]\n\nenable = [-1] * row + ([-1] + [0] * (row - 2) + [-1]) * (col - 2) + [-1] * row\n\n\n\n# for i in range(col):\n\n#     print(enable[i * row:(i + 1) * row])\n\n\n\nq = [s]\n\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\n\nwhile q:\n\n    c = q.pop()\n\n    if enable[c] == 1:\n\n        continue\n\n    elif enable[c] == -1:\n\n        print('INF')\n\n        exit()\n\n    enable[c] = 1\n\n    for dc, banned in moves:\n\n        if banned[c]:\n\n            continue\n\n        nc = c + dc\n\n        if enable[nc] == 1:\n\n            continue\n\n        q.append(nc)\n\n# for i in range(col):\n\n#     print(enable[i * row:(i + 1) * row])\n\n\n\n\n\nans = 0\n\nfor i in range(col):\n\n    ri = i * row\n\n    for j in range(row):\n\n        if enable[ri + j] != 1:\n\n            continue\n\n        t = y_list[i - 1]\n\n        b = y_list[i]\n\n        l = x_list[j - 1]\n\n        r = x_list[j]\n\n        ans += (b - t) * (r - l)\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import sys\n\nn, m, *abcdef = map(int, sys.stdin.buffer.read().split())\n\nver_lines = []\nhor_lines = []\nx_set = set()\ny_set = set()\n\nn3 = n * 3\n\nfor a, b, c in zip(abcdef[0:n3:3], abcdef[1:n3:3], abcdef[2:n3:3]):\n    y_set.add(a)\n    y_set.add(b)\n    x_set.add(c)\n    ver_lines.append((a, b, c))\n\nfor d, e, f in zip(abcdef[n3:], abcdef[n3+1::3], abcdef[n3+2::3]):\n    y_set.add(d)\n    x_set.add(e)\n    x_set.add(f)\n    hor_lines.append((d, e, f))\n\nx_set.add(0)\ny_set.add(0)\n\nx_list = sorted(x_set)\ny_list = sorted(y_set)\n\nx_dict = {x: i for i, x in enumerate(x_list, start=1)}\ny_dict = {y: i for i, y in enumerate(y_list, start=1)}\n\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\n\nbanned_up_ij = [[0] * row for _ in range(col)]\nbanned_down_ij = [[0] * row for _ in range(col)]\nbanned_left_ij = [[0] * col for _ in range(row)]\nbanned_right_ij = [[0] * col for _ in range(row)]\n\nfor a, b, c in ver_lines:\n    if a > b:\n        a, b = b, a\n    ai = y_dict[a]\n    bi = y_dict[b]\n    j = x_dict[c]\n    banned_left_ij[j][ai] += 1\n    banned_left_ij[j][bi] -= 1\n    banned_right_ij[j-1][ai] += 1\n    banned_right_ij[j-1][bi] -= 1\n\nfor d, e, f in hor_lines:\n    if e > f:\n        e, f = f, e\n    i = y_dict[d]\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up_ij[i][ej] += 1\n    banned_up_ij[i][fj] -= 1\n    banned_down_ij[i-1][ej] += 1\n    banned_down_ij[i-1][fj] -= 1\n\nbanned_up = [0] * (row * col)\nbanned_down = [0] * (row * col)\nbanned_left = [0] * (row * col)\nbanned_right = [0] * (row * col)\n\nfor i in range(col):\n    ru = banned_up_ij[i]\n    rd = banned_down_ij[i]\n    ri = row * i\n    banned_up[ri] = ru[0]\n    banned_down[ri] = rd[0]\n    for j in range(1, row):\n        banned_up[ri + j] = banned_up[ri + j - 1] + ru[j]\n        banned_down[ri + j] = banned_down[ri + j - 1] + rd[j]\n\nfor j in range(row):\n    rl = banned_left_ij[j]\n    rr = banned_right_ij[j]\n    banned_left[j] = rl[0]\n    banned_right[j] = rr[0]\n    for i in range(1, col):\n        ri0 = (i - 1) * row\n        ri1 = i * row\n        banned_left[ri1 + j] = banned_left[ri0 + j] + rl[i]\n        banned_right[ri1 + j] = banned_right[ri0 + j] + rr[i]\n\ns = row * y_dict[0] + x_dict[0]\nenable = [-1] * row + ([-1] + [0] * (row - 2) + [-1]) * (col - 2) + [-1] * row\n\nq = [s]\nmoves = [(-row, banned_up), (-1, banned_left), (1, banned_right), (row, banned_down)]\n\nwhile q:\n    c = q.pop()\n    if enable[c] == 1:\n        continue\n    elif enable[c] == -1:\n        print('INF')\n        exit()\n    enable[c] = 1\n    for dc, banned in moves:\n        if banned[c]:\n            continue\n        nc = c + dc\n        if enable[nc] == 1:\n            continue\n        q.append(nc)\n\nans = 0\nfor i in range(col):\n    ri = i * row\n    for j in range(row):\n        if enable[ri + j] != 1:\n            continue\n        t = y_list[i - 1]\n        b = y_list[i]\n        l = x_list[j - 1]\n        r = x_list[j]\n        ans += (b - t) * (r - l)\n\nprint(ans)"}
{"problem_id":"p02555","slow_code_col":"def main():\n\n    s = int(eval(input()))\n\n    mod = 10**9 + 7\n\n\n\n    dp = [0] * (s+1)\n\n    dp[0] = 1\n\n    for i in range(1, s+1):\n\n        for j in range(0, (i-3)+1):\n\n            dp[i] += dp[j]\n\n            dp[i] %= mod\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"def main():\n\n    s = int(eval(input()))\n\n    mod = 10**9 + 7\n\n\n\n    dp = [0] * (s+1)\n\n    dp[0] = 1\n\n#    for i in range(1, s+1):\n\n#        for j in range(0, (i-3)+1):\n\n#            dp[i] += dp[j]\n\n#            dp[i] %= mod\n\n    for i in range(1, s+1):\n\n        if i < 3:\n\n            dp[i] = 0\n\n        else:\n\n            dp[i] = dp[i-1] + dp[i-3]\n\n            dp[i] %= mod\n\n\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    s = int(eval(input()))\n    mod = 10**9 + 7\n\n    dp = [0] * (s+1)\n    dp[0] = 1\n\n    left = 0\n    total_sum = 0\n\n    for right in range(1, s+1):\n        total_sum += dp[right - 1]\n        if right >= 4:\n            total_sum -= dp[left]\n            left += 1\n        dp[right] = total_sum % mod\n\n    print(dp[-1])\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02792","slow_code_col":"def main():\n\n    n = int(eval(input()))\n\n    import numpy as np\n\n    ans = np.zeros((10,10))\n\n    for i in range(1,n+1):\n\n        h,t = str(i)[0],str(i)[-1]\n\n        ans[int(h)-1][int(t)-1]+=1\n\n    s = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            s += ans[i][j]*ans[j][i]\n\n\n\n    print((int(s)))\n\nif __name__ == \"__main__\":\n\n    main()","reference_code_col":"def main():\n\n    n = int(eval(input()))\n\n    dp = [[0 for i in range(10)] for i in range(10)]\n\n    for i in range(1,n+1):\n\n        h,t = int(str(i)[0]), int(str(i)[-1])\n\n        dp[h][t] += 1\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += dp[i][j] * dp[j][i]\n\n    print(ans)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    n = int(input())\n\n    import numpy as np\n\n    # Initialize a 10x10 matrix with zeros\n    ans = np.zeros((10, 10), dtype=int)\n\n    # Count occurrences of each digit pair\n    for i in range(1, n + 1):\n        h, t = divmod(i, 10)\n        ans[h][t] += 1\n\n    # Calculate the desired sum using vectorized operations\n    s = np.sum(ans * ans.T)\n\n    # Print the result\n    print(int(s))\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03078","slow_code_col":"def slove():\n\n    import sys\n\n    import heapq\n\n    import collections\n\n    input = sys.stdin.readline\n\n    x, y, z, k = list(map(int, input().rstrip('\\n').split()))\n\n    a = list(map(int, input().rstrip('\\n').split()))\n\n    a.sort(reverse=True)\n\n    b = list(map(int, input().rstrip('\\n').split()))\n\n    b.sort(reverse=True)\n\n    c = list(map(int, input().rstrip('\\n').split()))\n\n    c.sort(reverse=True)\n\n    q = [[-(a[0] + b[0] + c[0]), 0, 0, 0]]\n\n    heapq.heapify(q)\n\n    fq = collections.defaultdict(list)\n\n    fq[(-(a[0] + b[0] + c[0]), 0, 0, 0), 1] = 1\n\n    t = 0\n\n    for _ in range(k):\n\n        if len(q) != 0:\n\n            p = heapq.heappop(q)\n\n            t = p[0]\n\n            aq = p[1]\n\n            bq = p[2]\n\n            cq = p[3]\n\n            if aq + 1 < len(a):\n\n                if (-(a[aq+1] + b[bq] + c[cq]), aq+1, bq, cq) not in fq:\n\n                    heapq.heappush(q, [-(a[aq+1] + b[bq] + c[cq]), aq+1, bq, cq])\n\n                    fq[(-(a[aq+1] + b[bq] + c[cq]), aq+1, bq, cq)] = 1\n\n            if bq + 1 < len(b):\n\n                if (-(a[aq] + b[bq+1] + c[cq]), aq, bq+1, cq) not in fq:\n\n                    heapq.heappush(q, [-(a[aq] + b[bq+1] + c[cq]), aq, bq+1, cq])\n\n                    fq[(-(a[aq] + b[bq+1] + c[cq]), aq, bq+1, cq)] = 1\n\n            if cq + 1 < len(c):\n\n                if (-(a[aq] + b[bq] + c[cq+1]), aq, bq, cq+1) not in fq:\n\n                    heapq.heappush(q, [-(a[aq] + b[bq] + c[cq+1]), aq, bq, cq+1])\n\n                    fq[(-(a[aq] + b[bq] + c[cq+1]), aq, bq, cq+1)] = 1\n\n        print((-t))\n\n\n\n\n\nif __name__ == '__main__':\n\n    slove()\n","reference_code_col":"import sys\n\nimport collections\n\nimport heapq\n\n\n\n\n\ndef solve():\n\n    input = sys.stdin.readline\n\n    mod = 10 ** 9 + 7\n\n    x, y, z, k = list(map(int, input().rstrip('\\n').split()))\n\n    a = list(map(int, input().rstrip('\\n').split()))\n\n    b = list(map(int, input().rstrip('\\n').split()))\n\n    c = list(map(int, input().rstrip('\\n').split()))\n\n    a.sort(reverse=True)\n\n    b.sort(reverse=True)\n\n    c.sort(reverse=True)\n\n    ql = [[-(a[0] + b[0] + c[0]), 0, 0, 0]]\n\n    heapq.heapify(ql)\n\n    fq = collections.defaultdict(int)\n\n    fq[0, 0, 0]\n\n    for i in range(k):\n\n        s, ap, bp, cp = heapq.heappop(ql)\n\n        for app, bpp, cpp in ([[ap+1, bp, cp], [ap, bp+1, cp], [ap, bp, cp+1]]):\n\n            if app < x and bpp < y and cpp < z:\n\n                if (app, bpp, cpp) not in fq:\n\n                    heapq.heappush(ql, [-(a[app] + b[bpp] + c[cpp]), app, bpp, cpp])\n\n                    fq[app, bpp, cpp]\n\n        print((-s))\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n","model_generated_potentially_faster_code_col":"import sys\nimport heapq\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    x, y, z, k = map(int, data[:4])\n    a = list(map(int, data[4:4+x]))\n    b = list(map(int, data[4+x:4+x+y]))\n    c = list(map(int, data[4+x+y:]))\n    \n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    c.sort(reverse=True)\n    \n    q = [[-(a[0] + b[0] + c[0]), 0, 0, 0]]\n    heapq.heapify(q)\n    fq = defaultdict(int)\n    fq[(-(a[0] + b[0] + c[0]), 0, 0, 0)] = 1\n    \n    for _ in range(k):\n        if q:\n            p = heapq.heappop(q)\n            t = -p[0]\n            aq, bq, cq = p[1], p[2], p[3]\n            \n            if aq + 1 < len(a):\n                new_tuple = (-(a[aq+1] + b[bq] + c[cq]), aq+1, bq, cq)\n                if fq[new_tuple] == 0:\n                    heapq.heappush(q, new_tuple)\n                    fq[new_tuple] = 1\n            \n            if bq + 1 < len(b):\n                new_tuple = (-(a[aq] + b[bq+1] + c[cq]), aq, bq+1, cq)\n                if fq[new_tuple] == 0:\n                    heapq.heappush(q, new_tuple)\n                    fq[new_tuple] = 1\n            \n            if cq + 1 < len(c):\n                new_tuple = (-(a[aq] + b[bq] + c[cq+1]), aq, bq, cq+1)\n                if fq[new_tuple] == 0:\n                    heapq.heappush(q, new_tuple)\n                    fq[new_tuple] = 1\n        \n        print(t)\n\nif __name__ == \"__main__\":\n    solve()"}
{"problem_id":"p00500","slow_code_col":"N = int(input())\n\nscore = [list(map(int, input().split())) for _ in range(N)]\n\nplayers = [0 for _ in range(N)]\n\nfor play in list(zip(*score)):\n\n    for i, p in enumerate(play):\n\n        if play.count(p) == 1:\n\n            players[i] += p\n\nprint(*players, sep='\\n')\n","reference_code_col":"N = int(input())\n\nscore = [input().split() for _ in range(N)]\n\nplayers = [0]*N\n\nfor play in list(zip(*score)):\n\n    for i, p in enumerate(play):\n\n        if play.count(p) == 1:\n\n            players[i] += int(p)\n\nprint(*players, sep='\\n')\n","model_generated_potentially_faster_code_col":"N = int(input())\n\nscore = [list(map(int, input().split())) for _ in range(N)]\n\nplayers = [0 for _ in range(N)]\nplayer_scores = [[] for _ in range(N)]\n\nfor play in zip(*score):\n    counts = {}\n    for i, p in enumerate(play):\n        if p not in counts:\n            counts[p] = [i]\n        else:\n            counts[p].append(i)\n\n    for p, indices in counts.items():\n        if len(indices) == 1:\n            players[indices[0]] += p\n\nprint(*players, sep='\\n')"}
{"problem_id":"p03170","slow_code_col":"n,k = list(map(int,input().split()))\n\narr = list(map(int,input().split()))\n\n\n\ndp = [False]*(k+1)\n\n\n\nfor stones in range(k+1):\n\n    for x in arr:\n\n        if stones >= x and dp[stones-x] == False:\n\n            dp[stones] = True\n\n\n\nif dp[k]:\n\n    print(\"First\")\n\nelse:\n\n    print(\"Second\")\n","reference_code_col":"N,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\n\n\ndp = [False]*(K+1)\n\n\n\nfor i in range(K+1):\n\n    for j in range(N):\n\n        if i-A[j]>=0 and dp[i-A[j]] == False:\n\n            dp[i] = True\n\n\n\n        \n\nif dp[K]:\n\n    print(\"First\")\n\nelse:\n\n    print(\"Second\")","model_generated_potentially_faster_code_col":"n, k = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Calculate the XOR of all stones in the array\nxor_result = 0\nfor stone in arr:\n    xor_result ^= stone\n\n# If the XOR result is zero, the second player wins; otherwise, the first player wins\nif xor_result == 0:\n    print(\"Second\")\nelse:\n    print(\"First\")"}
{"problem_id":"p02780","slow_code_col":"import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    \u6587\u5b57\u5217\u3067\u4e0e\u3048\u3089\u308c\u305f\u76e4\u9762\u3092\u8aad\u307f\u53d6\u308b\u7528\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A\u5217\u3001B\u5217\u304c\u4e0e\u3048\u3089\u308c\u308b\u3088\u3046\u306a\u3068\u304d\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) \/ 2\n\n\n\n\n\n\n\n\n\nimport numpy as np\n\nP_mean = np.array([ret_mean(p) for p in P])\n\nP_accum = np.zeros(N+1)\n\nP_accum[1:] = P_mean.cumsum()\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum[j] - P_accum[i])\n\nprint(ans)\n","reference_code_col":"import sys\n\nread = sys.stdin.readline\n\n\n\n\n\ndef read_ints():\n\n    return list(map(int, read().split()))\n\n\n\n\n\ndef read_a_int():\n\n    return int(read())\n\n\n\n\n\ndef read_matrix(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\n\n\n\ndef read_map(H):\n\n    '''\n\n    H is number of rows\n\n    \u6587\u5b57\u5217\u3067\u4e0e\u3048\u3089\u308c\u305f\u76e4\u9762\u3092\u8aad\u307f\u53d6\u308b\u7528\n\n    '''\n\n    return [read()[:-1] for _ in range(H)]\n\n\n\n\n\ndef read_tuple(H):\n\n    '''\n\n    H is number of rows\n\n    '''\n\n    ret = []\n\n    for _ in range(H):\n\n        ret.append(tuple(map(int, read().split())))\n\n    return ret\n\n\n\n\n\ndef read_col(H, n_cols):\n\n    '''\n\n    H is number of rows\n\n    n_cols is number of cols\n\n\n\n    A\u5217\u3001B\u5217\u304c\u4e0e\u3048\u3089\u308c\u308b\u3088\u3046\u306a\u3068\u304d\n\n    '''\n\n    ret = [[] for _ in range(n_cols)]\n\n    for _ in range(H):\n\n        tmp = list(map(int, read().split()))\n\n        for col in range(n_cols):\n\n            ret[col].append(tmp[col])\n\n\n\n    return ret\n\n\n\n\n\nN, K = read_ints()\n\nP = read_ints()\n\n\n\n\n\ndef ret_mean(X):\n\n    return (X + 1) \/ 2\n\n\n\n\n\n\n\nclass cumsum1d:\n\n    def __init__(self, ls: list):\n\n        '''\n\n        1\u6b21\u5143\u30ea\u30b9\u30c8\u3092\u53d7\u3051\u53d6\u308b\n\n        '''\n\n        from itertools import accumulate\n\n        self.ls_accum = [0] + list(accumulate(ls))\n\n\n\n    def total(self, i, j):\n\n        # \u3082\u3068\u306e\u914d\u5217ls\u306b\u304a\u3051\u308b[i,j)\u306e\u4e2d\u5408\u8a08\n\n        return self.ls_accum[j] - self.ls_accum[i]\n\n      \n\nP_mean = [ret_mean(p) for p in P]\n\nP_accum = cumsum1d(P_mean)\n\n\n\nans = 0\n\n# print(P_accum)\n\nfor i in range(N - K + 1):\n\n    j = i + K\n\n    ans = max(ans, P_accum.total(i,j))\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import sys\nfrom typing import List\n\nread = sys.stdin.read\n\n\ndef read_ints() -> List[int]:\n    return list(map(int, read().split()))\n\n\ndef kadane_max_average(nums: List[float], k: int) -> float:\n    max_avg = -float('inf')\n    current_sum = 0.0\n\n    for i in range(len(nums)):\n        if i < k:\n            current_sum += nums[i]\n        else:\n            current_sum += nums[i] - nums[i - k]\n\n        if i >= k - 1:\n            avg = current_sum \/ k\n            max_avg = max(max_avg, avg)\n\n    return max_avg\n\n\nN, K = read_ints()\nP = read_ints()\n\nP_mean = [(p + 1) \/ 2 for p in P]\nmax_avg = kadane_max_average(P_mean, K)\nprint(max_avg)"}
{"problem_id":"p02419","slow_code_col":"W = input().lower()\n\ns = []\n\nwhile True:\n\n    T = list(map(str, input().split()))\n\n    if(T[0] == \"END_OF_TEXT\"):\n\n        break\n\n    else:\n\n        for i in range(len(T)):\n\n            s.append(T[i].lower())\n\nans = 0\n\nfor i in range(len(s)):\n\n    if(s[i] == W):\n\n        ans += 1\n\nprint(ans)","reference_code_col":"W = input().lower()\n\ns = []\n\nans = 0\n\nwhile True:\n\n    T = list(map(str, input().split()))\n\n    if(T[0] == \"END_OF_TEXT\"):\n\n        break\n\n    else:\n\n        for i in range(len(T)):\n\n            if(W == T[i].lower()):\n\n                ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"W = input().lower()\ns = [word.lower() for line in iter(input, 'END_OF_TEXT') for word in line.split()]\nprint(s.count(W))"}
{"problem_id":"p02702","slow_code_col":"import numpy as np\n\n\n\ns = input()[::-1]\n\nlength = len(s)\n\na = np.zeros(length, dtype=int)\n\nd = np.zeros(length, dtype=int)\n\nans = np.zeros(2019, dtype=int)\n\nx = 10\n\n\n\na[0] = int(s[0])\n\nd[0] = a[0]\n\nans[d[0]] += 1\n\n\n\nfor i in range(1, length):\n\n    a[i] = int(s[i]) * x % 2019\n\n    d[i] = (d[i-1] + a[i]) % 2019\n\n    ans[d[i]] += 1\n\n    x = x * 10 % 2019\n\n\n\nans_c = ans[np.nonzero(ans)]\n\n\n\nprint((int(sum([ans_c[i] * (ans_c[i]-1) for i in range(ans_c.shape[0])]) \/ 2) + ans[0]))","reference_code_col":"s = input()[::-1]\n\nlength = len(s)\n\na = [0] * length\n\nd = [0] * length\n\nans = [0] * 2019\n\nx = 10\n\n\n\na[0] = int(s[0])\n\nd[0] = a[0]\n\nans[d[0]] += 1\n\n\n\nfor i in range(1, length):\n\n    a[i] = int(s[i]) * x % 2019\n\n    d[i] = (d[i-1] + a[i]) % 2019\n\n    ans[d[i]] += 1\n\n    x = x * 10 % 2019\n\n\n\nprint((int(sum([ans[i] * (ans[i]-1) for i in range(2019)]) \/ 2) + ans[0]))","model_generated_potentially_faster_code_col":"import numpy as np\n\n\ndef count_pairs(arr):\n    counts = np.bincount(arr)\n    return np.sum(counts[:-1] * (counts[:-1] - 1) \/\/ 2)\n\n\ns = input()[::-1]\nlength = len(s)\nx = 10 ** np.arange(length) % 2019\nvalues = np.mod(np.cumsum(x * np.array(list(map(int, s)))), 2019)\nans = np.bincount(values)\nprint(count_pairs(ans) + ans[0])"}
{"problem_id":"p02773","slow_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\n\nS = read().split()\n\n\n\nS = sorted(S)\n\nls = [[] for i in range(N + 1)]\n\nmax_num = 0\n\nleft = 0\n\nright = 0\n\nwhile right < N:\n\n    while right < N and S[left] == S[right]:\n\n        right += 1\n\n    if (right  - left) >= max_num:\n\n        ls[right - left].append(S[left].decode())\n\n        max_num = right - left\n\n    left = right\n\n    \n\nprint(('\\n'.join(ls[max_num])))\n","reference_code_col":"from collections import Counter\n\n\n\nimport sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\n\nS = read().split()\n\n\n\nres = []\n\nc = Counter(S)\n\nmax_num = c.most_common(1)[0][1]\n\nfor i, j in list(c.items()):\n\n    if j == max_num:\n\n        res.append(i)\n\n        \n\nres.sort()\n\n\n\n        \n\nprint(('\\n'.join(list([x.decode() for x in res]))))\n","model_generated_potentially_faster_code_col":"import sys\n\n# Read input efficiently\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\nS = readline().strip().split()\n\n# Sort the strings\nS.sort()\n\n# Initialize variables\nls = [[] for _ in range(N + 1)]\nmax_num = 0\nleft = 0\nright = 0\n\n# Process the sorted list to find the longest group of identical strings\nwhile right < N:\n    while right < N and S[left] == S[right]:\n        right += 1\n    \n    # Append the current group to the result list\n    if (right - left) >= max_num:\n        ls[right - left].append(S[left])\n        max_num = right - left\n    \n    left = right\n\n# Output the result\nprint('\\n'.join(' '.join(map(str, s)) for s in ls[max_num]))"}
{"problem_id":"p03164","slow_code_col":"# temp\n\nn,w = list(map(int,input().split()))\n\nwv = [tuple(map(int,input().split())) for i in range(n)]\n\n\n\ndp = [0] + [float(\"inf\")]*(10**5)\n\nfor i in range(n):\n\n    for j in range(10**5,wv[i][1]-1,-1):\n\n        dp[j] = min(dp[j],dp[j-wv[i][1]]+wv[i][0])\n\n\n\nres = 0\n\nfor v,e in enumerate(dp):\n\n    if e <= w:\n\n        res = v\n\nprint(res)","reference_code_col":"# dpE - Knapsack 2\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    n, W = tuple(map(int, input().rstrip().split()))\n\n    A = tuple(tuple(map(int, input().rstrip().split())) for _ in range(n))\n\n    _, v = list(zip(*A))\n\n    lim = sum(v)\n\n    dp = [0] + [float(\"inf\")] * lim\n\n    for i in range(n):\n\n        for j in range(lim, A[i][1] - 1, -1):\n\n            dp[j] = min(dp[j], dp[j - A[i][1]] + A[i][0])\n\n    ans = max(v for v, w in enumerate(dp) if w <= W)\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()","model_generated_potentially_faster_code_col":"n, w = map(int, input().split())\n\nwv = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Reduce the size of the DP array to w+1\ndp = [0] + [float(\"inf\")] * w\n\nfor weight, value in wv:\n    # Iterate from w down to weight to avoid redundant updates\n    for j in range(w, weight - 1, -1):\n        dp[j] = min(dp[j], dp[j - weight] + value)\n\n# Find the maximum value that doesn't exceed the weight limit\nmax_value = next((i for i in range(w + 1) if dp[i] <= w), None)\n\nprint(max_value)"}
{"problem_id":"p02555","slow_code_col":"def main():\n\n  n = int(eval(input()))\n\n  \n\n  dp = [0]*(n+1)\n\n  dp[0] = 1\n\n  mod = pow(10, 9) + 7\n\n  for i in range(n+1):\n\n    for j in range(i-2):\n\n      dp[i] += dp[j]\n\n      dp[i] %= mod\n\n  \n\n  print((dp[n]))\n\n\n\nif __name__ == \"__main__\":\n\n  main()","reference_code_col":"def main():\n\n  n = int(eval(input()))\n\n  \n\n  dp = [0]*(n+1)\n\n  dp[0] = 1\n\n  mod = pow(10, 9) + 7\n\n  for i in range(3, n+1):\n\n    dp[i] = dp[i-1] + dp[i-3]\n\n    dp[i] %= mod\n\n  \n\n  print((dp[n]))\n\n\n\nif __name__ == \"__main__\":\n\n  main()","model_generated_potentially_faster_code_col":"def fibonacci(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, (a + b) % (10 ** 9 + 7)\n        return b\n\n\nif __name__ == \"__main__\":\n    n = int(eval(input()))\n    print(fibonacci(n))"}
{"problem_id":"p03253","slow_code_col":"# -*- coding: utf-8 -*-\n\n\n\n\"\"\"\n\n\u53c2\u8003\uff1ahttp:\/\/drken1215.hatenablog.com\/entry\/2018\/09\/23\/224100\n\n\u3000\u3000\u3000http:\/\/tutuz.hateblo.jp\/entry\/2018\/09\/24\/121248\n\n\u30fb\u7d20\u56e0\u6570\u5206\u89e3\u3068\u91cd\u8907\u7d44\u307f\u5408\u308f\u305b\n\n\u30fb\u6bce\u56de\u968e\u4e57\u3084\u308b\u3068\u6b7b\u306c\u304b\u3089\u968e\u4e57\u3068\u9006\u5143\u306e\u30c6\u30fc\u30d6\u30eb\u4f5c\u308b(\u5fd8\u308c\u3066\u305f)\n\n\"\"\"\n\n\n\nfrom collections import defaultdict\n\nfrom math import sqrt\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\ndef fact_prime(num):\n\n    d = defaultdict(int)\n\n    # \u7d42\u70b9\u306f\u30eb\u30fc\u30c8\u5207\u308a\u6368\u3066+1\n\n    end = int(sqrt(num)) + 1\n\n    for i in range(2, end+1):\n\n        cnt = 0\n\n        # \u7d20\u56e0\u6570\u5206\u89e3\uff1a\u5c0f\u3055\u3044\u65b9\u304b\u3089\u5272\u308c\u308b\u3060\u3051\u5272\u3063\u3066\u7d20\u6570\u3092\u30ab\u30a6\u30f3\u30c8\n\n        while num % i == 0:\n\n            num \/\/= i\n\n            d[i] += 1\n\n        # 1\u307e\u3067\u6765\u305f\u3089\u7d42\u4e86\n\n        if num == 1:\n\n            break\n\n    # \u6700\u5f8c\u307e\u3067\u305d\u306e\u307e\u307e\u6765\u305f\u3084\u3064\u306fnum\u304c\u7d20\u6570(\u305f\u3060\u30571^1\u306f1^0\u306a\u306e\u3067\u6570\u306b\u5165\u308c\u306a\u3044)\n\n    if num != 1:\n\n        d[num] += 1\n\n    return d\n\n\n\n# \u3068\u308a\u3042\u3048\u305av+N-1\u304c\u53ce\u307e\u308c\u3070\u3044\u3044\u306f\u305a\n\nMAX = 10 ** 5 * 2\n\n# \u4e88\u3081\u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\u306b\u5fc5\u8981\u306a\u968e\u4e57\u3068\u9006\u5143\u306e\u30c6\u30fc\u30d6\u30eb\u3092\u4f5c\u3063\u3066\u304a\u304f\n\nfactorial = [1] * (MAX)\n\nfactorial[0] = factorial[1] = 1\n\nfor i in range(2, MAX):\n\n    factorial[i] = factorial[i-1] * i % MOD\n\n\n\ninverse = [1] * (MAX)\n\n# pow\u306b\u7b2c\u4e09\u5f15\u6570\u5165\u308c\u308b\u3068\u51aa\u4e57\u306emod\u4ed8\u8a08\u7b97\u3092\u9ad8\u901f\u306b\u3084\u3063\u3066\u304f\u308c\u308b\n\ninverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n\nfor i in range(MAX-2, 0, -1):\n\n    # \u6700\u5f8c\u304b\u3089\u623b\u3063\u3066\u3044\u304f\u3053\u306e\u30eb\u30fc\u30d7\u306a\u3089H+W\u56depow\u3059\u308b\u3088\u308a\u51e6\u7406\u304c\u901f\u3044\n\n    inverse[i] = inverse[i+1] * (i+1) % MOD\n\n\n\n# \u7d44\u307f\u5408\u308f\u305b\u306e\u6570\n\ndef nCr(n, r):\n\n    # 10C7 = 10C3\n\n    r = min(r, n-r)\n\n    # \u5206\u5b50\u306e\u8a08\u7b97\n\n    numerator = factorial[n]\n\n    # \u5206\u6bcd\u306e\u8a08\u7b97\n\n    denominator = inverse[r] * inverse[n-r] % MOD\n\n    return numerator * denominator % MOD\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\n# d = fact_prime(M)\n\n# print(d)\n\nans = 1\n\nfor k, v in list(fact_prime(M).items()):\n\n    # \u91cd\u8907\u7d44\u307f\u5408\u308f\u305b\n\n    # v\u500b\u306ek\u3068N-1\u500b\u306e\u4ed5\u5207\u308a\u304b\u3089\u3001v\u500b\u3092\u4e26\u3079\u308b(v+N-1\u500b\u306e\u30de\u30b9\u304b\u3089v\u500b\u3092\u9078\u3073\u51fa\u3059\u7d44\u307f\u5408\u308f\u305b)\n\n    ans = (ans * nCr(v+N-1, v)) % MOD\n\nprint(ans)\n","reference_code_col":"# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x \/\/ y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = float('inf')\n\nMOD = 10 ** 9 + 7\n\n\n\ndef factorize(num: int) -> dict:\n\n    \"\"\" \u7d20\u56e0\u6570\u5206\u89e3 \"\"\"\n\n    from math import sqrt\n\n    from collections import Counter\n\n\n\n    d = Counter()\n\n    # \u7d42\u70b9\u306f\u30eb\u30fc\u30c8\u5207\u308a\u6368\u3066+1\n\n    for i in range(2, int(sqrt(num))+1):\n\n        # \u7d20\u56e0\u6570\u5206\u89e3\uff1a\u5c0f\u3055\u3044\u65b9\u304b\u3089\u5272\u308c\u308b\u3060\u3051\u5272\u3063\u3066\u7d20\u6570\u3092\u30ab\u30a6\u30f3\u30c8\n\n        while num % i == 0:\n\n            num \/\/= i\n\n            d[i] += 1\n\n        # 1\u307e\u3067\u5206\u89e3\u3057\u305f\u3089\u7d42\u4e86\n\n        if num == 1:\n\n            break\n\n    # \u6700\u5f8c\u306b\u6b8b\u3063\u305fnum\u306f\u7d20\u6570(\u305f\u3060\u30571^1\u306f1^0\u306a\u306e\u3067\u6570\u306b\u5165\u308c\u306a\u3044)\n\n    if num != 1:\n\n        d[num] += 1\n\n    return d\n\n\n\nclass FactInvMOD:\n\n    \"\"\" \u968e\u4e57\u305f\u304f\u3055\u3093\u4f7f\u3046\u6642\u7528\u306e\u30c6\u30fc\u30d6\u30eb\u6e96\u5099 \"\"\"\n\n\n\n    def __init__(self, MAX, MOD):\n\n        \"\"\" MAX\uff1a\u968e\u4e57\u306b\u4f7f\u3046\u6570\u5024\u306e\u6700\u5927\u4ee5\u4e0a\u307e\u3067\u4f5c\u308b \"\"\"\n\n        \n\n        MAX += 1\n\n        self.MAX = MAX\n\n        self.MOD = MOD\n\n        # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\n\n        factorial = [1] * MAX\n\n        factorial[0] = factorial[1] = 1\n\n        for i in range(2, MAX):\n\n            factorial[i] = factorial[i-1] * i % MOD\n\n        # \u968e\u4e57\u306e\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\n        inverse = [1] * MAX\n\n        # pow\u306b\u7b2c\u4e09\u5f15\u6570\u5165\u308c\u308b\u3068\u51aa\u4e57\u306emod\u4ed8\u8a08\u7b97\u3092\u9ad8\u901f\u306b\u3084\u3063\u3066\u304f\u308c\u308b\n\n        inverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n\n        for i in range(MAX-2, 0, -1):\n\n            # \u6700\u5f8c\u304b\u3089\u623b\u3063\u3066\u3044\u304f\u3053\u306e\u30eb\u30fc\u30d7\u306a\u3089MAX\u56depow\u3059\u308b\u3088\u308a\u51e6\u7406\u304c\u901f\u3044\n\n            inverse[i] = inverse[i+1] * (i+1) % MOD\n\n        self.fact = factorial\n\n        self.inv = inverse\n\n    \n\n    def nCr(self, n, r):\n\n        \"\"\" \u7d44\u307f\u5408\u308f\u305b\u306e\u6570 (\u5fc5\u8981\u306a\u968e\u4e57\u3068\u9006\u5143\u306e\u30c6\u30fc\u30d6\u30eb\u3092\u4e8b\u524d\u306b\u4f5c\u3063\u3066\u304a\u304f) \"\"\"\n\n\n\n        if n < r: return 0\n\n        # 10C7 = 10C3\n\n        r = min(r, n-r)\n\n        # \u5206\u5b50\u306e\u8a08\u7b97\n\n        numerator = self.fact[n]\n\n        # \u5206\u6bcd\u306e\u8a08\u7b97\n\n        denominator = self.inv[r] * self.inv[n-r] % self.MOD\n\n        return numerator * denominator % self.MOD\n\n\n\n    def nPr(self, n, r):\n\n        \"\"\" \u9806\u5217 \"\"\"\n\n\n\n        if n < r: return 0\n\n        return self.fact[n] * self.inv[n-r] % self.MOD\n\n\n\n    def nHr(self, n, r):\n\n        \"\"\" \u91cd\u8907\u7d44\u307f\u5408\u308f\u305b \"\"\"\n\n\n\n        # r\u500b\u9078\u3076\u3068\u3053\u308d\u306bN-1\u500b\u306e\u4ed5\u5207\u308a\u3092\u5165\u308c\u308b\n\n        return self.nCr(r+n-1, r)\n\n\n\nN, M = MAP()\n\n\n\nd = factorize(M)\n\n\n\n# \u4f8b\u5916\u51e6\u7406\n\nif not d:\n\n    print((1))\n\n    exit()\n\n\n\nMAX = N + max(d.values())\n\nfim = FactInvMOD(MAX, MOD)\n\nans = 1\n\nfor k, v in list(d.items()):\n\n    ans *= fim.nHr(N, v)\n\n    ans %= MOD\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nMOD = 10 ** 9 + 7\n\n# Precompute factorials and their modular inverses\nMAX = 10 ** 5 * 2\nfactorial = [1] * MAX\nfactorial_inv = [1] * MAX\n\nfor i in range(1, MAX):\n    factorial[i] = factorial[i - 1] * i % MOD\n    factorial_inv[i] = pow(factorial[i], MOD - 2, MOD)\n\n# Function to compute combinations using precomputed factorials\ndef nCr(n, r):\n    if r > n:\n        return 0\n    return factorial[n] * factorial_inv[r] * factorial_inv[n - r] % MOD\n\n# Input\nN, M = map(int, input().split())\n\n# Prime factorization\ndef fact_prime(num):\n    d = {}\n    end = int(num**0.5) + 1\n    for i in range(2, end):\n        while num % i == 0:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n            num \/\/= i\n    if num > 1:\n        d[num] = 1\n    return d\n\n# Calculate the result\nans = 1\nfor p, exp in fact_prime(M).items():\n    ans = ans * nCr(exp + N - 1, exp) % MOD\n\nprint(ans)"}
{"problem_id":"p02264","slow_code_col":"class Queue:\n\n    def __init__(self,values):\n\n        self.values = values\n\n\n\n    def empty(self):\n\n        if len(self.values) == 0:\n\n            return True\n\n        else:\n\n            return False\n\n\n\n    def enqueue(self,v):\n\n        self.values.append(v)\n\n\n\n    def dequeue(self):\n\n        if len(self.values) <= 0:\n\n            raise\n\n        else:\n\n            v = self.values[0]\n\n            del self.values[0]\n\n            return v\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nprocesses = []\n\nfor i in range(n):\n\n    n,t = input().split(' ')\n\n    processes.append((n,int(t)))\n\n\n\nqueue = Queue(processes)\n\n\n\nclock = 0\n\ndone = []\n\nwhile not queue.empty():\n\n    p = queue.dequeue()\n\n    n = p[0]\n\n    t = p[1]\n\n    if t <= q:\n\n        clock+=t\n\n        done.append((n,clock))\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        clock+=q\n\n\n\nfor p in done:\n\n    print(p[0],p[1])","reference_code_col":"class Queue:\n\n    def __init__(self,l):\n\n        self.values = []\n\n        self.l = l\n\n        for _ in range(l):\n\n            self.values.append(None)\n\n        self.head = 0\n\n        self.tail = 0\n\n    def inc(self,n):\n\n        if n+1 >= self.l:\n\n            return 0\n\n        else:\n\n            return n+1\n\n    def enqueue(self,v):\n\n        if self.inc(self.head) == self.tail:\n\n            print('overflow')\n\n            exit()\n\n        self.values[self.head] = v\n\n        self.head = self.inc(self.head)\n\n    def dequeue(self):\n\n        if self.head == self.tail:\n\n            print('underflow')\n\n            exit()\n\n        v = self.values[self.tail]\n\n        self.tail = self.inc(self.tail)\n\n        return v\n\n    def size(self):\n\n        if self.head >= self.tail:\n\n            return self.head-self.tail\n\n        else:\n\n            self.head + (self.l-self.tail)\n\n\n\nn,q = list(map(int,input().split(' ')))\n\nqueue = Queue(200000)\n\nfor _ in range(n):\n\n    n,t = input().split(' ')\n\n    t = int(t)\n\n    queue.enqueue((n,t))\n\n\n\nc = 0\n\nwhile queue.size()>0:\n\n    n,t = queue.dequeue()\n\n    if t <= q:\n\n        c += t\n\n        print(n,c)\n\n    else:\n\n        queue.enqueue((n,t-q))\n\n        c += q","model_generated_potentially_faster_code_col":"from collections import deque\n\nclass Queue:\n    def __init__(self):\n        self.values = deque()\n    \n    def empty(self):\n        return len(self.values) == 0\n    \n    def enqueue(self, v):\n        self.values.append(v)\n    \n    def dequeue(self):\n        if self.empty():\n            raise IndexError(\"Dequeue from an empty queue\")\n        return self.values.popleft()\n\nn, q = map(int, input().split())\nprocesses = [tuple(input().split()) for _ in range(n)]\nprocesses = [(name, int(time)) for name, time in processes]\n\nqueue = Queue()\nfor name, time in processes:\n    queue.enqueue((name, time))\n\nclock = 0\ndone = []\n\nwhile not queue.empty():\n    name, time = queue.dequeue()\n    if time <= q:\n        clock += time\n        done.append((name, clock))\n    else:\n        queue.enqueue((name, time - q))\n        clock += q\n\nfor name, finish_time in done:\n    print(name, finish_time)"}
{"problem_id":"p03371","slow_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n# C\u3092\u8cb7\u3063\u305f\u500b\u6570\u3068A\u3001B\u5358\u54c1\u3067\u8cb7\u3063\u305f\u5834\u5408\u306e\u30b3\u30b9\u30c8\u3092\u611a\u76f4\u306b\u8a66\u3059\n\ntotal = 1<<60\n\nfor i in range(10**5+1):\n\n  cost = 2*C*i + max(X-i, 0)*A + max(Y-i, 0)*B\n\n  total = min(cost, total)\n\n\n\nprint(total)","reference_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nif (A+B) <= 2*C: # \u5358\u54c1\u3060\u3051\u3067\u8cfc\u5165\n\n  print((X*A + Y*B))\n\nelse:\n\n  # AB\u3092\u8cb7\u3044\u6b8b\u308a\u3092\u5358\u54c1\u3067\u88dc\u3046\n\n  if X >= Y:\n\n    # AB\u3067Y\u306f\u8cc4\u3048\u308b\n\n    print((min(X*2*C, Y*2*C + A*(X-Y))))\n\n  else:\n\n    # AB\u3067X\u306f\u8cc4\u3048\u308b\n\n    print((min(Y*2*C, X*(2*C)+B*(Y-X))))","model_generated_potentially_faster_code_col":"A, B, C, X, Y = map(int, input().split())\n\n# Calculate the maximum number of items we can buy\nmax_items = min(X \/\/ A, Y \/\/ B)\n\n# Iterate over the possible number of items we can buy\nfor i in range(max_items + 1):\n    # Calculate the remaining items needed after buying i items\n    remaining_items = C - i\n    \n    # Calculate the cost of buying i items and the remaining items separately\n    cost_i = i * A\n    cost_remaining = max(remaining_items - X \/\/ A, 0) * B\n    \n    # Update the total cost if this combination is cheaper\n    total = min(total, cost_i + cost_remaining)\n\nprint(total)"}
{"problem_id":"p02983","slow_code_col":"l,r = list(map(int,input().split()))\n\n\n\nif r - l > 2019:\n\n    print((0))\n\nelse:\n\n    tres = 2019\n\n    for i in range(l,r):\n\n        for j in range(i+1,r+1):\n\n            mod = (i % 2019) * (j % 2019) % 2019\n\n            tres = min(tres,mod)\n\n    print(tres)\n","reference_code_col":"l,r = list(map(int,input().split()))\n\n\n\nif r - l > 2019:\n\n    print((0))\n\nelse:\n\n    tres = 2019\n\n    for i in range(l,r):\n\n        for j in range(i+1,r+1):\n\n            mod = (i % 2019) * (j % 2019) % 2019\n\n            tres = min(tres,mod)\n\n            if tres == 0:\n\n                break\n\n        if tres == 0:\n\n            break\n\n    print(tres)\n","model_generated_potentially_faster_code_col":"def find_min_mod_product(l, r):\n    MOD = 2019\n\n    # Precompute powers of 2018 modulo 2019\n    powers_of_2018 = [pow(2018, i, MOD) for i in range(MOD)]\n\n    # Find the smallest value in the range [l, r]\n    min_value = min(l, r)\n\n    # Calculate the minimum product using precomputed powers\n    min_product = (min_value * powers_of_2018[min_value]) % MOD\n\n    return min_product\n\n# Read input\nl, r = map(int, input().split())\n\n# Print result\nprint(find_min_mod_product(l, r))"}
{"problem_id":"p03086","slow_code_col":"# 2019-11-12 22:21:08(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\nimport itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# from scipy.misc import comb # float\n\n# import numpy as np \n\n\n\ndef main():\n\n    s = sys.stdin.readline().rstrip()\n\n    \n\n    all_words = []\n\n    for i in range(1, len(s) + 1):\n\n        for letters in itertools.product('ATCG', repeat=i):\n\n            word = ''.join(letters)\n\n            all_words.append(word)\n\n    \n\n    for i in range(len(all_words)-1, 0-1, -1):\n\n        if all_words[i] in s:\n\n            print((len(all_words[i])))\n\n            sys.exit()\n\n    print((0))\n\n\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"# 2019-11-12 22:21:08(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\n# import itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# from scipy.misc import comb # float\n\n# import numpy as np \n\n\n\ndef main():\n\n    s = sys.stdin.readline().rstrip()\n\n    \n\n    permitted = 'ACGT'\n\n    continuous_count = []\n\n    count = 0\n\n\n\n    for i in range(len(s)):\n\n        char = s[i]\n\n        if char in permitted:\n\n            count += 1\n\n        else:\n\n            continuous_count.append(count)\n\n            count = 0\n\n        if i == len(s) - 1:\n\n            continuous_count.append(count)\n\n    \n\n    if not continuous_count:\n\n        print((len(s)))\n\n    else:\n\n        print((max(continuous_count)))\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    s_set = set(s)\n    \n    max_length = len(s)\n    for length in range(1, max_length + 1):\n        for letters in itertools.product('ATCG', repeat=length):\n            word = ''.join(letters)\n            if all(char in s_set for char in word):\n                print(length)\n                return\n    \n    print(0)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03425","slow_code_col":"def resolve():\n\n    '''\n\n    code here\n\n    '''\n\n    import collections\n\n    import itertools\n\n    import numpy as np\n\n    N = int(eval(input()))\n\n    Ss = [input()[0] for _ in range(N)]\n\n\n\n    march_letter = [item for item in Ss if item in ['M', 'A', 'R', 'C', 'H']]\n\n    march_cnt = collections.Counter(march_letter)\n\n\n\n    if len(march_cnt) < 3:\n\n        res = 0\n\n    else:\n\n        res_list = itertools.combinations(list(march_cnt.values()),3)\n\n\n\n        res = 0\n\n        for element in res_list:\n\n            res += np.prod(np.array(element))\n\n    print(res)\n\n\n\nif __name__ == \"__main__\":\n\n    resolve()\n","reference_code_col":"def resolve():\n\n    '''\n\n    code here\n\n    '''\n\n    import collections\n\n    import itertools\n\n    N = int(eval(input()))\n\n    Ss = [input()[0] for _ in range(N)]\n\n\n\n    march_letter = [item for item in Ss if item in ['M', 'A', 'R', 'C', 'H']]\n\n    march_cnt = collections.Counter(march_letter)\n\n\n\n    if len(march_cnt) < 3:\n\n        res = 0\n\n    else:\n\n        res_list = itertools.combinations(list(march_cnt.values()),3)\n\n\n\n        res = 0\n\n        for element in res_list:\n\n            res += element[0]*element[1]*element[2]\n\n    print(res)\n\n\n\nif __name__ == \"__main__\":\n\n    resolve()\n","model_generated_potentially_faster_code_col":"def resolve():\n    import numpy as np\n\n    # Read input\n    N = int(input())\n    Ss = [input()[0] for _ in range(N)]\n\n    # Filter out non-march letters and count occurrences\n    march_letter = [item for item in Ss if item in {'M', 'A', 'R', 'C', 'H'}]\n    march_cnt = {letter: march_letter.count(letter) for letter in {'M', 'A', 'R', 'C', 'H'}}\n\n    # Check if there are at least three different letters\n    if len(march_cnt) < 3:\n        res = 0\n    else:\n        # Calculate the number of valid combinations\n        res = sum(np.prod([march_cnt[letter] for letter in comb]) for comb in itertools.combinations(march_cnt.keys(), 3))\n\n    print(res)\n\nif __name__ == \"__main__\":\n    resolve()"}
{"problem_id":"p03309","slow_code_col":"#                         author:  kagemeka \n\n#                         created: 2019-11-08 14:51:29(JST)\n\n## internal modules\n\nimport sys\n\n# import collections\n\n# import math\n\n# import string\n\n# import bisect\n\n# import re\n\n# import itertools\n\nimport statistics\n\n# import functools\n\n# import operator\n\n## external modules\n\n# import scipy.special   # if use comb function on AtCoder, \n\n# import scipy.misc      # select scipy.misc.comb (old version) \n\n\n\ndef main():\n\n    n, *a = (int(x) for x in sys.stdin.read().split())\n\n    \n\n    for i in range(n):\n\n        a[i] -= (i + 1)\n\n\n\n    if n % 2 != 0:\n\n        b = statistics.median(a)\n\n    else:\n\n        if a.count(statistics.median_high(a)) >= a.count(statistics.median_low(a)):\n\n            b = statistics.median_high(a)\n\n        else:\n\n            b = statistics.median_low(a)\n\n    \n\n    ans = sum([abs(a[i] - b) for i in range(n)])\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    # execute only if run as a script\n\n    main()\n\n\n\n\n","reference_code_col":"import sys\n\n\n\nn, *a = list(map(int, sys.stdin.read().split()))\n\n\n\ndef main():\n\n    for i in range(n):\n\n        a[i] -= (i + 1)\n\n    a.sort()\n\n    b = a[n \/\/ 2]\n\n    res = 0\n\n    for i in range(n):\n\n        res += abs(a[i] - b)\n\n    \n\n    return res\n\n    \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","model_generated_potentially_faster_code_col":"import sys\nfrom statistics import median, median_high, median_low\n\ndef main():\n    n, *a = map(int, sys.stdin.read().split())\n    \n    # Adjust the list elements\n    for i in range(n):\n        a[i] -= (i + 1)\n    \n    # Calculate the median\n    if n % 2 != 0:\n        b = median(a)\n    else:\n        mid = n \/\/ 2\n        if a[mid] > a[mid - 1]:\n            b = median_high(a)\n        else:\n            b = median_low(a)\n    \n    # Calculate the answer\n    ans = sum(abs(x - b) for x in a)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03416","slow_code_col":"def findSumDigit(num):\n\n    global total\n\n    total = \"\"\n\n    while num > 0:\n\n        total += str(num % 10)\n\n        num \/\/= 10\n\n    return total\n\n\n\ndef main():\n\n    a,b = list(map(int, input().split()))\n\n    ans = 0\n\n    for i in range(a,b+1):\n\n        tmp = str(findSumDigit(i))\n\n        if tmp == str(i):\n\n            ans += 1\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()","reference_code_col":"a, b = list(map(int, input().split()))\n\nans = 0\n\n\n\nfor i in range(a,b+1):\n\n    seki_gyaku = str(i)\n\n    if seki_gyaku == seki_gyaku[::-1]:\n\n        ans += 1\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"def find_sum_digit(num):\n    total = 0\n    while num > 0:\n        total += num % 10\n        num \/\/= 10\n    return total\n\n\ndef main():\n    a, b = map(int, input().split())\n    ans = 0\n    for i in range(a, b + 1):\n        if i % find_sum_digit(i) == 0:\n            ans += 1\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03680","slow_code_col":"N = int(eval(input()))\n\na = [int(eval(input())) for i in range(N)]\n\nnow = a[0]\n\ncount = 1\n\nc = 0\n\nfor i in range(10**6):\n\n    if now != 2:\n\n        count += 1\n\n        now = a[now - 1]\n\n    else:\n\n        print(count)\n\n        c = 1\n\n        break\n\nif c == 0:\n\n    print((-1))\n","reference_code_col":"N = int(eval(input()))\n\na = [0] + [int(eval(input())) for _ in range(N)]\n\nx = 1\n\nvisited = set([1])\n\nanswer = 0\n\n\n\nwhile True:\n\n  x = a[x]\n\n  if x in visited:\n\n    answer = -1\n\n    break\n\n  visited.add(x)\n\n  answer += 1\n\n  if x == 2:\n\n    break\n\n    \n\nprint(answer)\n","model_generated_potentially_faster_code_col":"N = int(input())\n\na = [int(input()) for _ in range(N)]\n\nindex_map = {value: idx for idx, value in enumerate(a)}\n\nnow = a[0]\ncount = 1\n\nfor i in range(1, len(a)):\n    if now != 2:\n        count += 1\n        now = a[now - 1]\n    else:\n        print(count)\n        break\nelse:\n    print(-1)"}
{"problem_id":"p02386","slow_code_col":"n=int(eval(input()))\n\na=[list(map(int,input().split()))for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in([0,1,2,3,4,5],[1,5,2,0,4,3],[2,1,5,3,0,4],[3,0,2,5,4,1],[4,1,0,3,5,2],[5,1,4,3,2,0]):\n\n    f=[d[k]for k in p]\n\n    if f[0]==e[0]and f[5]==e[5]:\n\n     f=f[1:5]*2\n\n     for k in range(4):\n\n      if f[k:k+4]==e[1:5]:return'No'\n\n return'Yes'\n\nprint((f()))\n","reference_code_col":"n=int(eval(input()))\n\na=[[int(s)for s in input().split()]for _ in range(n)]\n\ndef f():\n\n for i in range(n-1):\n\n  d=a[i][:];d[3],d[4]=d[4],d[3]\n\n  for j in range(i+1,n):\n\n   e=a[j][:];e[3],e[4]=e[4],e[3]\n\n   for p in([0,1,2,3,4,5],[1,5,2,0,4,3],[2,1,5,3,0,4],[3,0,2,5,4,1],[4,1,0,3,5,2],[5,1,4,3,2,0]):\n\n    f=[d[k]for k in p]\n\n    if f[0]==e[0]and f[5]==e[5]:\n\n     f=f[1:5]*2\n\n     for k in range(4):\n\n      if f[k:k+4]==e[1:5]:return'No'\n\n return'Yes'\n\nprint((f()))\n","model_generated_potentially_faster_code_col":"n = int(eval(input()))\na = [list(map(int, input().split())) for _ in range(n)]\n\ndef f():\n    # Create a set of tuples representing all possible rotations\n    rotations = set()\n    for p in ([0, 1, 2, 3, 4, 5], [1, 5, 2, 0, 4, 3], [2, 1, 5, 3, 0, 4],\n               [3, 0, 2, 5, 4, 1], [4, 1, 0, 3, 5, 2], [5, 1, 4, 3, 2, 0]):\n        rotated = tuple(a[0][k] for k in p)\n        rotations.add(rotated)\n\n    # Check each subsequent list against the rotations set\n    for i in range(1, n):\n        current = tuple(a[i][k] for k in [3, 4])\n        if any(current == r[1:5] for r in rotations):\n            return 'No'\n    \n    return 'Yes'\n\nprint(f())"}
{"problem_id":"p03568","slow_code_col":"import numpy as np\n\nfrom itertools import product\n\n\n\nn = int(eval(input()))\n\na = list(map(int,input().split()))\n\n\n\na = np.array(a)\n\n\n\nli = [-1,0,1]\n\ncnt = 0\n\nfor v in product(li,repeat = n):\n\n    v = np.array(v)\n\n    L =a+v\n\n    cum = L.cumprod()\n\n    if cum[-1]%2 ==0 :\n\n        cnt +=1\n\nprint(cnt)\n\n        ","reference_code_col":"n = int(eval(input()))\n\na = list(map(int,input().split()))\n\n\n\nfrom itertools import product\n\n\n\nli = [-1,0,1]\n\ncnt = 0\n\nfor v in product(li,repeat = n):\n\n    L = []\n\n    for i in range(n):\n\n        L.append(v[i]+a[i])\n\n    if any(x%2==0 for x in L):\n\n        cnt +=1\n\n\n\nprint(cnt)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn = int(eval(input()))\na = list(map(int, input().split()))\na = np.array(a)\n\n# Initialize counter\ncnt = 0\n\n# Iterate over all possible combinations\nfor v in range(3**n):\n    # Convert the current combination to a binary string and pad it with zeros\n    bin_str = format(v, '0{}b'.format(n))\n    \n    # Create the new array by adding corresponding bits (0 or 1) to a\n    new_array = a + np.array([int(bit) for bit in bin_str])\n    \n    # Check if the last element of the new array is odd\n    if new_array[-1] % 2 != 0:\n        cnt += 1\n\nprint(cnt)"}
{"problem_id":"p02952","slow_code_col":"N = int(eval(input()))\n\n\n\ncount = 0\n\nfor i in range(1, N + 1):\n\n    num_dig = 0\n\n    ii = i\n\n    while ii > 0:\n\n        ii = int(ii \/ 10)\n\n        num_dig += 1\n\n    if num_dig % 2 != 0:\n\n        count += 1\n\n\n\nprint(count)","reference_code_col":"N = int(eval(input()))\n\n\n\ncount = 0\n\nfor i in range(1, N + 1):\n\n    if len(str(i)) % 2 != 0:\n\n        count += 1\n\nprint(count)","model_generated_potentially_faster_code_col":"N = int(input())\n\n# Create an array to store the number of digits for each possible value of N\nnum_digits = [0] * (N + 1)\n\n# Calculate the number of digits for each number from 1 to N\nfor i in range(1, N + 1):\n    num_digits[i] = len(str(i))\n\n# Count the numbers with an odd number of digits\ncount = sum(num_digits[i] % 2 != 0 for i in range(1, N + 1))\n\nprint(count)"}
{"problem_id":"p03634","slow_code_col":"#!usr\/bin\/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\n\"\"\"\n\ndef gcd(a,b):\n\n    if a == 0:\n\n        return b\n\n    return gcd(b%a,a)\n\nn = I()\n\na = IR(n)\n\nl = a[0]\n\nfor i in range(1,n):\n\n    g = gcd(l,a[i])\n\n    l *= a[i]\/\/g\n\nprint(l)\n\n\"\"\"\n\n\n\n#B\n\nn = I()\n\nv = [[] for i in range(n)]\n\nfor i in range(n-1):\n\n    a,b,c = LI()\n\n    a -= 1\n\n    b -= 1\n\n    v[a].append([b,c])\n\n    v[b].append([a,c])\n\nQ,k = LI()\n\nd = [-1 for i in range(n)]\n\nd[k-1] = 0\n\nq = deque()\n\nq.append(k-1)\n\nwhile q:\n\n    x = q.pop()\n\n    for y,c in v[x]:\n\n        if d[y] == -1:\n\n            d[y] = d[x]+c\n\n            q.append(y)\n\nfor i in range(Q):\n\n    x,y = LI()\n\n    x -= 1\n\n    y -= 1\n\n    print((d[x]+d[y]))\n\n#C\n\n\n\n#D\n\n\n\n#E\n\n\n\n#F\n\n\n\n#G\n\n\n\n#H\n\n\n\n#I\n\n\n\n#J\n\n\n\n#K\n\n\n\n#L\n\n\n\n#M\n\n\n\n#N\n\n\n\n#O\n\n\n\n#P\n\n\n\n#Q\n\n\n\n#R\n\n\n\n#S\n\n\n\n#T\n","reference_code_col":"#!usr\/bin\/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\n\"\"\"\n\ndef gcd(a,b):\n\n    if a == 0:\n\n        return b\n\n    return gcd(b%a,a)\n\nn = I()\n\na = IR(n)\n\nl = a[0]\n\nfor i in range(1,n):\n\n    g = gcd(l,a[i])\n\n    l *= a[i]\/\/g\n\nprint(l)\n\n\"\"\"\n\n\n\n#B\n\nn = I()\n\nv = [[] for i in range(n)]\n\nfor i in range(n-1):\n\n    a,b,c = LI()\n\n    a -= 1\n\n    b -= 1\n\n    v[a].append([b,c])\n\n    v[b].append([a,c])\n\nQ,k = LI()\n\nd = [-1 for i in range(n)]\n\nd[k-1] = 0\n\nq = deque()\n\nq.append(k-1)\n\nwhile q:\n\n    x = q.popleft()\n\n    for y,c in v[x]:\n\n        if d[y] == -1:\n\n            d[y] = d[x]+c\n\n            q.append(y)\n\nfor i in range(Q):\n\n    x,y = LI()\n\n    x -= 1\n\n    y -= 1\n\n    print((d[x]+d[y]))\n\n#C\n\n\n\n#D\n\n\n\n#E\n\n\n\n#F\n\n\n\n#G\n\n\n\n#H\n\n\n\n#I\n\n\n\n#J\n\n\n\n#K\n\n\n\n#L\n\n\n\n#M\n\n\n\n#N\n\n\n\n#O\n\n\n\n#P\n\n\n\n#Q\n\n\n\n#R\n\n\n\n#S\n\n\n\n#T\n","model_generated_potentially_faster_code_col":"import heapq\n\ndef dijkstra(graph, start):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        \n        if current_dist > dist[u]:\n            continue\n        \n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            \n            if distance < dist[v]:\n                dist[v] = distance\n                heapq.heappush(pq, (distance, v))\n    \n    return dist\n\nn = I()\ngraph = [[] for _ in range(n)]\n\nfor _ in range(n-1):\n    a, b, c = LI()\n    a -= 1\n    b -= 1\n    graph[a].append((b, c))\n    graph[b].append((a, c))\n\nQ, k = LI()\ndistances = dijkstra(graph, k-1)\n\nfor _ in range(Q):\n    x, y = LI()\n    x -= 1\n    y -= 1\n    print(distances[x] + distances[y])"}
{"problem_id":"p02837","slow_code_col":"from itertools import product\n\nN=int(eval(input()))\n\ndata=[]\n\nfor i in range(N):\n\n    for j in range(int(eval(input()))):\n\n        x,y=list(map(int,input().split()))\n\n        data.append((i,x-1,y))\n\n#print(data)\n\n\n\nans=0\n\nfor i in product([1,0],repeat=N):\n\n    #print(i)\n\n    s=True\n\n    for k in data:\n\n        if i[k[0]]==1 and i[k[1]]!=k[2]:\n\n            s=False\n\n            break\n\n    if s:\n\n        ans=max(ans,sum(i))\n\nprint(ans)\n","reference_code_col":"from itertools import product\n\n\n\nN=int(eval(input()))\n\ndata=[]\n\nfor i in range(N):\n\n    for j in range(int(eval(input()))):\n\n        x,y=list(map(int,input().split()))\n\n        data.append((i,x-1,y)) #i\u3055\u3093\u304cx-1\u3055\u3093\u306b\u5618(0)or\u6b63\u76f4(1)\n\n\n\n\n\nans=0\n\nfor i in product([0,1],repeat=N):\n\n    ok=True\n\n    for j in data:\n\n        if i[j[0]]==1 and i[j[1]]!=j[2]:\n\n            ok = False\n\n            break\n\n    if ok:\n\n        ans=max(ans,sum(i))\n\nprint(ans)","model_generated_potentially_faster_code_col":"from collections import defaultdict\n\n# Read input values\nN = int(input())\ndata = []\n\nfor _ in range(N):\n    M = int(input())\n    for _ in range(M):\n        x, y = map(int, input().split())\n        data.append((x - 1, y - 1))  # Adjust indices to be zero-based\n\n# Initialize DP table\ndp = [defaultdict(int) for _ in range(2)]\n\n# Iterate over each (x, y) pair in data\nfor x, y in data:\n    new_dp = [defaultdict(int) for _ in range(2)]\n    for bit_x in dp[0]:\n        for bit_y in dp[1]:\n            if bit_x == 1 and bit_y != y:\n                continue\n            new_dp[bit_x][bit_y] = max(new_dp[bit_x][bit_y], dp[bit_x][bit_y])\n            new_dp[1 - bit_x][bit_y] = max(new_dp[1 - bit_x][bit_y], dp[bit_x][bit_y] + (1 - bit_x))\n    dp = new_dp\n\n# Find the maximum sum\nmax_sum = max(dp[0].values()) + max(dp[1].values())\n\nprint(max_sum)"}
{"problem_id":"p03013","slow_code_col":"mod = 10**9+7\n\nn, m = list(map(int, input().split()))\n\nl = [0]*n\n\nfor _ in range(m):\n\n  l[int(eval(input()))-1] = 1\n\n\n\ns = 0\n\nt = 1\n\n\n\nfor i in range(n):\n\n  if l[i] > 0:\n\n    t, s = 0, t\n\n  else:\n\n    t, s = (s+t)%mod, t\n\n\n\nprint(t)","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nmod = 10**9+7\n\nn, m = list(map(int, input().split()))\n\nl = [0]*n\n\nfor _ in range(m):\n\n  l[int(eval(input()))-1] = 1\n\n\n\nt, s = 1, 0\n\n\n\nfor i in range(n):\n\n  if l[i]:\n\n    t, s = 0, t\n\n  else:\n\n    t, s = (s+t)%mod, t\n\n\n\nprint(t)","model_generated_potentially_faster_code_col":"mod = 10**9+7\n\nn, m = map(int,input().split())\n\n# Precompute all possible answers\ndp = [[0]*2 for _ in range(n)]\ndp[0][0], dp[0][1] = 1, 0\nfor i in range(1,n):\n    dp[i][0], dp[i][1] = (dp[i-1][0]+dp[i-1][1])%mod, dp[i-1][0]\n\n# For each query, just print the precomputed result\nfor _ in range(m):\n    k = int(input()) - 1\n    print(dp[k][1])"}
{"problem_id":"p03774","slow_code_col":"N,M = [int(c) for c in input().split()]\n\nab = [list(map(int,input().split())) for c in range(N)]\n\ncd = [list(map(int,input().split())) for c in range(M)]\n\nfor i in range(N):\n\n    mi = 2*10**9\n\n    for j in range(M):\n\n        tmp = abs(ab[i][0]-cd[j][0])+abs(ab[i][1]-cd[j][1])\n\n        if mi > tmp:\n\n            mi = tmp\n\n            ans = j+1\n\n    print(ans)\n","reference_code_col":"N,M = [int(c) for c in input().split()]\n\nab = [list(map(int,input().split())) for c in range(N)]\n\ncd = [list(map(int,input().split())) for c in range(M)]\n\nfor i in range(N):\n\n    mi = 10**9\n\n    for j in range(M):\n\n        tmp = abs(ab[i][0]-cd[j][0])+abs(ab[i][1]-cd[j][1])\n\n        if mi > tmp:\n\n            mi = tmp\n\n            ans = j+1\n\n    print(ans)\n","model_generated_potentially_faster_code_col":"import bisect\n\nN, M = [int(c) for c in input().split()]\n\nab = [list(map(int, input().split())) for _ in range(N)]\ncd = [list(map(int, input().split())) for _ in range(M)]\n\n# Sort cd by x-coordinate\ncd.sort(key=lambda p: p[0])\n\nfor i in range(N):\n    # Find the index of the first point in cd with x-coordinate greater than or equal to ab[i][0]\n    idx = bisect.bisect_left(cd, [ab[i][0], -float('inf')])\n    \n    # If idx is out of bounds, set it to the last index of cd\n    if idx == len(cd):\n        idx -= 1\n    \n    # Check the distance between ab[i] and the point at idx\n    dist = abs(ab[i][0] - cd[idx][0]) + abs(ab[i][1] - cd[idx][1])\n    ans = idx + 1\n    \n    # Check if the point before idx is closer to ab[i]\n    if idx > 0:\n        prev_dist = abs(ab[i][0] - cd[idx-1][0]) + abs(ab[i][1] - cd[idx-1][1])\n        if prev_dist < dist:\n            dist = prev_dist\n            ans = idx\n    \n    print(ans)"}
{"problem_id":"p03416","slow_code_col":"def test():\n\n    a,b = list(map(int,input().split()))\n\n    count = 0\n\n    for i in range(a,b+1):\n\n        j = list(map(int,list(str(i))))\n\n        if j[0] == j[4] and j[1] == j[3]:\n\n            count += 1\n\n    print(count)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    test()\n","reference_code_col":"def test():\n\n    a,b = list(map(int,input().split()))\n\n    count = 0\n\n    for i in range(a,b+1):\n\n        if str(i)[0] == str(i)[4] and str(i)[1] == str(i)[3]:\n\n            count += 1\n\n    print(count)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    test()\n","model_generated_potentially_faster_code_col":"def test():\n    a, b = map(int, input().split())\n    count = 0\n    \n    for i in range(a, b + 1):\n        # Extract digits using modulo operation\n        d1 = i \/\/ 10000 % 10\n        d2 = i \/\/ 1000 % 10\n        d3 = i \/\/ 100 % 10\n        d4 = i \/\/ 10 % 10\n        d5 = i % 10\n        \n        # Check the condition\n        if d1 == d5 and d2 == d4:\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    test()"}
{"problem_id":"p02821","slow_code_col":"from bisect import bisect_left\n\nfrom bisect import bisect_right\n\n\n\nn,m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\na = sorted(a)\n\n\n\na_count = [0]*100010\n\na_sum = [0]*100010\n\n\n\nfor i in range(n):\n\n    a_count[a[i]] += 1\n\n    a_sum[a[i]] += a[i]\n\n\n\nfor i in range(100005,-1,-1):\n\n    a_count[i] += a_count[i+1]\n\n    a_sum[i] += a_sum[i+1]\n\n\n\ndef chk(x):\n\n    case = 0\n\n    for i in range(n):\n\n        if 0<= x-a[i]<= 10**5+5:\n\n            case += a_count[x-a[i]]\n\n        elif x-a[i] < 0:\n\n            case += n\n\n    if case >= m:\n\n        ch = True\n\n    else:\n\n        ch = False\n\n    return ch\n\n\n\nl = 2*a[-1]+1    #NG\n\nr = 1 #OK\n\n\n\nwhile abs(r-l) > 1:\n\n    kk = (r+l)\/\/2\n\n    if chk(kk):\n\n        r = kk\n\n    else:\n\n        l = kk\n\n\n\nans = 0\n\nsm = sum(a)\n\n\n\nl = r\n\n\n\ncase = 0\n\nfor i in range(n):\n\n    num = n-bisect_right(a,l-a[i]-1)\n\n    case += num\n\n    ans += num*a[i]*2\n\n\n\nans -= (case-m)*l\n\n\n\nprint(ans)","reference_code_col":"n, m = list(map(int, input().split()))\n\na = [int(x) for x in input().split()]\n\n\n\naa = [0]*(10**5+1)\n\naa_sum = [0]*(10**5+1)\n\n\n\nfor x in a:\n\n    aa[x] += 1\n\n    aa_sum[x] += x\n\n\n\nfor i in range(10**5)[::-1]:\n\n    aa[i] = aa[i] + aa[i+1]\n\n    aa_sum[i] = aa_sum[i] + aa_sum[i+1]\n\n\n\n\n\ndef count(x):\n\n    cnt = 0\n\n    sm = 0\n\n    for i in range(n):\n\n        if x-a[i] < 0:\n\n            cnt += n\n\n            sm += aa_sum[0]+n*a[i]\n\n        elif x-a[i] > 10**5:\n\n            continue\n\n        else:\n\n            cnt += aa[x-a[i]]\n\n            sm += aa_sum[x-a[i]]+aa[x-a[i]]*a[i]\n\n\n\n    return cnt, sm\n\n\n\n\n\nbottom = 0\n\ntop = 10**6\n\n\n\nwhile top - bottom > 1:\n\n    mid = (top+bottom) \/\/ 2\n\n    cnt, sm = count(mid)\n\n    if cnt < m:\n\n        top = mid\n\n    else:\n\n        bottom = mid\n\n\n\ncnt, sm = count(bottom)\n\nans = sm - (cnt-m)*bottom\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"from bisect import bisect_left, bisect_right\n\nn, m = map(int, input().split())\na = sorted(map(int, input().split()))\n\n# Initialize count and sum arrays with size n+1 to handle edge cases\na_count = [0] * (n + 1)\na_sum = [0] * (n + 1)\n\n# Calculate prefix sums and counts\nfor i in range(n):\n    a_count[i + 1] = a_count[i] + 1\n    a_sum[i + 1] = a_sum[i] + a[i]\n\n# Binary search function to find the smallest x such that there are at least m elements within [x-10^5-5, x]\ndef binary_search():\n    left, right = -10**6, 10**6\n    while left < right:\n        mid = (left + right) \/\/ 2\n        if any(a_count[bisect_right(a, mid - a[i]) - bisect_left(a, mid - a[i] - 10**5 - 5)] for i in range(n)) >= m:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Find the minimum value of x\nx = binary_search()\n\n# Calculate the answer\nanswer = 0\nfor i in range(n):\n    j = bisect_right(a, x - a[i])\n    k = bisect_left(a, x - a[i] - 10**5 - 5)\n    answer += (j - k) * a[i]\n\nprint(answer)"}
{"problem_id":"p03548","slow_code_col":"X, Y, Z = list(map(int, input().split()))\n\nfor n in range(10 ** 5, 0, -1):\n\n    if X >= n * (Y + Z) + Z:\n\n        break\n\nprint(n)","reference_code_col":"X, Y, Z = list(map(int, input().split()))\n\nprint(((X - Z) \/\/ (Y + Z)))","model_generated_potentially_faster_code_col":"X, Y, Z = map(int, input().split())\n\nleft, right = 0, 10**5\n\nwhile left < right:\n    mid = (left + right + 1) \/\/ 2\n    \n    if X >= mid * (Y + Z) + Z:\n        left = mid\n    else:\n        right = mid - 1\n\nprint(left)"}
{"problem_id":"p02576","slow_code_col":"array = list(map(int, input().split()))\n\nif array[0] % array[1] > 0:\n\n    print(((array[0] \/\/ array[1] + 1) * array[2]))\n\nelse:\n\n    print(((array[0] \/\/ array[1]) * array[2]))","reference_code_col":"n, x, t = list(map(int, input().split()))\n\n\n\nprint((0--n\/\/x*t))","model_generated_potentially_faster_code_col":"# Read elements from input and convert them to integers\na, b, c = map(int, input().split())\n\n# Calculate result based on whether 'a' is divisible by 'b'\nresult = ((a \/\/ b + (a % b != 0)) * c)\n\n# Print result\nprint(result)"}
{"problem_id":"p02268","slow_code_col":"N = int(eval(input()))\n\nS = list(map(int, input().split()))\n\nQ = int(eval(input()))\n\nT = list(map(int, input().split()))\n\n\n\ndef binary_search(target_num, head, tail):\n\n    idx = int((head+tail)\/2)\n\n    if target_num == S[idx]:\n\n        return True\n\n    elif target_num < S[idx]:\n\n        if head == idx:\n\n            return False\n\n        return binary_search(target_num, head, idx-1)\n\n    else:\n\n        if tail == idx:\n\n            return False\n\n        return binary_search(target_num, idx+1, tail)\n\n\n\n\n\nmatch_count = 0\n\nfor target_num in T:\n\n    if binary_search(target_num, 0, len(S)-1):\n\n        match_count += 1\n\n\n\nprint((str(match_count)))\n","reference_code_col":"N = int(eval(input()))\n\nS = list(map(int, input().split()))\n\nQ = int(eval(input()))\n\nT = list(map(int, input().split()))\n\n\n\ndef binary_search(target_num, head, tail):\n\n    while head <= tail:\n\n        idx = int((head+tail)\/2)\n\n        if target_num == S[idx]:\n\n            return True\n\n        elif target_num < S[idx]:\n\n            tail = idx - 1\n\n        else:\n\n            head = idx + 1\n\n    return False\n\n\n\n\n\nmatch_count = 0\n\nfor target_num in T:\n\n    if binary_search(target_num, 0, len(S)-1):\n\n        match_count += 1\n\n\n\nprint((str(match_count)))\n","model_generated_potentially_faster_code_col":"N = int(input())\nS = sorted(list(map(int, input().split())))\nQ = int(input())\nT = list(map(int, input().split()))\n\nmatch_count = 0\nfor target_num in T:\n    if target_num in S:\n        match_count += 1\n\nprint(str(match_count))"}
{"problem_id":"p03796","slow_code_col":"n=eval(input())\n\nn=int(n)\n\na=1\n\nfor i in range(n):\n\n    a=a*(i+1)\n\n    if a>=pow(10,9)+7:\n\n        a=a%(pow(10,9)+7)\n\nprint(a)","reference_code_col":"n=int(eval(input()))\n\na=1\n\nfor i in range(1,n+1):\n\n    a*=i\n\n    a %= (10**9+7)\n\nprint(a)","model_generated_potentially_faster_code_col":"# Read input as integer\nn = int(input())\n\n# Define the modulo constant\nMOD = 10**9 + 7\n\n# Initialize result\nresult = 1\n\n# Calculate factorial with modulo operation\nfor i in range(1, n + 1):\n    result = (result * i) % MOD\n\n# Print the final result\nprint(result)"}
{"problem_id":"p02537","slow_code_col":"class SegmentTree():\n\n    \"\"\"\n\n    update, get \u3092\u63d0\u4f9b\u3059\u308bSegmentTree\n\n\n\n    Attributes\n\n    ----------\n\n    __n : int\n\n        \u8449\u306e\u6570\u30022 ^ i - 1\n\n    __dot :\n\n        Segment function\n\n    __e: int\n\n        \u5358\u4f4d\u5143\n\n    __node: list\n\n        Segment Tree\n\n    \"\"\"\n\n    def __init__(self, A, dot, e):\n\n        \"\"\"\n\n        Parameters\n\n        ----------\n\n        A : list\n\n            \u5bfe\u8c61\u306e\u914d\u5217\n\n        dot :\n\n            Segment function\n\n        e : int\n\n            \u5358\u4f4d\u5143\n\n        \"\"\"\n\n        n = 2 ** (len(A) - 1).bit_length()\n\n        self.__n = n\n\n        self.__dot = dot\n\n        self.__e = e\n\n        self.__node = [e] * (2 * n)\n\n        for i in range(len(A)):\n\n            self.__node[i + n] = A[i]\n\n        for i in range(n - 1, 0, -1):\n\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[2 * i + 1])\n\n    \n\n    def update(self, i, c):\n\n        i += self.__n\n\n        node = self.__node\n\n        node[i] = c\n\n        while i > 1:\n\n            i \/\/= 2\n\n            node[i] = self.__dot(node[2 * i], node[2 * i + 1])\n\n\n\n    def get(self, l, r):\n\n        vl, vr = self.__e, self.__e\n\n        l += self.__n\n\n        r += self.__n\n\n        while (l < r):\n\n            if l & 1:\n\n                vl = self.__dot(vl, self.__node[l])\n\n                l += 1\n\n            l \/\/= 2\n\n            if r & 1:\n\n                r -= 1\n\n                vr = self.__dot(vr, self.__node[r])\n\n            r \/\/= 2\n\n        return self.__dot(vl, vr)\n\n\n\n\n\nN, K = list(map(int, input().split()))\n\nA = [int(eval(input())) for _ in range(N)]\n\nmax_A = max(A)\n\n\n\nst = SegmentTree([N] * (max_A + 1), min, N)\n\nedge = [set() for _ in range(N)]\n\nfor i, a in enumerate(reversed(A)):\n\n    j = N - 1 - i\n\n    p1 = st.get(a, min(max_A + 1, a + K + 1))\n\n    if p1 < N:\n\n        edge[j].add(p1)\n\n    p2 = st.get(max(0, a - K), a)\n\n    if p2 < N:\n\n        edge[j].add(p2)\n\n    p0 = st.get(a, a + 1)\n\n    if p0 < N:\n\n        edge[j].add(p0)\n\n    st.update(a, j)\n\n\n\ndp = [1] * N\n\nfor i in range(N - 1):\n\n    here = dp[i]\n\n    for ni in edge[i]:\n\n        if ni < N:\n\n            dp[ni] = max(dp[ni], dp[i] + 1)\n\n\n\nprint((max(dp)))\n","reference_code_col":"class SegmentTree():\n\n    \"\"\"\n\n    update, get \u3092\u63d0\u4f9b\u3059\u308bSegmentTree\n\n\n\n    Attributes\n\n    ----------\n\n    __n : int\n\n        \u8449\u306e\u6570\u30022 ^ i - 1\n\n    __dot :\n\n        Segment function\n\n    __e: int\n\n        \u5358\u4f4d\u5143\n\n    __node: list\n\n        Segment Tree\n\n    \"\"\"\n\n    def __init__(self, A, dot, e):\n\n        \"\"\"\n\n        Parameters\n\n        ----------\n\n        A : list\n\n            \u5bfe\u8c61\u306e\u914d\u5217\n\n        dot :\n\n            Segment function\n\n        e : int\n\n            \u5358\u4f4d\u5143\n\n        \"\"\"\n\n        n = 2 ** (len(A) - 1).bit_length()\n\n        self.__n = n\n\n        self.__dot = dot\n\n        self.__e = e\n\n        self.__node = [e] * (2 * n)\n\n        for i in range(len(A)):\n\n            self.__node[i + n] = A[i]\n\n        for i in range(n - 1, 0, -1):\n\n            self.__node[i] = self.__dot(self.__node[2 * i], self.__node[2 * i + 1])\n\n    \n\n    def update(self, i, c):\n\n        i += self.__n\n\n        node = self.__node\n\n        node[i] = c\n\n        while i > 1:\n\n            i \/\/= 2\n\n            node[i] = self.__dot(node[2 * i], node[2 * i + 1])\n\n\n\n    def get(self, l, r):\n\n        vl, vr = self.__e, self.__e\n\n        l += self.__n\n\n        r += self.__n\n\n        while (l < r):\n\n            if l & 1:\n\n                vl = self.__dot(vl, self.__node[l])\n\n                l += 1\n\n            l \/\/= 2\n\n            if r & 1:\n\n                r -= 1\n\n                vr = self.__dot(vr, self.__node[r])\n\n            r \/\/= 2\n\n        return self.__dot(vl, vr)\n\n\n\n\n\nN, K = list(map(int, input().split()))\n\nA = [int(eval(input())) for _ in range(N)]\n\nmax_A = max(A)\n\n\n\nst = SegmentTree([N] * (max_A + 1), min, N)\n\nedge = [set() for _ in range(N)]\n\nfor i, a in enumerate(reversed(A)):\n\n    j = N - 1 - i\n\n    p1 = st.get(a, min(max_A + 1, a + K + 1))\n\n    if p1 < N:\n\n        edge[j].add(p1)\n\n    p2 = st.get(max(0, a - K), a)\n\n    if p2 < N:\n\n        edge[j].add(p2)\n\n    st.update(a, j)\n\n\n\ndp = [1] * N\n\nfor i in range(N - 1):\n\n    here = dp[i]\n\n    for ni in edge[i]:\n\n        if ni < N:\n\n            dp[ni] = max(dp[ni], dp[i] + 1)\n\n\n\nprint((max(dp)))\n","model_generated_potentially_faster_code_col":"class SegmentTree():\n    def __init__(self, A, dot, e):\n        n = len(A)\n        self.n = 1 << (n - 1).bit_length()\n        self.dot = dot\n        self.e = e\n        self.node = [e] * (2 * self.n)\n        for i in range(n):\n            self.node[self.n + i] = A[i]\n        for i in range(self.n - 1, 0, -1):\n            self.node[i] = self.dot(self.node[2 * i], self.node[2 * i + 1])\n\n    def update(self, i, c):\n        i += self.n\n        self.node[i] = c\n        while i > 1:\n            i >>= 1\n            self.node[i] = self.dot(self.node[2 * i], self.node[2 * i + 1])\n\n    def query(self, l, r):\n        res = self.e\n        l += self.n\n        r += self.n\n        while l < r:\n            if l & 1:\n                res = self.dot(res, self.node[l])\n                l += 1\n            l >>= 1\n            if r & 1:\n                r -= 1\n                res = self.dot(res, self.node[r])\n            r >>= 1\n        return res\n\nN, K = map(int, input().split())\nA = [eval(input()) for _ in range(N)]\nmax_A = max(A)\nst = SegmentTree([N] * (max_A + 1), min, N)\nedge = [[] for _ in range(N)]\nfor i, a in enumerate(reversed(A)):\n    j = N - 1 - i\n    p1 = st.query(a, min(max_A + 1, a + K + 1))\n    if p1 < N:\n        edge[j].append(p1)\n    p2 = st.query(max(0, a - K), a)\n    if p2 < N:\n        edge[j].append(p2)\n    p0 = st.query(a, a + 1)\n    if p0 < N:\n        edge[j].append(p0)\n    st.update(a, j)\n\ndp = [1] * N\nfor i in range(N - 1):\n    for ni in edge[i]:\n        dp[ni] = max(dp[ni], dp[i] + 1)\n\nprint(max(dp))"}
{"problem_id":"p00003","slow_code_col":"import sys\n\nr = []\n\nn = int(eval(input()))\n\nl = sys.stdin.readlines()\n\nfor i in l:\n\n  x, y, z = sorted([x*x for x in list(map(int, i.split()))])\n\n  if x + y == z:\n\n      print(\"YES\")\n\n  else:\n\n      print(\"NO\")","reference_code_col":"import sys\n\n\n\nn = int(input())\n\nl = sys.stdin.readlines()\n\ns = \"\"\n\nfor i in l:\n\n  x, y, z = sorted(map(lambda x:x*x,map(int, i.split())))\n\n  if x + y == z:\n\n      s += \"YES\\n\"\n\n  else:\n\n      s += \"NO\\n\"\n\n\n\nprint(s,end=\"\")\n","model_generated_potentially_faster_code_col":"import sys\n\ndef is_right_triangle(line):\n    numbers = list(map(int, line.split()))\n    squares = [x * x for x in numbers]\n    x, y, z = sorted(squares)\n    return x + y == z\n\nn = int(sys.stdin.readline().strip())\n\nfor _ in range(n):\n    line = sys.stdin.readline().strip()\n    result = \"YES\" if is_right_triangle(line) else \"NO\"\n    print(result)"}
{"problem_id":"p03371","slow_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\nab = c * 2\n\n\n\nres = float(\"inf\")\n\nif a + b <= ab:\n\n    res = x * a + y * b\n\nelse:\n\n    if x == y:\n\n        res = x * ab\n\n    elif x > y:\n\n        for i in range(y, x + 1):\n\n            cost = i * ab + (x - i) * a\n\n            res = min(res, cost)\n\n    else:\n\n        for i in range(x, y + 1):\n\n            cost = i * ab + (y - i) * b\n\n            res = min(res, cost)\n\nprint(res)\n","reference_code_col":"import sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\ninput = sys.stdin.readline\n\nf_inf = float('inf')\n\nmod = 10 ** 9 + 7\n\n\n\n\n\ndef resolve():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    c *= 2\n\n    if a + b > c:\n\n        cost1 = max(x, y) * c\n\n        cost2 = min(x, y) * c\n\n        plus = ((y - x) * b) if x < y else (x - y) * a\n\n        res = min(cost1, cost2 + plus)\n\n    else:\n\n        res = x * a + y * b\n\n    print(res)\n\n\n\nif __name__ == '__main__':\n\n    resolve()\n","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\n\nab = c * 2\n\n# Calculate initial minimum cost assuming equal allocation\nmin_cost = min(a, b) * ab\n\n# If total capacity is sufficient, calculate the cost with full allocation\nif a + b <= ab:\n    res = x * a + y * b\nelse:\n    # Calculate the cost for partial allocation based on x and y values\n    if x < y:\n        res = min(min_cost, (y - x) * b + x * ab)\n    else:\n        res = min(min_cost, (x - y) * a + y * ab)\n\nprint(res)"}
{"problem_id":"p03371","slow_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\n\n\nans=a*x+b*y\n\nfor ci in range(max(x,y)+1):\n\n    sumc = 2*ci*c\n\n    sumc += (x-ci)*a if (x-ci)>0 else 0\n\n    sumc += (y-ci)*b if (y-ci)>0 else 0\n\n    ans=min(ans,sumc)\n\n\n\nprint(ans)","reference_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nif x==y:\n\n    ans=min(ans,2*x*c)\n\nelif x>y:\n\n    ans=min(ans,a*(x-y)+2*y*c)\n\n    ans=min(ans,2*x*c)\n\nelse:\n\n    ans=min(ans,b*(y-x)+2*x*c)\n\n    ans=min(ans,2*y*c)\n\nprint(ans)","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\n\n# Precompute the expressions (x-ci)*a and (y-ci)*b for each possible value of ci\nexpr_x = [0] * (max(x, y) + 1)\nexpr_y = [0] * (max(x, y) + 1)\n\nfor ci in range(max(x, y) + 1):\n    expr_x[ci] = (x - ci) * a if (x - ci) > 0 else 0\n    expr_y[ci] = (y - ci) * b if (y - ci) > 0 else 0\n\n# Initialize the answer with the initial cost\nans = a * x + b * y\n\n# Iterate through all possible values of ci and update the answer\nfor ci in range(max(x, y) + 1):\n    sumc = 2 * ci * c + expr_x[ci] + expr_y[ci]\n    ans = min(ans, sumc)\n\nprint(ans)"}
{"problem_id":"p01105","slow_code_col":"a=65280; b=61680; c=52428; d=43690; e=65535\n\nfrom heapq import heappush, heappop\n\nbase = [a, b, c, d, e, 0]\n\nQ = [(1, el) for el in base]\n\nL = {el: 1 for el in base}\n\nH = []\n\nget = L.get\n\npush = H.append\n\nwhile Q:\n\n    l, p = heappop(Q)\n\n    if L[p] < l: continue\n\n    if l+1 < get(p ^ e, 17):\n\n        L[p ^ e] = l+1\n\n        if l+1 < 16: heappush(Q, (l+1, p ^ e))\n\n    if l+3 < 16:\n\n        for q, r in H:\n\n            if l+r+3 <= 16:\n\n                if l+r+3 < get(p & q, 17):\n\n                    L[p & q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p & q))\n\n                if l+r+3 < get(p ^ q, 17):\n\n                    L[p ^ q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p ^ q))\n\n            else: break\n\n    if l < 7: push((p, l))\n\nprint(*map(L.__getitem__, eval(\"e&%s\"%\",e&\".join(open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]))),sep='\\n')\n","reference_code_col":"a=65280; b=61680; c=52428; d=43690; e=65535\n\nfrom heapq import heappush, heappop\n\nQ = [(1, a), (1, b), (1, c), (1, d)]\n\nL = {a: 1, b: 1, c: 1, d: 1, e: 1, e: 1, 0: 1}\n\nH = []\n\nget = L.get\n\npush = H.append\n\nwhile Q:\n\n    l, p = heappop(Q)\n\n    if L[p] < l: continue\n\n    if l+1 < get(p ^ e, 17):\n\n        L[p ^ e] = l+1\n\n        l < 15 and heappush(Q, (l+1, p ^ e))\n\n    if l < 13:\n\n        li = 13-l; l3 = 3+l\n\n        for q, r in H:\n\n            if r <= li:\n\n                k = p & q\n\n                if r < get(k, 17)-l3:\n\n                    L[k] = l3+r\n\n                    r < li and heappush(Q, (l3+r, k))\n\n                k = p ^ q\n\n                if r < get(k, 17)-l3:\n\n                    L[k] = l3+r\n\n                    r < li and heappush(Q, (l3+r, k))\n\n            else: break\n\n    if l < 7: push((p, l))\n\nprint(*map(L.__getitem__, eval(\"e&\"+\",e&\".join(open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]))),sep='\\n')\n","model_generated_potentially_faster_code_col":"import heapq\n\n# Constants\na, b, c, d, e = 65280, 61680, 52428, 43690, 65535\n\n# Initialize base set and heap\nbase = {a, b, c, d, e}\nheap = [(1, el) for el in base]\nheapq.heapify(heap)\n\n# Dictionary to store lengths\nlengths = {el: 1 for el in base}\n\n# Process the heap\nwhile heap:\n    length, value = heapq.heappop(heap)\n    \n    # Skip if the stored length is less than the current length\n    if lengths[value] < length:\n        continue\n    \n    # Update lengths and push new values onto the heap\n    for other in base:\n        new_value = value ^ other\n        new_length = length + 1\n        \n        if new_length < lengths[new_value]:\n            lengths[new_value] = new_length\n            heapq.heappush(heap, (new_length, new_value))\n        \n        new_value = value & other\n        new_length = length + 2\n        \n        if new_length < lengths[new_value]:\n            lengths[new_value] = new_length\n            heapq.heappush(heap, (new_length, new_value))\n\n# Read input from stdin and process\ninput_data = open(0).read()\ninput_data = input_data.replace('-', '~').replace('*', '&').replace('1', 'e').split()[:-1]\nresult = []\n\nfor item in input_data:\n    result.append(lengths[int(item)])\n\n# Print results\nprint('\\n'.join(map(str, result)))"}
{"problem_id":"p04020","slow_code_col":"def examB():\n\n    N = I(); A = [I() for _ in range(N)]\n\n    ans = 0; cur= 0\n\n    for i in A:\n\n        if i==0:\n\n            ans += cur\/\/2\n\n            cur = 0\n\n        else:\n\n            cur += i\n\n    ans += cur \/\/ 2\n\n    print(ans)\n\n    return\n\n\n\nimport sys,copy,bisect,itertools,heapq,math\n\nfrom heapq import heappop,heappush,heapify\n\nfrom collections import Counter,defaultdict,deque\n\ndef I(): return int(sys.stdin.readline())\n\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\n\ndef LS(): return sys.stdin.readline().split()\n\ndef SI(): return sys.stdin.readline().strip()\n\nmod = 10**9 + 7\n\ninf = float('inf')\n\n\n\nif __name__ == '__main__':\n\n    examB()\n","reference_code_col":"def examA():\n\n    S = SI()\n\n    if \"W\" in S and not \"E\" in S:\n\n        print(\"No\")\n\n    elif \"E\" in S and not \"W\" in S:\n\n        print(\"No\")\n\n    elif \"N\" in S and not \"S\" in S:\n\n        print(\"No\")\n\n    elif \"S\" in S and not \"N\" in S:\n\n        print(\"No\")\n\n    else:\n\n        print(\"Yes\")\n\n    return\n\n\n\ndef examB():\n\n    N = I()\n\n    A = [I()for _ in range(N)]\n\n    ans = 0\n\n    for i in range(N-1):\n\n        ans += A[i]\/\/2\n\n        if A[i]%2 and A[i+1]>=1:\n\n            ans += 1\n\n            A[i+1] -= 1\n\n    ans += A[N-1]\/\/2\n\n    print(ans)\n\n    return\n\n\n\ndef examC():\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\ndef examD():\n\n    N = I()\n\n    S = [I()for _ in range(N)]\n\n\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\ndef examE():\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\ndef examF():\n\n    ans = 0\n\n    print(ans)\n\n    return\n\n\n\nimport sys,bisect,itertools,heapq,math,random\n\nfrom copy import deepcopy\n\nfrom heapq import heappop,heappush,heapify\n\nfrom collections import Counter,defaultdict,deque\n\ndef I(): return int(sys.stdin.readline())\n\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\n\ndef LS(): return sys.stdin.readline().split()\n\ndef SI(): return sys.stdin.readline().strip()\n\nglobal mod,mod2,inf,alphabet,_ep\n\nmod = 10**9 + 7\n\nmod2 = 998244353\n\ninf = 10**18\n\n_ep = 10**(-12)\n\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\n\n\nsys.setrecursionlimit(10**6)\n\n\n\nif __name__ == '__main__':\n\n    examB()\n\n\n\n\"\"\"\n\n\n\n\"\"\"","model_generated_potentially_faster_code_col":"def examB():\n    # Read input\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    # Initialize variables\n    ans = 0\n    cur = 0\n\n    # Iterate through the array\n    for num in A:\n        if num == 0:\n            # If we encounter a zero, add half of current count to answer\n            ans += cur \/\/ 2\n            cur = 0  # Reset current count\n        else:\n            cur += num  # Add non-zero number to current count\n\n    # Add remaining count to answer\n    ans += cur \/\/ 2\n\n    # Print the result\n    print(ans)\n    return\n\n# Run the function\nexamB()"}
{"problem_id":"p03544","slow_code_col":"N = int(eval(input()))\n\nL = [ 0 ] * 1000000\n\n\n\nL[0] = 2\n\nL[1] = 1\n\n\n\nfor i in range(2, N+1):\n\n  L[i] = L[i-2] + L[i-1]\n\n\n\nprint((L[N]))\n","reference_code_col":"N = int(eval(input()))\n\nL = [ 0 ] * (N+1)\n\n\n\nL[0] = 2\n\nL[1] = 1\n\n\n\nfor i in range(2, N+1):\n\n  L[i] = L[i-2] + L[i-1]\n\n\n\nprint((L[N]))\n","model_generated_potentially_faster_code_col":"def fibonacci(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    a, b = 2, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\nN = int(input())\nresult = fibonacci(N)\nprint(result)"}
{"problem_id":"p03013","slow_code_col":"import sys\n\nN,M=list(map(int,input().split()))\n\nS=set(map(int,sys.stdin))\n\n\n\na,b=0,1\n\nfor i in range(1,N+1):\n\n    if i in S:\n\n        a,b=b,0\n\n    else:\n\n        a,b=b,a+b\n\n\n\nprint((b%(10**9+7)))\n","reference_code_col":"import sys\n\n\n\nN,M=list(map(int,input().split()))\n\nbad=set(map(int,sys.stdin))\n\nMOD=10**9+7\n\n\n\na,b=0,1\n\nfor i in range(1,N+1):\n\n    if i in bad:\n\n        a,b=b,0\n\n        if a==0:\n\n            break\n\n    else:\n\n        a,b=b,(a+b)%MOD\n\n\n\nprint(b)\n","model_generated_potentially_faster_code_col":"import sys\nfrom functools import lru_cache\n\n\ndef matrix_mult(A, B):\n    \"\"\"\n    Multiplies two matrices A and B.\n    \"\"\"\n    return [[sum(a * b for a, b in zip(row, col)) % (10**9 + 7) for col in zip(*B)] for row in A]\n\n\n@lru_cache(None)\ndef matrix_pow(M, n):\n    \"\"\"\n    Raises matrix M to the power of n using recursion and memoization.\n    \"\"\"\n    if n == 1:\n        return M\n    elif n % 2 == 0:\n        return matrix_pow(matrix_mult(M, M), n \/\/ 2)\n    else:\n        return matrix_mult(M, matrix_pow(matrix_mult(M, M), (n - 1) \/\/ 2))\n\n\ndef fibonacci_mod(n, m):\n    \"\"\"\n    Computes the nth Fibonacci number modulo m using matrix exponentiation.\n    \"\"\"\n    F = [[1, 1], [1, 0]]\n    result = matrix_pow(F, n - 1)\n    return result[0][0]\n\n\nN, M = map(int, input().split())\nS = set(map(int, sys.stdin))\n\n# Compute the number of missing integers between 1 and N\nnum_missing = sum(i not in S for i in range(1, N + 1))\n\n# Use the Fibonacci sequence to count the number of ways to arrange the missing integers\nresult = fibonacci_mod(num_missing + 1, M)\n\nprint(result)"}
{"problem_id":"p02982","slow_code_col":"import numpy as np\n\nimport itertools\n\n\n\nn, d = list(map(int, input().split()))\n\nx = [list(map(int, input().split())) for i in range(n)]\n\n\n\ncnt = 0\n\nfor i1, i2 in itertools.product(list(range(n)), list(range(n))):\n\n    if i1 == i2:\n\n        continue\n\n    x1 = np.array(x[i1])\n\n    x2 = np.array(x[i2])\n\n    d = sum(list([x ** 2 for x in list(x1 - x2)])) ** 0.5\n\n    if d == int(d):\n\n        cnt += 1\n\n\n\nprint((int(cnt \/ 2)))","reference_code_col":"n,d=list(map(int,input().split()))\n\nl=[list(map(int,input().split())) for i in range(n)]\n\n\n\ncnt=0\n\nfor i in range(n-1):\n\n for j in range(i+1,n):\n\n  l1=l[i]\n\n  l2=l[j]\n\n  sum=0\n\n  for y,z in zip(l1,l2):\n\n   sum+=(y-z)**2\n\n  dist=sum**0.5\n\n  if dist==int(dist):\n\n   cnt+=1\n\nprint(cnt)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn, d = map(int, input().split())\nx = [list(map(int, input().split())) for _ in range(n)]\n\n# Convert list of lists to a NumPy array for efficient computation\nx = np.array(x)\n\n# Initialize counter\ncnt = 0\n\n# Compute pairwise distances and check if they are integers\nfor i1 in range(n):\n    for i2 in range(i1 + 1, n):  # Skip self-comparison and ensure uniqueness\n        diff = x[i1] - x[i2]\n        dist_squared = np.sum(diff ** 2)\n        dist = np.sqrt(dist_squared)\n        \n        if dist.is_integer():\n            cnt += 1\n\n# Since each pair (i1, i2) is counted twice, divide by 2\nprint(int(cnt \/ 2))"}
{"problem_id":"p01138","slow_code_col":"import re\n\n\n\nwhile True:\n\n    n = int(input())\n\n    if n == 0:\n\n        break\n\n    l = [0] * (24*60*60+1)\n\n    for _ in range(n):\n\n        h1,m1,s1,h2,m2,s2 = list(map(int, re.split(':| ', input())))\n\n        l[h1*60*60 + m1*60 + s1] += 1\n\n        l[h2*60*60 + m2*60 + s2] -= 1\n\n    r = 0\n\n    for i in range(24*60*60):\n\n        l[i+1] += l[i]\n\n        r = max(r, l[i+1])\n\n    print(r)","reference_code_col":"while True:\n\n    n = int(input())\n\n    if n == 0:\n\n        break\n\n    l = []\n\n    for _ in range(n):\n\n        hms1, hms2 = input().split()\n\n        l.append((hms1, True))\n\n        l.append((hms2, False))\n\n    l.sort()\n\n    r, t = 0, 0\n\n    for i in range(len(l)):\n\n        if l[i][1]:\n\n            t += 1\n\n        else:\n\n            t -= 1\n\n        r = max(r, t)\n\n    print(r)","model_generated_potentially_faster_code_col":"import sys\n\n\ndef main():\n    while True:\n        n = int(sys.stdin.readline())\n        if not n:\n            break\n\n        # Initialize the array with zeros and increase\/decrease counts as before\n        times = [0] * (24*60*60+1)\n        for _ in range(n):\n            start, end = map(int, sys.stdin.readline().split())\n            times[start] += 1\n            times[end] -= 1\n\n        # Calculate the running sum and keep track of the maximum overlap\n        current_sum = max_sum = 0\n        for count in times:\n            current_sum += count\n            max_sum = max(max_sum, current_sum)\n\n        print(max_sum)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03038","slow_code_col":"import numpy as np\n\nn,m=list(map(int,input().split()))\n\na=np.array([int(i) for i in input().split()])\n\nbc=np.array([[int(i) for i in input().split()] for j in range(m)])\n\n\n\na.sort()\n\nb=bc[:,0]\n\nc=bc[:,1]\n\n\n\nidx=np.argsort(c)\n\nb=b[idx][::-1]\n\nc=c[idx][::-1]\n\n\n\np=0\n\nfor b,c in zip(b,c):\n\n    a[p:p+b]=np.maximum(a[p:p+b],c)\n\n    p+=b\n\n    \n\n    \n\nprint((a.sum()))","reference_code_col":"from heapq import heappop,heappush\n\nn,m=list(map(int,input().split()))\n\na=[int(i) for i in input().split()]\n\na.sort()\n\nbc=[[int(i) for i in input().split()]for j in range(m)]\n\nbc=sorted(bc, key=lambda x:x[1],reverse=True)\n\n\n\nans=[]\n\nfor b,c in bc:    \n\n    while b>0 and a: \n\n        x = heappop(a)\n\n        if x<c:\n\n            ans.append(c)\n\n            b-=1\n\n        else:\n\n            ans.append(x)\n\nprint((sum(ans)+sum(a)))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn, m = map(int, input().split())\na = np.array(list(map(int, input().split())))\nbc = np.array([list(map(int, input().split())) for _ in range(m)])\n\n# Sort array 'a'\na.sort()\n\n# Separate arrays 'b' and 'c' from 'bc'\nb, c = bc[:, 0], bc[:, 1]\n\n# Sort indices based on 'c' and reverse them\nidx = np.argsort(c)[::-1]\nb, c = b[idx], c[idx]\n\n# Initialize pointer 'p'\np = 0\n\n# Update 'a' with maximum values\nfor b_i, c_i in zip(b, c):\n    a[p:p + b_i] = np.maximum(a[p:p + b_i], c_i)\n    p += b_i\n\n# Print sum of 'a'\nprint(a.sum())"}
{"problem_id":"p03424","slow_code_col":"n=int(eval(input()))\n\ns=list(map(str,input().split()))\n\ntotal=[]\n\nfor i in range(n):\n\n    if s[i] not in total:\n\n        total.append(s[i])\n\nprint(('Three' if len(total)==3 else 'Four'))","reference_code_col":"eval(input())\n\nl=list(map(str,input().split()))\n\nprint(('Three' if len(set(l))==3 else 'Four'))","model_generated_potentially_faster_code_col":"n = int(input())\n\ns = input().split()\n\ntotal = []\n\nfor i in range(n):\n    if s[i] not in total:\n        total.append(s[i])\n\nprint('Three' if len(total) == 3 else 'Four')"}
{"problem_id":"p03164","slow_code_col":"import sys\n\nfrom collections import Counter, deque, defaultdict\n\nfrom itertools import accumulate, permutations, combinations, takewhile, compress, cycle\n\nfrom functools import reduce\n\nfrom math import ceil, floor, log10, log2, factorial\n\nfrom pprint import pprint\n\n\n\nsys.setrecursionlimit(1000000)\n\n# MOD = 10 ** 9 + 7\n\n# N = int(input())\n\n# A = [int(x) for x in input().split()]\n\n# V = [[0] * 100 for _ in range(100)]\n\n# A = [int(input()) for _ in range(N)]\n\n\n\nN, W = [int(x) for x in input().split()]\n\n\n\ndp = [float('inf')] * 1000 * 100*10\n\nvs = set()\n\nvs.add(0)\n\ndp[0] = 0\n\n\n\nfor i in range(N):\n\n    w, v = [int(x) for x in input().split()]\n\n\n\n    tmpDP = dp.copy()\n\n    for vv in list(vs):\n\n        if dp[vv + v] > dp[vv] + w:\n\n            tmpDP[vv + v] = dp[vv] + w\n\n            vs.add(vv + v)\n\n    dp = tmpDP\n\n\n\n\n\nans = 0\n\nfor v in list(vs):\n\n    if dp[v] <= W:\n\n        ans = max(ans, v)\n\nprint(ans)\n","reference_code_col":"import sys\n\nfrom collections import Counter, deque, defaultdict\n\nfrom itertools import accumulate, permutations, combinations, takewhile, compress, cycle\n\nfrom functools import reduce\n\nfrom math import ceil, floor, log10, log2, factorial\n\nfrom pprint import pprint\n\n\n\nsys.setrecursionlimit(1000000)\n\n# MOD = 10 ** 9 + 7\n\n# N = int(input())\n\n# A = [int(x) for x in input().split()]\n\n# V = [[0] * 100 for _ in range(100)]\n\n# A = [int(input()) for _ in range(N)]\n\n\n\nN, W = [int(x) for x in input().split()]\n\n\n\ndp = defaultdict(lambda: float('inf'))\n\ndp[0] = 0\n\n\n\nfor i in range(N):\n\n    w, v = [int(x) for x in input().split()]\n\n\n\n    add = defaultdict(lambda: float('inf'))\n\n    for vv in list(dp.keys()):\n\n        if dp[vv + v] > dp[vv] + w:\n\n            add[vv + v] = dp[vv] + w\n\n    dp.update(add)\n\n\n\nprint((max([i for i in list(dp.items()) if i[1] <= W], key=lambda x:x[0])[0]))\n","model_generated_potentially_faster_code_col":"import sys\n\nsys.setrecursionlimit(1000000)\n\nN, W = map(int, input().split())\n\ndp = [0] * (W + 1)\n\nfor _ in range(N):\n    w, v = map(int, input().split())\n    \n    # Update dp from right to left to avoid overwriting values prematurely\n    for j in range(W, w - 1, -1):\n        dp[j] = max(dp[j], dp[j - w] + v)\n\nmax_value = max(dp)\nprint(max_value)"}
{"problem_id":"p03796","slow_code_col":"from math import factorial\n\nN = int(eval(input()))\n\nprint((factorial(N) % (10**9 + 7)))","reference_code_col":"from math import factorial\n\nN = int(eval(input()))\n\nans = 1\n\nfor i in range(1,N+1):\n\n    ans *= i % (10**9 + 7)\n\n    ans %= 10**9 + 7\n\nprint(ans)","model_generated_potentially_faster_code_col":"def factorial_mod(n, mod):\n    fact = [0] * (n + 1)\n    fact[0] = 1\n    \n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % mod\n    \n    return fact[n]\n\nN = int(eval(input()))\nmod = 10**9 + 7\nprint(factorial_mod(N, mod))"}
{"problem_id":"p03013","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\nbroken = set([int(eval(input())) for _ in range(m)]) # \u3053\u3053\u304c'list'\u3060\u3068Pypy\u3067\u3082\u901a\u3089\u306a\u3044\n\n\n\ndef ptn_num(x): # 'x'step\u307e\u3067\u306e\u30d1\u30bf\u30fc\u30f3\u6570\n\n    dp = [0] * (x+1) # DP\u67a0_including step'0'\n\n    if 1 in broken: # in case, step'1' broken \n\n        dp[:2] = 1, 0\n\n    else:\n\n        dp[:2] = 1, 1 # Usually\n\n\n\n    for i in range(2, x+1):\n\n        if i not in broken: # \u968e\u6bb5\u304c\u58ca\u308c\u3066\u306a\u3044\u5834\u5408...\n\n            dp[i] = (dp[i-1] + dp[i-2]) % (10**9+7) # -1\u6bb5\u76ee\u3068-2\u6bb5\u76ee\u306e\u5408\u8a08\n\n    print((dp[-1]))\n\n\n\nptn_num(n)\n","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn, m = list(map(int, input().split()))\n\nbroken = set([int(eval(input())) for _ in range(m)]) # \u3053\u3053\u304c'list'\u3060\u3068Pypy\u3067\u3082\u901a\u3089\u306a\u3044\n\n\n\ndef ptn_num(x): # 'x'step\u307e\u3067\u306e\u30d1\u30bf\u30fc\u30f3\u6570\n\n    dp = [0] * (x+1) # DP\u67a0_including step'0'\n\n    if 1 in broken: # \u56fa\u5b9a\u90e8\u5206_in case, step'1' broken \n\n        dp[:2] = 1, 0\n\n    else:\n\n        dp[:2] = 1, 1 # \u56fa\u5b9a\u90e8\u5206_Usually\n\n\n\n    for i in range(2, x+1):\n\n        if i not in broken: # \u968e\u6bb5\u304c\u58ca\u308c\u3066\u306a\u3044\u5834\u5408...\n\n            dp[i] = (dp[i-1] + dp[i-2]) % (10**9+7) # -1\u6bb5\u76ee\u3068-2\u6bb5\u76ee\u306e\u5408\u8a08\n\n    print((dp[-1]))\n\n\n\nptn_num(n)","model_generated_potentially_faster_code_col":"import sys\n\n\ndef ptn_num(n):\n    MOD = 10 ** 9 + 7\n    dp = [-1] * (n + 1)\n    \n    def helper(i):\n        if i < 0:\n            return 0\n        elif i == 0 or i == 1:\n            return 1\n        elif dp[i] != -1:\n            return dp[i]\n        \n        dp[i] = (helper(i - 1) + helper(i - 2)) % MOD\n        return dp[i]\n\n    dp[0], dp[1] = 1, 1\n    if 1 in broken:\n        dp[1] = 0\n    \n    for i in range(2, n + 1):\n        if i not in broken:\n            dp[i] = helper(i)\n\n    print(dp[n])\n\n\nif __name__ == \"__main__\":\n    input = sys.stdin.readline\n    n, m = map(int, input().split())\n    broken = {int(eval(input())) for _ in range(m)}\n    ptn_num(n)"}
{"problem_id":"p03000","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nN, X  = list(map(int, input().split()))\n\n\n\nL = np.array(list(map(int, input().split())))\n\n\n\nx = np.zeros(N+1)\n\n\n\nfor n in range(1,N+1):\n\n    x[n] = x[n-1] + L[n-1]\n\n    if x[n] > X:\n\n        print(n)\n\n        sys.exit()\n\n\n\nprint((N+1))\n\n\n","reference_code_col":"N, X = list(map(int, input().split()))\n\nL = list(map(int, input().split()))\n\n\n\ncnt = 1\n\nsum_L = 0\n\nfor l in L:\n\n    sum_L += l\n\n    if sum_L <= X:\n\n        cnt += 1\n\n    else:\n\n        break\n\n\n\nprint(cnt)\n","model_generated_potentially_faster_code_col":"import sys\n\nimport numpy as np\n\n# Read input values\nN, X = map(int, input().split())\nL = np.array(list(map(int, input().split())))\n\n# Initialize variables\ncurrent_sum = 0\nresult = N + 1\n\n# Iterate through the array to find the prefix sum\nfor n in range(N):\n    current_sum += L[n]\n    if current_sum > X:\n        result = n + 1\n        break\n\n# Print the result\nprint(result)"}
{"problem_id":"p02881","slow_code_col":"n = int(eval(input()))\n\nr = int(n**.5)\n\nfor i in range(r):\n\n  if n % (r-i) == 0:\n\n    print(( (r-i) + n\/\/(r-i) - 2 ))\n\n    break","reference_code_col":"n = int(eval(input()))\n\ns = int(n**.5)\n\nfor i in range(s):\n\n  if n % (s-i) == 0:\n\n    print(((s-i) + n \/\/ (s-i) - 2))\n\n    break","model_generated_potentially_faster_code_col":"n = int(input())\n\n# If n is less than or equal to 1, there's no need to check for divisors.\nif n <= 1:\n    print(None)\nelse:\n    # Iterate from 2 up to the square root of n.\n    for i in range(2, int(n**0.5) + 1):\n        # If i divides n evenly, then it's the smallest divisor greater than 1.\n        if n % i == 0:\n            print(i + n\/\/i - 2)\n            break\n    else:\n        # If no divisors were found, n is prime.\n        print(n - 2)"}
{"problem_id":"p03253","slow_code_col":"from collections import Counter\n\ndef factorization(n) -> list:\n\n\tif n==1:\n\n\t\treturn [1]\n\n\tret = []\n\n\ti = 2\n\n\twhile i*i<=n:\n\n\t\twhile n%i==0:\n\n\t\t\tn \/\/= i\n\n\t\t\tret.append(i)\n\n\t\ti += 1\n\n\tif n!=1:\n\n\t\tret.append(n)\n\n\treturn ret\n\n\n\nn,m = list(map(int,input().split()))\n\nmod = 10**9+7\n\nif m==1:\n\n\tprint((1));exit()\n\n\n\nfactors = Counter(factorization(m))\n\nmx = n+max(factors.values())\n\n\n\nfac = [1]*(mx+1)\n\ninv = [1]*(mx+1)\n\nfor i in range(1,mx+1):\n\n\tfac[i] = fac[i-1] * i % mod\n\ninv[-1] = pow(fac[-1], mod - 2, mod)\n\nfor i in range(mx-1, -1, -1):\n\n\tinv[i] = inv[i+1] * (i+1) % mod\n\ndef cmb(n,r):\n\n\tassert n >= r >= 0\n\n\treturn fac[n] * inv[n-r] * inv[r] % mod\n\n\t\n\nans=1\n\nfor v in list(factors.values()):\n\n\tans*=cmb(n+v-1,v)\n\n\tans%=mod\n\n\n\nprint(ans)","reference_code_col":"from collections import Counter\n\ndef factorization(n) -> list:\n\n\tif n==1:return [1]\n\n\tret = []\n\n\ti = 2\n\n\twhile i*i<=n:\n\n\t\twhile n%i==0:\n\n\t\t\tn \/\/= i\n\n\t\t\tret.append(i)\n\n\t\ti += 1\n\n\tif n!=1:ret.append(n)\n\n\treturn ret\n\n\t\n\nfrom operator import mul\n\nfrom functools import reduce\n\ndef cmb(n,r):\n\n\tif n < r:return 0\n\n\tr = min(n-r,r)\n\n\tif r==0:return 1\n\n\tu = reduce(mul, list(range(n, n-r, -1)))\n\n\td = reduce(mul, list(range(1,r+1)))\n\n\treturn u\/\/d\n\n\n\ndef main():\n\n\tn,m = list(map(int,input().split()))\n\n\tmod = 10**9+7\n\n\tif m==1:\n\n\t\tprint((1))\n\n\t\texit()\n\n\tans=1\n\n\tfor v in list(Counter(factorization(m)).values()):\n\n\t\tans*=cmb(n+v-1,v)\n\n\t\tans%=mod\n\n\tprint(ans)\n\n\t\n\nif __name__==\"__main__\":main()","model_generated_potentially_faster_code_col":"from collections import Counter\n\ndef factorization(n):\n    factors = []\n    # Factorize out powers of 2\n    while n % 2 == 0:\n        factors.append(2)\n        n \/\/= 2\n    # Factorize out other primes\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n \/\/= i\n        i += 2\n    # If n is still greater than 2, then n itself is a prime number\n    if n > 2:\n        factors.append(n)\n    return factors\n\nn, m = map(int, input().split())\nmod = 10**9 + 7\n\nif m == 1:\n    print(1)\n    exit()\n\nfactors = Counter(factorization(m))\nmx = n + max(factors.values())\n\n# Precompute factorials and their modular inverses\nfact = [1] * (mx + 1)\ninv = [1] * (mx + 1)\nfor i in range(1, mx + 1):\n    fact[i] = fact[i - 1] * i % mod\ninv[mx] = pow(fact[mx], mod - 2, mod)\nfor i in range(mx - 1, -1, -1):\n    inv[i] = inv[i + 1] * (i + 1) % mod\n\ndef comb(n, r):\n    assert n >= r >= 0\n    return fact[n] * inv[n - r] * inv[r] % mod\n\nans = 1\nfor v in factors.values():\n    ans *= comb(n + v - 1, v)\n    ans %= mod\n\nprint(ans)"}
{"problem_id":"p02725","slow_code_col":"K, N = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\n\n\ndiff = A[0] + K - A[-1]\n\nans = A[-1] - A[0]\n\nfor i in range(1, N):\n\n    dist = K - A[i] + A[i - 1]\n\n    if dist < ans:\n\n        ans = dist\n\n\n\nprint(ans)\n","reference_code_col":"import sys\n\n\n\n\n\ndef input():\n\n    return sys.stdin.readline().strip()\n\n\n\n\n\ndef main():\n\n    K, N = list(map(int, input().split()))\n\n    A = list(map(int, input().split()))\n\n\n\n    ans = [K - A[i] + A[i - 1] for i in range(1, N)]\n\n    print((min(min(ans), A[-1] - A[0])))\n\n\n\n\n\nmain()\n","model_generated_potentially_faster_code_col":"K, N = map(int, input().split())\nA = list(map(int, input().split()))\n\ndiff = A[0] + K - A[-1]\nans = diff\n\nfor i in range(1, N):\n    dist = abs(A[i] - A[i-1])\n    if dist < ans:\n        ans = dist\n\nprint(ans)"}
{"problem_id":"p02837","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\nx = []\n\ny = []\n\nfor i in range(n):\n\n    a = int(sys.stdin.readline().rstrip())\n\n    xy = [sys.stdin.readline().split() for _ in range(a)]\n\n    if not xy:\n\n        x.append(None)\n\n        y.append(None)\n\n        continue\n\n    xi, yi = np.array(xy, np.int64).T\n\n    x.append(xi-1)\n\n    y.append(yi)\n\n\n\ndef main():\n\n\n\n    ans = 0\n\n    for comb in range(2 ** n):\n\n        cnt = 0\n\n        for i in range(n):\n\n            if not comb >> i & 1:\n\n                continue\n\n            if x[i] is None:\n\n                cnt += 1\n\n                continue\n\n            if np.count_nonzero(comb >> x[i] & 1 ^ y[i]):\n\n                break\n\n            cnt += 1\n\n        else:\n\n            ans = max(ans, cnt)\n\n    return ans\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","reference_code_col":"import sys\n\n\n\nn = int(sys.stdin.readline().rstrip())\n\nxy = [[] for _ in range(n)]\n\nfor i in range(n):\n\n    a = int(sys.stdin.readline().rstrip())\n\n    for j in range(a):\n\n        x, y = list(map(int, sys.stdin.readline().split()))\n\n        xy[i].append((x-1, y))\n\n\n\ndef main():\n\n    ans = 0\n\n    for comb in range(2 ** n):\n\n        cnt = 0\n\n        for i in range(n):\n\n            if comb >> i & 1 ^ 1:\n\n                continue\n\n            for x, y in xy[i]:\n\n                if comb >> x & 1 ^ y:\n\n                    break\n\n            else:\n\n                cnt += 1\n\n                continue\n\n            break\n\n        else:\n\n            ans = max(ans, cnt)\n\n    return ans\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\nn = int(sys.stdin.readline().rstrip())\nx = []\ny = []\n\nfor i in range(n):\n    a = int(sys.stdin.readline().rstrip())\n    xy = [list(map(int, sys.stdin.readline().split())) for _ in range(a)]\n    if not xy:\n        x.append(None)\n        y.append(None)\n        continue\n    xi, yi = np.array(xy, dtype=np.int64).T\n    x.append(xi - 1)\n    y.append(yi)\n\ndef main():\n    ans = 0\n    all_bits = (1 << n) - 1\n    \n    for comb in range(1 << n):\n        cnt = 0\n        for i in range(n):\n            if comb & (1 << i) == 0:\n                continue\n            if x[i] is None:\n                cnt += 1\n                continue\n            mask = comb >> x[i]\n            if (mask & y[i]) != y[i]:\n                break\n            cnt += 1\n        \n        if cnt == n:\n            ans = max(ans, cnt)\n    \n    return ans\n\nif __name__ == '__main__':\n    ans = main()\n    print(ans)"}
{"problem_id":"p03371","slow_code_col":"import sys\n\ninput = lambda: sys.stdin.readline().rstrip() \n\n\n\ndef resolve():\n\n    A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n    ans = float('inf')\n\n    for i in range(0, max(X, Y)*2+1, 2):\n\n        ans = min(A*max(X-i\/\/2, 0)+B*max(Y-i\/\/2, 0)+C*i, ans)\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    resolve()\n","reference_code_col":"import sys\n\ninput = lambda: sys.stdin.readline().rstrip() \n\n\n\ndef resolve():\n\n    A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n    ans = 0\n\n    if A+B > 2*C:\n\n        ans = 2*C*min(X, Y)+min((A if X>Y else B)*abs(X-Y), 2*C*abs(X-Y))\n\n    else:\n\n        ans = A*X+B*Y\n\n    \n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    resolve()\n","model_generated_potentially_faster_code_col":"import sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef resolve():\n    A, B, C, X, Y = map(int, input().split())\n\n    ans = float('inf')\n\n    for i in range(0, 2 * max(X, Y) + 1, 2):\n        x_val = max(X - i \/\/ 2, 0)\n        y_val = max(Y - i \/\/ 2, 0)\n        ans = min(A * x_val + B * y_val + C * i, ans)\n\n    print(ans)\n\nif __name__ == '__main__':\n    resolve()"}
{"problem_id":"p03416","slow_code_col":"A,B = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(A,B+1):\n\n    i = str(i)\n\n    if i[0] == i[4]:\n\n        if i[1] == i[3]:\n\n            ans += 1\n\n        else:\n\n            ans += 0\n\n    else:\n\n        ans += 0\n\nprint(ans)","reference_code_col":"A,B = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(A,B+1):\n\n    k = str(i)\n\n    if k[0] == k[4] and k[1] == k[3]:\n\n        ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"def is_palindrome(num):\n    return str(num) == str(num)[::-1]\n\nA, B = map(int, input().split())\n\ncount = sum(is_palindrome(i) for i in range(A, B + 1))\n\nprint(count)"}
{"problem_id":"p03568","slow_code_col":"def main():\n\n    N = int(input())\n\n    A = [int(i) for i in input().split()]\n\n    if N == 1:\n\n        return print(1 if A[0] % 2 == 0 else 2)\n\n    ans = 0\n\n    d = (-1, 0, 1)\n\n    from itertools import product\n\n    for i in product(range(3), repeat=N):\n\n        cur = 1\n\n        for j in range(N):\n\n            cur *= (A[j] + d[i[j]])\n\n        if cur % 2 == 0:\n\n            ans += 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def main():\n\n    N = int(eval(input()))\n\n    A = [int(i) for i in input().split()]\n\n    ans = 3**N\n\n    cnt = len([a for a in A if a % 2 == 0])\n\n    ans -= 2**cnt\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    # Initialize DP table\n    dp = [[0, 0] for _ in range(N+1)]\n\n    # Base case: one way to get a sum of 0 with 0 elements\n    dp[0][0] = 1\n\n    # Fill DP table\n    for i in range(1, N+1):\n        for j in range(2):  # Only two states: even (0) and odd (1)\n            dp[i][j] = dp[i-1][j]  # Carry forward previous state\n            if A[i-1] % 2 == j:  # If current element matches desired parity\n                dp[i][j] += dp[i-1][1-j]  # Add previous state with opposite parity\n\n    # The answer is the number of ways to get an even sum using all elements\n    print(dp[N][0])\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02982","slow_code_col":"import numpy as\tnp\n\n\n\nn, d = list(map(int, input().split()))\n\nx = []\n\nfor i in range(n):\n\n    x.append(list(map(int, input().split())))\n\n\n\nx = np.array(x)\n\n\n\ncount =\t0\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        dist = np.linalg.norm(x[i] - x[j])\n\n        if dist == int(dist):\n\n            count += 1\n\n\n\nprint(count)","reference_code_col":"n, d = list(map(int, input().split()))\n\nx = [list(map(int, input().split())) for _ in range(n)]\n\n\n\n\n\ndef dist(a, b):\n\n    sm = 0\n\n    for ea, eb in zip(a, b):\n\n        sm += (ea - eb) ** 2\n\n\n\n    return sm ** 0.5\n\n\n\n\n\nans = 0\n\nfor i in range(n):\n\n    for j in range(i + 1, n):\n\n        dst = dist(x[i], x[j])\n\n        for k in range(int(16000 ** 0.5) + 1):\n\n            if k == dst:\n\n                ans += 1\n\n                break\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn, d = map(int, input().split())\n\n# Read point coordinates into a NumPy array\nx = np.array([list(map(int, input().split())) for _ in range(n)])\n\n# Calculate squared distances matrix\nsquared_distances = np.sum((x[:, np.newaxis, :] - x[np.newaxis, :, :]) ** 2, axis=2)\n\n# Count integer distances\ncount = np.sum(np.isclose(np.sqrt(squared_distances), np.round(np.sqrt(squared_distances))))\n\n# Subtract self-distances (all zeros) and diagonal elements (repeated pairs)\ncount -= n * (n + 1) \/\/ 2\n\nprint(count)"}
{"problem_id":"p03254","slow_code_col":"import numpy as np\n\nN,x = list(map(int,input().split()))\n\nA = np.array(input().split(), dtype = np.int64)\n\nA.sort()\n\nnp.cumsum(A, out = A)\n\nanswer = (A <= x).sum()\n\n\n\nif answer == N and A[-1] != x:\n\n  answer -= 1\n\nprint(answer)\n","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom bisect import bisect_right\n\nimport itertools\n\n\n\nN,X,*A = list(map(int,read().split()))\n\n\n\nA.sort()\n\nAcum = list(itertools.accumulate(A))\n\n\n\nanswer = bisect_right(Acum,X)\n\nif answer == N:\n\n    if Acum[-1] < X:\n\n        answer -= 1\n\nprint(answer)","model_generated_potentially_faster_code_col":"import numpy as np\n\nN, x = map(int, input().split())\n\nA = np.array(list(map(int, input().split())), dtype=np.int64)\n\n# Sort the array in-place\nA.sort(kind='mergesort')\n\n# Compute cumulative sum in-place\nnp.cumsum(A, out=A)\n\n# Find the number of elements that are less than or equal to x\nanswer = (A <= x).sum()\n\n# If all elements are less than or equal to x and the last element is not x, decrement the count by 1\nif answer == N and A[-1] != x:\n    answer -= 1\n\nprint(answer)"}
{"problem_id":"p03425","slow_code_col":"# -*- coding: utf-8 -*-\n\nfrom collections import defaultdict\n\nfrom itertools import combinations\n\nN = int(eval(input()))\n\nC = [0, 0, 0, 0, 0, 0]\n\nD = defaultdict(int)\n\nfor i, m in enumerate(\"MARCH\", start=1):\n\n    D[m] = i\n\n\n\nfor _ in range(N):\n\n    C[D[input()[0]]] += 1\n\n\n\nans = 0\n\nfor a, b, c in combinations(list(range(1, 6)), r=3):\n\n    ans += C[a]*C[b]*C[c]\n\nprint(ans)","reference_code_col":"from collections import defaultdict\n\nfrom itertools import combinations\n\ndef inpl(): return list(map(int, input().split()))\n\n\n\nC = defaultdict(int)\n\nN = int(eval(input()))\n\nfor _ in range(N):\n\n    C[input()[0]] += 1\n\n\n\nres = 0\n\nfor H in combinations(\"MARCH\", r=3):\n\n    res += C[H[0]] * C[H[1]] * C[H[2]]\n\nprint(res)","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nfrom collections import Counter, defaultdict\n\nN = int(input())\n\nD = defaultdict(int)\nfor i, m in enumerate(\"MARCH\", start=1):\n    D[m] = i\n\n# Count occurrences of each character\ncounts = Counter([D[input()[0]] for _ in range(N)])\n\n# Calculate the number of valid combinations\nans = sum(counts[a] * counts[b] * counts[c] for a, b, c in combinations(range(1, 6), r=3))\n\nprint(ans)"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nN = int(eval(input()))\n\n\n\nprint((math.factorial(N) % (1000000000 + 7)))\n","reference_code_col":"import math\n\n\n\nN = int(eval(input()))\n\n\n\np = 1\n\nfor i in range(2, N+1):\n\n  p *= i\n\n  p = p % (1000000000 + 7)\n\n  \n\nprint(p)\n","model_generated_potentially_faster_code_col":"import sys\n\nN = int(sys.stdin.read())\n\nmodulus = 1000000000 + 7\nfactorial = 1\n\nfor i in range(2, N + 1):\n    factorial = (factorial * i) % modulus\n\nprint(factorial)"}
{"problem_id":"p03309","slow_code_col":"def main():\n\n    from statistics import median\n\n\n\n    n, *a, = list(map(int, open(0).read().split()))\n\n    a = [x - i for i, x in enumerate(a, 1)]\n\n    a.sort()\n\n    m = int(median(a))\n\n\n\n    ans = sum([abs(x - m) for x in a])\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def main():\n\n    n, *a, = list(map(int, open(0).read().split()))\n\n    a = [x - i for i, x in enumerate(a, 1)]\n\n    a.sort()\n\n    if n % 2 == 0:\n\n        ans = sum(a[n \/\/ 2:]) - sum(a[:n \/\/ 2])\n\n    else:\n\n        ans = sum(a[n \/\/ 2 + 1:]) - sum(a[:n \/\/ 2])\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    from statistics import median\n\n    # Read input and process it\n    n, *a = map(int, open(0).read().split())\n\n    # Adjust the array elements\n    a = [x - i for i, x in enumerate(a, 1)]\n\n    # Sort the array\n    a.sort()\n\n    # Calculate the median once\n    m = int(median(a))\n\n    # Calculate the sum of absolute differences efficiently\n    ans = sum(abs(x - m) for x in a)\n\n    # Print the result\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03037","slow_code_col":"N, M = list(map(int, input().split()))\n\nL, R = [], []\n\nlow = -float('INF')\n\nhigh = float('INF')\n\nfor i in range(M):\n\n    l, r = list(map(int, input().split()))\n\n    L.append(l)\n\n    R.append(r)\n\n    if l > low:\n\n        low = l\n\n    if r < high:\n\n        high = r\n\nprint((max(0, high - low + 1)))\n","reference_code_col":"N, M = list(map(int, input().split()))\n\nlow = -float('INF')\n\nhigh = float('INF')\n\nfor i in range(M):\n\n    l, r = list(map(int, input().split()))\n\n    if l > low:\n\n        low = l\n\n    if r < high:\n\n        high = r\n\nprint((max(0, high - low + 1)))\n","model_generated_potentially_faster_code_col":"N, M = map(int, input().split())\n\nL = []\nR = []\n\nfor _ in range(M):\n    l, r = map(int, input().split())\n    L.append(l)\n    R.append(r)\n\nlow = max(L)\nhigh = min(R)\n\nresult = max(0, high - low + 1)\n\nprint(result)"}
{"problem_id":"p03837","slow_code_col":"def main():\n\n    from sys import stdin\n\n    def input():\n\n        return stdin.readline().strip()\n\n\n\n    n, m = list(map(int, input().split()))\n\n    tree = [[] for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        i -= 1\n\n        j -= 1\n\n        tree[i].append((k, j))\n\n        tree[j].append((k, i))\n\n\n\n    # dijkstra\n\n    import heapq\n\n    from numpy import zeros\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in tree[i]:\n\n            seen = zeros(n)\n\n            goal = j[1]\n\n            base = j[0]\n\n            seen[i] = 1\n\n            todo = []\n\n            heapq.heapify(todo)\n\n            for k in tree[i]:\n\n                if k[0] < base and k != j:\n\n                    heapq.heappush(todo, k)\n\n            while len(todo) > 0:\n\n                k = heapq.heappop(todo)\n\n                if k[1] == goal:\n\n                    if k[0] < base:\n\n                        ans += 1\n\n                    break\n\n                seen[k[1]] = 1\n\n                for l in tree[k[1]]:\n\n                    if seen[l[1]] == 0 and k[0] + l[0] < base:\n\n                        heapq.heappush(todo, (k[0] + l[0], l[1]))\n\n\n\n    print((ans \/\/ 2))\n\n\n\nmain()","reference_code_col":"def main():\n\n    from sys import stdin\n\n    def input():\n\n        return stdin.readline().strip()\n\n\n\n    n, m = list(map(int, input().split()))\n\n    tree = [[] for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        i -= 1\n\n        j -= 1\n\n        tree[i].append((k, j))\n\n        tree[j].append((k, i))\n\n\n\n    # dijkstra\n\n    import heapq\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in tree[i]:\n\n            seen = [0] * n\n\n            goal = j[1]\n\n            base = j[0]\n\n            seen[i] = 1\n\n            todo = []\n\n            heapq.heapify(todo)\n\n            for k in tree[i]:\n\n                if k[0] < base and k != j:\n\n                    heapq.heappush(todo, k)\n\n            while len(todo) > 0:\n\n                k = heapq.heappop(todo)\n\n                if k[1] == goal:\n\n                    if k[0] < base:\n\n                        ans += 1\n\n                    break\n\n                seen[k[1]] = 1\n\n                for l in tree[k[1]]:\n\n                    if seen[l[1]] == 0 and k[0] + l[0] < base:\n\n                        heapq.heappush(todo, (k[0] + l[0], l[1]))\n\n\n\n    print((ans \/\/ 2))\n\n\n\nmain()","model_generated_potentially_faster_code_col":"def main():\n    from sys import stdin\n\n    def input():\n        return stdin.readline().strip()\n\n    n, m = map(int, input().split())\n\n    tree = [[] for _ in range(n)]\n\n    for _ in range(m):\n        i, j, k = map(int, input().split())\n        i -= 1\n        j -= 1\n        tree[i].append((k, j))\n        tree[j].append((k, i))\n\n    ans = 0\n\n    for node in range(n):\n        min_edge = float('inf')\n        for neighbor, weight in tree[node]:\n            if weight < min_edge:\n                min_edge = weight\n        for neighbor, weight in tree[node]:\n            if weight >= min_edge:\n                ans += 1\n\n    print(ans \/\/ 2)\n\n\nmain()"}
{"problem_id":"p03197","slow_code_col":"import numpy as np\n\n \n\ndef main():\n\n    stdin = np.fromstring(open(0).read(), dtype=np.int64, sep=' ')\n\n    A = stdin[1:]\n\n    A = np.mod(A, 2)\n\n    print(\"first\") if np.count_nonzero(A) else print(\"second\")\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"import sys\n\ndef input(): return sys.stdin.readline().strip()\n\ndef main():\n\n    N = int(input())\n\n    A = (int(input()) for _ in range(N))\n\n    print(\"second\") if all(( a%2==0 for a in A)) else print(\"first\")\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import numpy as np\n\ndef main():\n    # Read input string and convert it into a NumPy array of integers\n    stdin = np.fromstring(input(), dtype=np.int64, sep=' ')\n    \n    # Extract all elements except the first one\n    A = stdin[1:]\n    \n    # Use np.any() instead of np.count_nonzero() for better performance\n    has_odd = np.any(A % 2 != 0)\n    \n    # Print result based on whether there are any odd numbers\n    print(\"first\" if has_odd else \"second\")\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02555","slow_code_col":"a,b,c=1,0,0\n\nexec('a,b,c=b,c,(a+c)%(10**9+7);'*(int(eval(input()))-2))\n\nprint(c)","reference_code_col":"a,b,c=1,0,0\n\nexec('a,b,c=b,c,a+c;'*(int(eval(input()))-2))\n\nprint((c%(10**9+7)))","model_generated_potentially_faster_code_col":"a, b, c = 1, 0, 0\n\nn = int(eval(input()))\nfor _ in range(n - 2):\n    a, b, c = b, c, (a + c) % (10**9 + 7)\n\nprint(c)"}
{"problem_id":"p02615","slow_code_col":"# -*- coding: utf-8 -*-\n\n# \u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30a4\u30f3\u30dd\u30fc\u30c8\n\nimport math\n\nimport numpy as np\n\n\n\n# \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\n# \u6c42\u89e3\u51e6\u7406\n\nA = sorted(A, reverse=True)\n\nA = np.array(A)\n\nans = 2 * np.sum(A[:(N \/\/ 2)]) - A[0] + (N % 2) * A[math.floor(N \/ 2)]\n\n\n\n# \u7d50\u679c\u51fa\u529b\n\nprint(ans)\n","reference_code_col":"# -*- coding: utf-8 -*-\n\n# \u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30a4\u30f3\u30dd\u30fc\u30c8\n\nimport math\n\n\n\n# \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\n# \u6c42\u89e3\u51e6\u7406\n\nA = sorted(A, reverse=True)\n\nans = 0\n\nfor n in range(1, N + 1):\n\n    if n == 1:\n\n        continue\n\n    ans += A[math.ceil(n \/ 2) - 1]\n\n\n\n# \u7d50\u679c\u51fa\u529b\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\n# \u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30a4\u30f3\u30dd\u30fc\u30c8\n\nimport numpy as np\n\n# \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97\n\nN = int(input())\nA = list(map(int, input().split()))\n\n# \u6c42\u89e3\u51e6\u7406\nA.sort(reverse=True)\nA = np.array(A)\n\n# Calculate the sum of the first N\/\/2 elements\nsum_first_half = np.sum(A[:N \/\/ 2])\n\n# Calculate the result\nif N % 2 == 0:\n    ans = 2 * sum_first_half - A[0]\nelse:\n    ans = 2 * sum_first_half - A[0] + A[N \/\/ 2]\n\n# \u7d50\u679c\u51fa\u529b\nprint(ans)"}
{"problem_id":"p03371","slow_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\n\n\nz = max(x,y) * 2\n\nmin_sum = c * z\n\n\n\nfor i in range(z):\n\n    r = max(0, y - i) * b\n\n    t = max(0, x - i) * a\n\n    sum = c * i * 2 + r + t\n\n    if sum < min_sum:\n\n        min_sum = sum\n\n\n\nprint(min_sum)","reference_code_col":"a,b,c,x,y = list(map(int, input().split()))\n\n\n\nplan_a = c * (2*x) + max(0, y-x) * b\n\nplan_b = c * (2*y) + max(0, x-y) * a\n\nplan_c = a * x + b * y\n\n\n\nprint((min(plan_a, plan_b, plan_c)))","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\n\n# Calculate maximum value for i \nmax_i = min(x, y)\n\n# Calculate the sum with the optimal i\nmin_sum = c * max_i * 2 + max(0, y - max_i) * b + max(0, x - max_i) * a\n\nprint(min_sum)"}
{"problem_id":"p03796","slow_code_col":"N = int(eval(input()))\n\na = 1\n\nfor n in range(2,N+1):\n\n    a = a*n % (10**9+7)\n\nprint(a)","reference_code_col":"def factorial(N):\n\n    a = 1\n\n    for n in range(2,N+1):\n\n        a = a*n % (10**9 + 7)\n\n    return a\n\n\n\nif __name__ == '__main__':\n\n    N = int(eval(input()))\n\n    print((factorial(N)))","model_generated_potentially_faster_code_col":"N = int(eval(input()))\n\na = 1\n\nfor n in range(2,N+1):\n    a = (a * n) % (10**9 + 7)\n\nprint(a)"}
{"problem_id":"p03371","slow_code_col":"# -*- coding: utf-8 -*-\n\n\n\nA, B, C, X, Y = list(map(int, input().split()))\n\n\n\ncost = int(1e10)\n\nfor num_ac in range(0, int(1e5) + 1):\n\n    num_A = max(0, X - num_ac)\n\n    num_B = max(0, Y - num_ac)\n\n    c = 2 * C * num_ac + A * num_A + B * num_B\n\n    cost = min(c, cost)\n\nprint(cost)","reference_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\n\n\nans = 0\n\nif A + B > 2 * C:\n\n    z = min(X, Y)\n\n    X -= z\n\n    Y -= z\n\n    ans += 2 * z * C\n\n\n\n# \u504f\u308a\u5206\n\nif 2 * C < A:\n\n    k = X\n\n    X -= k\n\n    Y -= k\n\n    ans += 2 * C * k\n\nif 2 * C < B:\n\n    k = Y\n\n    X -= k\n\n    Y -= k\n\n    ans += 2 * C * k\n\n\n\n# \u3042\u307e\u308a\u5206\n\nans += A * max(0, X) + B * max(0, Y)\n\nprint(ans)","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nA, B, C, X, Y = map(int, input().split())\n\n# Calculate the maximum number of A and B that can be used\nmax_A = min(X, Y)\nmax_B = min(X, Y)\n\n# Calculate the remaining number of A and B after using the maximum amount\nremaining_A = X - max_A\nremaining_B = Y - max_B\n\n# Calculate the total cost\ncost = A * remaining_A + B * remaining_B + 2 * C * max_A\n\nprint(cost)"}
{"problem_id":"p03170","slow_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom operator import xor\n\nfrom functools import reduce\n\n\n\nN,K,*A = list(map(int,read().split()))\n\n\n\na = reduce(xor,(1<<a for a in A))\n\n\n\ndp = 0 # bitset\n\nfor n in range(K):\n\n    if not(dp&(1<<n)):\n\n        dp |= (a<<n)\n\n\n\nanswer = 'First' if dp&(1<<K) else 'Second'\n\nprint(answer)","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nN,K,*A = list(map(int,read().split()))\n\n\n\ndp = [0]*(K+1) # bitset\n\nfor n in range(K):\n\n    if not dp[n]:\n\n        for a in A:\n\n            if n+a>K:\n\n                break\n\n            dp[n+a]=1\n\n\n\nanswer = 'First' if dp[-1] else 'Second'\n\nprint(answer)","model_generated_potentially_faster_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nN, K, *A = map(int, read().split())\n\n# Initialize memoization table\nmemo = [-1] * (1 << N)\n\ndef dp(state):\n    if state == (1 << N) - 1:\n        return False\n    \n    if memo[state] != -1:\n        return memo[state]\n    \n    for i in range(N):\n        if not state & (1 << i):\n            new_state = state | (1 << i)\n            if not dp(new_state):\n                memo[state] = True\n                return True\n            \n    memo[state] = False\n    return False\n\nresult = 'First' if dp(0) else 'Second'\nprint(result)"}
{"problem_id":"p03060","slow_code_col":"import numpy as np\n\n\n\nn = int(eval(input()))\n\n\n\nv_list = np.array(list(map(int,input().split())))\n\nc_list = np.array(list(map(int,input().split())))\n\ne_list = list(v_list - c_list)\n\n\n\nans = 0\n\n\n\nfor i in range(n):\n\n    if e_list[i] > 0:\n\n        ans += e_list[i]\n\n\n\nprint(ans)\n","reference_code_col":"n = int(eval(input()))\n\n\n\nv_list = list(map(int,input().split()))\n\nc_list = list(map(int,input().split()))\n\n\n\ne_list = [v-c if (v-c > 0) else 0 for v,c in zip(v_list, c_list)]\n\n\n\nprint((sum(e_list)))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn = int(eval(input()))\nv_list = np.array(list(map(int, input().split())))\nc_list = np.array(list(map(int, input().split())))\n\n# Calculate the difference between v_list and c_list using vectorized operation\ne_list = v_list - c_list\n\n# Use NumPy's sum function to calculate the total positive values efficiently\nans = np.sum(e_list[e_list > 0])\n\nprint(ans)"}
{"problem_id":"p02624","slow_code_col":"n = int(eval(input()))\n\nans = 0\n\nSQRT = int(n ** 0.5)\n\nfor m in range(1,SQRT + 1):\n\n    b = int(n\/m)\n\n    ans += m * (m + b) * (b + 1 - m)\n\nans -= SQRT * (SQRT+1) * (2*SQRT+1) \/\/ 6\n\nprint(ans)","reference_code_col":"def main():\n\n  n = int(eval(input()))\n\n  ans = 0\n\n  SQRT = int(n ** 0.5)\n\n  for m in range(1,SQRT + 1):\n\n    b = int(n\/m)\n\n    ans += m * (m + b) * (b + 1 - m)\n\n  ans -= SQRT * (SQRT+1) * (2*SQRT+1) \/\/ 6\n\n  print(ans)\n\nmain()\n","model_generated_potentially_faster_code_col":"n = int(input())"}
{"problem_id":"p03173","slow_code_col":"import numpy as np\n\n\n\nN = int(eval(input()))\n\nA = [0] + list(map(int, input().split()))\n\n\n\nA = np.array(A, dtype = np.int64)\n\nA = np.cumsum(A)\n\n\n\ndp = np.zeros((N, N), dtype = np.int64)\n\n\n\nfor j in range(1, N):\n\n    for i in range(N - j):\n\n        # print (dp[i, i:i + j], dp[i + 1:i + j + 1, i + j])\n\n        tmp = min(dp[i, i:i + j] + dp[i + 1:i + j + 1, i + j])\n\n        dp[i][i + j] = tmp + A[i + j + 1] - A[i]\n\n\n\nprint((dp[0][N - 1]))","reference_code_col":"N = int(eval(input()))\n\nA = [0] + list(map(int, input().split()))\n\n\n\nINF = 10 ** 18\n\n\n\ndp = [[0] * (N) for _ in range(N)]\n\n\n\nfor i in range(N):\n\n    A[i + 1] += A[i]\n\n\n\nfor j in range(1, N):\n\n    for i in range(N - j):\n\n        tmp = INF\n\n        for k in range(i, i + j):\n\n            # print (i, i + j, k + 1)\n\n            tmp = min(tmp, dp[i][k] + dp[k + 1][i + j])\n\n        dp[i][i + j] = tmp + A[i + j + 1] - A[i]\n\n\n\nprint((dp[0][N - 1]))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(eval(input()))\nA = [0] + list(map(int, input().split()))\nA = np.array(A, dtype=np.int64)\nprefix_sum = np.cumsum(A)\n\ndp = np.zeros((N, N), dtype=np.int64)\n\nfor j in range(1, N):\n    for i in range(N - j):\n        dp[i][i + j] = float('inf')\n        for k in range(i, i + j):\n            if A[k] <= A[k + 1]:\n                dp[i][i + j] = min(dp[i][i + j], dp[i][k] + dp[k + 1][i + j])\n        dp[i][i + j] += prefix_sum[i + j + 1] - prefix_sum[i]\n\nprint(dp[0][N - 1])"}
{"problem_id":"p03828","slow_code_col":"import math\n\nimport collections\n\n\n\nN = int(eval(input()))\n\na = math.factorial(N)\n\ncheck = []\n\nans = 1\n\ni = 2\n\n\n\nwhile a != 1:\n\n    if a % i == 0:\n\n        a \/\/= i\n\n        check.append(i)\n\n    else:\n\n        i += 1\n\n        \n\ncheck = list(collections.Counter(check).values())\n\nfor i in check:\n\n    ans *= (i+1)\n\n    ans %= 10**9+7\n\nprint(ans)","reference_code_col":"from math import factorial\n\n\n\nN = factorial(int(eval(input())))\n\n\n\ni = 2\n\ncheck = 1\n\nans = 1\n\nwhile N != 1:\n\n    if N % i == 0:\n\n        N \/\/= i\n\n        check += 1\n\n    else:\n\n        ans *= check\n\n        check = 1\n\n        i += 1\n\nprint(((ans*check)%(10**9+7)))","model_generated_potentially_faster_code_col":"from math import factorial\nfrom collections import Counter\n\nN = int(input())\nfact = factorial(N)\nprime_factors = {}\n\n# find prime factors\ni = 2\nwhile fact != 1:\n    while fact % i == 0:\n        if i in prime_factors:\n            prime_factors[i] += 1\n        else:\n            prime_factors[i] = 1\n        fact \/\/= i\n    i += 1\n\n# calculate answer\nans = 1\nfor exp in prime_factors.values():\n    ans *= (exp + 1)\n    ans %= 10**9 + 7\n\nprint(ans)"}
{"problem_id":"p02988","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nP = np.array(lr())\n\n\n\nP_diff = np.diff(P)\n\nP_diff = P_diff > 0\n\nseries = P_diff[:-1] == P_diff[1:]\n\nanswer = series.sum()\n\nprint(answer)\n\n# 23","reference_code_col":"N = int(eval(input()))\n\nP = list(map(int, input().split()))\n\nanswer = sum(x>y>z or x<y<z for x, y, z in zip(P[:-2], P[1:-1], P[2:]))\n\nprint(answer)\n\n    ","model_generated_potentially_faster_code_col":"import sys\n\nN = int(input())\nP = [int(input()) for _ in range(N)]\n\nP_diff = [(P[i+1] - P[i]) > 0 for i in range(len(P)-1)]\nseries = [P_diff[i] == P_diff[i+1] for i in range(len(P_diff)-1)]\n\nanswer = sum(series)\nprint(answer)"}
{"problem_id":"p02982","slow_code_col":"import numpy as np\n\nn,d=list(map(int,input().split()))\n\nnda=np.empty((0,d),int)\n\nans=0\n\nfor i in range(0,n):\n\n  a=np.array([list(map(int,input().split()))])\n\n  for j in range(i):\n\n    chklen=np.linalg.norm(a-nda[j])\n\n    if chklen==chklen\/\/1:\n\n      ans+=1\n\n  nda=np.append(nda,a,axis=0)\n\nprint(ans)","reference_code_col":"import math\n\nn,d=list(map(int,input().split()))\n\na=[0]*n\n\nfor i in range(n):\n\n  a[i]=list(map(int,input().split()))\n\nans=0\n\nfor i in range(n-1):\n\n  for j in range(i+1,n):\n\n    chklen=0\n\n    wk=0\n\n    for k in range(d):\n\n      wk+=abs(a[i][k]-a[j][k])**2\n\n    chklen=math.sqrt(wk)\n\n    if chklen==chklen\/\/1:\n\n      ans+=1\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\nn, d = map(int, input().split())\n\n# read data into a list of lists\ndata = [list(map(int, input().split())) for _ in range(n)]\n\n# convert list of lists to numpy array\ndata = np.array(data)\n\n# compute all pairwise distances\ndistances = np.sqrt(((data[:, None] - data)**2).sum(axis=-1))\n\n# count pairs with integer distance\nans = np.sum(distances == np.round(distances))\n\nprint(ans)"}
{"problem_id":"p03371","slow_code_col":"A,B,C,X,Y=list(map(int,input().split()))\n\n\n\nK=10**9\n\nfor i in range(10**5+1):\n\n    S=i*2*C+max(0,X-i)*A+max(0,Y-i)*B\n\n    K=min(K,S)\n\nprint(K)","reference_code_col":"A,B,C,X,Y=list(map(int,input().split()))\n\n\n\na=min(X,Y)*min(A+B,2*C)\n\n\n\na+=max(0,X-Y)*min(A,2*C)\n\na+=max(0,Y-X)*min(B,2*C)\n\n\n\n\n\nprint(a)","model_generated_potentially_faster_code_col":"A, B, C, X, Y = map(int, input().split())\n\nK = float('inf')\n\n# Iterate only up to the minimum of X and Y\nfor i in range(min(X, Y) + 1):\n    S = i * 2 * C + max(0, X - i) * A + max(0, Y - i) * B\n    K = min(K, S)\n\nprint(K)"}
{"problem_id":"p03032","slow_code_col":"N, K = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\n\n\nanswer = 0\n\nlimit = min(N, K)\n\nfor a in range(limit+1): #\u5de6\u304b\u3089\u53d6\u308a\u51fa\u3059\n\n    for b in range(limit-a+1): #\u53f3\u304b\u3089\u53d6\u308a\u51fa\u3059\n\n        for c in range(K-(a+b)+1):\n\n            use = V[:a] + V[N-b:]\n\n            use.sort()\n\n            s = sum(use[c:])\n\n            answer = max(answer, s)\n\n\n\nprint(answer)","reference_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 9)\n\n\n\nN, K = list(map(int, input().split()))\n\nV = list(map(int, input().split()))\n\nV2 = V * 2\n\nanswer = 0\n\nfor i in range(1, min(N, K)+1): # i\u306f\u5b9d\u77f3\u3092\u53d6\u308a\u51fa\u3059\u500b\u6570\n\n    for j in range(0, min(i, K-i)+1): # j\u306f\u4f55\u500b\u306e\u5b9d\u77f3\u3092\u624b\u96e2\u3059\u304b\n\n        for k in range(max(0, N-i), N+1): # V2\u306e\u4e2d\u3067\u4f55\u756a\u76ee\u304b\u3089\u53d6\u308a\u51fa\u3059\u304b\n\n            use = V2[k:k+i]\n\n            use.sort()\n\n            s = sum(use[j:])\n\n            if s > answer:\n\n                answer = s\n\n\n\nprint(answer)\n","model_generated_potentially_faster_code_col":"N, K = map(int, input().split())\nV = list(map(int, input().split()))\n\n# Create a prefix sum array\nprefix_sum = [0]\nfor v in V:\n    prefix_sum.append(prefix_sum[-1] + v)\n\nanswer = 0\n\n# Iterate over all possible left lengths\nfor i in range(min(N, K) + 1):\n    # Iterate over all possible right lengths\n    for j in range(min(N - i, K - i) + 1):\n        # Calculate the sum of the remaining elements\n        remaining_sum = prefix_sum[-1] - prefix_sum[i + j]\n        # Update the maximum sum\n        answer = max(answer, remaining_sum)\n\nprint(answer)"}
{"problem_id":"p02390","slow_code_col":"S = int(input())\n\n\n\nif S >= 3600:\n\n    h=S\/\/3600\n\n    m=S%3600\/\/60\n\n    s=S%60\n\nelif 3600 > S >= 60:\n\n    h=0\n\n    m=S\/\/60\n\n    s=S%60\n\nelse:\n\n    h=m=0\n\n    s=S\n\nprint(h, m, s, sep=\":\")\n","reference_code_col":"s = int(input())\n\nh = s \/\/ 3600\n\nm = (s - h * 3600) \/\/ 60\n\ns = s -  h * 3600 - m * 60\n\nprint(h, m, s, sep=\":\")\n","model_generated_potentially_faster_code_col":"S = int(input())\n\nh = S \/\/ 3600\nm = (S % 3600) \/\/ 60 if S >= 60 else 0\ns = S % 60 if S >= 60 else S\n\nprint(f\"{h:02}:{m:02}:{s:02}\")"}
{"problem_id":"p03806","slow_code_col":"def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1<<30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(400, -1, -1):\n\n\t\t\tfor j in range(400, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\nif __name__==\"__main__\":\n\n\tmain()","reference_code_col":"def main():\n\n\tn, ma, mb, *L = list(map(int, open(0).read().split()))\n\n\tM = 1 << 30\n\n\tdp = [[M] * 420 for _ in range(420)]\n\n\tdp[0][0] = 0\n\n\tua = ub = 15\n\n\tfor a, b, c in zip(*[iter(L)] * 3):\n\n\t\tfor i in range(ua, -1, -1):\n\n\t\t\tfor j in range(ub, -1, -1):\n\n\t\t\t\tt = dp[i][j] + c\n\n\t\t\t\tif dp[i + a][j + b] > t:\n\n\t\t\t\t\tdp[i + a][j + b] = t\n\n\t\t\t\t\tif ua < i + a:\n\n\t\t\t\t\t\tua = i + a\n\n\t\t\t\t\tif ub < j + b:\n\n\t\t\t\t\t\tub = j + b\n\n\tans = M\n\n\t_ma, _mb = ma, mb\n\n\twhile _ma < 410 > _mb:\n\n\t\tans = min(ans, dp[_ma][_mb])\n\n\t\t_ma += ma\n\n\t\t_mb += mb\n\n\tprint((ans if ans < M else -1))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()\n","model_generated_potentially_faster_code_col":"def main():\n    n, ma, mb, *L = map(int, input().split())\n\n    # Initialize DP table with a large value (infinity)\n    dp = [float('inf')] * (n + 1)\n\n    # Base case\n    dp[0] = 0\n\n    # Process each triplet (a, b, c)\n    for a, b, c in zip(L[::3], L[1::3], L[2::3]):\n        # Update DP table from the back to avoid overwriting\n        for i in range(n, -1, -1):\n            if dp[i] == float('inf'):\n                break\n            if i + a <= n and dp[i + a] > dp[i] + c:\n                dp[i + a] = dp[i] + c\n\n    # Find the minimum cost starting from (ma, mb) and moving along the path\n    ans = float('inf')\n    while ma >= 0 and mb >= 0:\n        if dp[ma] != float('inf') and dp[mb] != float('inf'):\n            ans = min(ans, dp[ma] + dp[mb])\n        ma -= ma\n        mb -= mb\n\n    print(-1 if ans == float('inf') else ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\n\n\nn = int(eval(input()))\n\na = np.array(list(map(int,input().split())))\n\n\n\ncount = 0\n\nwhile np.all(a%2==0):\n\n    count+=1\n\n    a=a\/2\n\nprint(count)\n","reference_code_col":"N=int(eval(input()))\n\na = [int(i) for i in input().split()]\n\n\n\ncount=0\n\nwhile 1:\n\n    if sum([i%2 for i in a]) == 0:\n\n        a = [i\/2 for i in a]\n\n        count=count+1\n\n    else:\n\n        print(count)\n\n        break\n","model_generated_potentially_faster_code_col":"import numpy as np\n\nn = int(eval(input()))\na = np.array(list(map(int,input().split())))\nmax_a = np.max(a)\nhighest_power_of_2 = np.floor(np.log2(max_a)).astype(int)\ntotal_bits = np.ceil(np.log2(max_a + 1)).astype(int)\ncount = total_bits - highest_power_of_2\nprint(count)"}
{"problem_id":"p03434","slow_code_col":"_,s=open(c:=0)\n\nfor a in sorted(map(int,s.split())):c=a-c\n\nprint(c)","reference_code_col":"for a in sorted(map(int,[*open(c:=0)][1].split())):c=a-c\n\nprint(c)","model_generated_potentially_faster_code_col":"import sys\n\n# Read the line from standard input\nline = sys.stdin.read().strip()\n\n# Split the line into integers and sort them\nsorted_numbers = sorted(map(int, line.split()))\n\n# Initialize the result with the first element of the sorted list\nresult = sorted_numbers[0]\n\n# Iterate over the remaining elements and update the result\nfor num in sorted_numbers[1:]:\n    result -= num\n\n# Print the final result\nprint(result)"}
{"problem_id":"p02883","slow_code_col":"import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n \n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n \n\n    num = 0\n\n    sum_ = []\n\n    for i in range(N):\n\n      sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 90):\n\n        number = 0\n\n        mid = (left + right) \/\/ 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) \/ F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # \u6700\u5927\u5024\u3092mid\u3088\u308a\u5c0f\u3055\u304f\u3067\u304d\u306a\u3044 -> \u6700\u5927\u5024\u306f\u3082\u3063\u3068\u3067\u304b\u3044\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n        \n\n \n\n \n\n \n\nif __name__ == '__main__':\n\n    main()","reference_code_col":"import sys\n\nsys.setrecursionlimit(10000000)\n\nimport heapq\n\nimport math\n\n\n\ndef main():\n\n    N, K = list(map(int, input().split()))\n\n    A = [int(c) for c in input().split()]\n\n    F = [int(c) for c in input().split()]\n\n    \n\n    A.sort()\n\n    F.sort(reverse=True)\n\n\n\n    num = 0\n\n    sum_ = []\n\n    for i in range(len(A)):\n\n        sum_.append(A[i] * F[i])\n\n    left = 0\n\n    right = 10 ** 12\n\n    while(num < 50):\n\n        number = 0\n\n        mid = (left + right) \/\/ 2\n\n        # print(mid)\n\n        for i in range(len(A)):\n\n            if sum_[i] <= mid:\n\n                continue\n\n            else:\n\n                number += math.ceil((sum_[i] - mid) \/ F[i])\n\n            # print(number)\n\n        if number > K:\n\n            # \u6700\u5927\u5024\u3092mid\u3088\u308a\u5c0f\u3055\u304f\u3067\u304d\u306a\u3044 -> \u6700\u5927\u5024\u306f\u3082\u3063\u3068\u3067\u304b\u3044\n\n            left = mid + 1\n\n        else:\n\n            right = mid\n\n        num += 1\n\n    print(mid)\n\n                \n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import heapq\nimport math\n\ndef main():\n    N, K = map(int, input().split())\n    A = sorted(map(int, input().split()))\n    F = sorted(map(int, input().split()), reverse=True)\n\n    # Initialize variables\n    left = 0\n    right = 10**12\n    num = 0\n\n    while num < 90:\n        mid = (left + right) \/\/ 2\n        number = 0\n\n        for i in range(N):\n            if sum_[i] <= mid:\n                continue\n            else:\n                number += math.ceil((sum_[i] - mid) \/ F[i])\n\n        if number > K:\n            left = mid + 1\n        else:\n            right = mid\n\n        num += 1\n\n    print(left)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p00134","slow_code_col":"from statistics import mean\n\n\n\ninputCount = int(eval(input()))\n\nprices = [int(eval(input())) for lp in range(inputCount)]\n\naverage = mean(prices)\n\nprint((int(average)))\n\n\n","reference_code_col":"inputCount = int(eval(input()))\n\nprices = [int(eval(input())) for lp in range(inputCount)]\n\naverage = sum(prices) \/\/ inputCount\n\nprint(average)\n\n\n","model_generated_potentially_faster_code_col":"from statistics import mean\n\ninputCount = int(input())\n\nprices = []\nfor _ in range(inputCount):\n    prices.append(int(input()))\n\naverage = mean(prices)\nprint(int(average))"}
{"problem_id":"p03559","slow_code_col":"from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nimport sys,bisect,math,itertools,fractions,pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn = inp()\n\nA = sorted(inpl())\n\nB = sorted(inpl())\n\nC = sorted(inpl())\n\ncnt = [0] * n\n\nres = 0\n\nfor i,b in enumerate(B):\n\n    c = bisect.bisect_left(C,b+1)\n\n    cnt[i] = n-c\n\n\n\nacc = [0]\n\nfor x in cnt:\n\n    acc += [acc[-1] + x]\n\nsu = sum(cnt) \n\nfor i,a in enumerate(A):\n\n    c = bisect.bisect_left(B,a+1)\n\n    res += su - acc[c]\n\nprint(res)","reference_code_col":"from collections import Counter,defaultdict,deque\n\nfrom heapq import heappop,heappush,heapify\n\nimport sys,bisect,math,itertools,fractions,pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\nINF = float('inf')\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\n\n\nn = inp()\n\na = inpl()\n\nb = inpl()\n\nc = inpl()\n\na.sort()\n\nb.sort()\n\nc.sort()\n\nlb = [0] * n\n\nres = 0\n\nfor i in range(n):\n\n    tmp = bisect.bisect_right(b,a[i])\n\n    if tmp == n: continue\n\n    lb[tmp] += 1\n\nllb = list(itertools.accumulate(lb))\n\n# print(lb,llb)\n\nrr = [0] * n\n\nfor i in range(n):\n\n    tmp = bisect.bisect_right(c,b[i])\n\n    if tmp == n: continue\n\n    rr[tmp] += llb[i]\n\nprint((sum(list(itertools.accumulate(rr)))))","model_generated_potentially_faster_code_col":"from collections import Counter, defaultdict, deque\nfrom heapq import heappop, heappush, heapify\nimport sys, bisect, math, itertools, fractions, pprint\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9 + 7\n\nINF = float('inf')\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef inpl():\n    return list(map(int, sys.stdin.readline().split()))\n\n# Read input\nn = inp()\nA = sorted(inpl())\nB = sorted(inpl())\nC = sorted(inpl())\n\n# Initialize variables\ncnt = [0] * n\nres = 0\n\n# Count how many elements in C are greater than each element in B\nfor b in B:\n    c = bisect.bisect_right(C, b)\n    cnt[b] = n - c\n\n# Calculate prefix sums for cnt array\nacc = [0]\nfor x in cnt:\n    acc.append(acc[-1] + x)\n\n# Calculate the result using the prefix sums\nfor a in A:\n    c = bisect.bisect_right(B, a)\n    res += (len(C) - c) * (n - acc[c])\n\nprint(res % mod)"}
{"problem_id":"p00144","slow_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nhttp:\/\/judge.u-aizu.ac.jp\/onlinejudge\/description.jsp?id=0144\n\n\n\n\"\"\"\n\nimport sys\n\nfrom sys import stdin\n\ninput = stdin.readline\n\nfrom enum import Enum\n\n\n\n\n\nclass Graph(object):\n\n    \"\"\" single source shortest path \"\"\"\n\n    class Status(Enum):\n\n        \"\"\" ?????????????\u00a8??????\u00b6??? \"\"\"\n\n        white = 1  # ????\u00a8????\n\n        gray = 2  # ?\u00a8???????\n\n        black = 3  #?\u00a8???????\n\n\n\n    def __init__(self, n, data):\n\n        self.num_of_nodes = n+1\n\n        self.color = [Graph.Status.white] * self.num_of_nodes  # ????????????????\u00a8??????\u00b6???\n\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n\n        for i in range(self.num_of_nodes):\n\n            self.M[i][i] = 0\n\n        self._make_matrix(data)  # data????????????????????\u00a3??\\??????(?????\\?\u00b6???\u00a8???????????????????????\u00a7????????????)\n\n        self.d = [float('inf')] * self.num_of_nodes  # ?\u00a7???????????????????(?????????)\n\n        self.p = [-1] * self.num_of_nodes  # ????????????????????????????\u00a8?????????????????????????\n\n\n\n    def _make_matrix(self, data):\n\n        for d in data:\n\n            r = d[0]\n\n            for t in d[2:]:\n\n                self.M[r][t] = 1\n\n\n\n    def dijkstra(self, start):\n\n        self.d[start] = 0\n\n        self.p[start] = -1\n\n        while True:\n\n            mincost = float('inf')\n\n            # ??\\??????????????\u00a7??????????????\u00a8?????????????????????u???????????????\n\n            for i in range(len(self.d)):\n\n                if self.color[i] != Graph.Status.black and self.d[i] < mincost:  # S????\u00b1???????????????????S??\u00a8??\\?\u00b6?????????????????????????????????????????\u00b0???????????????????\n\n                    mincost = self.d[i]\n\n                    u = i  # u??????????????????ID\n\n            if mincost == float('inf'):\n\n                break\n\n            self.color[u] = Graph.Status.black  # ?????????u???S????\u00b1???????????????\u00b4???\n\n            for v in range(len(self.d)):\n\n                if self.color[v] != Graph.Status.black and self.M[u][v] != float('inf'):\n\n                    # v????????????????????????????????\u00b0??????S???????????\u00a3???u????????????????????????????????????????????\u00b0??????????????\u00b1??\u00a7??\u00b4??\u00b0??????\n\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n\n                        self.d[v] = self.d[u] + self.M[u][v]\n\n                        self.p[v] = u\n\n                        self.color[v] = Graph.Status.gray\n\n\n\n    def warshallFloyd(self):\n\n        V = self.num_of_nodes\n\n        for k in range(V):\n\n            for i in range(V):\n\n                for j in range(V):\n\n                    self.M[i][j] = min(self.M[i][j], self.M[i][k] + self.M[k][j])\n\n\n\n\n\n\n\ndef main(args):\n\n    n = int(eval(input()))\n\n    network = []\n\n    for _ in range(n):\n\n        network.append([int(x) for x in input().split()])\n\n\n\n    packets = []\n\n    p = int(eval(input()))\n\n    for _ in range(p):\n\n        packets.append([int(x) for x in input().split()])\n\n\n\n    g = Graph(n, network)\n\n    g.warshallFloyd()\n\n\n\n    for s, d, v in packets:\n\n        if g.M[s][d] < v:\n\n            print((g.M[s][d]+1))\n\n        else:\n\n            print('NA')\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])","reference_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nhttp:\/\/judge.u-aizu.ac.jp\/onlinejudge\/description.jsp?id=0144\n\n\n\n\"\"\"\n\nimport sys\n\nfrom sys import stdin\n\ninput = stdin.readline\n\nfrom enum import Enum\n\n\n\n\n\nclass Graph(object):\n\n    \"\"\" single source shortest path \"\"\"\n\n    class Status(Enum):\n\n        \"\"\" ?????????????\u00a8??????\u00b6??? \"\"\"\n\n        white = 1  # ????\u00a8????\n\n        gray = 2  # ?\u00a8???????\n\n        black = 3  #?\u00a8???????\n\n\n\n    def __init__(self, n, data):\n\n        self.num_of_nodes = n+1\n\n        self.color = [Graph.Status.white] * self.num_of_nodes  # ????????????????\u00a8??????\u00b6???\n\n        self.M = [[float('inf')] * self.num_of_nodes for _ in range(self.num_of_nodes)]\n\n        for i in range(self.num_of_nodes):\n\n            self.M[i][i] = 0\n\n        self._make_matrix(data)  # data????????????????????\u00a3??\\??????(?????\\?\u00b6???\u00a8???????????????????????\u00a7????????????)\n\n        self.d = [float('inf')] * self.num_of_nodes  # ?\u00a7???????????????????(?????????)\n\n        self.p = [-1] * self.num_of_nodes  # ????????????????????????????\u00a8?????????????????????????\n\n\n\n    def _make_matrix(self, data):\n\n        for d in data:\n\n            r = d[0]\n\n            for t in d[2:]:\n\n                self.M[r][t] = 1\n\n\n\n    def dijkstra(self, start):\n\n        self.d[start] = 0\n\n        self.p[start] = -1\n\n        while True:\n\n            mincost = float('inf')\n\n            # ??\\??????????????\u00a7??????????????\u00a8?????????????????????u???????????????\n\n            for i in range(len(self.d)):\n\n                if self.color[i] != Graph.Status.black and self.d[i] < mincost:  # S????\u00b1???????????????????S??\u00a8??\\?\u00b6?????????????????????????????????????????\u00b0???????????????????\n\n                    mincost = self.d[i]\n\n                    u = i  # u??????????????????ID\n\n            if mincost == float('inf'):\n\n                break\n\n            self.color[u] = Graph.Status.black  # ?????????u???S????\u00b1???????????????\u00b4???\n\n            for v in range(len(self.d)):\n\n                if self.color[v] != Graph.Status.black and self.M[u][v] != float('inf'):\n\n                    # v????????????????????????????????\u00b0??????S???????????\u00a3???u????????????????????????????????????????????\u00b0??????????????\u00b1??\u00a7??\u00b4??\u00b0??????\n\n                    if self.d[u] + self.M[u][v] < self.d[v]:\n\n                        self.d[v] = self.d[u] + self.M[u][v]\n\n                        self.p[v] = u\n\n                        self.color[v] = Graph.Status.gray\n\n\n\n    def warshallFloyd(self):\n\n        for k in range(self.num_of_nodes):\n\n            for i in range(self.num_of_nodes):\n\n                for j in range(self.num_of_nodes):\n\n                    if self.M[i][k] + self.M[k][j] < self.M[i][j]: \n\n                        self.M[i][j] = self.M[i][k] + self.M[k][j]\n\n\n\n\n\ndef main(args):\n\n    n = int(eval(input()))\n\n    network = []\n\n    for _ in range(n):\n\n        network.append([int(x) for x in input().split()])\n\n\n\n    packets = []\n\n    p = int(eval(input()))\n\n    for _ in range(p):\n\n        packets.append([int(x) for x in input().split()])\n\n\n\n    g = Graph(n, network)\n\n    g.warshallFloyd()\n\n\n\n    for s, d, v in packets:\n\n        if g.M[s][d] < v:\n\n            print((g.M[s][d]+1))\n\n        else:\n\n            print('NA')\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\nhttp:\/\/judge.u-aizu.ac.jp\/onlinejudge\/description.jsp?id=0144\n\"\"\"\n\nimport sys\nfrom heapq import heappop, heappush\nfrom typing import List, Tuple\n\ninput = sys.stdin.read\ndata = input().split()\n\nclass Graph(object):\n    \"\"\" Single source shortest path \"\"\"\n    \n    def __init__(self, n: int, edges: List[Tuple[int, int]]):\n        self.n = n + 1\n        self.graph = [[] for _ in range(self.n)]\n        \n        for u, v in edges:\n            self.graph[u].append(v)\n            \n        self.dist = [float('inf')] * self.n\n        self.prev = [-1] * self.n\n    \n    def dijkstra(self, start: int):\n        self.dist[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            dist_u, u = heappop(pq)\n            \n            if dist_u > self.dist[u]:\n                continue\n            \n            for v in self.graph[u]:\n                alt = dist_u + 1\n                \n                if alt < self.dist[v]:\n                    self.dist[v] = alt\n                    self.prev[v] = u\n                    heappush(pq, (alt, v))\n                    \n    def shortest_path(self, start: int, end: int) -> int:\n        self.dijkstra(start)\n        return self.dist[end]\n    \n    def reconstruct_path(self, start: int, end: int) -> List[int]:\n        path = []\n        current = end\n        \n        while current != start and current != -1:\n            path.append(current)\n            current = self.prev[current]\n        \n        if current == -1:\n            return []\n        \n        path.append(start)\n        return path[::-1]\n\ndef main():\n    index = 0\n    n = int(data[index])\n    index += 1\n    \n    edges = []\n    for _ in range(n):\n        u = int(data[index]) - 1\n        index += 1\n        m = int(data[index])\n        index += 1\n        for _ in range(m):\n            v = int(data[index]) - 1\n            index += 1\n            edges.append((u, v))\n    \n    p = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(p):\n        s = int(data[index]) - 1\n        index += 1\n        d = int(data[index]) - 1\n        index += 1\n        v = int(data[index])\n        index += 1\n        queries.append((s, d, v))\n    \n    g = Graph(n, edges)\n    \n    for s, d, v in queries:\n        if g.shortest_path(s, d) < v:\n            print(g.shortest_path(s, d) + 1)\n        else:\n            print('NA')\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02268","slow_code_col":"def binarySearch():\n\n    n = int(eval(input()))\n\n    S = set(map(int, input().split()))\n\n    q = int(eval(input()))\n\n    T = set(map(int, input().split()))\n\n    print((len(S.intersection(T))))\n\n    \n\n\n\nbinarySearch()","reference_code_col":"def binarySearch():\n\n    n = int(eval(input()))\n\n    S = set(input().split())\n\n    q = int(eval(input()))\n\n    T = set(input().split())\n\n    print((len(S.intersection(T))))\n\n    \n\n\n\nbinarySearch()","model_generated_potentially_faster_code_col":"def binary_search():\n    n = int(input())\n    S = set(map(int, input().split()))\n    q = int(input())\n    T = set(map(int, input().split()))\n    \n    # Calculate the length of the intersection of S and T\n    result = len(S & T)\n    \n    # Print the result\n    print(result)\n\n# Call the function\nbinary_search()"}
{"problem_id":"p03416","slow_code_col":"a,b=list(map(int,input().split()))\n\n\n\nans=0\n\n\n\nfor i in range(a,b+1):\n\n    buf=str(i)\n\n    #print(buf[0:int(len(buf)\/2)],buf[int(len(buf)\/2+1):])\n\n    str1=buf[0:int(len(buf)\/2)]\n\n    str2=buf[int(len(buf)\/2+1):]\n\n    if str1[0]==str2[1] and str1[1]==str2[0]:\n\n        ans+=1\n\n\n\nprint(ans)\n","reference_code_col":"a,b=list(map(int,input().split()))\n\n\n\nans=0\n\n\n\nfor i in range(a,b+1):\n\n    buf=str(i)\n\n    str1=buf[::-1]\n\n    if buf==str1:\n\n        ans+=1\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"a, b = map(int, input().split())\n\nans = 0\n\nfor i in range(a, b + 1):\n    s = str(i)\n    n = len(s)\n    \n    # Check if the string has an odd length\n    if n % 2 == 1:\n        continue\n    \n    # Extract the first half and second half of the string\n    mid = n \/\/ 2\n    first_half = s[:mid]\n    second_half = s[mid:]\n    \n    # Check if the condition is met\n    if first_half[0] == second_half[-1] and first_half[1] == second_half[0]:\n        ans += 1\n\nprint(ans)"}
{"problem_id":"p02725","slow_code_col":"#template\n\ndef inputlist(): return [int(j) for j in input().split()]\n\n#template\n\n#issue\u304b\u3089\u59cb\u3081\u308b\n\nK,N = inputlist()\n\nA = inputlist()\n\nlia = [0]*N\n\nfor i in range(1,N):\n\n    k = A[i] - A[i-1]\n\n    lia[i] = k\n\nlia[0] = (K+A[0]-A[-1])\n\nlia.sort()\n\nans = 0\n\nfor i in range(N-1):\n\n    ans += lia[i]\n\nprint(ans)","reference_code_col":"#template\n\ndef inputlist(): return [int(j) for j in input().split()]\n\ndef listinput(): return input().split()\n\n#template\n\nK,N = inputlist()\n\nA = inputlist()\n\ndis = [0]*(N)\n\nfor i in range(N):\n\n    if i == N-1:\n\n        dis[i] = K+A[0] - A[i]\n\n        continue\n\n    dis[i] = A[i+1] - A[i]\n\ndis.sort()\n\nprint((sum(dis[:-1])))","model_generated_potentially_faster_code_col":"def inputlist():\n    return list(map(int, input().split()))\n\n# Read input values\nK, N = inputlist()\nA = inputlist()\n\n# Calculate differences and handle the circular nature\ndiffs = [(A[i] - A[(i - 1) % N]) for i in range(N)]\n\n# Sort the differences\ndiffs.sort()\n\n# Sum up all but the largest difference\nans = sum(diffs[:-1])\n\nprint(ans)"}
{"problem_id":"p03000","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, X = lr()\n\nL = np.array([0] + lr())\n\nLcum = L.cumsum()\n\ni = np.searchsorted(Lcum, X, side='right')\n\nprint(i)\n\n# ","reference_code_col":"# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, X = lr()\n\nL = lr()\n\ncnt = 1\n\ncur = 0\n\nfor l in L:   \n\n    cur += l\n\n    if cur > X:\n\n        break\n\n    cnt += 1\n\n\n\nanswer = cnt\n\nprint(answer)\n","model_generated_potentially_faster_code_col":"import sys\nimport bisect\n\ndef read_int():\n    return int(sys.stdin.readline().strip())\n\ndef read_int_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\n# Read input\nN, X = read_int_list()\nL = [0] + read_int_list()\n\n# Calculate cumulative sum\nLcum = []\ncurrent_sum = 0\nfor num in L:\n    current_sum += num\n    Lcum.append(current_sum)\n\n# Perform binary search\nindex = bisect.bisect_right(Lcum, X)\n\nprint(index)"}
{"problem_id":"p02767","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tN = II()\n\n\tX = LI()\n\n\tX = np.array(X)\n\n\tm = round(np.sum(X) \/ N)\n\n\tprint(int(np.sum((X-m)**2)))\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n","reference_code_col":"import sys\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tN = II()\n\n\tX = LI()\n\n\tm = round(sum(X) \/ N)\n\n\tans = 0\n\n\tfor x in X:\n\n\t\tans += ((x-m)**2)\n\n\tprint(ans)\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n","model_generated_potentially_faster_code_col":"import sys\n\n\nsys.setrecursionlimit(10 ** 6)\n\n\nint1 = lambda x: int(x) - 1\n\n\ndef IS(): return sys.stdin.readline()[:-1]\n\n\ndef II(): return int(IS())\n\n\ndef MI(): return map(int, IS().split())\n\n\ndef LI(): return list(MI())\n\n\ndef LI1(): return list(map(int1, IS().split()))\n\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\ndef main():\n    N = II()\n    X = LI()\n\n    # Calculate mean using vectorized operation\n    m = sum(X) \/\/ N\n\n    # Calculate variance using vectorized operation\n    variance = sum((xi - m) ** 2 for xi in X)\n\n    print(variance)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03720","slow_code_col":"n, m = list(map(int, input().split()))\n\nRD = list(list(map(int, input().split())) for _ in range(m))\n\nfor i in range(1, n + 1):\n\n    ans = 0\n\n    for j in RD:\n\n        ans += j.count(i)\n\n    print(ans)","reference_code_col":"n, m = list(map(int, input().split()))\n\nNRD = list(0 for i in range(n))\n\nfor i in range(m):\n\n    r1, r2 = list(map(int, input().split()))\n\n    NRD[r1 - 1] += 1\n\n    NRD[r2 - 1] += 1\n\nfor i in range(n):\n\n    print((NRD[i]))","model_generated_potentially_faster_code_col":"n, m = map(int, input().split())\n\n# Initialize a dictionary to store the count of each number\ncount_dict = {i: 0 for i in range(1, n + 1)}\n\n# Read the matrix and update the count dictionary\nfor _ in range(m):\n    row = list(map(int, input().split()))\n    for num in row:\n        if num in count_dict:\n            count_dict[num] += 1\n\n# Print the count of each number\nfor i in range(1, n + 1):\n    print(count_dict[i])"}
{"problem_id":"p03371","slow_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nfor HaH in range(0,2*max(x,y)+1,2):\n\n    ans = min(ans, c*HaH+max(0, a*(x-HaH\/\/2))+max(0, b*(y-HaH\/\/2)))\n\nprint(ans)","reference_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\nans=0\n\nm=min(x,y)\n\nif a+b>=2*c: #Half and Half\u8cfc\u5165\u3067\u5b89\u304f\u306a\u308b\u53ef\u80fd\u6027\u3042\u308b\u30d1\u30bf\u30fc\u30f3\n\n    # HaH\u3092m\u679a\u8cb7\u3063\u3066\u6b8b\u308aHaH\u8cfc\u5165,\u307e\u305f\u306f\u5168\u90e8HaH\u8cfc\u5165,\u3053\u306e\u3044\u305a\u308c\u304b\u3057\u304b\u3042\u308a\u5f97\u306a\u3044\n\n    ans = min(2*c*m+a*(x-m)+b*(y-m), 2*c*max(x,y))\n\nelse:\n\n    ans = a*x+b*y\n\nprint(ans)","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\n\nans = a * x + b * y\n\n# Iterate only up to 2x\nfor HaH in range(0, 2 * x + 1, 2):\n    ans = min(ans, c * HaH + a * (x - HaH \/\/ 2) + b * (y - HaH \/\/ 2))\n\nprint(ans)"}
{"problem_id":"p02994","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, L = lr()\n\nA = np.arange(1, N+1)\n\nA += (L - 1)\n\nanswer = A.sum() - A[np.argmin(np.abs(A))]\n\nprint(answer)","reference_code_col":"import sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN, L = lr()\n\ntotal = sum(range(L, L+N))\n\nsub = min(list(range(L, L+N)), key=abs)\n\nprint((total-sub))\n","model_generated_potentially_faster_code_col":"A = np.arange(N) + L"}
{"problem_id":"p03078","slow_code_col":"import numpy as np\n\n\n\n\n\ndef main():\n\n    X, Y, Z, K = list(map(int, input().split(' ')))\n\n    A = np.array(list(map(int, input().split(' '))))\n\n    B = np.array(list(map(int, input().split(' '))))\n\n    C = np.array(list(map(int, input().split(' '))))\n\n    AB = np.array(np.meshgrid(A, B)).T.reshape(-1, 2).sum(axis=1)\n\n    AB[::-1].sort()\n\n    AB = AB[:min([K, X * Y])]\n\n    ABC = np.array(np.meshgrid(AB, C)).T.reshape(-1, 2).sum(axis=1)\n\n    ABC[::-1].sort()\n\n    for ans in ABC[:K]:\n\n        print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()","reference_code_col":"from heapq import heappush, heappop\n\nfrom collections import defaultdict\n\n\n\n\n\ndef main():\n\n    X, Y, Z, K = list(map(int, input().split(' ')))\n\n    A = list(map(int, input().split(' ')))\n\n    B = list(map(int, input().split(' ')))\n\n    C = list(map(int, input().split(' ')))\n\n    A.sort(reverse=True)\n\n    B.sort(reverse=True)\n\n    C.sort(reverse=True)\n\n    que = [(- A[0] - B[0] - C[0], 0, 0, 0)]  # multiply -1 to change min to max\n\n    already_inserted = defaultdict(int)\n\n    answer = list()\n\n    for _ in range(K):\n\n        q, i, j, k = heappop(que)\n\n        answer.append(-q)\n\n        if i + 1 < X:\n\n            item_a = (- A[i + 1] - B[j] - C[k], i + 1, j, k)\n\n            if already_inserted[item_a] == 0:\n\n                heappush(que, item_a)\n\n                already_inserted[item_a] = 1\n\n        if j + 1 < Y:\n\n            item_b = (- A[i] - B[j + 1] - C[k], i, j + 1, k)\n\n            if already_inserted[item_b] == 0:\n\n                heappush(que, item_b)\n\n                already_inserted[item_b] = 1\n\n        if k + 1 < Z:\n\n            item_c = (- A[i] - B[j] - C[k + 1], i, j, k + 1)\n\n            if already_inserted[item_c] == 0:\n\n                heappush(que, item_c)\n\n                already_inserted[item_c] = 1\n\n    for ans in answer:\n\n        print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"import numpy as np\nimport heapq\n\ndef main():\n    X, Y, Z, K = map(int, input().split())\n\n    A = np.array(input().split(), dtype=int)\n    B = np.array(input().split(), dtype=int)\n    C = np.array(input().split(), dtype=int)\n\n    # Calculate all possible sums of pairs from A and B\n    AB = np.sort(np.unique(A + B))[-min(K, X * Y):]\n\n    # Use a min-heap to maintain the top K sums of triples (AB[i] + C[j])\n    heap = []\n    for ab in AB:\n        for c in C:\n            if len(heap) < K:\n                heapq.heappush(heap, ab + c)\n            elif ab + c > heap[0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, ab + c)\n\n    # Print the top K sums\n    while heap:\n        print(heapq.heappop(heap))\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03325","slow_code_col":"N = int(eval(input()))\n\nx = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in x:\n\n  while i % 2 == 0:\n\n    cnt += 1\n\n    i \/= 2\n\nprint(cnt)","reference_code_col":"n = int(eval(input()))\n\nans = 0\n\nfor i in map(int, input().split()):\n\n    cnt = 0\n\n    while i % 2 == 0:\n\n        i >>= 1\n\n        cnt += 1\n\n    ans += cnt\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(input())\n\nx = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in x:\n\n  while i % 2 == 0:\n\n    cnt += 1\n\n    i \/\/= 2\n\nprint(cnt)"}
{"problem_id":"p02649","slow_code_col":"def popcount(x):\n\n    x = x - ((x >> 1) & 0x55555555)\n\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n\n    x = x + (x >> 8)\n\n    x = x + (x >> 16)\n\n    return x & 0x0000007f\n\n\n\ncmb=[[0 for i in range(51)] for j in range(51)]\n\ncmb[0][0]=1\n\nfor i in range(51):\n\n    for j in range(51):\n\n        if i!=50 and j!=50:\n\n            cmb[i+1][j+1]+=cmb[i][j]\n\n        if i!=50:\n\n            cmb[i+1][j]+=cmb[i][j]\n\n\n\nfor i in range(1,51):\n\n    for j in range(2,51):\n\n        cmb[i][j]+=cmb[i][j-1]\n\n\n\nN,K,T,S=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\n\n\nmust0=[i for i in range(18) if S>>i &1==0]\n\nmust1=[i for i in range(18) if T>>i &1==1]\n\n\n\nA=[]\n\nfor val in a:\n\n    check=True\n\n    for j in must0:\n\n        check=check&(val>>j &1==0)\n\n    for j in must1:\n\n        check=check&(val>>j &1==1)\n\n    if check:\n\n        A.append(val)\n\n\n\nif not A:\n\n    print((0))\n\n    exit()\n\n\n\nbit=[]\n\nfor i in range(18):\n\n    if i not in must0 and i not in must1:\n\n        bit.append(i)\n\n\n\nfor i in range(len(A)):\n\n    temp=0\n\n    for j in range(len(bit)):\n\n        temp+=(A[i]>>bit[j] &1==1)*2**j\n\n    A[i]=temp\n\n\n\nans=0\n\nn=len(bit)\n\ndata=[0]*(2**n)\n\nfor i in range(2**n):\n\n    t=set([])\n\n    for a in A:\n\n        data[a&i]+=1\n\n        t.add(a&i)\n\n    temp=0\n\n    for val in t:\n\n        temp+=cmb[data[val]][min(K,data[val])]\n\n    ans+=temp*(-1)**popcount(i)\n\n    for val in t:\n\n        data[val]=0\n\n\n\nprint(ans)\n","reference_code_col":"def popcount(x):\n\n    x = x - ((x >> 1) & 0x55555555)\n\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n\n    x = x + (x >> 8)\n\n    x = x + (x >> 16)\n\n    return x & 0x0000007f\n\n\n\ncmb=[[0 for i in range(51)] for j in range(51)]\n\ncmb[0][0]=1\n\nfor i in range(51):\n\n    for j in range(51):\n\n        if i!=50:\n\n            cmb[i+1][j]+=cmb[i][j]\n\n        if j!=50 and i!=50:\n\n            cmb[i+1][j+1]+=cmb[i][j]\n\n\n\n\n\nfor i in range(1,51):\n\n    for j in range(2,51):\n\n        cmb[i][j]+=cmb[i][j-1]\n\n\n\nimport random\n\nN,K,T,S=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\n\n\nmust0=[i for i in range(18) if S>>i &1==0]\n\nmust1=[i for i in range(18) if T>>i &1==1]\n\n\n\nA=[]\n\nfor val in a:\n\n    check=True\n\n    for j in must0:\n\n        check=check&(val>>j &1==0)\n\n    for j in must1:\n\n        check=check&(val>>j &1==1)\n\n    if check:\n\n        A.append(val)\n\n\n\nif not A:\n\n    print((0))\n\n    exit()\n\n\n\nbit=[]\n\nfor i in range(18):\n\n    if i not in must0 and i not in must1:\n\n        bit.append(i)\n\n\n\nfor i in range(len(A)):\n\n    temp=0\n\n    for j in range(len(bit)):\n\n        temp+=(A[i]>>bit[j] &1==1)*2**j\n\n    A[i]=temp\n\n\n\nans=0\n\nn=len(bit)\n\ndata=[0]*(2**n)\n\npc=[popcount(i) for i in range(2**n)]\n\nfor i in range(2**n):\n\n    for a in A:\n\n        data[a&i]+=1\n\n    for a in A:\n\n        if data[a&i]:\n\n            ans+=cmb[data[a&i]][min(K,data[a&i])]*(-1)**pc[i]\n\n            data[a&i]=0\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"def popcount(x):\n    x -= (x >> 1) & 0x55555555\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f\n    x += x >> 8\n    x += x >> 16\n    return x & 0x0000007f"}
{"problem_id":"p03078","slow_code_col":"import sys\n\n#import numpy as np\n\n\n\ns2nn = lambda s: [int(c) for c in s.split(' ')]\n\nss2nn = lambda ss: [int(s) for s in ss]\n\nss2nnn = lambda ss: [s2nn(s) for s in ss]\n\ni2s = lambda: sys.stdin.readline().rstrip()\n\ni2n = lambda: int(i2s())\n\ni2nn = lambda: s2nn(i2s())\n\nii2ss = lambda n: [sys.stdin.readline().rstrip() for _ in range(n)]\n\nii2nn = lambda n: ss2nn(ii2ss(n))\n\nii2nnn = lambda n: ss2nnn(ii2ss(n))\n\n\n\nN = 10000\n\ndef tokey(i, j, k):\n\n    return i*N*N + j*N + k\n\ndef dekey(n):\n\n    i = int(n \/ N \/ N)\n\n    j = int(n \/ N) % N\n\n    k = n % N\n\n    return i, j, k\n\n\n\ndef main():\n\n    X, Y, Z, K = i2nn()\n\n    A = i2nn()\n\n    B = i2nn()\n\n    C = i2nn()\n\n    A.sort()\n\n    A.reverse()\n\n    B.sort()\n\n    B.reverse()\n\n    C.sort()\n\n    C.reverse()\n\n    Q = [(A[0] + B[0] + C[0], 0, 0, 0)]\n\n    loop = 0\n\n    stored = set()\n\n    def next(i, j, k):\n\n        if i >= X or j >= Y or k >= Z:\n\n            return\n\n        key = tokey(i, j, k)\n\n        if key not in stored:\n\n            stored.add(key)\n\n            n = A[i] + B[j] + C[k]\n\n            Q.append((n, i, j, k))\n\n    while True:\n\n        v = max(Q, key=lambda v: v[0])\n\n        Q.remove(v)\n\n        print((v[0]))\n\n        loop += 1\n\n        if loop >= K:\n\n            break\n\n        next(v[1]+1, v[2], v[3])\n\n        next(v[1], v[2]+1, v[3])\n\n        next(v[1], v[2], v[3]+1)\n\n\n\nmain()\n","reference_code_col":"import sys\n\nfrom collections import deque  # \u53cc\u65b9\u5411\u30ad\u30e5\u30fc\n\nfrom collections import defaultdict  # \u521d\u671f\u5316\u6e08\u307f\u8f9e\u66f8\n\nfrom heapq import heapify, heappush, heappop, heappushpop  # \u30d7\u30e9\u30a4\u30aa\u30ea\u30c6\u30a3\u30ad\u30e5\u30fc\n\nfrom bisect import bisect_left, bisect_right  # \u4e8c\u5206\u63a2\u7d22\n\n#import numpy as np  # 1.8.2\n\n#import scipy  # 0.13.3\n\n#sys.setrecursionlimit(int(1e+6))\n\ns2nn = lambda s: [int(c) for c in s.split(' ')]\n\nss2nn = lambda ss: [int(s) for s in ss]\n\nss2nnn = lambda ss: [s2nn(s) for s in ss]\n\ni2s = lambda: sys.stdin.readline().rstrip()\n\ni2n = lambda: int(i2s())\n\ni2nn = lambda: s2nn(i2s())\n\nii2ss = lambda n: [sys.stdin.readline().rstrip() for _ in range(n)]\n\nii2sss = lambda n: [list(sys.stdin.readline().rstrip()) for _ in range(n)]\n\nii2nn = lambda n: ss2nn(ii2ss(n))\n\nii2nnn = lambda n: ss2nnn(ii2ss(n))\n\nMOD = int(1e+9) + 7\n\n\n\ndef main():\n\n    X, Y, Z, K = i2nn()\n\n    A = i2nn()\n\n    B = i2nn()\n\n    C = i2nn()\n\n    A.sort()\n\n    A.reverse()\n\n    B.sort()\n\n    B.reverse()\n\n    C.sort()\n\n    C.reverse()\n\n    s = set()\n\n    hq = []\n\n    n = 0\n\n    heappush(hq, ((A[0] + B[0] + C[0]) * -1, (0, 0, 0)))\n\n    while n < K:\n\n        t, abc = heappop(hq)\n\n        if abc in s:\n\n            continue\n\n        s.add(abc)\n\n        (a, b, c) = abc\n\n        if a+1 < X:\n\n            heappush(hq, ((A[a+1] + B[b] + C[c]) * -1, (a+1, b, c)))\n\n        if b+1 < Y:\n\n            heappush(hq, ((A[a] + B[b+1] + C[c]) * -1, (a, b+1, c)))\n\n        if c+1 < Z:\n\n            heappush(hq, ((A[a] + B[b] + C[c+1]) * -1, (a, b, c+1)))\n\n        print((-t))\n\n        n += 1\n\n\n\nmain()\n","model_generated_potentially_faster_code_col":"import sys\nfrom heapq import heappop, heappush\n\n# Helper functions\ns2nn = lambda s: [int(c) for c in s.split(' ')]\nss2nn = lambda ss: [int(s) for s in ss]\nss2nnn = lambda ss: [s2nn(s) for s in ss]\ni2s = lambda: sys.stdin.readline().rstrip()\ni2n = lambda: int(i2s())\ni2nn = lambda: s2nn(i2s())\nii2ss = lambda n: [sys.stdin.readline().rstrip() for _ in range(n)]\nii2nn = lambda n: ss2nn(ii2ss(n))\nii2nnn = lambda n: ss2nnn(ii2ss(n))\n\n# Constants\nN = 10000\n\n# Functions\ndef tokey(i, j, k):\n    return i * N * N + j * N + k\n\ndef dekey(n):\n    i = int(n \/ N \/ N)\n    j = int(n \/ N) % N\n    k = n % N\n    return i, j, k\n\ndef main():\n    X, Y, Z, K = i2nn()\n    A = i2nn()\n    B = i2nn()\n    C = i2nn()\n\n    # Sort lists in descending order\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n\n    # Initialize heap with the first element\n    Q = [(-A[0] - B[0] - C[0], 0, 0, 0)]\n    heappush(Q, (-A[0] - B[0] - C[0], 0, 0, 0))\n\n    stored = set()\n    loop = 0\n\n    while Q:\n        v = heappop(Q)\n        print(-v[0])\n        loop += 1\n        if loop >= K:\n            break\n\n        i, j, k = v[1], v[2], v[3]\n        if i < X - 1:\n            next_val = -A[i + 1] - B[j] - C[k]\n            heappush(Q, (next_val, i + 1, j, k))\n        if j < Y - 1:\n            next_val = -A[i] - B[j + 1] - C[k]\n            heappush(Q, (next_val, i, j + 1, k))\n        if k < Z - 1:\n            next_val = -A[i] - B[j] - C[k + 1]\n            heappush(Q, (next_val, i, j, k + 1))\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02761","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nN, M = [int(_) for _ in input().split()]\n\n\n\nif M == 0:\n\n    if N == 1:\n\n        print(\"0\")\n\n    else:\n\n        ans = [0] * N\n\n        ans[0] = 1\n\n        print((\"\".join(map(str, ans))))\n\n    sys.exit()\n\n\n\nS, C = np.array([[int(_) for _ in input().split()] for i in range(M)]).T\n\n\n\nans = [-1] * N\n\n\n\nfor i in range(M):\n\n    j = int(S[i]) - 1\n\n    if ans[j] == -1 or ans[j] == C[i]:\n\n        ans[j] = C[i]\n\n    else:\n\n        print(\"-1\")\n\n        sys.exit()\n\n\n\nif N >= 2 and ans[0] == 0:\n\n    print(\"-1\")\n\n    sys.exit()\n\n\n\nif N >= 2 and ans[0] == -1:\n\n    ans[0] = 1\n\n\n\nfor i in range(1, N):\n\n    if ans[i] == -1:\n\n        ans[i] = 0\n\n\n\ns = \"\".join(map(str, ans))\n\nprint(s)\n","reference_code_col":"import sys\n\n\n\nN, M = [int(_) for _ in input().split()]\n\nSC = [[int(_) for _ in input().split()] for i in range(M)]\n\n\n\nif N == 1:\n\n    start = 0\n\n    end = 10\n\nelse:\n\n    start = 10 ** (N - 1)\n\n    end = 10 ** N\n\n\n\nfor i in range(start, end):\n\n    ans = list(map(int, str(i)))\n\n    valid = True\n\n    for s, c in SC:\n\n        if ans[s-1] != c:\n\n            valid = False\n\n            break\n\n    if valid:\n\n        print(i)\n\n        sys.exit()\n\n\n\nprint((-1))\n","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Read input values\nN, M = map(int, input().split())\n\nif M == 0:\n    if N == 1:\n        print(\"0\")\n    else:\n        print(\"1\" + \"0\" * (N - 2) + \"1\")\n    sys.exit()\n\n# Read constraints into numpy array\nS, C = np.array([map(int, input().split()) for _ in range(M)]).T\n\n# Initialize answer array with -1\nans = [-1] * N\n\n# Process each constraint\nfor s, c in zip(S, C):\n    s -= 1\n    if ans[s] == -1 or ans[s] == c:\n        ans[s] = c\n    else:\n        print(\"-1\")\n        sys.exit()\n\n# Check initial conditions for N >= 2\nif N >= 2 and ans[0] == 0:\n    print(\"-1\")\n    sys.exit()\nelif N >= 2 and ans[0] == -1:\n    ans[0] = 1\n\n# Fill remaining positions\nfor i in range(1, N):\n    if ans[i] == -1:\n        ans[i] = 0\n\n# Print result\nprint(''.join(map(str, ans)))"}
{"problem_id":"p03363","slow_code_col":"import numpy\n\nN=int(eval(input()))\n\nA=list(map(int,input().split()))\n\nB=list(numpy.cumsum(A))+[0]\n\nC=sorted(B)\n\nd=C[0]\n\ncnt=1\n\nans=0\n\nfor i in range(N):\n\n  if C[i+1]==d:\n\n    cnt+=1\n\n  else:\n\n    ans+=cnt*(cnt-1)\/\/2\n\n    cnt=1\n\n    d=C[i+1]\n\nans+=cnt*(cnt-1)\/\/2\n\nprint(ans)    ","reference_code_col":"N=int(eval(input()))\n\nA=list(map(int, input().split()))\n\nD=[0]\n\nd=0\n\nfor i in A:\n\n  d+=i\n\n  D.append(d)\n\nD=sorted(D)\n\nans=0\n\nd=-10**9+1\n\nD.append(10**9+1)\n\ncnt=0\n\nfor i in range(N+2):\n\n  if D[i]==d:\n\n    cnt+=1\n\n  else:\n\n    if cnt>1:\n\n      ans+=cnt*(cnt-1)\/\/2\n\n      cnt=1\n\n    else:\n\n      cnt=1\n\n    d=D[i]\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(input())\nA = list(map(int, input().split()))\nB = np.cumsum(A)\nC = sorted(B.tolist() + [0])\n\nd = C[0]\ncnt = 1\nans = 0\n\nfor i in range(1, len(C)):\n    if C[i] == d:\n        cnt += 1\n    else:\n        ans += cnt * (cnt - 1) \/\/ 2\n        cnt = 1\n        d = C[i]\n\nans += cnt * (cnt - 1) \/\/ 2\nprint(ans)"}
{"problem_id":"p03634","slow_code_col":"import sys\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(v,p,d):\n\n    for i, j in tree[v]:\n\n        if i != p:\n\n            depth[i] = d + j\n\n            dfs(i,v,d+j)\n\n\n\nN = int(eval(input()))\n\n\n\ntree = [[] for _ in range(N)]\n\n\n\nfor i in range(N-1):\n\n    a, b, c = list(map(int, input().split()))\n\n    a -= 1\n\n    b -= 1\n\n    tree[a].append((b,c))\n\n    tree[b].append((a,c))\n\n\n\nQ, K = list(map(int, input().split()))\n\n\n\ndepth = [0 for i in range(N)]\n\ndepth[K-1] = 0\n\n\n\ndfs(K-1,-1,0)\n\n\n\nfor _ in range(Q):\n\n    x, y = list(map(int, input().split()))\n\n    print((depth[x-1] + depth[y-1]))","reference_code_col":"import heapq\n\nimport sys\n\n\n\ninput = sys.stdin.readline\n\n\n\ndef dijkstra(s, edge, N):\n\n    d = [float('inf')] * N\n\n    used = [True] * N\n\n    d[s] = 0\n\n    used[s] = False\n\n    edgelist = []\n\n    for a, b in edge[s]:\n\n        heapq.heappush(edgelist, a * (10 ** 6) + b)\n\n    while len(edgelist):\n\n        minedge = heapq.heappop(edgelist)\n\n\n\n        if not used[minedge%(10 ** 6)]:\n\n            continue\n\n        v = minedge % (10 ** 6)\n\n        d[v] = minedge \/\/ (10 ** 6)\n\n        used[v] = False\n\n        for e in edge[v]:\n\n            if used[e[1]]:\n\n                heapq.heappush(edgelist, (e[0] + d[v]) * (10 ** 6) + e[1])\n\n    return d\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    edge = [[] for _ in range(N)]\n\n    for _ in range(N-1):\n\n        a, b, c = list(map(int, input().split()))\n\n        a -= 1\n\n        b -= 1\n\n        edge[a].append([c,b])\n\n        edge[b].append([c,a])\n\n    Q, K = list(map(int, input().split()))\n\n    K -= 1\n\n    d = dijkstra(K, edge, N)\n\n    for _ in range(Q):\n\n        x, y = list(map(int, input().split()))\n\n        x -= 1\n\n        y -= 1\n\n        print((d[x] + d[y]))\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()","model_generated_potentially_faster_code_col":"import sys\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(v, p, d):\n    depth[v] = d\n    for i, j in tree[v]:\n        if i != p:\n            dfs(i, v, d + j)\n\nN = int(input())\ntree = [[] for _ in range(N)]\nfor i in range(N - 1):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    tree[a].append((b, c))\n    tree[b].append((a, c))\n\nQ, K = map(int, input().split())\ndepth = [0] * N\ndfs(K - 1, -1, 0)\n\n# Precompute the sum of depths for each node\nsum_depths = [0] * N\nfor i in range(N):\n    sum_depths[i] = sum(depth[j] for j in range(N) if depth[j] >= depth[i])\n\nfor _ in range(Q):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    print(sum_depths[x] + sum_depths[y])"}
{"problem_id":"p03796","slow_code_col":"import math\n\nn = int(eval(input()))\n\n\n\npower = math.factorial(n)\n\n\n\nprint((power % (10**9 + 7)))\n","reference_code_col":"import math\n\nn = int(eval(input()))\n\n\n\npower = 1\n\n\n\nfor i in range(1, n+1):\n\n    power = i * power % (10**9 + 7)\n\n\n\nprint(power)\n","model_generated_potentially_faster_code_col":"def factorial_modulo(n):\n    result = 1\n    for i in range(2, n+1):\n        result = (result * i) % (10**9 + 7)\n    return result\n\nn = int(input())\nprint(factorial_modulo(n))"}
{"problem_id":"p03575","slow_code_col":"'''\n\n\u7121\u5411\u30b0\u30e9\u30d5\u306e\u6a4b\u306e\u6570\u3092\u8abf\u3079\u308b\n\n\u30eb\u30fc\u30d7\u7121\u3057\/2\u91cd\u8fba\u7121\u3057\n\n'''\n\n\n\ndef main():\n\n    import sys\n\n    #input = sys.stdin.readline\n\n    sys.setrecursionlimit(10000000)\n\n    from collections import Counter, deque\n\n    #from collections import defaultdict\n\n    from itertools import combinations\n\n    #from itertools import accumulate, product, permutations\n\n    from math import floor, ceil\n\n\n\n    #mod = 1000000007\n\n\n\n    node,m =list(map(int, input().split()))\n\n    edge = [list(map(int, input().split())) for _ in range(m)]\n\n    res = 0\n\n\n\n    def dfs(num):\n\n        flag[num-1] = 1\n\n        for x, y in edge:\n\n            if x==num:\n\n                if not flag[y-1]:\n\n                    dfs(y)\n\n            if y==num:\n\n                if not flag[x-1]:\n\n                    dfs(x)\n\n    \n\n    for i in range(m):\n\n        bridge = edge.pop(i)\n\n        flag = [0]*node\n\n        s = edge[0][0]\n\n        dfs(s)\n\n        if not all(flag):\n\n            res += 1\n\n        edge.insert(i, bridge)\n\n    print(res)\n\n\n\nif __name__ == '__main__':\n\n    main()","reference_code_col":"'''\n\nhttps:\/\/atcoder.jp\/contests\/abc075\/tasks\/abc075_c?lang=ja\n\n\u6df1\u3055\u512a\u5148\u63a2\u7d22\u3067\u3082\u89e3\u3051\u308b\n\n'''\n\ndef main():\n\n    import sys\n\n    #input = sys.stdin.readline\n\n    sys.setrecursionlimit(10000000)\n\n    from collections import Counter, deque\n\n    #from collections import defaultdict\n\n    from itertools import combinations, permutations\n\n    #from itertools import accumulate, product\n\n    from bisect import bisect_left,bisect_right\n\n    from math import floor, ceil\n\n    #from operator import itemgetter\n\n\n\n    #mod = 1000000007\n\n\n\n    class UnionFind():\n\n        #n\u500b\u306e\u8981\u7d20\u3092\u756a\u53f70~n-1\u3067\u7ba1\u7406\u3059\u308b\n\n        #parents:\u8981\u7d20\u306e\u89aa(1\u3064\u4e0a), \u8981\u7d20\u304c\u6839\u306e\u5834\u5408\u30b5\u30a4\u30ba\u3092\u8868\u3059\n\n        def __init__(self, n):\n\n            self.n = n\n\n            self.parents = [-1] * n\n\n    \n\n        #\u8981\u7d20x\u306e\u6839\u3092\u8fd4\u3059, \u305d\u306e\u904e\u7a0b\u3067\u7d4c\u8def\u5727\u7e2e\u3082\u884c\u3046\n\n        def find(self, x):\n\n            if self.parents[x] < 0:\n\n                return x\n\n            else:\n\n                self.parents[x] = self.find(self.parents[x])\n\n                return self.parents[x]\n\n    \n\n        def union(self, x, y):\n\n            x = self.find(x)\n\n            y = self.find(y)\n\n            if x == y:\n\n                return\n\n            #\u305d\u308c\u305e\u308c\u306esize\u3067\u6bd4\u3079\u308b\n\n            if self.parents[x] > self.parents[y]:\n\n                x, y = y, x\n\n            self.parents[x] += self.parents[y]\n\n            self.parents[y] = x #\u6839\u3092\u304f\u3063\u3064\u3051\u308b(\u7247\u65b9\u3092\u89aa\u306b\u3059\u308b)\n\n    \n\n        #x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306esize\n\n        def size(self, x):\n\n            return -self.parents[self.find(x)]\n\n    \n\n        #x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u304b\u3069\u3046\u304b\n\n        def same(self, x, y):\n\n            return self.find(x) == self.find(y)\n\n    \n\n        #x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u5168\u3066\u3092\u8fd4\u3059\n\n        def members(self, x):\n\n            root = self.find(x)\n\n            return [i for i in range(self.n) if self.find(i) == root]\n\n    \n\n        #\u5168\u3066\u306e\u6839\u306e\u8981\u7d20\u3092\u8fd4\u3059\n\n        def roots(self):\n\n            return [i for i, x in enumerate(self.parents) if x < 0]\n\n    \n\n        #\u5404\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u3092\u8f9e\u66f8\u3067\u8fd4\u3059\n\n        def all_group_members(self):\n\n            return {r: self.members(r) for r in self.roots()}\n\n    \n\n        #print(uf)\n\n        def __str__(self):\n\n            return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n    n,m = list(map(int, input().split()))\n\n    edge = [list(map(int, input().split())) for _ in range(m)]\n\n    res = 0\n\n    for i in range(m):\n\n        uf = UnionFind(n)\n\n        for j in range(m):\n\n            if i==j:\n\n                continue\n\n            a,b = edge[j]\n\n            uf.union(a-1,b-1)\n\n        if uf.size(0)!=n:\n\n            res += 1\n\n    print(res)\n\n\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"import sys\n\n#input = sys.stdin.readline\nsys.setrecursionlimit(10000000)\nfrom collections import Counter, deque\n\ndef dfs(graph, start, visited):\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            visited[node] = True\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    stack.append(neighbor)\n\ndef count_bridges(n, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n\n    visited = [False] * n\n    bridges = 0\n\n    for u, v in edges:\n        graph[u-1].remove(v-1)\n        graph[v-1].remove(u-1)\n\n        dfs(graph, u-1, visited)\n\n        if not all(visited):\n            bridges += 1\n\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n\n        visited = [False] * n\n\n    return bridges\n\ndef main():\n    node, m = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(m)]\n    \n    result = count_bridges(node, edges)\n    print(result)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03634","slow_code_col":"import heapq\n\n\n\nN = int(eval(input()))\n\nabc = [list(map(int,input().split())) for _ in range(N-1)]\n\nQ,K = list(map(int,input().split()))\n\nxy = [list(map(int,input().split())) for _ in range(Q)]\n\n\n\nconnect = [[] for _ in range(N)]\n\nINFTY = 10**15\n\nfor a,b,c in abc:\n\n    connect[a-1].append([b-1,c])\n\n    connect[b-1].append([a-1,c])\n\n\n\ncost = [[INFTY,False] for _  in range(N)]\n\ncost[K-1][0] = 0\n\nq = [(0,K-1)]\n\nwhile q:\n\n    _,i = heapq.heappop(q)\n\n    if cost[i][1]:\n\n        continue\n\n    cost[i][1] = True\n\n    ci0 = cost[i][0]\n\n    for j,c in connect[i]:\n\n        if cost[j][1]:\n\n            continue\n\n        tmp_cost = ci0+c\n\n        if tmp_cost < cost[j][0]:\n\n            cost[j][0] = tmp_cost\n\n            heapq.heappush(q,(tmp_cost,j))\n\n\n\nfor x,y in xy:\n\n    print((cost[x-1][0] + cost[y-1][0]))","reference_code_col":"N = int(eval(input()))\n\nABC = [list(map(int,input().split())) for _ in [0]*(N-1)]\n\nQ,K = list(map(int,input().split()))\n\nXY = [list(map(int,input().split())) for _ in [0]*Q]\n\n\n\nE = [{} for _ in [0]*N]\n\nfor a,b,c in ABC:\n\n    E[a-1][b-1] = c\n\n    E[b-1][a-1] = c\n\n\n\ndef dist_dfs_tree(N,E,start):\n\n    d = [-1]*N\n\n    d[start] = 0\n\n    q = [start]\n\n    while q:\n\n        i = q.pop()\n\n        ci = d[i]\n\n        for j,cj in list(E[i].items()):\n\n            if d[j] !=-1:continue\n\n            d[j] = ci+cj\n\n            q.append(j)\n\n    return d\n\n\n\nd = dist_dfs_tree(N,E,K-1)\n\nfor x,y in XY:\n\n    print((d[x-1]+d[y-1]))","model_generated_potentially_faster_code_col":"import heapq\n\nN = int(eval(input()))\nabc = [list(map(int, input().split())) for _ in range(N - 1)]\nQ, K = list(map(int, input().split()))\nxy = [list(map(int, input().split())) for _ in range(Q)]\n\n# Create an adjacency matrix\nadj = [[float('inf')] * N for _ in range(N)]\nfor a, b, c in abc:\n    adj[a - 1][b - 1] = c\n    adj[b - 1][a - 1] = c\n\n# Initialize the distance array and priority queue\ndist = [float('inf')] * N\ndist[K - 1] = 0\npq = [(0, K - 1)]\n\nwhile pq:\n    d, u = heapq.heappop(pq)\n    if dist[u] != d:\n        continue\n    for v in range(N):\n        if dist[v] > dist[u] + adj[u][v]:\n            dist[v] = dist[u] + adj[u][v]\n            heapq.heappush(pq, (dist[v], v))\n\n# Output the results\nfor x, y in xy:\n    print(dist[x - 1] + dist[y - 1])"}
{"problem_id":"p03416","slow_code_col":"A,B = list(map(int,input().split()))\n\n\n\n\n\ndef kaibun(n):\n\n\tkey = 0\n\n\tfor i in range(1,n+1):\n\n\t\tif str(i) == str(i)[::-1]:\n\n\t\t\tkey += 1\n\n\treturn key\n\n\n\nprint((kaibun(B)-kaibun(A-1)))","reference_code_col":"A,B = list(map(int,input().split()))\n\n\n\n\n\ndef kaibun(m, n):\n\n\tkey = 0\n\n\tfor i in range(m,n+1):\n\n\t\tif str(i) == str(i)[::-1]:\n\n\t\t\tkey += 1\n\n\treturn key\n\n\n\nprint((kaibun(A,B)))","model_generated_potentially_faster_code_col":"A, B = map(int, input().split())\n\ndef kaibun(n):\n    count = 0\n    for i in range(max(2, A), n + 1):\n        if all(i % d != 0 for d in range(2, int(i**0.5) + 1)) or i < 10:\n            count += 1\n    return count\n\nprint(kaibun(B) - kaibun(A - 1))"}
{"problem_id":"p02555","slow_code_col":"from sys import stdin\n\ndef solve():\n\n    s = int(stdin.readline())\n\n    mod = 10**9+7\n\n    if s < 3: return 0\n\n    dp = [0]*(s+1)\n\n    dp[0] = 1\n\n    for i in range(3,s+1):\n\n        for x in range(3,i+1):\n\n            if x in [i-1,i-2]:\n\n                continue\n\n            dp[i] += dp[i-x]\n\n    return dp[s]%mod\n\nprint((solve()))","reference_code_col":"from sys import stdin\n\ndef solve():\n\n    s = int(stdin.readline())\n\n    mod = 10**9+7\n\n    if s < 3: return 0\n\n    dp = [0]*(s+1)\n\n    dp[0] = 1\n\n    for i in range(3,s+1):\n\n        dp[i] = dp[i-1] + dp[i-3]\n\n    return dp[s]%mod\n\nprint((solve()))","model_generated_potentially_faster_code_col":"from sys import stdin\n\ndef solve():\n    s = int(stdin.readline())\n    \n    mod = 10**9 + 7\n    \n    if s < 3: \n        return 0\n    \n    dp = [0] * (s + 1)\n    dp[0] = 1\n    dp[1] = 0\n    dp[2] = 1\n    \n    for i in range(3, s + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % mod\n    \n    return dp[s]\n\nprint(solve())"}
{"problem_id":"p02780","slow_code_col":"import numpy as np\n\nn, k = list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\np += 1\n\nsum_E = np.cumsum(p)\n\nsum_e = np.append([0], sum_E)\n\nans = -1\n\nfor i in range(n-k+1):\n\n    ans = max(ans, sum_e[i+k] - sum_e[i])\n\nprint((ans\/2))","reference_code_col":"n, k = list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\ndef calc(x):\n\n    return (x + 1) \/ 2\n\n\n\n\n\nw = 0\n\n\n\nfor i in range(k):\n\n    w += calc(p[i])\n\n\n\nans = w\n\nfor i in range(k, n):\n\n    w += calc(p[i]) - calc(p[i - k])\n\n    ans = max(ans, w)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn, k = map(int, input().split())\np = np.array(list(map(int, input().split())))\n\n# Increment p by 1\np += 1\n\n# Compute cumulative sums\ncumulative_sum = np.cumsum(p)\n\n# Compute prefix sums (including 0 at the beginning)\nprefix_sums = np.insert(cumulative_sum, 0, 0)\n\n# Calculate the maximum difference between prefix sums over the window size k\nmax_difference = np.max(prefix_sums[k:] - prefix_sums[:-k])\n\n# Print the result divided by 2\nprint(max_difference \/ 2)"}
{"problem_id":"p03013","slow_code_col":"import numpy as np\n\n\n\n\n\ndef main(n, m, a):\n\n    dp = np.zeros(n + 1, dtype=int)\n\n    dp[0] = 1\n\n    dp[1] = 1 if 1 not in a else 0\n\n\n\n    for i in range(2, len(dp)):\n\n        dp[i] = dp[i - 1] + dp[i - 2] if i not in a else 0\n\n        dp[i] %= 1000000007\n\n\n\n    return dp[-1]\n\n\n\n\n\nif __name__ == '__main__':\n\n    N, M = list(map(int, input().split()))\n\n    A = set()\n\n    for _ in range(M):\n\n        A.add(int(eval(input())))\n\n\n\n    print((main(N, M, A)))\n","reference_code_col":"import math\n\n\n\nMOD = int(math.pow(10, 9)) + 7\n\nN, M = list(map(int, input().split(' ')))\n\nbroken_steps = {int(eval(input())) for _ in range(M)}\n\n\n\ndp = [0] * (N + 1)\n\n\n\ndp[0] = 1\n\nif 1 not in broken_steps:\n\n    dp[1] = 1\n\n\n\nfor step in range(2, N + 1):\n\n    if step not in broken_steps:\n\n        dp[step] = (dp[step - 1] + dp[step - 2]) % MOD\n\n\n\nprint((dp[N]))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n\ndef main(n, m, a):\n    # Precompute dp values for indices in set a\n    dp_in_a = [0] * (n + 1)\n    for i in a:\n        dp_in_a[i] = 1\n\n    # Initialize dp array with base cases\n    dp = np.zeros(n + 1, dtype=int)\n    dp[0] = 1\n    dp[1] = 1 if 1 not in a else 0\n\n    # Fill dp array using memoization\n    for i in range(2, len(dp)):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007\n\n    # Add dp values for indices in set a\n    for i in a:\n        dp[i] += dp_in_a[i]\n\n    return dp[-1]\n\n\nif __name__ == '__main__':\n    N, M = map(int, input().split())\n    A = set()\n    for _ in range(M):\n        A.add(int(input()))\n\n    print(main(N, M, A))"}
{"problem_id":"p03038","slow_code_col":"n,m = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nA.sort()\n\nbc = [list(map(int,input().split())) for _ in range(m)]\n\n\n\nbc.sort(key=lambda x:x[1],reverse=1)\n\n\n\ni = 0#bc\u306e\u6dfb\u3048\u5b57\n\nj = 0#A\u306e\u6dfb\u3048\u5b57\n\nwhile 1:\n\n\tif i >= m or j >= n:\n\n\t\t#print('i\u304bj\u304c\u8d85\u3048\u305f\uff01')\n\n\t\tbreak\n\n\tif bc[i][1] < A[j]:\n\n\t\t#print('A\u3067\u3063\u304b')\n\n\t\tbreak\n\n\tfor k in range(bc[i][0]):\n\n\t\t#print(i,j,k)\n\n\t\tA[j] = bc[i][1]\n\n\t\tj+=1\n\n\t\tif j >= n:\n\n\t\t\t#print('for\u6587\u5185\u3001j\u304c\u8d85\u3048\u305f')\n\n\t\t\tbreak\n\n\t\tif A[j] > bc[i][1]:\n\n\t\t\t#print('for\u6587\u5185\u3001A\u3067\u3063\u304b')\n\n\t\t\tbreak\n\n\ti+=1\n\n# print(A)\n\nprint((sum(A)))","reference_code_col":"from heapq import heapify,heappop,heappush\n\nn,m = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nheapify(A)\n\nbc = [list(map(int,input().split())) for i in range(m)]\n\nbc.sort(key=lambda x:x[1],reverse=1)\n\n\n\nflag = 0\n\n# print(A)\n\nfor b,c in bc:\n\n\tif flag:\n\n\t\tbreak\n\n\tfor i in range(b):\n\n\t\ta = heappop(A)\n\n\t\tif c <= a:\n\n\t\t\theappush(A,a)\n\n\t\t\tflag = 1\n\n\t\t\tbreak\n\n\t\telse:\n\n\t\t\theappush(A,c)\n\nprint((sum(A)))","model_generated_potentially_faster_code_col":"n, m = map(int, input().split())\n\nA = list(map(int, input().split()))\nA.sort()\n\nbc = [tuple(map(int, input().split())) for _ in range(m)]\nbc.sort(key=lambda x: x[1], reverse=True)\n\ni = 0  # bc\u306e\u6dfb\u3048\u5b57\nj = 0  # A\u306e\u6dfb\u3048\u5b57\n\nwhile i < m and j < n:\n    while j < n and A[j] <= bc[i][1]:\n        A[j] = bc[i][1]\n        j += 1\n    i += 1\n\nprint(sum(A))"}
{"problem_id":"p02874","slow_code_col":"# coding: utf-8\n\nimport numpy as np\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    n = int(args[0])\n\n    LR = [tuple(map(int, a.split())) for a in args[1:]]\n\n    L, R = list(zip(*LR))\n\n\n\n    ret = 0\n\n\n\n    p, q = np.argmax(L), np.argmin(R)\n\n    lp, rq = L[p], R[q]\n\n\n\n    ret = max(0, 1+rq-lp) + max(0, max(1+r-l for l, r in LR))\n\n\n\n    AB = [[max(0, 1+r-lp), max(0, 1+rq-l)] for l, r in LR]\n\n    AB.sort(key=lambda x: (x[0], -x[1]))\n\n    A, B = list(map(list, list(zip(*AB))))\n\n\n\n    # for i in range(1, n):\n\n    #     ret = max(ret, min(A[i:]) + min(B[:i]))\n\n    b_min = 1+10**9\n\n    for i in range(n-1):\n\n        b_min = min(b_min, B[i])\n\n        ret = max(ret, b_min + A[i+1])\n\n\n\n    return str(ret)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n","reference_code_col":"# coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    n = int(args[0])\n\n    LR = [tuple(map(int, a.split())) for a in args[1:]]\n\n    L, R = list(zip(*LR))\n\n\n\n    ret = 0\n\n\n\n    # lp, rq = max(L), min(R)\n\n    lp, rq = 0, 1+10**9\n\n    for l, r in LR:\n\n        lp, rq = max(lp, l), min(rq, r)\n\n\n\n    ret = max(0, 1+rq-lp) + max(0, max(1+r-l for l, r in LR))\n\n\n\n    AB = [[max(0, 1+r-lp), max(0, 1+rq-l)] for l, r in LR]\n\n    AB.sort(key=lambda x: (x[0], -x[1]))\n\n    A, B = list(map(list, list(zip(*AB))))\n\n\n\n    # for i in range(1, n):\n\n    #     ret = max(ret, min(A[i:]) + min(B[:i]))\n\n    b_min = 1+10**9\n\n    for i in range(n-1):\n\n        b_min = min(b_min, B[i])\n\n        ret = max(ret, b_min + A[i+1])\n\n\n\n    return str(ret)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n","model_generated_potentially_faster_code_col":"# coding: utf-8\n\nimport numpy as np\n\ndef solve(*args: str) -> str:\n    n = int(args[0])\n    LR = [tuple(map(int, a.split())) for a in args[1:]]\n    L, R = list(zip(*LR))\n\n    ret = 0\n\n    p, q = np.argmax(L), np.argmin(R)\n    lp, rq = L[p], R[q]\n\n    ret = max(0, 1 + rq - lp) + max(0, max(1 + r - lp for l, r in LR))\n\n    AB = [[max(0, 1 + r - lp), max(0, 1 + rq - l)] for l, r in LR]\n    AB.sort(key=lambda x: (x[0], -x[1]))\n    A, B = list(map(list, list(zip(*AB))))\n\n    b_min = float('inf')\n    for i in range(n - 1):\n        b_min = min(b_min, B[i])\n        ret = max(ret, b_min + A[i + 1])\n\n    return str(ret)\n\nif __name__ == \"__main__\":\n    print(solve(*(open(0).read().splitlines())))"}
{"problem_id":"p03164","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\n \n\nN,W = list(map(int, input().split()))\n\n \n\ndp = [10 ** 10] * N * (10 ** 4)\n\ndp[0] = 0\n\ndp = np.array(dp)\n\n \n\n \n\nfor i in range(N):\n\n    w,v = list(map(int, input().split()))\n\n    dp[v:] = np.minimum(dp[v:] , dp[:-v] + w)\n\n  \n\nfor i,count in enumerate(dp):\n\n    if dp[i] <= W:\n\n        ans = i\n\nprint(ans)","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\n \n\nN,W = list(map(int, input().split()))\n\n \n\ndp = [10 ** 10] * (N * (10 ** 3) + 1)\n\ndp[0] = 0\n\ndp = np.array(dp)\n\n \n\n \n\nfor i in range(N):\n\n    w,v = list(map(int, input().split()))\n\n    dp[v:] = np.minimum(dp[v:] , dp[:-v] + w)\n\n  \n\nfor i,count in enumerate(dp):\n\n    if dp[i] <= W:\n\n        ans = i\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\n# Read input values\nN, W = map(int, input().split())\n\n# Initialize DP array with a large value\ndp = [float('inf')] * (W + 1)\ndp[0] = 0\n\n# Process each item\nfor _ in range(N):\n    w, v = map(int, input().split())\n    # Update DP array from right to left to avoid overwriting values prematurely\n    for j in range(W, v - 1, -1):\n        dp[j] = min(dp[j], dp[j - v] + w)\n\n# Find the maximum value of v such that dp[v] <= W\nans = max(i for i in range(W + 1) if dp[i] <= W)\n\nprint(ans)"}
{"problem_id":"p03796","slow_code_col":"import math\n\nx = int(eval(input()))\n\nprint((math.factorial(x) % (10**9 + 7)))","reference_code_col":"M = 1000000007\n\nn=int(eval(input()))\n\nf = 1\n\nfor i in range(1, n + 1):  \n\n    f = (f * i) % M \n\nprint(f)","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\nMAX_N = 10**5 # Maximum possible input value\nfact = [0] * (MAX_N + 1)\nfact[0] = fact[1] = 1\nfor i in range(2, MAX_N + 1):\n    fact[i] = (i * fact[i - 1]) % MOD\n\nn = int(input())\nprint(fact[n])"}
{"problem_id":"p03416","slow_code_col":"a,b=list(map(int,input().split()))\n\nans=0\n\nfor i in range(b+1)[a:]:\n\n  if len(str(i))%2==0:\n\n    p=list(str(i))[:len(str(i))\/\/2]\n\n    q=list(reversed(list(str(i))[len(str(i))\/\/2:]))\n\n    if p==q:\n\n      ans+=1\n\n  else:\n\n    s=list(str(i))[:len(str(i))\/\/2+1]\n\n    d=list(reversed(list(str(i))[len(str(i))\/\/2:]))\n\n    if s==d:\n\n      ans += 1\n\nprint(ans)","reference_code_col":"a,s=list(map(int,input().split()))\n\nad=0\n\nfor i in range(a,s+1):\n\n  if str(i)==str(i)[::-1]:ad+=1\n\nprint(ad)","model_generated_potentially_faster_code_col":"a, b = map(int, input().split())\n\ndef is_palindrome(n):\n    str_n = str(n)\n    return str_n == str_n[::-1]\n\nans = sum(is_palindrome(i) for i in range(a, b + 1))\nprint(ans)"}
{"problem_id":"p01093","slow_code_col":"while int(eval(input())) > 0:\n\n    s = sorted(map(int, input().split()))\n\n    print((min(abs(a - b) for (a, b) in zip(s, s[1:]))))","reference_code_col":"while True:\n\n    if int(eval(input())) == 0:\n\n        break\n\n    s = sorted(map(int, input().split()))\n\n    r = min(abs(x - y) for (x, y) in zip(s, s[1:]))\n\n    print(r)","model_generated_potentially_faster_code_col":"while True:\n    try:\n        n = int(input())\n        if n <= 0:\n            break\n\n        s = list(map(int, input().split()))\n        s.sort()\n\n        min_diff = float('inf')\n        for i in range(1, len(s)):\n            diff = abs(s[i] - s[i-1])\n            if diff < min_diff:\n                min_diff = diff\n\n        print(min_diff)\n        \n    except EOFError:\n        break"}
{"problem_id":"p02412","slow_code_col":"def main():\n\n\n\n    while True:\n\n        n, x = tuple(map(int, input().split()))\n\n        pattern = 0\n\n\n\n        if n == x == 0:\n\n            break\n\n        else:\n\n            for a in range(1, n+1):\n\n                for b in range(1, a):\n\n                    for c in range(1, b):\n\n                        pattern += 1 if a + b + c == x and a > b > c else 0\n\n            print(pattern)\n\n                            \n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def divide_two(c, z):\n\n    min_b = z \/\/ 2 + 1\n\n    max_b = min(c-1, z-1)\n\n    return max(max_b-min_b+1, 0)\n\n    \n\n\n\nnum_set = []\n\ncnt = 0\n\nwhile True:\n\n    n, x = list(map(int, input().split()))\n\n    if (n, x) == (0, 0):\n\n        break\n\n    else:\n\n        num_set.append((n, x))\n\n        cnt += 1\n\n\n\nfor i in range(cnt):\n\n    num_count = 0\n\n    (n, x) = num_set[i]\n\n    for c in range(x\/\/3, n+1):\n\n        num_count += divide_two(c, x-c)\n\n    print(num_count)\n","model_generated_potentially_faster_code_col":"def main():\n    while True:\n        n, x = map(int, input().split())\n        \n        if n == x == 0:\n            break\n        \n        count = 0\n        for a in range(1, n):\n            for b in range(a+1, n-a):  # b starts from a+1 to ensure a > b\n                c = x - (a + b)\n                if c > b:  # c should be greater than b to maintain a > b > c\n                    count += 1\n                    \n        print(count)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03416","slow_code_col":"A, B = list(map(int, input().split()))\n\nnumbers = list(range(A, B+1))\n\ncount = 0\n\nfor i in numbers:\n\n    m = str(i)\n\n    rm = ''.join(list(reversed(m)))\n\n    if m == rm:\n\n        count += 1\n\nprint(count)","reference_code_col":"A, B = list(map(int, input().split()))\n\nx = list(range(1,10))\n\ny = list(range(10))\n\ncount = 0\n\nfor p in x:\n\n    for q in y:\n\n        for r in y:\n\n            sakasama = int(str(p)+str(q)+str(r)+str(q)+str(p))\n\n            if A <= sakasama <= B:\n\n                count += 1\n\nprint(count)","model_generated_potentially_faster_code_col":"def is_palindrome(num):\n    return str(num) == str(num)[::-1]\n\nA, B = map(int, input().split())\n\ncount = sum(is_palindrome(i) for i in range(A, B + 1))\n\nprint(count)"}
{"problem_id":"p02863","slow_code_col":"import sys\n\nfrom operator import itemgetter\n\nfrom heapq import heapify, heappop, heappush\n\nMAX_INT = int(10e15)\n\nMIN_INT = -MAX_INT\n\nmod = 1000000007\n\nsys.setrecursionlimit(1000000)\n\ndef IL(): return list(map(int,input().split()))\n\ndef SL(): return input().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef S(): return eval(input())\n\n\n\nN, T = IL()\n\nab = [IL() for i in range(N)]\n\nab.sort(key=itemgetter(0))\n\n#print(ab)\n\n\n\ndp = [[0]*(T+1+3000+1) for _ in range(N+1)]\n\nans = 0\n\nfor i in range(N):\n\n  for j in range(T+1+3000+1):\n\n    time, deli = ab[i]\n\n    if 0 <= j-time < T:\n\n      dp[i + 1][j] = max(dp[i][j], dp[i][j - time] + deli)\n\n    else:\n\n      dp[i + 1][j] = dp[i][j]\n\n    ans = max(ans, dp[i + 1][j])\n\nprint(ans)\n\n\n\n#print(dp)\n","reference_code_col":"import sys\n\nfrom collections import deque\n\nMAX_INT = int(10e10)\n\nMIN_INT = -MAX_INT\n\nmod = 1000000007\n\nsys.setrecursionlimit(1000000)\n\ndef IL(): return list(map(int,input().split()))\n\ndef SL(): return input().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef S(): return eval(input())\n\n\n\nN,T = IL()\n\nab = [IL() for i in range(N)]\n\nab.sort()\n\n\n\nans = 0\n\ndp = [[0]*T for i in range(N+1)]\n\nfor i in range(1,N+1):\n\n  a,b = ab[i-1]\n\n  for j in range(T):\n\n    if 0 <= j-a < T:\n\n      dp[i][j] = max(dp[i-1][j], dp[i-1][j-a] + b)\n\n    else:\n\n      dp[i][j] = dp[i-1][j]\n\n  else:\n\n    ans = max(ans, dp[i-1][-1] + b)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\n\nfrom heapq import heappop, heappush\n\nMAX_INT = int(10e15)\n\nMIN_INT = -MAX_INT\n\nmod = 1000000007\n\nsys.setrecursionlimit(1000000)\n\ndef IL(): return list(map(int,input().split()))\n\ndef SL(): return input().split()\n\ndef I(): return int(sys.stdin.readline())\n\ndef S(): return eval(input())\n\nN, T = IL()\nab = [IL() for i in range(N)]\nab.sort(key=itemgetter(0))\npq = []\nans = 0\nfor i in range(N):\n    while pq and pq[0][0] < ab[i][0]:\n        _, deli = heappop(pq)\n        ans = max(ans, deli)\n    if pq and pq[0][0] == ab[i][0]:\n        heappush(pq, (-ab[i][1], ab[i][1]))\n    elif pq:\n        deli = -heappop(pq)[1]\n        ans = max(ans, deli)\n        heappush(pq, (-deli-ab[i][1], deli-ab[i][1]))\n    else:\n        heappush(pq, (-ab[i][1], ab[i][1]))\nprint(ans)"}
{"problem_id":"p02792","slow_code_col":"from functools import lru_cache\n\nimport sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\n\n\n@lru_cache(maxsize=None)\n\ndef check(l, r, n, k=1):\n\n    t = l + '0' * k + r\n\n    e = l + '9' * k + r\n\n\n\n    if int(e) <= n:\n\n        return pow(10, k) + check(l, r, n, k + 1)\n\n\n\n    if int(t) <= n < int(e):\n\n        x = int(str(n)[1:-1])\n\n        if int(str(n)[-1]) < int(r):\n\n            x -= 1\n\n        return x + 1\n\n\n\n    if n < int(t):\n\n        return 0\n\n\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n\n\n    ret = 0\n\n    for x in range(1, n + 1):\n\n        if x % 10 == 0:\n\n            continue\n\n        s = str(x)\n\n        t = s[-1] + s[0]\n\n        if s[0] == s[-1]:\n\n            ret += 1\n\n        if int(t) <= n:\n\n            ret += 1\n\n        ret += check(s[-1], s[0], n, k=1)\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"# \u89e3\u8aac\u653e\u9001\n\n\n\ndef main():\n\n    from collections import defaultdict\n\n\n\n    n = int(eval(input()))\n\n\n\n    d = defaultdict(int)\n\n    for x in range(1, n + 1):\n\n        if x % 10 == 0:\n\n            continue\n\n\n\n        tail = x % 10\n\n        head = 0\n\n        while x:\n\n            head = x\n\n            x \/\/= 10\n\n\n\n        d[head, tail] += 1\n\n\n\n    ret = 0\n\n    for (head, tail), cnt in tuple(d.items()):\n\n        # RuntimeError: dictionary changed size during iteration\n\n        # defaultdict\u306e\u672a\u5b9a\u7fa9(?)\u306ekey\u306b\u30a2\u30af\u30bb\u30b9\u3059\u308b\u305b\u3044\u3067\u3001RE\u306b\u306a\u308b\n\n        # d.items()\u3092tuple\u5316\u3057\u3066\u56de\u907f\n\n        ret += d[head, tail] * d[tail, head]\n\n        # (head,tail)\u306e\u51fa\u73fe\u6570\u3092\u8f9e\u66f8\u3067\u7ba1\u7406\u3059\u308b\n\n        # (head,tail)*(tail,head)\u306e\u7d44\u307f\u5408\u308f\u305b\u304c\u3042\u308b\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"from functools import lru_cache\n\nsys.setrecursionlimit(10 ** 7)\n\n@lru_cache(maxsize=None)\ndef check(l, r, n, k=1):\n    t = int(l + '0' * k + r)\n    e = int(l + '9' * k + r)\n\n    if e <= n:\n        return pow(10, k) + check(l, r, n, k + 1)\n\n    if t <= n < e:\n        x = int(str(n)[1:-1])\n        if int(str(n)[-1]) < int(r):\n            x -= 1\n        return x + 1\n\n    if n < t:\n        return 0\n\ndef main():\n    n = int(eval(input()))\n    \n    ret = 0\n    \n    for x in range(1, n + 1):\n        if x % 10 == 0:\n            continue\n        \n        s = str(x)\n        t = s[-1] + s[0]\n        \n        if s[0] == s[-1]:\n            ret += 1\n        \n        if int(t) <= n:\n            ret += 1\n        \n        ret += check(s[-1], s[0], n)\n    \n    print(ret)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03325","slow_code_col":"import math\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\n\n\ndef trial_division(n):\n\n    factor = []\n\n    tmp = int(math.sqrt(n)) + 1\n\n    for _ in range(2,tmp):\n\n        while n % 2 == 0:\n\n            n \/\/= 2\n\n            factor.append(2)\n\n    if not factor:\n\n        return [n]\n\n    else:\n\n        factor.append(n)\n\n        return factor\n\n\n\n\n\ncount = 0\n\nfor i in a:\n\n    temp = trial_division(i)\n\n    count += temp.count(2)\n\n\n\nprint(count)","reference_code_col":"n = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\n\n\ndef trial_division(n):\n\n    #\uff12\u3067\u5272\u3063\u305f\u56e0\u6570\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n\n    factor = []\n\n    #2\u3067\u5272\u308c\u306a\u304f\u306a\u3063\u305f\u6642\u70b9\u3067\u30b9\u30c8\u30c3\u30d7\n\n    while n % 2 == 0:\n\n        n \/\/= 2    # \uff12\u3067\u5272\u3063\u305f\u5546\u3092\u5207\u308a\u6368\u3066\u3066\u4ee3\u5165\n\n        factor.append(2)\n\n    #n\u304c\u4e00\u5ea6\u3082\uff12\u3067\u5272\u308c\u306a\u304b\u3063\u305f\u3089\u305d\u306e\u307e\u307e\u8fd4\u3059\n\n    if not factor:\n\n        return [n]\n\n    else:\n\n        factor.append(n)\n\n        return factor\n\n\n\n\n\ncount = 0\n\nfor i in a:\n\n    temp = trial_division(i)\n\n    count += temp.count(2)\n\n\n\nprint(count)","model_generated_potentially_faster_code_col":"import math\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Function to perform trial division and return the count of prime factors\ndef count_prime_factors(num):\n    factors = {}\n    # Check for smallest prime factor (2)\n    while num % 2 == 0:\n        if 2 in factors:\n            factors[2] += 1\n        else:\n            factors[2] = 1\n        num \/\/= 2\n    \n    # Check for odd prime factors from 3 onwards\n    for i in range(3, int(math.sqrt(num)) + 1, 2):\n        while num % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            num \/\/= i\n    \n    # If num is still greater than 2, it must be a prime factor\n    if num > 2:\n        factors[num] = 1\n    \n    return factors\n\n# Count the total number of twos\ntotal_twos = 0\n\n# Process each number in the list\nfor num in a:\n    factors = count_prime_factors(num)\n    if 2 in factors:\n        total_twos += factors[2]\n\nprint(total_twos)"}
{"problem_id":"p03164","slow_code_col":"\n\n\n\n# N\u500b\u306e\u8377\u7269\u3001\u30ca\u30c3\u30d7\u30b6\u30c3\u30af\u306e\u5bb9\u91cf\u306fW\n\nN, W = list(map(int, input().split()))\n\nw = [0] * N\n\nv = [0] * N\n\n\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    w[i] = a\n\n    v[i] = b\n\n\n\n# 1 <= W <= 10^9\u306a\u306e\u3067\u6a2a\u8ef8\u3092W\u306b\u3059\u308b\u3068\u30c6\u30fc\u30d6\u30eb\u304c\u3067\u304b\u3059\u304e\u308b\n\n# \u305d\u306e\u304b\u308f\u308a\u306bV\u306e\u65b9\u3092\u6a2a\u8ef8\u306b\u3059\u308b\n\n\n\n# \u4fa1\u5024\u306e\u7dcf\u5408\u8a08\u306f\u307e\u3060\u4e0d\u660e\u306a\u306e\u3067\u3001\u9069\u5f53\u306b\u3067\u304b\u3044\u5024\u306b\u3057\u3068\u304f\n\n# \u6700\u4e0a\u90e8\u3068\u6700\u5de6\u90e8\u306b0\u304c\u5165\u308b\u306e\u3067\u3001\u305d\u306e\u5206\u3092+1\n\nV = N*1000+1\n\ndp = [ [float('inf') for _ in range(V+1)] for _ in range(N+1) ]\n\n\n\n# \u6700\u5c0f\u5024\u3092\u6c42\u3081\u308b\u306e\u3067\u3001\u4e0a\u8a18\u3067inf\u304c\u5165\u3063\u3066\u308b\u306e\u3067\u3001\u521d\u671f\u5024\u306f0\u3092\u3044\u308c\u308b\u5fc5\u8981\u304c\u3042\u308b\n\ndp[0][0] = 0\n\n\n\n# dp[i][sum_v] = \u3053\u308c\u307e\u3067(i-1)\u756a\u76ee\u307e\u3067\u306e\u54c1\u7269\u304b\u3089\u4fa1\u5024\u304csum_v\u4ee5\u4e0a\u306b\u306a\u308b\u3088\u3046\u306b\u9078\u3093\u3060\u3068\u304d\u306e\u3001\u91cd\u3055\u306e\u7dcf\u548c\u306e\u6700\u5c0f\u5024\n\nfor i in range(N):\n\n    for sum_v in range(V):\n\n        if sum_v - v[i] >= 0:\n\n            dp[i+1][sum_v] = min(dp[i+1][sum_v], dp[i][sum_v-v[i]]+w[i])\n\n\n\n        dp[i+1][sum_v] = min(dp[i+1][sum_v], dp[i][sum_v])\n\n\n\n\n\n# \u4e2d\u8eab\u304cW\u306a\u306e\u3067\u3001W\u4ee5\u4e0b\u3067\u3042\u308b\u3046\u3061\u306esum_v\u306e\u6700\u5927\u5024\u3092\u6c42\u3081\u308c\u3070\u3044\u3044\n\nfor sum_v in range(V):\n\n    # \u6700\u7d42\u884c\u3060\u3051\u898b\u308c\u3070\u3044\u3044\u306e\u3067\u3001\u7aef\u304b\u3089sum_v\u306e\u6700\u5927\u5024\u3092\u306a\u3081\u308b\u3060\u3051\n\n    if dp[N][sum_v] <= W:\n\n        ans = sum_v\n\n\n\nprint(ans)","reference_code_col":"\n\n\n\nimport sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\n# A = [ int(input()) for _ in range(N) ]\n\n##############################\n\n\n\nN, W = list(map(int, input().split()))\n\nw = []\n\nv = []\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    w.append(a)\n\n    v.append(b)\n\n\n\nV = sum(v)\n\n\n\ndp = [ [INF for _ in range(V+1)] for _ in range(N+1) ]\n\n\n\ndp[0][0] = 0\n\n\n\nfor i in range(N):\n\n    for j in range(V+1):\n\n        if j - v[i] < 0:\n\n            dp[i+1][j] = dp[i][j]\n\n        else:\n\n            dp[i+1][j] = min(dp[i][j], dp[i][j-v[i]]+w[i])\n\n\n\n#print(dp[N])\n\n\n\nans = 0\n\nfor v in range(V+1):\n\n    if dp[N][v] <= W:\n\n        ans = v\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nW = int(data[1])\n\nw = []\nv = []\n\nindex = 2\nfor i in range(N):\n    a = int(data[index])\n    b = int(data[index + 1])\n    w.append(a)\n    v.append(b)\n    index += 2\n\n# Calculate a reasonable upper bound for the total value\nmax_value_per_item = max(v)\nupper_bound = (W \/\/ max_weight) * max_value_per_item\n\n# Initialize DP array with infinity\ndp = [float('inf')] * (upper_bound + 1)\ndp[0] = 0\n\n# Fill DP array\nfor i in range(N):\n    for sum_v in range(v[i], upper_bound + 1):\n        dp[sum_v] = min(dp[sum_v], dp[sum_v - v[i]] + w[i])\n        dp[sum_v] = min(dp[sum_v], dp[sum_v])\n\n# Find the maximum value that fits within the weight limit\nans = 0\nfor sum_v in range(upper_bound + 1):\n    if dp[sum_v] <= W:\n        ans = sum_v\n\nprint(ans)"}
{"problem_id":"p02599","slow_code_col":"import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\nMOD = 1000000007\n\n\n\n# Reference: https:\/\/www.geeksforgeeks.org\/queries-number-distinct-elements-subarray\/\n\n# Python3 code to find number of\n\n# distinct numbers in a subarray\n\nMAX = 1000001\n\n\n\n# structure to store queries\n\nclass Query:\n\n    def __init__(self, l, r, idx):\n\n        self.l = l\n\n        self.r = r\n\n        self.idx = idx\n\n\n\n\n\n# updating the bit array\n\ndef update(idx, val, bit, n):\n\n    while idx <= n:\n\n        bit[idx] += val\n\n        idx += idx & -idx\n\n\n\n\n\n# querying the bit array\n\ndef query(idx, bit, n):\n\n    summ = 0\n\n    while idx:\n\n        summ += bit[idx]\n\n        idx -= idx & -idx\n\n    return summ\n\n\n\n\n\ndef answeringQueries(arr, n, queries, q):\n\n\n\n    # initialising bit array\n\n    bit = [0] * (n + 1)\n\n\n\n    # holds the rightmost index of\n\n    # any number as numbers of a[i]\n\n    # are less than or equal to 10^6\n\n    last_visit = [-1] * MAX\n\n\n\n    # answer for each query\n\n    ans = [0] * q\n\n\n\n    query_counter = 0\n\n    for i in range(n):\n\n\n\n        # If last visit is not -1 update -1 at the\n\n        # idx equal to last_visit[arr[i]]\n\n        if last_visit[arr[i]] != -1:\n\n            update(last_visit[arr[i]] + 1, -1, bit, n)\n\n\n\n        # Setting last_visit[arr[i]] as i and\n\n        # updating the bit array accordingly\n\n        last_visit[arr[i]] = i\n\n        update(i + 1, 1, bit, n)\n\n\n\n        # If i is equal to r of any query store answer\n\n        # for that query in ans[]\n\n        while query_counter < q and queries[query_counter].r == i:\n\n            ans[queries[query_counter].idx] = query(queries[query_counter].r + 1, bit, n) - query(\n\n                queries[query_counter].l, bit, n\n\n            )\n\n            query_counter += 1\n\n\n\n    # print answer for each query\n\n    for i in range(q):\n\n        print((ans[i]))\n\n\n\n\n\n# This code is contributed by\n\n# sanjeev2552\n\n\n\n\n\ndef main():\n\n    N, Q = list(map(int, readline().split()))\n\n    C = list(map(int, readline().split()))\n\n    (*LR,) = list(map(int, read().split()))\n\n\n\n    queries = [0] * Q\n\n    for i, (l, r) in enumerate(zip(*[iter(LR)] * 2)):\n\n        queries[i] = Query(l - 1, r - 1, i)\n\n\n\n    queries.sort(key=lambda x: x.r)\n\n    answeringQueries(C, N, queries, Q)\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n\n\n","reference_code_col":"import sys\n\n\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\n\nMOD = 1000000007\n\n\n\n\n\nclass BIT:\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.data = [0] * (n + 1)\n\n\n\n    def add(self, i, x=1):\n\n        i += 1\n\n        while i <= self.n:\n\n            self.data[i] += x\n\n            i += i & -i\n\n\n\n    def get_sum(self, i):\n\n        i += 1\n\n        x = 0\n\n        while i > 0:\n\n            x += self.data[i]\n\n            i -= i & -i\n\n        return x\n\n\n\n    # Return sum for [l, r)\n\n    def get_sum_range(self, l, r):\n\n        return self.get_sum(r - 1) - self.get_sum(l - 1)\n\n\n\n\n\ndef main():\n\n    N, Q = map(int, readline().split())\n\n    C = list(map(int, readline().split()))\n\n    LR = map(int, read().split())\n\n\n\n    prev = [-1] * (N + 1)\n\n    ps = [[] for _ in range(N)]\n\n    for i, c in enumerate(C):\n\n        if prev[c] != -1:\n\n            ps[prev[c]].append(i)\n\n        prev[c] = i\n\n\n\n    qs = [[] for _ in range(N + 1)]\n\n    for i, (l, r) in enumerate(zip(*[iter(LR)] * 2)):\n\n        l -= 1\n\n        r -= 1\n\n        qs[l].append((r, i))\n\n\n\n    ans = [0] * Q\n\n    bit = BIT(N)\n\n\n\n    for l in range(N - 1, -1, -1):\n\n        for r in ps[l]:\n\n            bit.add(r)\n\n        for r, i in qs[l]:\n\n            ans[i] = (r - l + 1) - bit.get_sum(r)\n\n\n\n    print(*ans, sep='\\n')\n\n\n\n    return\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 1 << 60\nMOD = 1000000007\n\nMAX = 1000001\n\n\nclass SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (4 * n)\n        self.lazy = [0] * (4 * n)\n\n    def push(self, node, left, right):\n        if self.lazy[node] == 0:\n            return\n        mid = (left + right) \/\/ 2\n        self.tree[node * 2] += self.lazy[node]\n        self.tree[node * 2 + 1] += self.lazy[node]\n        if left < mid:\n            self.lazy[node * 2] += self.lazy[node]\n        if mid < right:\n            self.lazy[node * 2 + 1] += self.lazy[node]\n        self.lazy[node] = 0\n\n    def update_range(self, node, left, right, ql, qr, diff):\n        self.push(node, left, right)\n        if ql > right or qr < left:\n            return\n        if ql <= left and right <= qr:\n            self.tree[node] += diff\n            if left < right:\n                self.lazy[node * 2] += diff\n                self.lazy[node * 2 + 1] += diff\n            return\n        mid = (left + right) \/\/ 2\n        self.update_range(node * 2, left, mid, ql, qr, diff)\n        self.update_range(node * 2 + 1, mid + 1, right, ql, qr, diff)\n        self.tree[node] = max(self.tree[node * 2], self.tree[node * 2 + 1])\n\n    def query(self, node, left, right, ql, qr):\n        self.push(node, left, right)\n        if ql > right or qr < left:\n            return 0\n        if ql <= left and right <= qr:\n            return self.tree[node]\n        mid = (left + right) \/\/ 2\n        return max(\n            self.query(node * 2, left, mid, ql, qr),\n            self.query(node * 2 + 1, mid + 1, right, ql, qr)\n        )\n\n\ndef answeringQueries(arr, n, queries, q):\n    st = SegmentTree(MAX)\n    last_visit = [-1] * MAX\n    ans = [0] * q\n\n    for i in range(n):\n        if last_visit[arr[i]] != -1:\n            st.update_range(1, 1, MAX, last_visit[arr[i]] + 1, i, -1)\n        last_visit[arr[i]] = i\n        st.update_range(1, 1, MAX, i + 1, i + 1, 1)\n\n        for j, query in enumerate(queries):\n            if query.r == i:\n                ans[query.idx] = st.query(1, 1, MAX, query.l, query.r)\n                break\n\n    for i in range(q):\n        print(ans[i])\n\n\ndef main():\n    N, Q = map(int, readline().split())\n    C = list(map(int, readline().split()))\n    LR = list(map(int, read().split()))\n\n    queries = []\n    for i, (l, r) in enumerate(zip(*[iter(LR)] * 2)):\n        queries.append((l - 1, r - 1, i))\n\n    queries.sort(key=lambda x: x[1])\n    answeringQueries(C, N, queries, Q)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02596","slow_code_col":"k = int(eval(input()))\n\nnum = 0\n\nif not k%2:\n\n    print((-1))\n\nelse:\n\n    for i in range(k):\n\n        num = (num*10+7)%k\n\n        if num == 0:\n\n            print((i+1))\n\n            break\n\n    else:\n\n        print((-1))","reference_code_col":"K = int(eval(input()))\n\n\n\nans = 1\n\nnum = 0\n\nseven = 7\n\n\n\nif not K%2:\n\n    print((-1))\n\nelse:\n\n    for i in range(K):\n\n        num = num + seven\n\n        seven = seven*10%K\n\n        num = num%K\n\n        if num == 0:\n\n            print(ans)\n\n            break\n\n        ans += 1\n\n    else:\n\n        print((-1))","model_generated_potentially_faster_code_col":"def find_cycle_length(k):\n    mod = 10 ** (k - 1)\n    if pow(10, mod, k) != 1: \n        return -1\n    x = 1\n    while True:\n        if pow(10, x, k) == 1: \n            return x\n        x += 1\n\nk = int(input())\nprint(find_cycle_length(k))"}
{"problem_id":"p02886","slow_code_col":"N=int(eval(input()))\n\nd=list(map(int, input().split()))\n\n\n\nimport numpy as np\n\nd = np.array(d)\n\n\n\nprint(( ( (np.sum(d))**2 - np.sum(d**2) ) \/\/ 2 ))\n","reference_code_col":"N=int(eval(input()))\n\nd=list(map(int, input().split()))\n\n\n\ncumsum = 0\n\nfor n in range(N):\n\n    cumsum += d[n]\n\nsub_cumsum = 0\n\nans = 0\n\nfor n in range(N):\n\n    sub_cumsum += d[n]\n\n    ans += d[n] * (cumsum-sub_cumsum)\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"N = int(input())\nd = [int(x) for x in input().split()]\n\n# Calculate the sum and sum of squares\ntotal_sum = sum(d)\nsum_of_squares = sum(x**2 for x in d)\n\n# Calculate the final result\nresult = ((total_sum ** 2) - sum_of_squares) \/\/ 2\n\nprint(result)"}
{"problem_id":"p02596","slow_code_col":"k = int(eval(input()))\n\ncount = 1\n\nn = 0\n\nif k % 2 == 0 or k % 5 == 0:\n\n    print((-1))\n\nelse:\n\n  while 1:\n\n      n = (n * 10 + 7) % k  \n\n      if n == 0:\n\n        break \n\n      count += 1\n\n  print(count)","reference_code_col":"def main(h):\n\n  count = 1\n\n  n = 0\n\n  for i in range (k):\n\n    n = (n * 10 + 7) % k  \n\n    if n == 0: \n\n      print(count)\n\n      return 0\n\n    count += 1\n\n  print((-1))\n\n  \n\nif __name__ == '__main__':\n\n  k = int(eval(input()))\n\n  main(k)","model_generated_potentially_faster_code_col":"k = int(eval(input()))\ncount = 1\nn = 10\n\n# Check if k is a power of 2 or 5\nif k & (k - 1) == 0 or k % 5 == 0:\n    print(-1)\nelse:\n    # Use Fermat's Little Theorem to find the upper bound of the order\n    max_order = k - 1\n    i = 2\n    while i <= max_order:\n        if max_order % i == 0:\n            max_order \/\/= i\n        else:\n            i += 1\n\n    # Find the smallest x such that 10^x \u2261 1 (mod k)\n    while True:\n        n = (n * 10) % k\n        count += 1\n        if n == 1:\n            break\n        if count > max_order:  # If no solution found within max_order, return -1\n            print(-1)\n            break"}
{"problem_id":"p03250","slow_code_col":"a, b, c = sorted(map(int, input().split()))\n\n\n\nprint((c*10 + b + a))","reference_code_col":"a, b, c = list(map(int, input().split()))\n\n\n\nprint((max(a, b, c)*9 + (a + b + c)))","model_generated_potentially_faster_code_col":"import sys\n\na, b, c = map(int, sys.stdin.read().strip().split())\n\nprint(c * 10 + b + a)"}
{"problem_id":"p03371","slow_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\nans = float('inf')\n\n\n\nfor i in range(200005):\n\n    tmp = i * 2 * c\n\n    tmp += max(0, x-i) * a\n\n    tmp += max(0, y-i) * b\n\n    ans = min(ans, tmp)\n\n\n\nprint(ans)","reference_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\nans = float('inf')\n\n\n\nfor i in range(100005):\n\n    tmp = i * 2 * c\n\n    tmp += max(0, x-i) * a\n\n    tmp += max(0, y-i) * b\n\n    ans = min(ans, tmp)\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"tmp = i * 2 * c + max(0, x - i) * a + max(0, y - i) * b"}
{"problem_id":"p02574","slow_code_col":"import sys\n\nsys.setrecursionlimit(1 << 25)\n\nreadline = sys.stdin.buffer.readline\n\nread = sys.stdin.readline  # \u6587\u5b57\u5217\u8aad\u307f\u8fbc\u3080\u6642\u306f\u3053\u3063\u3061\n\nra = range\n\nenu = enumerate\n\n\n\n\n\ndef exit(*argv, **kwarg):\n\n    print(*argv, **kwarg)\n\n    sys.exit()\n\n\n\n\n\ndef mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))\n\n# \u53d7\u3051\u6e21\u3055\u308c\u305f\u3059\u3079\u3066\u306e\u8981\u7d20\u304b\u3089sub\u3060\u3051\u5f15\u304f.\u30ea\u30b9\u30c8\u3092*\u3092\u3064\u3051\u3066\u5c55\u958b\u3057\u3066\u304a\u304f\u3053\u3068\n\n\n\n\n\ndef a_int(): return int(readline())\n\n\n\n\n\ndef ints(): return list(map(int, readline().split()))\n\n\n\n\n\ndef _make_minimum_prime(N: int):\n\n    # x\u306e\u6700\u5c0f\u306e\u7d20\u56e0\u6570\u8868\u3092\u4f5c\u6210\n\n    min_prime = [x for x in range(N + 1)]\n\n    # min_prime[0] = 0  # 0\u30681\u306f\u7d20\u6570\u3067\u306f\u306a\u3044\n\n    # min_prime[1] = 1\n\n    for i in range(2, int(N ** 0.5) + 1):\n\n        if min_prime[i] == i:  # \u7d20\u6570\u3060\u3063\u305f\u3089\u66f4\u65b0\n\n            for j in range(2 * i, N + 1, i):  # i\u306e\u500d\u6570\u306f\u7d20\u6570\u3067\u306a\u3044\n\n                if min_prime[j] == j:\n\n                    min_prime[j] = i\n\n    return min_prime\n\n\n\n\n\nmin_prime = _make_minimum_prime(10**6)\n\n\n\n\n\nfrom collections import Counter\n\n\n\n\n\ndef fast_factorization(N: int):\n\n    # -> List[Tuple[int,int]] (\u7d20\u6570,\u51aa\u6570)\u3092\u683c\u7d0d\n\n    # \u6700\u5c0f\u7d20\u6570\u914d\u5217min_prime\u3092\u4f7f\u3063\u3066O(log N)\u3067\u56e0\u6570\u5206\u89e3\n\n    if N == 1:\n\n        return Counter()  # 1\u306f\u7d20\u6570\u3067\u306f\u306a\u3044\n\n    # \u7d20\u56e0\u6570\u5206\u89e3\n\n    arr = []\n\n    tmp = N\n\n    while tmp != 1:\n\n        p = min_prime[tmp]\n\n        tmp \/\/= p\n\n        arr.append(p)\n\n\n\n    return Counter(arr)\n\n\n\n\n\nMOD = 10**9 + 7\n\nINF = 2**31  # 2147483648 > 10**9\n\n# default import\n\nfrom collections import defaultdict, Counter, deque\n\nimport random\n\nfrom math import gcd\n\n\n\n\n\nN = a_int()\n\nA = ints()\n\nrandom.shuffle(A)\n\n\n\n# set\u304b\u306f\u3059\u3050\u308f\u304b\u308b\n\n# set\u3067\u306a\u3051\u308c\u3070 not coprime\n\n# pair\u306f\u4e92\u3044\u306b\u7d20\u304b\u3092\u307f\u308c\u3070\u3044\u3044\u306e\u304b\n\n# \u3064\u307e\u308a\u56e0\u6570\u5206\u89e3\u3057\u3066\u8db3\u3057\u3066\u3063\u305f\u3068\u304d\u306b\u3059\u3079\u3066\u306e\u7d20\u6570\u306e\u3079\u304d\u6570\u304c1\u4ee5\u4e0b\u3067\u3042\u308c\u3070\u826f\u3044\n\n\n\ng_set = 0\n\ncnt = defaultdict(lambda: 0)\n\nflg = 1  # pairwise\u3067\u3042\u308b\u30d5\u30e9\u30b0\n\nfor a in A:\n\n    g_set = gcd(g_set, a)\n\n    if flg:\n\n        for p, n in fast_factorization(a).items():\n\n            if cnt[p] != 0:\n\n                flg = 0\n\n            cnt[p] += n\n\n\n\n\n\n# print(cnt)\n\n# for v in cnt.values():\n\n#     if v > 1:\n\n#         flg = 0\n\n#         break\n\n\n\nif g_set > 1:\n\n    print('not coprime')\n\nelif flg:\n\n    print('pairwise coprime')\n\nelse:\n\n    print('setwise coprime')\n","reference_code_col":"import sys\n\nsys.setrecursionlimit(1 << 25)\n\nreadline = sys.stdin.buffer.readline\n\nread = sys.stdin.readline  # \u6587\u5b57\u5217\u8aad\u307f\u8fbc\u3080\u6642\u306f\u3053\u3063\u3061\n\nra = range\n\nenu = enumerate\n\n\n\n\n\ndef exit(*argv, **kwarg):\n\n    print(*argv, **kwarg)\n\n    sys.exit()\n\n\n\n\n\ndef mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))\n\n# \u53d7\u3051\u6e21\u3055\u308c\u305f\u3059\u3079\u3066\u306e\u8981\u7d20\u304b\u3089sub\u3060\u3051\u5f15\u304f.\u30ea\u30b9\u30c8\u3092*\u3092\u3064\u3051\u3066\u5c55\u958b\u3057\u3066\u304a\u304f\u3053\u3068\n\n\n\n\n\ndef a_int(): return int(readline())\n\n\n\n\n\ndef ints(): return list(map(int, readline().split()))\n\n\n\n\n\nfrom collections import Counter\n\n\n\n\n\nclass FastFactorization:\n\n    def __init__(self, N: int):\n\n        '''\u69cb\u7bc9O(NloglogN)\u3001\u30af\u30a8\u30eaO(logN)'''\n\n        self.N = N\n\n        self.min_prime = self._make_minimum_prime()\n\n\n\n    def _make_minimum_prime(self):\n\n        # x\u306e\u6700\u5c0f\u306e\u7d20\u56e0\u6570\u8868\u3092\u4f5c\u6210\n\n        min_prime = [x for x in range(self.N + 1)]\n\n        # min_prime[0] = 0  # 0\u30681\u306f\u7d20\u6570\u3067\u306f\u306a\u3044\n\n        # min_prime[1] = 1\n\n        for i in range(2, int(self.N ** 0.5) + 1):\n\n            if min_prime[i] == i:  # \u7d20\u6570\u3060\u3063\u305f\u3089\u66f4\u65b0\n\n                for j in range(2 * i, self.N + 1, i):  # i\u306e\u500d\u6570\u306f\u7d20\u6570\u3067\u306a\u3044\n\n                    if min_prime[j] == j:\n\n                        min_prime[j] = i\n\n        return min_prime\n\n\n\n    def query(self, x: int):\n\n        # -> Counter[p,n] (\u7d20\u6570,\u51aa\u6570) \u3092\u683c\u7d0d\n\n        # \u6700\u5c0f\u7d20\u6570\u914d\u5217min_prime\u3092\u4f7f\u3063\u3066O(log N)\u3067\u56e0\u6570\u5206\u89e3\n\n        if x == 1:\n\n            return Counter()  # 1\u306f\u7d20\u6570\u3067\u306f\u306a\u3044\n\n\n\n        # \u7d20\u56e0\u6570\u5206\u89e3\n\n        arr = []\n\n        tmp = x\n\n        while tmp != 1:\n\n            p = self.min_prime[tmp]\n\n            tmp \/\/= p\n\n            arr.append(p)\n\n        return Counter(arr)\n\n\n\n\n\nMOD = 10**9 + 7\n\nINF = 2**31  # 2147483648 > 10**9\n\n# default import\n\nfrom collections import defaultdict, Counter, deque\n\nfrom math import gcd\n\n\n\n\n\nN = a_int()\n\nA = ints()\n\n\n\nfact = FastFactorization(max(A))\n\n\n\n# set\u304b\u306f\u3059\u3050\u308f\u304b\u308b\n\n# set\u3067\u306a\u3051\u308c\u3070 not coprime\n\n# pair\u306f\u4e92\u3044\u306b\u7d20\u304b\u3092\u307f\u308c\u3070\u3044\u3044\u306e\u304b\n\n# \u3064\u307e\u308a\u56e0\u6570\u5206\u89e3\u3057\u3066\u8db3\u3057\u3066\u3063\u305f\u3068\u304d\u306b\u3059\u3079\u3066\u306e\u7d20\u6570\u306e\u3079\u304d\u6570\u304c1\u4ee5\u4e0b\u3067\u3042\u308c\u3070\u826f\u3044\n\n\n\ng_set = 0\n\ncnt = defaultdict(lambda: 0)\n\nflg = 1  # pairwise\u3067\u3042\u308b\u30d5\u30e9\u30b0\n\nfor a in A:\n\n    g_set = gcd(g_set, a)\n\n    if flg:\n\n        for p, n in fact.query(a).items():\n\n            if cnt[p] != 0:\n\n                flg = 0\n\n            cnt[p] += n\n\n\n\n\n\n# print(cnt)\n\n# for v in cnt.values():\n\n#     if v > 1:\n\n#         flg = 0\n\n#         break\n\n\n\nif g_set > 1:\n\n    print('not coprime')\n\nelif flg:\n\n    print('pairwise coprime')\n\nelse:\n\n    print('setwise coprime')\n","model_generated_potentially_faster_code_col":"import sys\nimport random\nfrom math import gcd\nfrom collections import defaultdict, deque\n\nsys.setrecursionlimit(1 << 25)\nreadline = sys.stdin.buffer.readline\na_int = lambda: int(readline())\nints = lambda: list(map(int, readline().split()))\n\ndef _make_minimum_prime(N):\n    min_prime = list(range(N + 1))\n    for i in range(2, int(N ** 0.5) + 1):\n        if min_prime[i] == i:\n            for j in range(i * 2, N + 1, i):\n                if min_prime[j] == j:\n                    min_prime[j] = i\n    return min_prime\n\nmin_prime = _make_minimum_prime(10**6)\n\nMOD = 10**9 + 7\nINF = 2**31\n\nN = a_int()\nA = ints()\nrandom.shuffle(A)\n\ng_set = 0\ncnt = defaultdict(int)\nis_pairwise_coprime = True\n\nfor a in A:\n    g_set = gcd(g_set, a)\n    for p, n in ((p, n) for p, n in _fast_factorization(a).items()):\n        if cnt[p] != 0:\n            is_pairwise_coprime = False\n        cnt[p] += n\n\nif g_set > 1:\n    print('not coprime')\nelif is_pairwise_coprime:\n    print('pairwise coprime')\nelse:\n    print('setwise coprime')\n\ndef _fast_factorization(N):\n    if N == 1:\n        return {}\n    arr = []\n    tmp = N\n    while tmp != 1:\n        p = min_prime[tmp]\n        tmp \/\/= p\n        arr.append(p)\n    factor_counts = {}\n    for p in arr:\n        if p in factor_counts:\n            factor_counts[p] += 1\n        else:\n            factor_counts[p] = 1\n    return factor_counts"}
{"problem_id":"p03844","slow_code_col":"print((eval(input())))","reference_code_col":"print(eval(input()))","model_generated_potentially_faster_code_col":"import ast\n\nprint(ast.literal_eval(input()))"}
{"problem_id":"p03568","slow_code_col":"N = int(eval(input()))\n\nAs = list(map(int,input().split()))\n\n\n\n\n\ndef dfs(A_s, index,Bss):\n\n    if index == N:\n\n        tmp = 1\n\n        for b in Bss:\n\n            tmp *= b\n\n        return 1 if tmp % 2 == 0 else 0\n\n    b_mi = Bss.copy()\n\n    b_mi.append(A_s[index] - 1)\n\n\n\n    b = Bss.copy()\n\n    b.append(A_s[index])\n\n\n\n    b_pl = Bss.copy()\n\n    b_pl.append(A_s[index] + 1)\n\n    return dfs(A_s,index + 1, b_mi) + dfs(A_s,index + 1,b) + dfs(A_s,index + 1,b_pl)\n\n\n\n\n\nprint((dfs(As,0,[])))\n","reference_code_col":"N = int(eval(input()))\n\nAs = list(map(int,input().split()))\n\n\n\ntmp = 1\n\nfor i in range(N):\n\n    if As[i] % 2 == 0:\n\n       tmp *= 2\n\n\n\nprint((3 ** N - tmp))","model_generated_potentially_faster_code_col":"N = int(eval(input()))\n   As = list(map(int, input().split()))"}
{"problem_id":"p02767","slow_code_col":"import numpy as np\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    N = int(readline())\n\n    X = [int(i) for i in readline().split()]\n\n    X = np.array(X)\n\n\n\n    ans = np.min(np.sum((X - np.arange(1,101).reshape(100, 1))**2, axis=1))\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    N = int(readline())\n\n    X = [int(i) for i in readline().split()]\n\n\n\n    ans = float('inf')\n\n    for i in range(1,101):\n\n        tmp = 0\n\n        for x in X:\n\n            tmp += (x - i)**2\n\n        \n\n        if tmp < ans:\n\n            ans = tmp\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import numpy as np\n\ndef main():\n    # Read input from stdin\n    N = int(input())\n    X = list(map(int, input().split()))\n    \n    # Convert list to NumPy array\n    X = np.array(X)\n    \n    # Calculate squared differences and sum along columns\n    squared_diffs = (X[:, None] - np.arange(1, 101)) ** 2\n    sums_of_squares = np.sum(squared_diffs, axis=0)\n    \n    # Find the minimum value among the sums of squares\n    ans = np.min(sums_of_squares)\n    \n    # Print the result\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03796","slow_code_col":"import math\n\nn=int(eval(input()))\n\nprint((math.factorial(n)%(10**9+7)))","reference_code_col":"N=int(eval(input()))\n\ndef fact(n):\n\n    val=1\n\n    for i in range(2,n+1):\n\n        val*=i\n\n        val%=1000000007\n\n    return val\n\nprint((fact(N)))","model_generated_potentially_faster_code_col":"def factorial(n):\n    result = 1\n    for i in range(2,n+1):\n        result *= i\n    return result % (10**9+7)\n\nn = int(input())\nprint(factorial(n))"}
{"problem_id":"p03309","slow_code_col":"N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# \u4e2d\u592e\u5024\n\nB = []\n\nfor i in range(N):\n\n    B.append(A[i] - (i+1))\n\nb = sorted(B)[N\/\/2]\n\n\n\nans = 0\n\nfor i in range(N):\n\n    ans += abs(A[i] - (i + 1) - b)\n\n\n\nprint(ans)\n\n\n","reference_code_col":"from statistics import median_low\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nD = []\n\nfor i in range(N):\n\n    D.append(A[i] - (i+1))\n\n\n\nm = median_low(D)\n\nans = 0\n\nfor d in D:\n\n    ans += abs(d - m)\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"N = int(input())\nA = list(map(int, input().split()))\n\n# Calculate the difference between each element and its index\nB = [a - i for i, a in enumerate(A)]\n\n# Find the median of B\nB.sort()\nb = B[N \/\/ 2]\n\n# Calculate the total absolute deviation from the median\nans = sum(abs(a - b) for a in A)\n\nprint(ans)"}
{"problem_id":"p03801","slow_code_col":"n = int(input())\n\na = list(map(int, input().split()))\n\n\n\ntmp = [[e, n - i] for i, e in enumerate(a)]\n\ntmp.sort(reverse=True)\n\n\n\naa = [[e, n - i] for e, i in tmp] + [[0, -1]]\n\n\n\nv_prev, i_prev = aa[0]\n\ni = 0\n\nans = [0] * n\n\nsm = 0\n\nwhile i < n:\n\n    while aa[i][1] >= i_prev:\n\n        sm += aa[i][0]\n\n        i += 1\n\n\n\n    ans[i_prev] += sm - aa[i][0] * i\n\n    sm = aa[i][0] * i\n\n    v_prev, i_prev = aa[i]\n\n\n\nprint(*ans, sep=\"\\n\")\n","reference_code_col":"from bisect import bisect_right\n\n\n\nn = int(input())\n\na = list(map(int, input().split()))\n\n\n\nli = [[0, -1]]\n\nfor i, e in enumerate(a):\n\n    if e > li[-1][0]:\n\n        li.append([e, i])\n\n\n\nli = li[::-1]\n\n\n\na.sort()\n\nacc = [0] * (n + 1)\n\nfor i in range(n - 1, -1, -1):\n\n    acc[i] = acc[i+1] + a[i]\n\n\n\nans = [0] * n\n\nsub = 0\n\nans_prev = 0\n\nfor (ep, ip), (e, i) in zip(li, li[1:]):\n\n    j = bisect_right(a, e)\n\n    ans[ip] = acc[j] - e * (n - j)\n\n\n\ni_prev = 0\n\nfor i in range(1, n):\n\n    if ans[i]:\n\n        ans[i_prev] -= ans[i]\n\n        i_prev = i\n\n\n\nprint(*ans, sep=\"\\n\")\n","model_generated_potentially_faster_code_col":"n = int(input())\na = list(map(int, input().split()))\n\n# Calculate prefix sums\nprefix_sum = [0] * (n + 1)\nfor i in range(n):\n    prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n# Sort indices based on values in descending order\nindices_sorted_by_value = sorted(range(n), key=lambda x: a[x], reverse=True)\n\n# Initialize result array\nresult = [0] * n\n\n# Iterate over sorted indices\nfor i in range(n):\n    if i > 0 and a[indices_sorted_by_value[i]] == a[indices_sorted_by_value[i - 1]]:\n        result[indices_sorted_by_value[i]] = result[indices_sorted_by_value[i - 1]]\n    else:\n        result[indices_sorted_by_value[i]] = prefix_sum[n] - prefix_sum[indices_sorted_by_value[i]]\n\nprint(*result, sep=\"\\n\")"}
{"problem_id":"p03013","slow_code_col":"N, M = list(map(int, input().split()))\n\nA_ = [int(eval(input())) for _ in range(M)]\n\nA = [0] * (N+3)\n\nfor a in A_:\n\n    A[a] = 1\n\ndp = [0] * (N+3)\n\ndp[0] = 1\n\n\n\nmod = 10**9+7\n\n\n\nfor i in range(1, N+1):\n\n    if A[i-1] == 0:\n\n        dp[i] += dp[i-1]\n\n    if A[i-2] == 0:\n\n        dp[i] += dp[i-2]\n\n    dp[i] %= mod\n\nprint((dp[N]))","reference_code_col":"n,m=list(map(int,input().split()))\n\ndp=[0]*(n+3)\n\na=[int(eval(input())) for i in range(m)]\n\nmod=10**9+7\n\nfor i in range(m):\n\n    dp[a[i]]=-1\n\n\n\ndp[0]=1\n\nif dp[1]!=-1:\n\n    dp[1]+=dp[0]\n\n\n\nfor i in range(n+1):\n\n    if dp[i+2]==-1:\n\n        continue\n\n    if dp[i]!=-1:\n\n        dp[i+2]+=dp[i]\n\n    if dp[i+1]!=-1:\n\n        dp[i+2]+=dp[i+1]\n\n    dp[i+2]%=mod\n\nprint((dp[n]%mod))","model_generated_potentially_faster_code_col":"N, M = map(int, input().split())\n\n# Create a set to store blocked positions for O(1) lookup\nblocked_positions = {int(input()) for _ in range(M)}\n\nA = [0] * (N + 3)\ndp = [0] * (N + 3)\n\n# Initialize dp array\ndp[0] = 1\n\n# Fill the dp array\nfor i in range(1, N + 1):\n    if i - 1 not in blocked_positions:\n        dp[i] += dp[i - 1]\n    if i - 2 not in blocked_positions:\n        dp[i] += dp[i - 2]\n    dp[i] %= 10**9 + 7\n\nprint(dp[N])"}
{"problem_id":"p02635","slow_code_col":"# coding: utf-8\n\n# Your code here!\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\n\n\n#a,b,c,d = map(int,readline().split())\n\ns,k = readline().split()\n\n\n\n\n\na = [len(i) for i in s.split(\"0\")]\n\nwhile a and a[-1] == 0: a.pop()\n\n\n\nif not a:\n\n    print((1))\n\n    exit()\n\n\n\nMOD = 998244353\n\n\n\nM = sum(a)+1\n\nk = min(int(k),M)\n\n\n\n\n\ndp = [[0]*M for _ in range(k+1)] # j \u4f7f\u3063\u3066\uff08\u4e0a\u9650 k\uff09\u3001l \u4f59\u3063\u3066\u308b\n\ndp[0][0] = 1\n\n\n\n#print(a)\n\nfor ai in a[::-1]:\n\n    ndp = [[0]*M for _ in range(k+1)] # j \u4f7f\u3063\u3066\uff08\u4e0a\u9650 k\uff09\u3001l \u4f59\u3063\u3066\u308b\n\n    for j in range(k+1):\n\n        for l in range(M):\n\n            for ll in range(l):\n\n                ndp[j][ll] += dp[j][l]\n\n                ndp[j][ll] %= MOD\n\n            \n\n            V = min(M-l,k-j+1,ai+1)\n\n            for i in range(V):\n\n                #if j+i > k: break\n\n                ndp[j+i][l+i] += dp[j][l]\n\n                ndp[j+i][l+i] %= MOD\n\n    \n\n    dp = ndp\n\n    #print(dp)\n\n\n\nans = 0\n\nfor jj in range(k+1):\n\n    ans += dp[jj][0]\n\n\n\nprint((ans%MOD))\n\n\n\n\n\n\n\n\n\n\n","reference_code_col":"# coding: utf-8\n\n# Your code here!\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\n\n\n#a,b,c,d = map(int,readline().split())\n\ns,k = readline().split()\n\n\n\n\n\na = [len(i) for i in s.split(\"0\")]\n\nwhile a and a[-1] == 0: a.pop()\n\n\n\nif not a:\n\n    print((1))\n\n    exit()\n\n\n\nMOD = 998244353\n\n\n\nM = sum(a)+1\n\nk = min(int(k),M)\n\n\n\n\n\ndp = [[0]*M for _ in range(k+1)] # j \u4f7f\u3063\u3066\uff08\u4e0a\u9650 k\uff09\u3001l \u4f59\u3063\u3066\u308b\n\ndp[0][0] = 1\n\n\n\n#print(a)\n\nfor ai in a[::-1]:\n\n    ndp = [[0]*M for _ in range(k+1)] # j \u4f7f\u3063\u3066\uff08\u4e0a\u9650 k\uff09\u3001l \u4f59\u3063\u3066\u308b\n\n    for j in range(k+1):\n\n        for l in range(M):\n\n            if dp[j][l]:\n\n                for ll in range(l):\n\n                    ndp[j][ll] += dp[j][l]\n\n                    ndp[j][ll] %= MOD\n\n\n\n                V = min(M-l,k-j+1,ai+1)\n\n                for i in range(V):\n\n                    #if j+i > k: break\n\n                    ndp[j+i][l+i] += dp[j][l]\n\n                    ndp[j+i][l+i] %= MOD\n\n    \n\n    dp = ndp\n\n    #print(dp)\n\n\n\nans = 0\n\nfor jj in range(k+1):\n\n    ans += dp[jj][0]\n\n\n\nprint((ans%MOD))\n\n\n\n\n\n\n\n\n\n\n","model_generated_potentially_faster_code_col":"# coding: utf-8\n\nimport sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\ns, k = readline().split()\n\na = [len(i) for i in s.split(\"0\") if i]\na.reverse()\n\nMOD = 998244353\n\nM = sum(a) + 1\nk = min(int(k), M)\n\ndp = [[0] * M for _ in range(k + 1)]\ndp[0][0] = 1\n\nfor ai in a:\n    ndp = [[0] * M for _ in range(k + 1)]\n    \n    for j in range(k + 1):\n        for l in range(M):\n            ndp[j][l] += dp[j][l]\n            ndp[j][l] %= MOD\n            \n            if j < k:\n                V = min(M - l, k - j + 1, ai + 1)\n                for i in range(1, V):\n                    ndp[j + i][l + i] += dp[j][l]\n                    ndp[j + i][l + i] %= MOD\n    \n    dp = ndp\n\nans = sum(dp[jj][0] for jj in range(k + 1)) % MOD\nprint(ans)"}
{"problem_id":"p02792","slow_code_col":"n=int(eval(input()))\n\nD={}\n\nDD={}\n\nfor i in range(1,n+1):\n\n   s=(str(i)[0],str(i)[-1])\n\n   t=(str(i)[-1],str(i)[0])\n\n   if s not in D:\n\n      D[s]=1\n\n   else:\n\n      D[s]+=1\n\n   if t not in DD:\n\n      DD[t]=1\n\n   else:\n\n      DD[t]+=1\n\nans=0\n\nfor i in D:\n\n   if i in DD:\n\n      ans+=D[i]*DD[i]\n\nprint(ans)\n\n      ","reference_code_col":"n=int(eval(input()))\n\nD={}\n\nfor i in range(1,n+1):\n\n   s=(str(i)[0],str(i)[-1])\n\n   if s in D:\n\n      D[s]+=1\n\n   else:\n\n      D[s]=1\n\n\n\nans=0\n\nfor aj,bj in D:\n\n   if (bj,aj) in D:\n\n      ans+=D[(aj,bj)]*D[(bj,aj)]\n\nprint(ans)","model_generated_potentially_faster_code_col":"n = int(input())\n\nD = {}\nDD = {}\n\nfor i in range(1, n + 1):\n    first_digit = str(i)[0]\n    last_digit = str(i)[-1]\n    \n    # Update counts in D\n    if (first_digit, last_digit) in D:\n        D[(first_digit, last_digit)] += 1\n    else:\n        D[(first_digit, last_digit)] = 1\n    \n    # Update counts in DD\n    if (last_digit, first_digit) in DD:\n        DD[(last_digit, first_digit)] += 1\n    else:\n        DD[(last_digit, first_digit)] = 1\n\nans = sum(D[key] * DD[key] for key in D if key in DD)\nprint(ans)"}
{"problem_id":"p03013","slow_code_col":"n,m=[int(i) for i in input().split()]\n\ndp=[1,1] ;a=set() ; mod=(10**9+7)\n\nfor i in range(m):\n\n    a.add(int(eval(input())))\n\nif 1 in a: dp[1]=0\n\nfor i in range(2,n+1):\n\n    if i not in a:\n\n        dp.append((dp[-1]+dp[-2])%mod)\n\n    else:\n\n        dp.append(0)\n\nprint((dp[-1]))\n\n    \n","reference_code_col":"import sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nn,m=[int(i) for i in input().split()]\n\ndp=[1,1] ;a=set() ; mod=(10**9+7)\n\nfor i in range(m):\n\n    a.add(int(eval(input())))\n\nif 1 in a: dp[1]=0\n\nfor i in range(2,n+1):\n\n    if i not in a:\n\n        dp.append((dp[-1]+dp[-2])%mod)\n\n    else:\n\n        dp.append(0)\n\nprint((dp[-1]))\n\n    \n","model_generated_potentially_faster_code_col":"n, m = map(int, input().split())\n\ndp = [1, 1]\na = {int(input()) for _ in range(m)}\nmod = (10 ** 9 + 7)\n\nif 1 in a:\n    dp[1] = 0\n\nfor i in range(2, n + 1):\n    dp.append((dp[-1] + dp[-2]) % mod if i not in a else 0)\n\nprint(dp[-1])"}
{"problem_id":"p03013","slow_code_col":"from functools import lru_cache\n\n\n\ndef main():\n\n    n,m = list(map(int,input().split()))\n\n    import numpy as np\n\n    ans = np.ones(n+1,dtype=int)*-1\n\n    ans[0] = 1\n\n    mod = 10**9+7\n\n    for _ in range(m):\n\n        a = int(eval(input()))\n\n        ans[a]=0\n\n    if ans[1]!=0:\n\n        ans[1]=1\n\n    for i in range(2,n+1):\n\n        if ans[i]!=0:\n\n            ans[i] = (ans[i-1]+ans[i-2])%mod\n\n    print((ans[-1]))\n\n        \n\n\n\nif __name__ == \"__main__\":\n\n    main()","reference_code_col":"def main():\n\n    n,m = list(map(int,input().split()))\n\n    dp = [0 for i in range(n+1)]\n\n    mod = 10**9+7\n\n    for i in range(m):\n\n        a = int(eval(input()))\n\n        dp[a] = -1\n\n    dp[0] = 1\n\n    if dp[1]!=-1:\n\n        dp[1] = 1\n\n    for i in range(2,n+1):\n\n        if dp[i]==-1:\n\n            continue\n\n        if dp[i-1]!=-1 and dp[i-2]!=-1:\n\n            dp[i] = dp[i-1] + dp[i-2]\n\n            dp[i] = dp[i]%mod\n\n        elif dp[i-1]!=-1 and dp[i-2]==-1:\n\n            dp[i] = dp[i-1]\n\n        elif dp[i-1]==-1 and dp[i-2]!=-1:\n\n            dp[i] = dp[i-2]\n\n        else:\n\n            dp[i] = 0\n\n    print((dp[-1]))\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"from functools import lru_cache\nimport numpy as np\n\ndef main():\n    n, m = map(int, input().split())\n\n    # Initialize the answer array\n    ans = np.zeros(n + 1, dtype=int)\n    ans[0] = 1\n\n    # Read and mark invalid indices\n    for _ in range(m):\n        a = int(input())\n        ans[a] = 0\n\n    # Set ans[1] to 1 if it was not marked as invalid\n    if ans[1] == 0:\n        ans[1] = 1\n\n    # Precompute Fibonacci numbers modulo 10^9 + 7\n    mod = 10**9 + 7\n    fib = np.zeros(n + 1, dtype=int)\n    fib[0], fib[1] = 1, 1\n    for i in range(2, n + 1):\n        fib[i] = (fib[i - 1] + fib[i - 2]) % mod\n\n    # Update valid indices with Fibonacci numbers\n    for i in range(2, n + 1):\n        if ans[i] != 0:\n            ans[i] = fib[i]\n\n    print(ans[-1])\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nN = int(eval(input()))\n\nans = 0\n\n\n\nans =math.factorial(N) % (10**9 +7)\n\n\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\npower = 1\n\n\n\nfor i in range(N):\n\n    power = ((i+1) * power) % 1000000007\n\n\n\nprint(power)","model_generated_potentially_faster_code_col":"import sys\n\n# Read input value from standard input\ninput_value = sys.stdin.read().strip()\n\n# Convert input value to integer\nN = int(input_value)\n\n# Initialize result variable to 1\nresult = 1\n\n# Calculate factorial of N iteratively\nfor i in range(2, N+1):\n    result *= i\n\n# Take modulo with 10^9 + 7 to get final answer\nfinal_answer = result % (10**9 + 7)\n\n# Print the final answer\nprint(final_answer)"}
{"problem_id":"p03078","slow_code_col":"X,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nalready = [[0,0,0]]\n\nx,y,z = 0,0,0\n\nplace_sum = []\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        place_sum.append([x + 1,y,z])\n\n        check.append(asort[x + 1] + bsort[y] + csort[z])\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        place_sum.append([x,y + 1,z])\n\n        check.append(asort[x] + bsort[y + 1] + csort[z])\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        place_sum.append([x,y,z + 1])\n\n        check.append(asort[x] + bsort[y] + csort[z + 1])\n\n    print((max(check)))\n\n    x,y,z = place_sum[check.index(max(check))][0],place_sum[check.index(max(check))][1],place_sum[check.index(max(check))][2]\n\n    place_sum.pop(check.index(max(check)))\n\n    check.remove(max(check))","reference_code_col":"import heapq\n\nX,Y,Z,K = list(map(int,input().split()))\n\nA = list(map(int,input().split()))\n\nB = list(map(int,input().split()))\n\nC = list(map(int,input().split()))\n\nasort,bsort,csort = sorted(A,reverse=True),sorted(B,reverse=True),sorted(C,reverse=True)\n\nalready = [[0,0,0]]\n\nprint((asort[0] + bsort[0] + csort[0]))\n\nx,y,z = 0,0,0\n\ncheck = []\n\nfor k in range(K - 1):\n\n    if [x + 1,y,z] not in already and x + 1 < X:\n\n        already.append([x + 1,y,z])\n\n        heapq.heappush(check,(-(asort[x + 1] + bsort[y] + csort[z]),x + 1,y,z))\n\n    if [x,y + 1,z] not in already and y + 1 < Y:\n\n        already.append([x,y + 1,z])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y + 1] + csort[z]),x,y + 1,z))\n\n    if [x,y,z + 1] not in already and z + 1 < Z:\n\n        already.append([x,y,z + 1])\n\n        heapq.heappush(check,(-(asort[x] + bsort[y] + csort[z + 1]),x,y,z + 1))\n\n    maxsum = heapq.heappop(check)\n\n    print((-maxsum[0]))\n\n    x,y,z = maxsum[1],maxsum[2],maxsum[3]","model_generated_potentially_faster_code_col":"import heapq\n\nX, Y, Z, K = map(int, input().split())\n\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\n\n# Sort arrays in descending order\nasort = sorted(A, reverse=True)\nbsort = sorted(B, reverse=True)\ncsort = sorted(C, reverse=True)\n\n# Initialize variables\nx, y, z = 0, 0, 0\nplace_sum = []\ncheck = []\n\n# Push initial state into heap\nheapq.heappush(check, (-asort[0] - bsort[0] - csort[0], (x, y, z)))\n\nwhile len(check) > 0 and K > 0:\n    # Get the current state with the highest sum\n    _, (x, y, z) = heapq.heappop(check)\n    \n    # Print the current maximum sum\n    print(-_, end=' ')\n    \n    # Generate new states and push them into the heap\n    if x + 1 < X and [x + 1, y, z] not in place_sum:\n        place_sum.append([x + 1, y, z])\n        heapq.heappush(check, (-asort[x + 1] - bsort[y] - csort[z], (x + 1, y, z)))\n    \n    if y + 1 < Y and [x, y + 1, z] not in place_sum:\n        place_sum.append([x, y + 1, z])\n        heapq.heappush(check, (-asort[x] - bsort[y + 1] - csort[z], (x, y + 1, z)))\n    \n    if z + 1 < Z and [x, y, z + 1] not in place_sum:\n        place_sum.append([x, y, z + 1])\n        heapq.heappush(check, (-asort[x] - bsort[y] - csort[z + 1], (x, y, z + 1)))\n    \n    K -= 1"}
{"problem_id":"p02725","slow_code_col":"import numpy as np\n\nk,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = np.zeros(n)\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n  \n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))","reference_code_col":"k,n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = [0 for i in range(n)]\n\nfor i in range(0,n-1):\n\n  b[i] = a[i+1] -a[i]\n\n\n\nb[n-1] = k - a[n-1] + a[0]\n\nans = k - max(b)\n\nprint((int(ans)))","model_generated_potentially_faster_code_col":"import numpy as np\n\nk,n = map(int, input().split())\n\na = list(map(int, input().split()))\n\nmin_diff = float('inf')\n\nfor i in range(0,n-1):\n    diff = abs(a[i+1] - a[i])\n    if diff < min_diff:\n        min_diff = diff\n\n# Calculate the last difference considering the circular nature of the array\nlast_diff = abs(k - a[n-1] + a[0])\nif last_diff < min_diff:\n    min_diff = last_diff\n\nans = k - min_diff\n\nprint(ans)"}
{"problem_id":"p02996","slow_code_col":"import numpy as np\n\n# \u7de0\u5207\u304c\u65e9\u3044\u3082\u306e\u304b\u3089\u51e6\u7406\n\nN = int(eval(input()))\n\nAB = np.array([[int(x) for x in input().split()] for _ in range(N)])\n\nA = AB[:,0]\n\nB = AB[:,1]\n\nidx = B.argsort()\n\nA = A[idx]\n\nB = B[idx]\n\nnp.cumsum(A, out = A)\n\nbl = (A <= B).all()\n\nanswer = 'Yes' if bl else 'No'\n\nprint(answer)\n","reference_code_col":"def main():\n\n    N = int(eval(input()))\n\n    A = []\n\n    for _ in range(N):\n\n        a, b = list(map(int, input().split()))\n\n        A.append((a, b))\n\n\n\n    A = sorted(A, key=lambda x: x[1])\n\n    time = 0\n\n    for a, b in A:\n\n        time += a\n\n        if time > b:\n\n            return 'No'\n\n\n\n    return 'Yes'\n\n\n\nif __name__ == '__main__':\n\n    print((main()))\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# \u7de0\u5207\u304c\u65e9\u3044\u3082\u306e\u304b\u3089\u51e6\u7406\n\nN = int(input())\n\nAB = np.array([[int(x) for x in input().split()] for _ in range(N)])\n\nA = AB[:,0]\n\nB = AB[:,1]\n\nidx = B.argsort()\n\nA = A[idx]\n\nB = B[idx]\n\nnp.cumsum(A, out = A)\n\nbl = (A <= B).all()\n\nanswer = 'Yes' if bl else 'No'\n\nprint(answer)"}
{"problem_id":"p03371","slow_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\nans=a*x+b*y\n\nn=max(x,y)\n\nfor i in range(1,n+1):\n\n  ans=min(ans,2*i*c+a*max(0,x-i)+b*max(0,y-i))\n\nprint(ans)\n\n\n\n\n","reference_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\nans1=a*x+b*y\n\nans2=2*c*max(x,y)\n\nans3=2*c*min(x,y)+a*(x-min(x,y))+b*(y-min(x,y))\n\nprint((min(ans1,ans2,ans3)))","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\n\n# Calculate the minimum value without using a loop\nmin_value = min(a * x + b * y,\n                2 * x * c + a * (x - x) + b * max(0, y - x),\n                2 * y * c + a * max(0, x - y) + b * (y - y))\n\nprint(min_value)"}
{"problem_id":"p03325","slow_code_col":"answer = 0\n\nN = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nfor i in range(N) :\n\n    while A[i] % 2 == 0 :\n\n        A[i] = A[i] \/ 2\n\n        answer += 1\n\nprint(answer)\n\n\n","reference_code_col":"N = int(eval(input()))\n\nL = list(map(int,input().split()))\n\n\n\nans = 0\n\nfor i in range(N) :\n\n    flag = 0\n\n    while flag == 0 :\n\n        if (L[i] % 2) == 0 :\n\n            ans += 1\n\n            L[i] = L[i]\/\/2\n\n        else :\n\n            flag = 1\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"answer = 0\n\nN = int(input())\n\nA = list(map(int,input().split()))\n\nfor num in A :\n\n    while num % 2 == 0 :\n\n        num = num \/\/ 2\n\n        answer += 1\n\nprint(answer)"}
{"problem_id":"p03034","slow_code_col":"import sys\n\n\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    S = list(map(int, input().split()))\n\n\n\n    ans = 0\n\n    for C in range(1, N\/\/2):\n\n        n = N \/\/ C\n\n        point = 0\n\n        used = set([0])\n\n        for k in range(1, n):\n\n            A = N - 1 - k*C\n\n\n\n            if A in used or k*C in used or A == k*C:\n\n                break\n\n            used.add(A)\n\n            used.add(k*C)\n\n\n\n            point += S[A] + S[k*C]\n\n            ans = max(ans, point)\n\n\n\n    return ans\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((main()))\n","reference_code_col":"import sys\n\n\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    S = list(map(int, input().split()))\n\n\n\n    ans = 0\n\n    # C = A - B\n\n    for C in range(1, N\/\/2):\n\n        n = (N-1) \/\/ C\n\n        point = 0\n\n        for k in range(1, n):\n\n            A = N-1 - k*C\n\n\n\n            # Check A and B are positive integer, and S_i is not used twice.\n\n            #\n\n            # B = A - C and B >= 0, so A must be over C (A > C).\n\n            #\n\n            # If C is aliquot of N-1 (N-1 % C = 0), A is also aliquot of N-1\n\n            # (N-1 % A = 0) because A + kC = N-1. Therefore when A is less than\n\n            # or equal kC, the A's value is already used by kC.\n\n            if A < C or ((N-1) % C == 0 and A <= k*C):\n\n                break\n\n\n\n            point += S[A] + S[k*C]\n\n            ans = max(ans, point)\n\n\n\n    return ans\n\n\n\n\n\nif __name__ == '__main__':\n\n    print((main()))\n","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    input = sys.stdin.readline\n    \n    # Read input values\n    N = int(input())\n    S = list(map(int, input().split()))\n    \n    ans = 0\n    \n    for C in range(1, N \/\/ 2):\n        n = N \/\/ C\n        \n        # Initialize used indices as False\n        used = [False] * N\n        \n        point = 0\n        used[0] = True\n        \n        for k in range(1, n):\n            A = N - 1 - k * C\n            \n            if used[A] or used[k * C] or A == k * C:\n                break\n            \n            used[A] = True\n            used[k * C] = True\n            \n            point += S[A] + S[k * C]\n            ans = max(ans, point)\n    \n    return ans\n\nif __name__ == '__main__':\n    print(main())"}
{"problem_id":"p03038","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N,M=MI()\n\n    A=LI()\n\n    CB=[[0,0]for _ in range(M)]\n\n    A.sort()\n\n    for i in range(M):\n\n        CB[i][1],CB[i][0]=MI()\n\n        \n\n    CB.sort(reverse=True)\n\n    now=0\n\n    \n\n    for i in range(N):\n\n        if CB[now][1]<=0:\n\n            now+=1\n\n        \n\n        if now>=M:\n\n            break    \n\n        \n\n        ch=CB[now][0]\n\n        if A[i]<ch:\n\n            A[i]=ch\n\n            CB[now][1]-=1\n\n        else:\n\n            break\n\n        \n\n    print((sum(A)))\n\n    \n\n\n\nmain()\n","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\ndef I(): return int(eval(input()))\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\n\n\ndef main():\n\n    mod=10**9+7\n\n    N,M=MI()\n\n    A=LI()\n\n    B=[0]*M\n\n    C=[0]*M\n\n    for i in range(M):\n\n        B[i],C[i]=MI()\n\n    \n\n    C,B=list(zip(*sorted(zip(C,B))))\n\n    B=B[::-1]\n\n    C=C[::-1]\n\n    \n\n    import heapq\n\n    heapq.heapify(A)\n\n    \n\n    for i in range(M):\n\n        b=B[i]\n\n        c=C[i]\n\n        for _ in range(b):\n\n            a=heapq.heappop(A)\n\n            if a>=c:\n\n                heapq.heappush(A,a)\n\n                break\n\n            else:\n\n                heapq.heappush(A,c)\n\n                \n\n    ans=0\n\n    for i in range(N):\n\n        a=heapq.heappop(A)\n\n        ans+=a\n\n        \n\n    print(ans)\n\n\n\nmain()\n","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\ndef I():\n    return int(input())\n\n\ndef MI():\n    return map(int, input().split())\n\n\ndef LI():\n    return map(int, input().split())\n\n\ndef main():\n    mod = 10 ** 9 + 7\n    N, M = MI()\n    A = sorted(LI())\n    CB = [MI() for _ in range(M)]\n    CB.sort(reverse=True)\n    \n    for i in range(N):\n        j = bisect.bisect_left(CB, [A[i]+1, float('inf')])\n        if j < M:\n            ch, freq = CB[j]\n            if freq > 0:\n                A[i] = ch\n                CB[j][1] -= 1\n    \n    print(sum(A))\n\n\nmain()"}
{"problem_id":"p03828","slow_code_col":"from math import factorial\n\n\n\nn = int(eval(input()))\n\nf = factorial(n)\n\n\n\nmod = 10 ** 9 + 7\n\n\n\ndef primes(n):\n\n    is_prime = [True] * (n + 1)\n\n    is_prime[0] = False\n\n    is_prime[1] = False\n\n    for i in range(2, int(n ** 0.5) + 1):\n\n        if not is_prime[i]:\n\n            continue\n\n        for j in range(i * 2, n + 1, i):\n\n            is_prime[j] = False\n\n    return [i for i in range(n + 1) if is_prime[i]]\n\n\n\nans = 1\n\nfor p in primes(n):\n\n    temp = 1\n\n    while f % p == 0:\n\n        temp += 1\n\n        f \/\/= p\n\n    ans = (ans * temp) % mod\n\nprint(ans)\n","reference_code_col":"n=int(eval(input()))\n\nm=10**9+7\n\np=[1 for i in range(10000)]\n\np[0]=0\n\np[1]=0\n\nfor i in range(2,n+1):\n\n  if p[i]==1:\n\n    for j in range(i*i,n+1,i):\n\n        p[j]=0\n\nans=1\n\nfor i in range(2,n+1):\n\n  if p[i]:\n\n    c=0\n\n    k=i\n\n    while n\/\/k>0:\n\n      c=c+(n\/\/k)%m\n\n      k=k*i\n\n    ans=(ans*((c+1)%m))%m\n\nprint((ans%m))\n\n    \n\n    \n\n      \n\n      \n","model_generated_potentially_faster_code_col":"from math import factorial\n\nn = int(eval(input()))\nf = factorial(n)\nmod = 10 ** 9 + 7\n\ndef primes(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n + 1, i):\n                is_prime[j] = False\n    return [i for i in range(n + 1) if is_prime[i]]\n\n# Precompute the powers of each prime up to n\nprime_powers = {}\nprimes_list = primes(n)\nfor p in primes_list:\n    power = 0\n    num = n\n    while num >= p:\n        power += num \/\/ p\n        num \/\/= p\n    prime_powers[p] = power\n\n# Calculate the result using the precomputed prime powers\nans = 1\nfor p, power in prime_powers.items():\n    ans = (ans * (power + 1)) % mod\n\nprint(ans)"}
{"problem_id":"p02883","slow_code_col":"import sys\n\ninput = sys.stdin.buffer.readline\n\nimport numpy as np\n\n\n\ndef main():\n\n    N,K = list(map(int,input().split()))\n\n    a = list(map(int,input().split()))\n\n    f = list(map(int,input().split()))\n\n    a.sort()\n\n    f.sort(reverse=True)\n\n\n\n    if sum(a) <= K:\n\n        print((0))\n\n    else:\n\n        a = np.array(a)\n\n        f = np.array(f)\n\n        left,right = 0,max(a)*max(f)\n\n        while right-left > 1:\n\n            mid = (left+right)\/\/2\n\n            pra = a-mid\/\/f\n\n            pra[pra<0] = 0\n\n            if np.sum(pra) > K:\n\n                left = mid\n\n            else:\n\n                right = mid\n\n        print(right)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\ndef main():\n\n    N,K = list(map(int,input().split()))\n\n    a = list(map(int,input().split()))\n\n    f = list(map(int,input().split()))\n\n    \n\n    a.sort()\n\n    f.sort(reverse=True)\n\n    \n\n    l,r = -1,max(a)*max(f)+1\n\n    \n\n    while r-l>1:\n\n        mid = (r+l)\/\/2\n\n        count = 0\n\n        for cost,dif in zip(a,f):\n\n            if mid >= cost*dif:\n\n                continue\n\n            rest = cost*dif-mid\n\n            count += -(-rest\/\/dif)\n\n        if count <= K:\n\n            r = mid\n\n        else:\n\n            l = mid\n\n            \n\n    print(r)\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\ninput = sys.stdin.buffer.readline\n\ndef main():\n    N, K = map(int, input().split())\n    a = sorted(map(int, input().split()))\n    f = sorted(map(int, input().split()), reverse=True)\n    \n    if sum(a) <= K:\n        print(0)\n        return\n    \n    a = np.array(a)\n    f = np.array(f)\n    \n    # Calculate prefix sums of a\n    prefix_sums = np.cumsum(a)\n    \n    left, right = 0, max(a) * max(f)\n    \n    while right - left > 1:\n        mid = (left + right) \/\/ 2\n        pra = a - mid \/\/ f\n        pra[pra < 0] = 0\n        \n        # Use prefix sums to calculate the total cost\n        total_cost = np.searchsorted(prefix_sums, mid, side='right').sum()\n        \n        if total_cost > K:\n            left = mid\n        else:\n            right = mid\n    \n    print(right)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02996","slow_code_col":"import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\nab = [list(li()) for _ in range(n)]\n\n\n\nab.sort(key=lambda x: x[1])\n\n\n\ncur = 0\n\n\n\nans = True\n\n\n\nfor ai, bi in ab:\n\n    cur += ai\n\n    if cur > bi:\n\n        ans = False\n\n\n\nprint((\"Yes\" if ans else \"No\"))","reference_code_col":"import sys\n\nstdin = sys.stdin\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\n\n\ndef li(): return list(map(int, stdin.readline().split()))\n\ndef li_(): return [int(x) - 1 for x in stdin.readline().split()]\n\ndef lf(): return list(map(float, stdin.readline().split()))\n\ndef ls(): return stdin.readline().split()\n\ndef ns(): return stdin.readline().rstrip()\n\ndef lc(): return list(ns())\n\ndef ni(): return int(stdin.readline())\n\ndef nf(): return float(stdin.readline())\n\n\n\nn = ni()\n\nab = [tuple(li()) for _ in range(n)]\n\n\n\nab.sort(key=lambda x: x[1])\n\ncur = 0\n\nok = True\n\n\n\nfor ai, bi in ab:\n\n    cur += ai\n\n    if cur > bi:\n\n        ok = False\n\n        break\n\n\n\nprint((\"Yes\" if ok else \"No\"))\n","model_generated_potentially_faster_code_col":"import heapq\nimport sys\n\n# Set recursion limit high enough to avoid stack overflow errors\nsys.setrecursionlimit(10**7)\n\n# Helper functions for reading input\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef li_():\n    return [int(x) - 1 for x in sys.stdin.readline().split()]\n\ndef lf():\n    return list(map(float, sys.stdin.readline().split()))\n\ndef ls():\n    return sys.stdin.readline().split()\n\ndef ns():\n    return sys.stdin.readline().rstrip()\n\ndef lc():\n    return list(ns())\n\ndef ni():\n    return int(sys.stdin.readline())\n\ndef nf():\n    return float(sys.stdin.readline())\n\n# Read input values\nn = ni()\nab = [li() for _ in range(n)]\n\n# Sort intervals by end time\nab.sort(key=lambda x: x[1])\n\n# Initialize variables\nend_time = 0\nvalid = True\n\n# Process each interval using a min-heap\nfor ai, bi in ab:\n    if ai < end_time:\n        valid = False\n        break\n    end_time = max(end_time, bi)\n\n# Output result\nprint(\"Yes\" if valid else \"No\")"}
{"problem_id":"p03416","slow_code_col":"n, m = list(map(int, input().split()))\n\nans = 0\n\nfor i in range(n, m+1):\n\n    if str(i)[0]+str(i)[1] == str(i)[-1]+str(i)[-2]: ans += 1\n\nprint(ans)","reference_code_col":"a, b = list(map(int, input().split()))\n\nans = 0\n\nfor n in range(a, b+1):\n\n    if str(n) == str(n)[::-1]: ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"n, m = map(int, input().split())\n\nans = 0\n\nfor i in range(n, m+1):\n    # Directly compare the first two and last two digits without converting to string\n    if i \/\/ 100 % 10 == i % 100 \/\/ 10 and i \/\/ 1000 % 10 == i % 1000 \/\/ 10:\n        ans += 1\n\nprint(ans)"}
{"problem_id":"p00001","slow_code_col":"ans=[]\n\nfor i in range (0,10):\n\n    ans.append(int(eval(input())))\n\nans.sort(reverse=True)\n\nfor i in range (0,3):\n\n    print((ans[i]))","reference_code_col":"mountain=[]\n\nfor s in range(0,10):\n\n    mountain.append(int(eval(input())))\n\nmountain.sort(reverse=True)\n\nfor s in range(0,3):\n\n print((mountain[s]))","model_generated_potentially_faster_code_col":"# Using list comprehension to optimize the performance\nans = [int(input()) for _ in range(10)]\n\n# Sorting only the first three elements\nfor i in range(min(3, len(ans))):\n    for j in range(i+1, min(4, len(ans))):\n        if ans[i] < ans[j]:\n            ans[i], ans[j] = ans[j], ans[i]\n\n# Printing the top three numbers\nfor i in range(min(3, len(ans))):\n    print(ans[i])"}
{"problem_id":"p02555","slow_code_col":"# -*- coding: utf-8 -*-\n\nimport sys\n\n\n\n\n\ndef main():\n\n    S = int( sys.stdin.readline() )\n\n\n\n    dp = [0]*(S+1)\n\n    dp[0] = 1\n\n    mod = 10**9 + 7\n\n\n\n    for i in range(3, S+1):\n\n        cnt = 0\n\n\n\n        for j in range(3, i+1):\n\n            cnt += dp[i-j]\n\n            cnt %= mod\n\n        \n\n        dp[i] = cnt\n\n\n\n\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"# -*- coding: utf-8 -*-\n\nimport sys\n\n\n\n\n\ndef main():\n\n    S = int( sys.stdin.readline() )\n\n\n\n    dp = [0]*(S+1)\n\n    dp[0] = 1\n\n    mod = 10**9 + 7\n\n\n\n    for i in range(3, S+1):\n\n        dp[i] = dp[i-3] + dp[i-1]\n\n        dp[i] %= mod\n\n    \n\n\n\n    print((dp[-1]))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nimport sys\n\n\ndef main():\n    S = int(sys.stdin.readline())\n\n    dp = [0] * (S + 1)\n    dp[0] = 1\n    mod = 10**9 + 7\n\n    for i in range(3, S + 1):\n        cnt = 0\n\n        for j in range(3, i \/\/ 2 + 1):  # Optimized iteration range\n            cnt += dp[i - j]\n            cnt %= mod\n\n        dp[i] = cnt\n\n    print(dp[-1])\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03363","slow_code_col":"from collections import Counter\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.array(input().split(), dtype = np.int64)\n\n\n\nc = Counter(A.cumsum())\n\nc[0] += 1\n\nanswer = sum(x*(x-1)\/\/2 for x in list(c.values()))\n\nprint(answer)","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\nfrom collections import defaultdict\n\n\n\nN,*A = list(map(int,read().split()))\n\n\n\nAcum = [0] + list(itertools.accumulate(A))\n\n\n\ncounter = defaultdict(int)\n\nanswer = 0\n\nfor x in Acum:\n\n    answer += counter[x]\n\n    counter[x] += 1\n\n\n\nprint(answer)","model_generated_potentially_faster_code_col":"from collections import Counter\n\nimport numpy as np\n\nN = int(eval(input()))\nA = np.array(input().split(), dtype=np.int64)\n\n# Initialize counter for cumulative sum parities\nparity_counter = Counter()\n\n# Initialize current cumulative sum and answer\ncurrent_sum = 0\nanswer = 0\n\n# Iterate through the array\nfor num in A:\n    # Update the current cumulative sum\n    current_sum += num\n    \n    # Add the count of the opposite parity to the answer\n    answer += parity_counter[current_sum % 2]\n    \n    # Increment the count of the current parity\n    parity_counter[current_sum % 2] += 1\n\nprint(answer)"}
{"problem_id":"p02731","slow_code_col":"import numpy as np\n\nL = np.array(int(eval(input())), dtype='float128')\n\nans = (L \/ 3)**3\n\nprint(ans)\n","reference_code_col":"import numpy as np\n\nL = int(eval(input()))\n\nans = (L \/ 3)**3\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Get user input as a list of numbers\nnumbers = [float(num) for num in input(\"Enter numbers separated by spaces: \").split()]\n\n# Convert the list to a NumPy array\nL = np.array(numbers, dtype='float128')\n\n# Perform the operation\nans = (L \/ 3)**3\n\nprint(ans)"}
{"problem_id":"p02785","slow_code_col":"def solve():\n\n  N, K = list(map(int, input().split()))\n\n  H = list(map(int, input().split()))\n\n  if K>=N:\n\n    return 0\n\n  H.sort()\n\n  ans = sum(H[:N-K])\n\n  return ans\n\nprint((solve()))","reference_code_col":"def solve():\n\n  N, K = list(map(int, input().split()))\n\n  H = list(map(int, input().split()))\n\n  H.sort()\n\n  ans = sum(H[:max(N-K,0)])\n\n  return ans\n\nprint((solve()))","model_generated_potentially_faster_code_col":"import heapq\n\ndef solve():\n    N, K = map(int, input().split())\n    \n    # Create a min-heap with the first N elements\n    heap = list(map(int, input().split()[:N]))\n    heapq.heapify(heap)\n    \n    # Remove the largest element from the heap K times\n    for _ in range(K):\n        heapq.heappop(heap)\n    \n    # Return the sum of the remaining elements in the heap\n    return sum(heap)\n\nprint(solve())"}
{"problem_id":"p03835","slow_code_col":"k, s = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor x in range(k+1):\n\n  for y in range(k+1):\n\n    if 0<=s-x-y<=k:\n\n      ans += 1\n\n      \n\nprint(ans)","reference_code_col":"k,s=list(map(int,input().split()))\n\nans=0\n\nfor i in range(k+1):\n\n  num=s-i\n\n  for j in range(min(num+1,k+1)):\n\n    if 0<=num-j<=k:\n\n      ans+=1\n\nprint(ans)","model_generated_potentially_faster_code_col":"def count_combinations(k, s):\n    # Ensure s is within the valid range\n    if s < 0 or s > 3 * k:\n        return 0\n    \n    # Calculate the number of combinations using the formula\n    # The formula is based on the stars and bars method with constraints\n    # It counts the number of non-negative integer solutions to x + y <= k and x + z <= k - y\n    return (k + 1) * (k + 2) \/\/ 2 - max(0, s - k) * (max(0, s - k) + 1) \/\/ 2\n\n# Input values\nk, s = map(int, input().split())\n\n# Output the result\nprint(count_combinations(k, s))"}
{"problem_id":"p03680","slow_code_col":"import sys\n\n\n\nN = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\nl = 1\n\np = a[0] - 1\n\n\n\nif a[0] == 2:\n\n    print(l)\n\n    sys.exit()\n\n\n\nwhile l < int(1e6):\n\n    l += 1\n\n    if a[p] == 2:\n\n        print(l)\n\n        break\n\n    else:\n\n        p = a[p] - 1\n\nelse:\n\n    print((-1))","reference_code_col":"import sys\n\n\n\nN = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\nl = 1\n\np = a[0] - 1\n\n\n\nif a[0] == 2:\n\n    print(l)\n\n    sys.exit()\n\n\n\nwhile l < int(2e5):\n\n    l += 1\n\n    if a[p] == 2:\n\n        print(l)\n\n        break\n\n    else:\n\n        p = a[p] - 1\n\nelse:\n\n    print((-1))","model_generated_potentially_faster_code_col":"import sys\n\n\nN = int(input())\n\na = [int(input()) for _ in range(N)]\n\n\nvisited_indices = set()\np = a[0] - 1\n\nif a[0] == 2:\n    print(1)\n    sys.exit()\n\n\ncounter = 1\nwhile counter < int(1e6):\n    if p in visited_indices:\n        print(-1)\n        sys.exit()\n\n    visited_indices.add(p)\n    if a[p] == 2:\n        print(counter + 1)\n        break\n\n    p = a[p] - 1\n    counter += 1"}
{"problem_id":"p03752","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\ninput = sys.stdin.buffer.readline\n\n\n\n\n\ndef RD(): return sys.stdin.read()\n\ndef II(): return int(eval(input()))\n\ndef MI(): return list(map(int,input().split()))\n\ndef LI(): return list(map(int,input().split()))\n\ndef TI(): return tuple(map(int,input().split()))\n\n\n\n# mod=10**9+7\n\n# rstrip().decode('utf-8')\n\n\n\nimport numpy as np\n\nfrom itertools import combinations\n\n\n\ndef main():\n\n\tn,k=MI()\n\n\tans=10**18\n\n\n\n\tA=LI()\n\n\tA=[A[0]-1]+A\n\n\tA=np.array(A)\n\n\n\n\tfor t in combinations(list(range(n)),k):\n\n\t\tB=A.copy()\n\n\t\ttmp=0\n\n\t\tfor i in t:\n\n\t\t\ti+=1\n\n\t\t\tB[i]=max(B[:i].max()+1,A[i])\n\n\t\t\ttmp+=B[i]-A[i]\n\n\t\tans=min(ans,tmp)\n\n\tprint(ans)\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()\n","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\ninput = sys.stdin.buffer.readline\n\n\n\n\n\ndef RD(): return sys.stdin.read()\n\ndef II(): return int(eval(input()))\n\ndef MI(): return list(map(int,input().split()))\n\ndef LI(): return list(map(int,input().split()))\n\ndef TI(): return tuple(map(int,input().split()))\n\n\n\n# mod=10**9+7\n\n# rstrip().decode('utf-8')\n\n\n\n#import numpy as np\n\nfrom itertools import combinations\n\n\n\ndef main():\n\n\tn,k=MI()\n\n\tans=10**18\n\n\n\n\tA=LI()\n\n\tA=[A[0]-1]+A\n\n\n\n\tfor t in combinations(list(range(n)),k):\n\n\t\tB=A.copy()\n\n\t\ttmp=0\n\n\t\tfor i in t:\n\n\t\t\ti+=1\n\n\t\t\tB[i]=max(max(B[:i])+1,A[i])\n\n\t\t\ttmp+=B[i]-A[i]\n\n\t\tans=min(ans,tmp)\n\n\tprint(ans)\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()\n","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.buffer.readline\n\n\ndef RD(): return sys.stdin.read()\n\ndef II(): return int(input())\n\ndef MI(): return list(map(int, input().split()))\n\ndef LI(): return list(map(int, input().split()))\n\ndef TI(): return tuple(map(int, input().split()))\n\n\ndef main():\n    n, k = MI()\n    A = LI()\n\n    # Sort the array to find the median easily\n    A.sort()\n\n    # The optimal strategy is to make all elements equal to the median\n    target = A[k - 1] if k % 2 != 0 else (A[k - 1] + A[k]) \/\/ 2\n\n    ans = sum(abs(x - target) for x in A)\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03434","slow_code_col":"import numpy as np\n\n\n\nn = int(eval(input()))\n\na_list = list(map(int, input().split()))\n\n\n\nalice_point = 0\n\nbob_point = 0\n\nfor i in range(n):\n\n    argmax_a = np.argmax(a_list)\n\n    max_a = np.max(a_list)\n\n    if i % 2 == 0: # If Alice takes a card\n\n        alice_point += max_a\n\n    else: # If Bob takes a card\n\n        bob_point += max_a\n\n    del a_list[argmax_a] # No confidence -> Review how to delete list element!\n\n\n\nprint((alice_point - bob_point))","reference_code_col":"n = int(eval(input()))\n\na_list = list(map(int, input().split()))\n\na_list = sorted(a_list, reverse=True)\n\n\n\nalice_point = 0\n\nbob_point = 0\n\nfor i in range(n):\n\n    if i % 2 == 0:\n\n        alice_point += a_list[i]\n\n    else:\n\n        bob_point += a_list[i]\n\n\n\nprint((alice_point - bob_point))","model_generated_potentially_faster_code_col":"import numpy as np\n\nn = int(eval(input()))\na_array = np.array(list(map(int, input().split())))\n\nalice_points = 0\nbob_points = 0\n\n# Sort the array in descending order\nsorted_indices = np.argsort(a_array)[::-1]\n\nfor i in range(n):\n    if i % 2 == 0:  # If Alice takes a card\n        alice_points += a_array[sorted_indices[i]]\n    else:  # If Bob takes a card\n        bob_points += a_array[sorted_indices[i]]\n\nprint(alice_points - bob_points)"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    power = math.factorial(N)\n\n    print((power % (10 ** 9 + 7)))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"def main():\n\n    N = int(eval(input()))\n\n    power = 1\n\n    for i in range(1, N + 1):\n\n        power *= i\n\n        power %= 10 ** 9 + 7\n\n    print(power)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\ndef factorial(n):\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n    return fact[n]\n\ndef main():\n    N = int(eval(input()))\n    print(factorial(N))\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03078","slow_code_col":"def main():\n\n\tx, y, z, k = list(map(int, input().split()))\n\n\ta = list(map(int, input().split()))\n\n\tb = list(map(int, input().split()))\n\n\tc = list(map(int, input().split()))\n\n\td = [0]*x*y\n\n\tfor i in range(x):\n\n\t\tfor j in range(y):\n\n\t\t\td[i*y+j] = a[i]+b[j]\n\n\td.sort(reverse=True)\n\n\tc.sort(reverse=True)\n\n\n\n\tc_len = min(k, z)\n\n\td_len = min(k, x*y)\n\n\te = [0]*d_len*c_len\n\n\tfor i in range(d_len):\n\n\t\tfor j in range(c_len):\n\n\t\t\te[i*c_len+j] = d[i] + c[j]\n\n\te.sort(reverse=True)\n\n\tfor i in range(k):\n\n\t\tprint((e[i]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()","reference_code_col":"def main():\n\n\tx, y, z, k = list(map(int, input().split()))\n\n\ta = list(map(int, input().split()))\n\n\tb = list(map(int, input().split()))\n\n\tc = list(map(int, input().split()))\n\n\n\n\tsolve(a, b, c, x, y, z, k)\n\n\n\ndef solve(a, b, c, x, y, z, k):\n\n\ta.sort(reverse=True)\n\n\tb.sort(reverse=True)\n\n\tc.sort(reverse=True)\n\n\tstack = list()\n\n\tfor p in range(x):\n\n\t\tfor q in range(y):\n\n\t\t\tif (p+1)*(q+1) > k:\n\n\t\t\t\tbreak\n\n\t\t\tfor r in range(z):\n\n\t\t\t\tif (p+1)*(q+1)*(r+1) > k:\n\n\t\t\t\t\tbreak\n\n\t\t\t\tstack.append(a[p]+b[q]+c[r])\n\n\tstack.sort(reverse=True)\n\n\tfor i in range(k):\n\n\t\tprint((stack[i]))\n\n\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"def main():\n    x, y, z, k = map(int, input().split())\n\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = sorted(list(map(int, input().split())), reverse=True)[:z]\n\n    d = sorted([a[i] + b[j] for i in range(x) for j in range(y)], reverse=True)[:x * y]\n\n    e = sorted([d[i] + c[j] for i in range(min(k, x * y)) for j in range(min(k, z))], reverse=True)[:k]\n\n    for num in e:\n        print(num)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p00713","slow_code_col":"from math import sqrt\n\nfrom bisect import bisect_left\n\ndef circle_center(x1, y1, x2, y2):\n\n    xd = x2 - x1; yd = y2 - y1\n\n    d = xd**2 + yd**2\n\n    k = sqrt((4.0 - d) \/ d) \/ 2.0\n\n    xc = (x1 + x2) \/ 2.0\n\n    yc = (y1 + y2) \/ 2.0\n\n    return [[xc - k*yd, yc + k*xd], [xc + k*yd, yc - k*xd]]\n\nwhile 1:\n\n    n = int(input())\n\n    if n==0: break\n\n    p = [list(map(float, input().split())) for i in range(n)]\n\n    p.sort()\n\n    prev = 0\n\n    ans = 1\n\n    for i in range(n):\n\n        bx, by = p[i]\n\n        while bx - p[prev][0] >= 2.0: prev += 1\n\n        for j in range(i+1, n):\n\n            cx, cy = p[j]\n\n            if cx - bx >= 2.0: break\n\n            if (bx - cx)**2 + (by - cy)**2 <= 4.0:\n\n                for ex, ey in circle_center(bx, by, cx, cy):\n\n                    count = 2\n\n                    for k in range(prev, n):\n\n                        if k==i or k==j: continue\n\n                        dx, dy = p[k]\n\n                        if dx - bx >= 2.0: break\n\n                        if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n\n                            count += 1\n\n                    ans = max(ans, count)\n\n    print(ans)","reference_code_col":"from math import sqrt\n\nfrom bisect import bisect_left\n\ndef circle_center(x1, y1, x2, y2):\n\n    xd = x2 - x1; yd = y2 - y1\n\n    d = xd**2 + yd**2\n\n    k = sqrt((4.0 - d) \/ d) \/ 2.0\n\n    xc = (x1 + x2) \/ 2.0; yc = (y1 + y2) \/ 2.0\n\n    xd *= k; yd *= k\n\n    return [[xc - yd, yc + xd], [xc + yd, yc - xd]]\n\nwhile 1:\n\n    n = int(input())\n\n    if n==0: break\n\n    p = sorted(list(map(float, input().split())) for i in range(n))\n\n    prev = 0\n\n    ans = 1\n\n    for i in range(n):\n\n        bx, by = p[i]\n\n        while bx - p[prev][0] >= 2.0: prev += 1\n\n        for j in range(i+1, n):\n\n            cx, cy = p[j]\n\n            if cx - bx >= 2.0: break\n\n            if (bx - cx)**2 + (by - cy)**2 <= 4.0:\n\n                for ex, ey in circle_center(bx, by, cx, cy):\n\n                    count = 2\n\n                    for k in range(prev, n):\n\n                        if k==i or k==j: continue\n\n                        dx, dy = p[k]\n\n                        if dx - ex >= 1.0: break\n\n                        if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n\n                            count += 1\n\n                    ans = max(ans, count)\n\n    print(ans)","model_generated_potentially_faster_code_col":"import math\nfrom bisect import bisect_left\n\ndef circle_center(x1, y1, x2, y2):\n    xd = x2 - x1; yd = y2 - y1\n    d = xd**2 + yd**2\n    k = math.sqrt((4.0 - d) \/ d) \/ 2.0\n    xc = (x1 + x2) \/ 2.0\n    yc = (y1 + y2) \/ 2.0\n    return [(xc - k*yd, yc + k*xd), (xc + k*yd, yc - k*xd)]\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        # Read points and sort them\n        points = sorted([tuple(map(float, input().split())) for _ in range(n)])\n        \n        ans = 1\n        \n        for i in range(n):\n            bx, by = points[i]\n            \n            # Find the first point outside the current circle\n            prev = bisect_left(points, (bx + 2.0, float('-inf')))\n            \n            for j in range(i + 1, n):\n                cx, cy = points[j]\n                \n                # Break if the distance between points is too large\n                if cx - bx >= 2.0:\n                    break\n                \n                # Check if points lie within the circle formed by (bx, by) and (cx, cy)\n                if (bx - cx)**2 + (by - cy)**2 <= 4.0:\n                    \n                    # Find points within the circle centered at (bx, by) with radius 1\n                    count = 2\n                    end = min(j, bisect_left(points, (bx + 2.0, float('-inf'))))\n                    for k in range(prev, end):\n                        dx, dy = points[k]\n                        \n                        # Break if the distance between points is too large\n                        if dx - bx >= 2.0:\n                            break\n                        \n                        # Check if points lie within the circle centered at (ex, ey) with radius 1\n                        for ex, ey in circle_center(bx, by, cx, cy):\n                            if (ex - dx)**2 + (ey - dy)**2 <= 1.0:\n                                count += 1\n                    \n                    ans = max(ans, count)\n        \n        print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03371","slow_code_col":"import sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef resolve():\n\n    import math\n\n    a,b,c,x,y=list(map(int, input().split()))\n\n    cmax=max(x,y)*2\n\n    l=[]\n\n    for i in range(cmax+1):\n\n        amai = max(math.ceil(x - 0.5 * i),0)\n\n        bmai = max(math.ceil(y - 0.5 * i),0)\n\n        l.append(amai*a+bmai*b+i*c)\n\n    print((min(l)))\n\nresolve()","reference_code_col":"import sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef resolve():\n\n    import math\n\n    a,b,c,x,y=list(map(int, input().split()))\n\n    # AB\u30d4\u30b6\u3092\u5947\u6570\u679a\u8cb7\u3063\u3066\u30821\u679a\u7121\u99c4\u306b\u306a\u308b\u304b\u3089\u3001AB\u30d4\u30b6\u306f2\u679a\u30921\u679a\u3060\u3068\u8003\u3048\u308b\n\n    # c\u306e\u5024\u6bb5\u30922\u500d\u306b\u3057\u3066\u679a\u6570\u3092\u534a\u5206\u306b\n\n    cmax=max(x,y) # AB\u30d4\u30b6\u306e\u6700\u5927\u679a\u6570(2\u679a\u30921\u679a\u3068\u8003\u3048\u305f\u3068\u304d)\n\n    c=2*c\n\n    l=[]\n\n    for i in range(cmax+1):\n\n        amai = max(x - i,0)\n\n        bmai = max(y - i,0)\n\n        l.append(amai*a+bmai*b+i*c)\n\n    print((min(l)))\n\nresolve()","model_generated_potentially_faster_code_col":"import sys\nimport math\n\ndef input(): return sys.stdin.readline().strip()\n\ndef resolve():\n    a, b, c, x, y = map(int, input().split())\n\n    cmax = max(x, y) * 2\n\n    min_cost = float('inf')\n\n    for i in range(cmax + 1):\n        amai = max(math.ceil(x - 0.5 * i), 0)\n        bmai = max(math.ceil(y - 0.5 * i), 0)\n        cost = amai * a + bmai * b + i * c\n        if cost < min_cost:\n            min_cost = cost\n\n    print(min_cost)\n\nresolve()"}
{"problem_id":"p03796","slow_code_col":"import math\n\nN = int(eval(input()))\n\nans = math.factorial(N) % (10 ** 9 + 7)\n\nprint(ans)","reference_code_col":"n = int(eval(input()))\n\nfrom functools import reduce\n\nprint((reduce(lambda x,y:x*y%1000000007,list(range(1,n+1)))))","model_generated_potentially_faster_code_col":"def factorial(n):\n    result = 1\n    for i in range(2, n+1):\n        result *= i\n    return result\n\nN = int(eval(input()))\nans = factorial(N) % (10 ** 9 + 7)\nprint(ans)"}
{"problem_id":"p03371","slow_code_col":"#python3\n\nINF = int(1e9)\n\ndef main():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    ans = INF\n\n    for i in range(2*10**5+100):\n\n        t = 2*c*i + max(x-i, 0) * a + max(y-i, 0) * b\n\n        ans = min(ans, t)\n\n    print(ans)\n\nmain()","reference_code_col":"INF = int(1e5)+5\n\n\n\ndef main():\n\n    a, b, c, x, y = list(map(int, input().split()))\n\n    ans = INF*INF\n\n    for i in range(INF):\n\n        tmp = 2*i*c + a*max(x-i, 0) + b*max(y-i, 0) \n\n        ans = min(tmp, ans)\n\n    print(ans)\n\nmain()\n","model_generated_potentially_faster_code_col":"INF = int(1e9)\n\ndef main():\n    a, b, c, x, y = map(int, input().split())\n\n    ans = INF\n\n    for i in range(min(x, y) + 1):\n        t = 2 * c * i + max(x - i, 0) * a + max(y - i, 0) * b\n        ans = min(ans, t)\n\n    print(ans)\n\nmain()"}
{"problem_id":"p03828","slow_code_col":"from functools import reduce\n\nN = int(eval(input()))\n\n\n\nprime_table = [1] * (N+1)\n\n\n\nfor x in range(2, N+1):\n\n    for t in range(2, x+1):\n\n        while x % t == 0:\n\n            prime_table[t] += 1\n\n            x \/\/= t\n\nprint((reduce(lambda x, y: x * y % (int(1e9) + 7), prime_table)))","reference_code_col":"def prime_factorize(n):\n\n    while n % 2 == 0:\n\n        a[2] += 1\n\n        n \/\/= 2\n\n    f = 3\n\n    while f * f <= n:\n\n        if n % f == 0:\n\n            a[f] += 1\n\n            n \/\/= f\n\n        else:\n\n            f += 2\n\n    if n != 1:\n\n        a[n] += 1\n\n\n\nN = int(eval(input()))\n\na = [0]*(N+1)\n\nfor i in range(2, N+1):\n\n    prime_factorize(i)\n\nans = 1\n\nfor i in a:\n\n    if i > 0:\n\n        ans *= (i+1)\n\nbig = 10**9 + 7\n\nprint((ans % big))","model_generated_potentially_faster_code_col":"from functools import reduce\n\nN = int(eval(input()))\n\nprime_table = [0] * (N + 1)\n\n# Sieve of Eratosthenes\nprimes = []\nis_prime = [True] * (N + 1)\nis_prime[0] = is_prime[1] = False\n\nfor i in range(2, N + 1):\n    if is_prime[i]:\n        primes.append(i)\n        for j in range(i * i, N + 1, i):\n            is_prime[j] = False\n\n# Count prime factors\nfor p in primes:\n    count = 0\n    x = N\n    while x % p == 0:\n        count += 1\n        x \/\/= p\n    prime_table[p] = count\n\n# Calculate product of prime factors modulo 10^9 + 7\nresult = reduce(lambda x, y: x * y % (int(1e9) + 7), prime_table)\n\nprint(result)"}
{"problem_id":"p03457","slow_code_col":"import numpy as np\n\nn = int(eval(input()))\n\nT = []\n\nX = []\n\nY = []\n\nt1 = 0\n\nx1 = 0\n\ny1 = 0\n\nfor i in range(n):\n\n    m = input().split()\n\n    T.append(int(m[0]) - t1)\n\n    t1 = int(m[0])\n\n    X.append(abs(int(m[1]) - x1))\n\n    x1 = int(m[1])\n\n    Y.append(abs(int(m[2]) - y1))\n\n    y1 = int(m[2])\n\nT = np.array(T)\n\nX = np.array(X)\n\nY = np.array(Y)\n\nfor i in range(n):\n\n    if X[i] + Y[i] > T[i] or (X[i] + Y[i] + T[i]) % 2 == 1:\n\n        print('No')\n\n        break\n\nelse:\n\n    print('Yes')","reference_code_col":"n = int(eval(input()))\n\nt1 = 0\n\nx1 = 0\n\ny1 = 0\n\nboolean = True\n\n\n\nfor __ in range(n):\n\n    t, x, y = [int(_) for _ in input().split()]\n\n    if boolean:\n\n        temp1 = x\n\n        temp2 = t\n\n        x = abs(x - x1) + abs(y - y1)\n\n        t -= t1\n\n        x1 = temp1\n\n        y1 = y\n\n        t1 = temp2\n\n        if x > t or (x + t) % 2 == 1:\n\n            boolean = False\n\nif boolean:\n\n    print('Yes')\n\nelse:\n\n    print('No')","model_generated_potentially_faster_code_col":"import numpy as np\n\nn = int(eval(input()))\n\n# Initialize variables to store previous values\nprev_time = 0\nprev_x = 0\nprev_y = 0\n\n# Initialize lists to store differences\ntime_diffs = []\nx_diffs = []\ny_diffs = []\n\n# Read input and calculate differences\nfor _ in range(n):\n    current_time, current_x, current_y = map(int, input().split())\n    \n    # Calculate time difference from the previous point\n    time_diff = current_time - prev_time\n    \n    # Calculate absolute differences in x and y coordinates\n    x_diff = abs(current_x - prev_x)\n    y_diff = abs(current_y - prev_y)\n    \n    # Append differences to respective lists\n    time_diffs.append(time_diff)\n    x_diffs.append(x_diff)\n    y_diffs.append(y_diff)\n    \n    # Update previous values for next iteration\n    prev_time = current_time\n    prev_x = current_x\n    prev_y = current_y\n\n# Convert lists to NumPy arrays for efficient computation\ntime_diffs = np.array(time_diffs)\nx_diffs = np.array(x_diffs)\ny_diffs = np.array(y_diffs)\n\n# Check conditions for each point\nif np.any((x_diffs + y_diffs > time_diffs) | ((x_diffs + y_diffs + time_diffs) % 2 != 0)):\n    print('No')\nelse:\n    print('Yes')"}
{"problem_id":"p03835","slow_code_col":"K,S = list(map(int,input().split(\" \")))\n\nans = 0\n\nfor i in range(K+1):\n\n\tfor j in range(K+1):\n\n\t\tif (S - i - j) <= K and (S-i-j) >= 0:\n\n\t\t\tans += 1\n\n\n\nprint(ans)\n","reference_code_col":"K, S = list(map(int,input().split(\" \")))\n\nans = 0\n\nfor X in range(K+1):\n\n    for Y in range(K+1):\n\n        if 0 <= (S - X - Y) <= K:\n\n            ans += 1\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"K, S = map(int, input().split())\n\nans = 0\n\n# Iterate over all possible values of i\nfor i in range(min(K, S) + 1):\n    # Calculate the remaining value for j\n    j = S - i\n    # Check if j is within the valid range\n    if 0 <= j <= K:\n        ans += 1\n\nprint(ans)"}
{"problem_id":"p02412","slow_code_col":"while 1:\n\n    ans=0\n\n    n,x=list(map(int,input().split()))\n\n    if n:\n\n        for i in range(1,n-1):\n\n            for j in range(i+1,n):\n\n                for k in range(j+1,n+1):\n\n                    if i+j+k==x:ans+=1\n\n    else:break\n\n    print(ans)","reference_code_col":"while 1:\n\n    a=0\n\n    n,x=list(map(int,input().split()))\n\n    if n==0:break\n\n    for i in range(1,n-1):\n\n        for j in range(i+1,n):\n\n            c=x-i-j\n\n            if c>j and c<=n:a+=1\n\n    print(a)","model_generated_potentially_faster_code_col":"def count_triplets_with_sum(n, x):\n    nums = list(map(int, input().split()))\n    \n    # Sort the numbers to enable binary search\n    nums.sort()\n    \n    ans = 0\n    \n    for i in range(n - 2):\n        left, right = i + 1, n - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == x:\n                ans += 1\n                \n                # Move both pointers inward to find all pairs with the same sum\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n            \n            elif current_sum < x:\n                left += 1\n            else:\n                right -= 1\n    \n    return ans\n\nwhile True:\n    n, x = map(int, input().split())\n    \n    if n == 0:\n        break\n    \n    print(count_triplets_with_sum(n, x))"}
{"problem_id":"p02767","slow_code_col":"def main():\n\n  from statistics import mean\n\n  from math import floor,ceil\n\n\n\n  n = int(eval(input()))\n\n  x = list(map(int, input().split()))\n\n  x_mean = mean(x) \n\n  if x_mean == 0.5:\n\n      greater_than_x = len([i for i in x if i > x_mean])\n\n      if greater_than_x * 2 >= n:\n\n          x_mean = ceil(x_mean)\n\n      else:\n\n          x_mean = floor(x_mean)\n\n  elif x_mean % 1 > 0.5:\n\n      x_mean = ceil(x_mean)\n\n  else:\n\n      x_mean = floor(x_mean)\n\n  x2 = [(num - x_mean)**2 for num in x]\n\n  print((sum(x2)))\n\n\n\nmain()","reference_code_col":"import sys\n\nread = sys.stdin.read\n\ndef main():\n\n    n, *x = list(map(int, read().split()))\n\n    r = float('inf')\n\n    for i1 in range(1, 101):\n\n        rt = 0\n\n        for xe in x:\n\n            rt += (xe - i1)**2\n\n        r = min(r, rt)\n\n    print(r)\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    n = int(input())\n    x = list(map(int, input().split()))\n    \n    # Calculate sum of elements and count positive numbers\n    total_sum = sum(x)\n    positive_count = sum(1 for num in x if num > 0)\n    \n    # Calculate mean and round it to nearest integer\n    x_mean = round(total_sum \/ n)\n    \n    # Adjust mean based on conditions\n    if (x_mean == 0.5 or x_mean == -0.5):\n        if positive_count * 2 >= n:\n            x_mean = ceil(x_mean)\n        else:\n            x_mean = floor(x_mean)\n    elif x_mean % 1 > 0.5:\n        x_mean = ceil(x_mean)\n    else:\n        x_mean = floor(x_mean)\n    \n    # Calculate sum of squared differences\n    x2 = [(num - x_mean)**2 for num in x]\n    \n    print(sum(x2))\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\n\n\neval(input())\n\nA = np.array(list(map(int, input().split())))\n\n\n\nans = 0\n\nwhile(all(A%2==0)):\n\n    A = A\/2\n\n    ans += 1\n\n\n\nprint(ans)\n","reference_code_col":"eval(input())\n\nA = list(map(int, input().split()))\n\n\n\nans = 0\n\nwhile all(a%2==0 for a in A):\n\n    A=[a\/2 for a in A]\n\n    ans += 1\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\neval(input())\n\nA = np.array(list(map(int, input().split())))\n\nans = 0\n\nwhile((A & 1).all() == False):\n\n    A = A >> 1\n\n    ans += 1\n\nprint(ans)"}
{"problem_id":"p02691","slow_code_col":"n = int(eval(input()))\n\na = list(map(int, input().split()))\n\na_index = []\n\nfor i in range(n):\n\n    a_index.append((i, a[i]))\n\ndic1 = {}\n\ndic2 = {}\n\nfor i in range(n):\n\n    one = a_index[i][0] + a_index[i][1]\n\n    two = a_index[i][0] - a_index[i][1]\n\n    if one not in dic1:\n\n        dic1[one] = 1\n\n    else:\n\n        dic1[one] += 1\n\n    if two not in dic2:\n\n        dic2[two] = 1\n\n    else:\n\n        dic2[two] += 1\n\nans = 0\n\nfor i in list(dic1.keys()):\n\n    if i in dic2:\n\n        ans += dic2[i] * dic1[i]\n\nfor i in list(dic2.keys()):\n\n    if i in dic1:\n\n        ans += dic1[i] * dic2[i]\n\n        #print(i)\n\nprint((ans \/\/ 2))\n","reference_code_col":"n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nimport collections\n\nans = 0\n\ndic = collections.defaultdict(int)\n\nfor i in range(1, n + 1):\n\n    ans += dic[i - a[i - 1]]\n\n    dic[i + a[i - 1]] += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"n = int(input())\na = list(map(int, input().split()))\n\n# Create a dictionary to store the sum and difference counts\nsum_diff_counts = {}\n\n# Iterate through the array to populate the dictionary\nfor i in range(n):\n    one = i + a[i]\n    two = i - a[i]\n    for key in (one, two):\n        if key in sum_diff_counts:\n            sum_diff_counts[key] += 1\n        else:\n            sum_diff_counts[key] = 1\n\n# Calculate the number of valid pairs\nans = 0\nfor count in sum_diff_counts.values():\n    ans += count * (count - 1) \/\/ 2\n\nprint(ans)"}
{"problem_id":"p03835","slow_code_col":"k,s=list(map(int,input().split()))\n\nans=chk=0\n\nfor i in range(k+1):\n\n    for j in range(k+1):\n\n        if (0<=s-i-j<=k): ans+=1\n\nprint(ans)","reference_code_col":"k,s=list(map(int,input().split()))\n\nans=0\n\nx=min(k+1,s+1)\n\ny=max(0,s-k-k)\n\nfor i in range(y,x):\n\n    for j in range(y,x):\n\n        if i+j>s: break\n\n        if 0<=s-i-j<=k:\n\n            ans+=1\n\nprint(ans)","model_generated_potentially_faster_code_col":"k, s = map(int, input().split())\n\n# Ensure that s is within the valid range [0, 3*k]\nif s < 0 or s > 3 * k:\n    print(0)\nelse:\n    # Calculate the number of valid combinations using combinatorial mathematics\n    ans = 0\n    for i in range(max(0, s - 2 * k), min(s + 1, k + 1)):\n        ans += max(0, min(s - i, k) - i + 1)\n\n    print(ans)"}
{"problem_id":"p03564","slow_code_col":"N,K = int(eval(input())), int(eval(input()))\n\nnow = 1\n\nfor i in range(N):\n\n    if now*2 < now + K:\n\n        now *= 2\n\n    else:\n\n        now += K\n\nprint(now)\n","reference_code_col":"N = int(eval(input()))\n\nK = int(eval(input()))\n\nans = 1\n\nfor i in range(N):\n\n    if ans < K:\n\n        ans *= 2\n\n    else:\n\n        ans += K\n\nprint(ans)","model_generated_potentially_faster_code_col":"N, K = map(int, input().split())\n\nnow = 1\n\nfor _ in range(N):\n    if now * 2 < now + K:\n        now *= 2\n    else:\n        now += K\n\nprint(now)"}
{"problem_id":"p02850","slow_code_col":"#d3\u3068\u540c\u4e00\u89e3\u6cd5\n\nn=int(eval(input()))\n\nimport sys\n\n#\u518d\u5e30\u95a2\u6570\u306e\u518d\u5e30\u56de\u6570\u3092\u5909\u66f4\n\nsys.setrecursionlimit(10**6)\n\ns=[[] for _ in range(n)]\n\n\n\nfor i in range(n-1):\n\n    a,b=list(map(int,input().split()))\n\n    s[a-1].append((b-1,i))\n\n    s[b-1].append((a-1,i))\n\n\n\nl=[0]*(n-1)\n\n\n\ndef dfs(node,pre_col,par):\n\n    col=1\n\n    for nei,i in s[node]:\n\n        if nei==par:\n\n            continue\n\n        if col==pre_col:\n\n            col+=1\n\n        l[i]=col\n\n        dfs(nei,col,node)\n\n        col+=1\n\ndfs(0,-1,-1)\n\nprint((max(l)))\n\nfor i in l:\n\n    print(i)\n","reference_code_col":"import sys\n\nsys.setrecursionlimit(500000)\n\nN = int(eval(input()))\n\nE = [[] for _ in range(N+1)]\n\nfor i in range(N-1):\n\n    a, b = list(map(int, input().split()))\n\n    E[a].append((b, i))\n\n    E[b].append((a, i))\n\nK = max(len(e) for e in E)\n\nprint(K)\n\nAns = [-1] * (N-1)\n\ndef dfs(v=1, p=0, p_col=-1):\n\n    col = 1\n\n    for u, idx in E[v]:\n\n        if u!=p: #\u6728\u69cb\u9020\u306e\u9006\u5411\u304d\u306e\u77e2\u5370\u3092\u9664\u304f\u305f\u3081\u306e\u6761\u4ef6\n\n            if col == p_col:\n\n                col += 1\n\n            Ans[idx] = col\n\n            #print(p_col)\n\n            dfs(u, v, col) #u;\u8abf\u3079\u308b\u9802\u70b9 v;\u76f4\u524d\u306b\u8abf\u3079\u305f\u8fba\u3067\u3001\u8abf\u3079\u308b\u9802\u70b9\u3068\u7d50\u3070\u308c\u3066\u3044\u308b\u9802\u70b9\u3000col;\u76f4\u524d\u306b\u8abf\u3079\u305f\u8fba\u306e\u8272\u756a\u53f7\n\n            col += 1 #\u6700\u6df1\u90e8\u307e\u3067\u8abf\u3079\u305f\u3089 \u30c7\u30d5\u30a9\u30eb\u30c8\u306e\u8272=\u6700\u5f8c\u306b\u8abf\u3079\u305f\u8fba\u306e\u8272+1\u3068\u3059\u308b\n\n            #\u6700\u6df1\u90e8\u306b\u7e4b\u304c\u3063\u305f\u8fba\u306e\u8272+1\u3057\u3066\u3084\u308c\u3070\u3001\u6b21\u306e\u8fba\u306e\u8272\u306f\u5fc5\u305a\u6761\u4ef6\u3092\u6e80\u305f\u3057\u3066\u304f\u308c\u308b\n\n\n\ndfs()\n\nprint((\"\\n\".join(map(str, Ans))))\n","model_generated_potentially_faster_code_col":"n = int(input())\n\nimport sys\n\n# Set recursion limit to n + 2\nsys.setrecursionlimit(n + 2)\n\ns = [[] for _ in range(n)]\n\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    s[a - 1].append(b - 1)\n    s[b - 1].append(a - 1)\n\nl = [0] * (n - 1)\n\n\ndef dfs(node, pre_col, par):\n    col = 1\n    for nei in s[node]:\n        if nei == par:\n            continue\n        if col == pre_col:\n            col += 1\n        l[nei] = col\n        dfs(nei, col, node)\n        col += 1\n\n\ndfs(0, -1, -1)\nprint(max(l))\nfor i in l:\n    print(i)"}
{"problem_id":"p03494","slow_code_col":"eval(input())\n\n\n\nimport numpy as np\n\nA = np.array(list(map(int, input().split(\" \"))))\n\na = 0\n\n\n\nwhile np.sum(A%2) == 0:\n\n  A = A\/2\n\n  a = a + 1\n\n\n\nprint(a)","reference_code_col":"eval(input())\n\n\n\nA = list(map(int, input().split(\" \")))\n\nB = 0\n\n\n\nwhile all(a%2 == 0 for a in A):\n\n  A = [a\/2 for a in A]\n\n  B += 1\n\n  \n\nprint(B)\n\n    ","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read the input line by line.\ninput_line = input()\ninput_list = list(map(int, input_line.split(\" \")))\n\na = 0\n\n# Use a for-loop instead of while-loop to avoid calling sum() repeatedly.\nfor num in input_list:\n    if num % 2 != 0: \n        break\n    else:\n        num \/= 2\n        a += 1\n\nprint(a)"}
{"problem_id":"p02881","slow_code_col":"import math\n\nn=int(eval(input()))\n\nans=n\n\ni=1\n\nwhile(i<=math.sqrt(n)):\n\n    if n%i==0:\n\n        d=i+n\/i-2\n\n        ans=min(ans,d)\n\n    i+=1\n\nprint((int(ans)))","reference_code_col":"from math import floor\n\nfrom math import sqrt\n\nn=int(eval(input()))\n\nnn=floor(sqrt(n))\n\nrest=n%nn\n\nwhile rest!=0:\n\n    nn-=1\n\n    rest=n%nn\n\nnnn=n\/nn\n\nprint((int(nn+nnn-2)))","model_generated_potentially_faster_code_col":"import math\n\nn = int(eval(input()))\n\nif n == 1:\n    print(0)\nelse:\n    ans = float('inf')\n    i = 1\n    while i <= math.sqrt(n):\n        if n % i == 0:\n            d = i + n \/ i - 2\n            if d < ans:\n                ans = d\n                # If the current i is the smallest divisor found so far,\n                # then no need to search further.\n                break\n        i += 1\n    print(int(ans))"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nN = int(eval(input()))\n\n\n\npower = math.factorial(N)\n\n\n\nprint((power % 1000000007))\n\n\n","reference_code_col":"n=int(eval(input()))\n\nans=1\n\nfor i in range(n):\n\n    ans=(ans*(i+1))%(10**9+7)\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(eval(input()))\n\n# Initialize result as 1\nresult = 1\n\n# Calculate factorial iteratively\nfor i in range(2, N + 1):\n    result = (result * i) % 1000000007\n\nprint(result)"}
{"problem_id":"p03170","slow_code_col":"n, k = list(map(int, input().split()))\n\na_s = list(map(int, input().split()))\n\ndp = [\"Second\"] * (k + 1)\n\nfor i in range(k + 1):\n\n    if dp[i] == \"Second\":\n\n        for a in a_s:\n\n            ii = i + a\n\n            if ii <= k:\n\n                dp[ii] = \"First\"\n\nprint((dp[-1]))\n","reference_code_col":"n, k = list(map(int, input().split()))\n\na_s = list(map(int, input().split()))\n\ndp = [\"Second\"] * (k + 1)\n\nfor i in range(k + 1):\n\n    if dp[i] == \"Second\":\n\n        for a in a_s:\n\n            ii = i + a\n\n            if ii > k:break\n\n            dp[ii] = \"First\"\n\nprint((dp[-1]))\n","model_generated_potentially_faster_code_col":"n, k = map(int, input().split())\n\na_s = list(map(int, input().split()))\n\ndp = [False] * (k + 1)\n\nfor a in a_s:\n    for i in range(a, k + 1):\n        dp[i] = True\n\nprint(\"First\" if dp[k] else \"Second\")"}
{"problem_id":"p02886","slow_code_col":"N = int(eval(input()))\n\nD = list(map(int,input().split()))\n\ncnt = 0\n\nfor i in range(N-1):\n\n    for j in range(i+1,N):\n\n        cnt += D[i]*D[j]\n\nprint(cnt)","reference_code_col":"N = int(eval(input()))\n\nD = list(map(int,input().split()))\n\ncnt = 0\n\nfor i in range(N):\n\n    cnt += D[i]**2\n\ntot = 0\n\nfor i in range(N):\n\n    tot += D[i]\n\ntot = tot**2\n\ntot -= cnt\n\nprint((tot\/\/2))","model_generated_potentially_faster_code_col":"N = int(input())\nD = list(map(int, input().split()))\n\nprefix_sum = [0] * (N + 1)\n\n# Calculate prefix sums\nfor i in range(N):\n    prefix_sum[i + 1] = prefix_sum[i] + D[i]\n\ncnt = 0\n\n# Use prefix sums to calculate the result\nfor i in range(1, N + 1):\n    cnt += D[i - 1] * prefix_sum[N] - prefix_sum[i]\n\nprint(cnt)"}
{"problem_id":"p02792","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nN = int(eval(input()))\n\nketa = len(str(N))\n\nif keta == 1:\n\n    print(N)\n\n    sys.exit()\n\nans = {}\n\nfor i in [1,2,3,4,5,6,7,8,9]:\n\n    for j in [1,2,3,4,5,6,7,8,9]:\n\n        ans[(i, j)] = 0\n\nfor i in range(1, N+1):\n\n    maxdigit = int(str(i)[0])\n\n    mindigit = int(str(i)[-1])\n\n    if mindigit != 0:\n\n        ans[(maxdigit, mindigit)] += 1\n\ncnt = 0\n\nfor i in range(1, 10):\n\n    for j in range(1, 10):\n\n        if i == j:\n\n            cnt += ans[(i, i)] ** 2\n\n        else:\n\n            cnt += ans[(i, j)] * ans[(j, i)] * 2\n\n            ans[(i, j)] = 0\n\n            ans[(j, i)] = 0\n\nprint(cnt)\n\n\n\n        \n\n\n\n    ","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\n\n\nfrom collections import defaultdict\n\n\n\nd = defaultdict(int) # d[(a, b)] : \u5148\u982da, \u672b\u5c3eb\n\n\n\nfor i in range(1, n + 1):\n\n    i_str = str(i)\n\n    d[(i_str[0], i_str[-1])] += 1\n\n\n\nans = 0\n\n\n\nfor i in range(1, 10):\n\n    for j in range(10):\n\n        ans += d[(str(i), str(j))] * d[(str(j), str(i))]\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\nN = int(input())\n\n# Initialize the dictionary with keys [1, 2, ..., 9]\nans = {(i, j): 0 for i in range(1, 10) for j in range(1, 10)}\n\n# Count occurrences of each pair (first digit, last digit)\nfor i in range(1, N + 1):\n    max_digit = i \/\/ 10**(len(str(i)) - 1)\n    min_digit = i % 10\n    if min_digit != 0:\n        ans[(max_digit, min_digit)] += 1\n\n# Calculate the final result\ncnt = 0\nfor i in range(1, 10):\n    for j in range(1, 10):\n        if i == j:\n            cnt += ans[(i, i)] ** 2\n        else:\n            cnt += ans[(i, j)] * ans[(j, i)] * 2\n\nprint(cnt)"}
{"problem_id":"p02555","slow_code_col":"from math import factorial\n\n\n\ns = int(eval(input()))\n\nmod = pow(10, 9) + 7\n\n\n\n\n\ndef nCr(n, r):\n\n    return int(factorial(n) \/\/ factorial(r) \/\/ factorial (n - r) % mod)\n\n\n\nans = 0\n\nseq_len = s \/\/ 3\n\n\n\nfor i in range(1, seq_len + 1):\n\n    ans += nCr(s - 3 * i + (i - 1), i - 1)\n\n\n\nprint((ans % mod))","reference_code_col":"# \u52d5\u7684\u8a08\u753b\u6cd5\u306b\u3088\u308b\u89e3\u6cd5\n\n\n\ns = int(eval(input()))\n\nmod = pow(10, 9) + 7\n\n\n\nA = [0] * (s + 1)\n\n\n\nif s >= 3:\n\n    A[3] = 1\n\n\n\nfor i in range(4, s + 1):\n\n    A[i] = (A[i - 3] + A[i - 1]) % mod\n\n\n\nprint((A[s]))","model_generated_potentially_faster_code_col":"from math import factorial\n\ns = int(eval(input()))\nmod = pow(10, 9) + 7\n\n# Precompute factorial values\nfact = [1]\nfor i in range(1, s+1):\n    fact.append(fact[-1] * i % mod)\n\ndef nCr(n, r):\n    if r > n:\n        return 0\n    else:\n        return (fact[n] * pow(fact[r], mod-2, mod) * pow(fact[n-r], mod-2, mod)) % mod\n\nans = 0\nseq_len = s \/\/ 3\n\nfor i in range(1, seq_len + 1):\n    ans += nCr(s - 3 * i + (i - 1), i - 1)\n    ans %= mod\n\nprint(ans)"}
{"problem_id":"p03370","slow_code_col":"N, X = list(map(int, input().split()))\n\n\n\nmn = [0]*N\n\nfor i in range(N):\n\n  mn[i] = int(eval(input()))\n\n  \n\nans = N\n\nx = X - sum(mn)\n\n\n\nwhile(x >= min(mn)):\n\n  if x \/\/ min(mn) == 0:\n\n    mn[mn.index(min(mn))] = 1000000\n\n  else:\n\n    if x >= min(mn):\n\n      x -= min(mn)\n\n      ans += 1\n\n      \n\nprint(ans)","reference_code_col":"N, X = list(map(int, input().split()))\n\n\n\nmn = [0]*N\n\nfor i in range(N):\n\n  mn[i] = int(eval(input()))\n\n  \n\nans = N\n\nx = X - sum(mn)\n\n\n\nwhile(x >= min(mn)):\n\n  if x \/\/ min(mn) == 0:\n\n    mn[mn.index(min(mn))] = 1000000\n\n  else:\n\n    x -= min(mn)\n\n    ans += 1\n\n      \n\nprint(ans)","model_generated_potentially_faster_code_col":"# Read input\nN, X = map(int, input().split())\n\n# Initialize list to store the numbers\nmn = []\n\n# Read N numbers into the list\nfor _ in range(N):\n    mn.append(int(input()))\n\n# Calculate the remaining value needed to reach X\nx = X - sum(mn)\n\n# Initialize answer to N (maximum possible operations)\nans = N\n\n# Continue until x is zero\nwhile x > 0:\n    # Find the smallest number in the list that is less than or equal to x\n    min_val = min(val for val in mn if val <= x)\n    \n    # Subtract this value from x\n    x -= min_val\n    \n    # Increment the operation count\n    ans += 1\n    \n    # Mark this position as used by setting it to a very large number\n    mn[mn.index(min_val)] = float('inf')\n\nprint(ans)"}
{"problem_id":"p03644","slow_code_col":"import numpy as np\n\nN=int(eval(input()))\n\nprint((2**int(np.log2(N))))","reference_code_col":"import math\n\nN=int(eval(input()))\n\nprint((2**int(math.log2(N))))","model_generated_potentially_faster_code_col":"import math\n\nN = int(eval(input()))\nprint(2 ** math.ceil(math.log2(N)))"}
{"problem_id":"p02596","slow_code_col":"#! \/usr\/bin\/env python3\n\n\n\nimport sys\n\nint1 = lambda x: int(x) - 1\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(500000)\n\n\n\n\n\ndef isMultiple(s, m):\n\n    tmp = 0\n\n    for i in range(len(s)):\n\n        tmp = (tmp * 10 + int(s[i])) % m\n\n        if tmp == 0:\n\n            return i\n\n    return -1\n\n\n\n\n\nk = int(readline())\n\nacc = \"7\" * 50000000\n\nif k % 2 == 0:\n\n    ans = -1\n\nelse:\n\n\n\n    ans = isMultiple(acc, k)\n\n    if ans != -1:\n\n        ans += 1\n\n\n\nprint(ans)\n","reference_code_col":"#! \/usr\/bin\/env python3\n\n\n\nimport sys\n\nint1 = lambda x: int(x) - 1\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\nsys.setrecursionlimit(500000)\n\n\n\nk = int(readline())\n\n\n\nans = -1\n\nacc = 7 % k\n\nfor n in range(1, k + 10):\n\n    if acc == 0:\n\n        ans = n\n\n        break\n\n    acc = (10 * acc + 7) % k\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\n\n# Function to check if the number formed by repeating '7' n times is divisible by k\ndef is_multiple(n, k):\n    remainder = 0\n    for _ in range(n):\n        remainder = (remainder * 10 + 7) % k\n        if remainder == 0:\n            return True\n    return False\n\n# Read input from stdin\nk = int(sys.stdin.buffer.readline().decode().strip())\n\n# Check if k is even\nif k % 2 == 0:\n    print(-1)\nelse:\n    n = 1\n    while not is_multiple(n, k):\n        n *= 10\n        n += 1\n    \n    print(n)"}
{"problem_id":"p03253","slow_code_col":"from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# x\u3092\u7d20\u56e0\u6570\u5206\u89e3\u3059\u308b\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x \/\/= d\n\n\n\n    if x != 1:\n\n        ans.append(x)\n\n\n\n    return ans\n\n\n\n# x\u306en\u4e57\uff08\u4e8c\u5206\u7d2f\u4e57\u6cd5\uff09\n\ndef power(x, n):\n\n    ans = 1\n\n    while n:\n\n        if n % 2 == 1:\n\n            ans = (ans * x) % MOD\n\n        x = (x * x) % MOD\n\n        n \/\/= 2\n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nN2 = N\n\nif len(cnt):\n\n    N2 += max(cnt.values())\n\n\n\n# facts[x]: x\u306e\u968e\u4e57\n\nfacts = [1] + [0] * N2\n\nfor x in range(1, N2 + 1):\n\n    facts[x] = (facts[x - 1] * x) % MOD\n\n\n\n# invFs[x]: x\u306e\u968e\u4e57\u306e\u9006\u5143\n\ninvFs = [0] * N2 + [power(facts[N2], MOD - 2)]\n\nfor x in reversed(list(range(N2))):\n\n    invFs[x] = (invFs[x + 1] * (x + 1)) % MOD\n\n\n\ndef comb(n, k):\n\n    return ((facts[n] * invFs[k]) % MOD * invFs[n - k]) % MOD\n\n\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans = (ans * comb(N + num - 1, num)) % MOD\n\nprint(ans)\n","reference_code_col":"from math import floor, sqrt\n\nfrom collections import Counter\n\n\n\nMOD = 10 ** 9 + 7\n\n\n\n# x\u3092\u7d20\u56e0\u6570\u5206\u89e3\u3059\u308b\n\ndef getPrimeFactor(x):\n\n    ans = []\n\n    for d in range(2, floor(sqrt(x)) + 1):\n\n        while x % d == 0:\n\n            ans.append(d)\n\n            x \/\/= d\n\n    if x != 1:\n\n        ans.append(x)\n\n    return ans\n\n\n\ndef comb(n, k):\n\n    k = min(k, n - k)\n\n    ans = 1\n\n    for i in range(n, n - k, -1):\n\n        ans *= i\n\n    for i in range(1, k + 1):\n\n        ans \/\/= i \n\n    return ans\n\n\n\n\n\nN, M = list(map(int, input().split()))\n\n\n\nPFs = getPrimeFactor(M)\n\ncnt = Counter(PFs)\n\n\n\nans = 1\n\nfor num in list(cnt.values()):\n\n    ans *= comb(N + num - 1, num)\n\nprint((ans % MOD))\n","model_generated_potentially_faster_code_col":"from math import floor, sqrt\nfrom collections import Counter\n\nMOD = 10 ** 9 + 7\n\n# x\u3092\u7d20\u56e0\u6570\u5206\u89e3\u3059\u308b\ndef get_prime_factors(x):\n    factors = []\n    # Check for number of 2s in x\n    while x % 2 == 0:\n        factors.append(2)\n        x \/\/= 2\n    # Check for other primes\n    for i in range(3, floor(sqrt(x)) + 1, 2):\n        while x % i == 0:\n            factors.append(i)\n            x \/\/= i\n    # If x is a prime number greater than 2\n    if x > 2:\n        factors.append(x)\n    return factors\n\n# x\u306en\u4e57\uff08\u4e8c\u5206\u7d2f\u4e57\u6cd5\uff09\ndef power(x, n):\n    result = 1\n    while n:\n        if n % 2 == 1:\n            result = (result * x) % MOD\n        x = (x * x) % MOD\n        n \/\/= 2\n    return result\n\n# Read input\nN, M = map(int, input().split())\n\n# Get prime factors of M\nprime_factors = get_prime_factors(M)\nfactor_count = Counter(prime_factors)\n\n# Adjust N based on the maximum count of any prime factor\nN2 = N\nif factor_count:\n    N2 += max(factor_count.values())\n\n# Precompute factorials and their modular inverses\nfacts = [1] * (N2 + 1)\nfor i in range(1, N2 + 1):\n    facts[i] = (facts[i - 1] * i) % MOD\n\ninv_facts = [0] * (N2 + 1)\ninv_facts[-1] = power(facts[N2], MOD - 2)\nfor i in range(N2 - 1, -1, -1):\n    inv_facts[i] = (inv_facts[i + 1] * (i + 1)) % MOD\n\n# Function to calculate combinations\ndef comb(n, k):\n    return ((facts[n] * inv_facts[k]) % MOD * inv_facts[n - k]) % MOD\n\n# Calculate the final answer\nanswer = 1\nfor count in factor_count.values():\n    answer = (answer * comb(N + count - 1, count)) % MOD\n\nprint(answer)"}
{"problem_id":"p02615","slow_code_col":"n,*l=list(map(int,open(0).read().split()));print((sum(sorted(l*2)[-2:~n:-1])))","reference_code_col":"n,*l=list(map(int,open(0).read().split()))\n\nl.sort(reverse=1)\n\nprint((sum(l[i\/\/2] for i in range(1,n))))","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n = data[0]\n    l = data[1:]\n    \n    # sort only once and store in descending order\n    sorted_l = sorted(l, reverse=True)\n    \n    print(sum(sorted_l[:n]))\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03796","slow_code_col":"import numpy as np\n\nmod=10**9+7\n\nd=np.zeros(100100,dtype=np.int64)\n\nd[0]=1\n\nfor i in range(1,10**5+1):\n\n  d[i]=d[i-1]*i%mod\n\nprint((d[int(eval(input()))]))","reference_code_col":"d,mod=[1]+[0]*100100,10**9+7\n\nfor i in range(1,10**5+1):d[i]=d[i-1]*i%mod\n\nprint((d[int(eval(input()))]))","model_generated_potentially_faster_code_col":"import numpy as np\n\nmod = 10**9 + 7\nn = 10**5 + 1\nd = np.zeros(n, dtype=np.int64)\nd[0] = 1\n\n# Precompute the factorial values\nfor i in range(1, n):\n    d[i] = d[i - 1] * i % mod\n\n# Read input and print result\nprint(d[int(input())])"}
{"problem_id":"p02881","slow_code_col":"import math\n\nN = int(eval(input()))\n\nfor i in range(int(math.sqrt(N))):\n\n    if N % (int(math.sqrt(N))-i) == 0:\n\n        print((int(N\/(int(math.sqrt(N))-i)+int(math.sqrt(N))-i-2)))\n\n        break","reference_code_col":"import math\n\nN = int(eval(input()))\n\nM = int(math.sqrt(N))\n\nfor i in range(M):\n\n    if N % (M-i) == 0:\n\n        print((int(N\/(M-i)+M-i-2)))\n\n        break\n","model_generated_potentially_faster_code_col":"import math\n\nN = int(eval(input()))\nsqrt_N = int(math.sqrt(N))\n\nfor i in range(sqrt_N):\n\n    if N % (sqrt_N - i) == 0:\n\n        print((N\/\/(sqrt_N - i) + sqrt_N - i - 2))\n        \n        break"}
{"problem_id":"p02994","slow_code_col":"N, L = [int(i) for i in input().split()]\n\n\n\nmin_ = L\n\nmax_ = L + N -1\n\n\n\ndef eat_apple():\n\n    if max_<0:\n\n        return max_ \n\n    if L < 0:\n\n        return 0\n\n    return L\n\n\n\nprint(((min_+max_)*(max_-min_+1)\/\/2 - eat_apple()))","reference_code_col":"N, L = [int(i) for i in input().split()]\n\n\n\nmin_ = L\n\nmax_ = L + N -1\n\n\n\ndef eat_apple(N, L, max_):\n\n    if max_<0:\n\n        return max_ \n\n    if L < 0:\n\n        return 0\n\n    return L\n\n\n\nprint(((min_+max_)*(max_-min_+1)\/\/2 - eat_apple(N, L, max_)))","model_generated_potentially_faster_code_col":"N, L = map(int, input().split())\n\nmin_ = L\nmax_ = L + N - 1\n\n# Directly incorporate the logic from eat_apple() into the main calculation\nif max_ < 0:\n    result = max_\nelif L < 0:\n    result = 0\nelse:\n    result = L\n\nprint(((min_ + max_) * (max_ - min_ + 1) \/\/ 2 - result))"}
{"problem_id":"p03363","slow_code_col":"from collections import Counter\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\nruisekiwa = [0] * (N+1)\n\n\n\nfor i in range(N):\n\n    ruisekiwa[i+1] = ruisekiwa[i] + inputs[i]\n\n\n\nruisekiwa = ruisekiwa[1:]\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n","reference_code_col":"from collections import Counter\n\nfrom itertools import accumulate\n\n\n\nN = int(eval(input()))\n\ninputs = [int(i) for i in input().split()]\n\n\n\nans = 0\n\n\n\nruisekiwa = list(accumulate(inputs))\n\nruisekiwa.sort()\n\ncounter_ruiseki = Counter(ruisekiwa)\n\n\n\nfor key, value in list(counter_ruiseki.items()):\n\n    if key == 0 and value == 1:\n\n        ans += value\n\n        continue\n\n    elif key == 0 and value > 1:\n\n        ans += value\n\n    if value > 1:\n\n        ans += sum(list(range(value)))\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"from collections import Counter\n\n# Read input values\nN = int(input())\ninputs = list(map(int, input().split()))\n\n# Calculate cumulative sums and sort them\ncumulative_sums = sorted([sum(inputs[:i+1]) for i in range(N)])\n\n# Count occurrences of each cumulative sum\nsum_counts = Counter(cumulative_sums)\n\n# Initialize answer\nanswer = 0\n\n# Iterate through counted sums\nfor key, value in sum_counts.items():\n    # Add one occurrence of zero if present\n    if key == 0 and value > 0:\n        answer += 1\n    \n    # Add all multiples of occurrences greater than one\n    if value > 1:\n        answer += value * (value - 1) \/\/ 2\n\n# Output result\nprint(answer)"}
{"problem_id":"p03457","slow_code_col":"import sys\n\n_input = sys.stdin.readline\n\n\n\n\n\ndef resolve():\n\n    N = int(_input())\n\n    T = [list(map(int, _input().split())) for _ in range(N)]\n\n    t, x, y = 0, 0, 0\n\n    for next_t, next_x, next_y in T:\n\n        diff_xy = abs(x - next_x) + abs(y - next_y)\n\n        diff_t = next_t - t\n\n        if diff_xy > diff_t or (diff_xy % 2 != diff_t % 2):\n\n            print('No')\n\n            exit(0)\n\n    print('Yes')\n\n\n\n\n\nif __name__ == '__main__':\n\n    resolve()","reference_code_col":"import sys\n\n_input = sys.stdin.readline\n\n\n\n\n\ndef resolve():\n\n    N = int(_input())\n\n    t, x, y = 0, 0, 0\n\n    for _ in range(N):\n\n        next_t, next_x, next_y = list(map(int, _input().split()))\n\n        diff_xy = abs(x - next_x) + abs(y - next_y)\n\n        diff_t = next_t - t\n\n        if diff_xy > diff_t or (diff_xy % 2 != diff_t % 2):\n\n            print('No')\n\n            exit(0)\n\n    print('Yes')\n\n\n\n\n\nif __name__ == '__main__':\n\n    resolve()","model_generated_potentially_faster_code_col":"import sys\n\n_input = sys.stdin.readline\n\n\ndef resolve():\n    N = int(_input())\n    T = [tuple(map(int, _input().split())) for _ in range(N)]\n    \n    t, x, y = 0, 0, 0\n    \n    for next_t, next_x, next_y in T:\n        dx, dy = next_x - x, next_y - y\n        dt = next_t - t\n        \n        # Check if the difference in time allows reaching the point\n        if abs(dx) + abs(dy) > dt or (abs(dx) + abs(dy)) % 2 != dt % 2:\n            print('No')\n            return\n    \n    print('Yes')\n\n\nif __name__ == '__main__':\n    resolve()"}
{"problem_id":"p02596","slow_code_col":"K = int(eval(input()))\n\n\n\nflg = [False]*K\n\n\n\ntmp = 7 % K\n\ncnt = 1\n\nif tmp == 0:\n\n    print(cnt)\n\n    exit()\n\nwhile True:\n\n    tmp = (tmp*10+7)%K\n\n    if flg[tmp]:\n\n        print((-1))\n\n        break\n\n    else:\n\n        cnt += 1\n\n        if tmp == 0:\n\n            print(cnt)\n\n            break\n\n        flg[tmp] = True\n","reference_code_col":"K = int(eval(input()))\n\nt = 7\n\nt %= K\n\n\n\nfor i in range(K+1):\n\n    if t == 0:\n\n        print((i+1))\n\n        exit()\n\n    t = (t*10+7)%K\n\nprint((-1))\n","model_generated_potentially_faster_code_col":"def find_min_n(K):\n    if K <= 1:\n        return -1\n\n    # Initialize variables\n    n = 0\n    power_of_7 = 1\n\n    while True:\n        # Update the power of 7 modulo K\n        power_of_7 = (power_of_7 * 7) % K\n        \n        # Check if we found a cycle\n        if power_of_7 == 1:\n            if n > 0:\n                return n\n            else:\n                return -1\n\n        n += 1\n\n\n# Get input from user\nK = int(input())\n\n# Find and print result\nprint(find_min_n(K))"}
{"problem_id":"p03796","slow_code_col":"from math import factorial\n\nprint((factorial(int(eval(input()))) % (10**9+7)))","reference_code_col":"ans = 1\n\nfor k in range(1, int(eval(input()))+1):\n\n    ans = ans*k % (10**9+7)\n\nprint(ans)","model_generated_potentially_faster_code_col":"from math import factorial\n\nn = int(input())\nmodulus = 10**9 + 7\nfact = 1\n\nfor i in range(2, n + 1):\n    fact = (fact * i) % modulus\n\nprint(fact)"}
{"problem_id":"p03822","slow_code_col":"import sys\n\nsys.setrecursionlimit(202020)\n\n\n\nN = int(eval(input()))\n\nwon = [[] for i in range(N)]\n\nfor i in range(1,N):\n\n    a = int(eval(input())) - 1\n\n    won[a].append(i)\n\n\n\ndef height(v):\n\n    if not won[v]: return 0\n\n    hs = [height(op) for op in won[v]]\n\n    ret = 0\n\n    for i,h in enumerate(sorted(hs)):\n\n        ret = max(ret, h + len(hs) - i)\n\n    return ret\n\n\n\nprint((height(0)))","reference_code_col":"import sys\n\nsys.setrecursionlimit(10**8)\n\nN = int(eval(input()))\n\nA = [int(eval(input()))-1 for i in range(N-1)]\n\nwins = [[] for _ in range(N)]\n\n\n\nfor i,a in enumerate(A):\n\n    wins[a].append(i+1)\n\n\n\ndepth = [-1] * N\n\ndef dep(v):\n\n    if len(wins[v])==0: return 0\n\n    if depth[v] >= 0:\n\n        return depth[v]\n\n    ds = []\n\n    for w in wins[v]:\n\n        ds.append(dep(w))\n\n    ds.sort(reverse=True)\n\n    ret = 0\n\n    for i,d in enumerate(ds):\n\n        ret = max(ret, i+d+1)\n\n    depth[v] = ret\n\n    return ret\n\nprint((dep(0)))","model_generated_potentially_faster_code_col":"import sys\n\nsys.setrecursionlimit(202020)\n\n\nN = int(eval(input()))\n\nwon = [[] for i in range(N)]\n\n\nfor i in range(1,N):\n\n    a = int(eval(input())) - 1\n\n    won[a].append(i)\n\n\n@lru_cache(maxsize=None)\ndef height(v):\n    if not won[v]:\n        return 0\n\n    hs = [height(op) for op in won[v]]\n    \n    return max(hs) + 1\n\n\nprint(height(0))"}
{"problem_id":"p02595","slow_code_col":"N, D = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    if (a**2 + b**2) <= D**2:\n\n        count += 1\n\nprint(count)\n","reference_code_col":"N, D = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(N):\n\n    a, b = list(map(int, input().split()))\n\n    if (a*a + b*b) <= D*D:\n\n        count += 1\n\nprint(count)\n","model_generated_potentially_faster_code_col":"import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Extract N and D\nN = int(data[0])\nD_squared = int(data[1]) ** 2\n\n# Initialize count\ncount = 0\n\n# Iterate over remaining input values in pairs\ni = 2\nwhile i < len(data):\n    a = int(data[i])\n    b = int(data[i+1])\n\n    if (a**2 + b**2) <= D_squared:\n        count += 1\n\n    i += 2\n\nprint(count)"}
{"problem_id":"p03309","slow_code_col":"# ABC102C - Linear Approximation (ARC100C)\n\nfrom statistics import median\n\n\n\n\n\ndef main():\n\n    n = int(eval(input()))\n\n    A = tuple(map(int, input().rstrip().split()))\n\n    A = tuple(j - i for i, j in enumerate(A, start=1))\n\n    b = median(A)\n\n    ans = sum(abs(a - b) for a in A)\n\n    print((int(ans)))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()","reference_code_col":"# ABC102C - Linear Approximation (ARC100C)\n\ndef main():\n\n    n = int(eval(input()))\n\n    A = tuple(map(int, input().rstrip().split()))\n\n    A = sorted(j - i for i, j in enumerate(A, start=1))\n\n    b = A[n \/\/ 2]\n\n    ans = sum(abs(a - b) for a in A)\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()","model_generated_potentially_faster_code_col":"import statistics\n\ndef main():\n    n = int(input())\n    A = list(map(int, input().rstrip().split()))\n    \n    # Transform A to B: B[i] = A[i] - (i + 1)\n    B = [A[i] - (i + 1) for i in range(n)]\n    \n    # Calculate the median of B\n    b = statistics.median(B)\n    \n    # Calculate the sum of absolute differences from the median\n    ans = sum(abs(b - x) for x in B)\n    \n    print(int(ans))\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p01105","slow_code_col":"a=65280; b=61680; c=52428; d=43690; e=65535\n\nL = {el: 1 for el in [a, b, c, d, e, 0]}\n\nfor i in range(6):\n\n    R = sorted(L.items(), key=lambda x: x[1])\n\n    for p, l in R:\n\n        if l < 16:\n\n            L[p ^ e] = min(L.get(p ^ e, 16), l+1)\n\n            if l+3 < 16:\n\n                for q, r in R:\n\n                    if l+r+3 <= 16:\n\n                        L[p & q] = min(L.get(p & q, 16), l+r+3)\n\n                        L[p ^ q] = min(L.get(p ^ q, 16), l+r+3)\n\n                    else: break\n\n        else: break\n\nprint(*(L[e & eval(s)] for s in open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]),sep='\\n')\n","reference_code_col":"a=65280; b=61680; c=52428; d=43690; e=65535\n\nfrom heapq import heappush, heappop\n\nbase = [a, b, c, d, e, 0]\n\nQ = [(1, el) for el in base]\n\nL = {el: 1 for el in base}\n\nH = []\n\nwhile Q:\n\n    l, p = heappop(Q)\n\n    if L[p] < l: continue\n\n    if l+1 < L.get(p ^ e, 17):\n\n        L[p^e] = l+1\n\n        if l+1 < 16: heappush(Q, (l+1, p^e))\n\n    if l+3 < 16:\n\n        for q, r in H:\n\n            if l+r+3 <= 16:\n\n                if l+r+3 < L.get(p & q, 17):\n\n                    L[p & q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p & q))\n\n                if l+r+3 < L.get(p ^ q, 17):\n\n                    L[p ^ q] = l+r+3\n\n                    if l+r+3 < 16: heappush(Q, (l+r+3, p ^ q))\n\n            else: break\n\n    if l < 7: H.append((p, l))\n\nprint(*(L[e & eval(s)] for s in open(0).read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]),sep='\\n')\n","model_generated_potentially_faster_code_col":"# Precomputed values for initialization\nvalues = [65280, 61680, 52428, 43690, 65535, 0]\nL = {el: 1 for el in values}\n\n# Function to update the dictionary\ndef update_dict(L, p, e):\n    L[p ^ e] = min(L.get(p ^ e, 16), L[p] + 1)\n    if L[p] + 3 < 16:\n        for q in L:\n            if L[p] + L[q] + 3 <= 16:\n                L[p & q] = min(L.get(p & q, 16), L[p] + L[q] + 3)\n                L[p ^ q] = min(L.get(p ^ q, 16), L[p] + L[q] + 3)\n            else:\n                break\n\n# Main loop\nfor _ in range(6):\n    # Sort the dictionary based on values\n    R = sorted(L.items(), key=lambda x: x[1])\n    \n    for p, l in R:\n        if l < 16:\n            update_dict(L, p, 65535)  # Assuming e is always 65535\n        else:\n            break\n\n# Process input file\nwith open(0) as f:\n    lines = f.read().replace(*\"-~\").replace(*\"*&\").replace(*\"1e\").split()[:-1]\n\n# Print results\nfor s in lines:\n    result = L[int(s, 16)]\n    print(result)"}
{"problem_id":"p02792","slow_code_col":"#python3\n\nfrom collections import defaultdict\n\nfrom collections import namedtuple\n\n\n\nP = namedtuple('P', ['front', 'end'])\n\n\n\ndef f(x):\n\n    return P(str(x)[0], str(x)[-1]) \n\n\n\ndef main():\n\n\n\n    n = int(eval(input()))\n\n    freq = defaultdict(int)\n\n\n\n    for i in range(1, n+1):\n\n        p = f(i)\n\n        freq[p]+=1\n\n\n\n\n\n    ans = 0\n\n    for i in range(1, n + 1):\n\n        p = f(i)\n\n        q = (p.end, p.front)\n\n        ans += freq[q]\n\n\n\n    print(ans)\n\n\n\nmain()","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nfrom collections import defaultdict\n\n\n\ndef f(x):\n\n    return (int(str(x)[0]), int(str(x)[-1])) \n\ndef main():\n\n    N = int(readline())\n\n    df = defaultdict(int)\n\n    for i in range(1, N+1):\n\n        df[f(i)] += 1\n\n    ans = 0\n\n    for i in range(1, 10):\n\n        for j in range(1, 10):\n\n            ans +=  df[(i, j)]*df[(j, i)]\n\n    print(ans)\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"from collections import Counter\n\ndef main():\n    n = int(input())\n    freq = Counter()\n\n    for i in range(1, n+1):\n        first_digit = str(i)[0]\n        last_digit = str(i)[-1]\n        freq[first_digit, last_digit] += 1\n\n    ans = 0\n    for i in range(1, n + 1):\n        first_digit = str(i)[0]\n        last_digit = str(i)[-1]\n        q = (last_digit, first_digit)\n        ans += freq[q]\n\n    print(ans)\n\nmain()"}
{"problem_id":"p03038","slow_code_col":"n, m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nbc = [list(map(int, input().split())) for _ in range(m)]\n\n\n\nbc.sort(key=lambda x: x[1], reverse=True)\n\na.sort()\n\n\n\ni = 0\n\nfor b, c in bc:\n\n    for _ in range(b):\n\n        if i < n and a[i] < c:\n\n            a[i] = c\n\n            i += 1\n\n        else:\n\n            break\n\n\n\nans = sum(a)\n\nprint(ans)\n","reference_code_col":"n, m = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nbc = [list(map(int, input().split())) for _ in range(m)]\n\n\n\nbc.sort(reverse=True, key=lambda x: x[1])\n\n\n\nli = []\n\nl = 0\n\ni = 0\n\nwhile i < m and l < n:\n\n    b, c = bc[i]\n\n    li += [c] * b\n\n    i += 1\n\n    l += b\n\n\n\na += li\n\na.sort(reverse=True)\n\nans = sum(a[:n])\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"n, m = map(int, input().split())\n\na = list(map(int, input().split()))\n\nbc = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Sort by count (b) in descending order, then by value (c) in ascending order\nbc.sort(key=lambda x: (-x[0], x[1]))\n\n# Initialize the result\nresult = sum(a)\n\n# Use two pointers to merge sorted arrays efficiently\ni, j = 0, 0\nwhile i < n and j < m:\n    b, c = bc[j]\n    while i < n and a[i] < c:\n        a[i] = c\n        i += 1\n        b -= 1\n    if b == 0:\n        j += 1\n\nprint(result)"}
{"problem_id":"p02837","slow_code_col":"import itertools\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nstl = []\n\nfor i in range(N):\n\n    a = int(eval(input()))\n\n    for _ in range(a):\n\n        x, y = list(map(int, input().split()))\n\n        stl.append((i, x-1, y))\n\ndl = np.array(list(itertools.product([0, 1], repeat=N)), np.bool)\n\nfor i, x, y in stl:\n\n    bl = (dl[:, i] == False) | (dl[:, x] == bool(y))\n\n    dl = dl[bl]\n\nres = dl.sum(axis=1).max()\n\nprint(res)\n","reference_code_col":"import sys\n\nimport itertools\n\nimport collections\n\n\n\n\n\ndef solve():\n\n    readline = sys.stdin.buffer.readline\n\n    mod = 10 ** 9 + 7\n\n    n = int(readline())\n\n    xy = []\n\n    for i in range(n):\n\n        a = int(readline())\n\n        for j in range(a):\n\n            x, y = list(map(int, readline().split()))\n\n            xy.append([i, x-1, y])\n\n    ls = collections.deque([v for v in itertools.product([True, False], repeat=n)])\n\n    for i, x, y in xy:\n\n        for j in range(len(ls)):\n\n            lsv = ls.pop()\n\n            if not lsv[i] or lsv[x] == bool(y):\n\n                ls.appendleft(lsv)\n\n    t = 0\n\n    for i in range(len(ls)):\n\n        t = max(t, ls[i].count(True))\n\n    print(t)\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(input())\n\n# Preallocate memory for the array 'dl'\ndl = np.ones((2**N, N), dtype=bool)\n\n# Read input data and update 'dl' accordingly\nfor i in range(N):\n    a = int(input())\n    for _ in range(a):\n        x, y = map(int, input().split())\n        dl[:, i] &= (dl[:, x] != bool(y))\n\n# Calculate the result by summing along axis 1 and finding the maximum\nres = dl.sum(axis=1).max()\nprint(res)"}
{"problem_id":"p02901","slow_code_col":"INF = 10**10\n\n\n\nN, M = list(map(int, input().split()))\n\ncosts = []\n\nkeys = []\n\nfor _ in range(M):\n\n    A, B = list(map(int, input().split()))\n\n    cs = list(map(int, input().split()))\n\n    costs.append(A)\n\n    # \u9375\u30922\u9032\u6570\u5316\u3059\u308b\n\n    key = 0\n\n    for c in cs:\n\n        key |= 1<<(c-1)\n\n    keys.append(key)\n\n\n\n# [1]\u306e\u500b\u6570\u3067\u5206\u985e\u3059\u308b\n\nmaskss = [[] for _ in range(N+1)]\n\nnum1s = [0] * (2**N)\n\nfor S in range(2**N):\n\n    num = bin(S).count('1')\n\n    maskss[num].append(S)\n\n    num1s[S] = num\n\n\n\ndpAll = [INF] * (2**N)\n\nfor S in range(2**N):\n\n    for cost, key in zip(costs, keys):\n\n        if S & key == S:\n\n            if cost < dpAll[S]:\n\n                dpAll[S] = cost\n\n\n\ndp = [INF] * (2**N)\n\nfor S in range(2**N):\n\n    cost = dpAll[S]\n\n    num1 = num1s[S]\n\n    for k in range(1, (num1+1)\/\/2+1):\n\n        for mask in maskss[k]:\n\n            if mask & S == mask:\n\n                m2 = S^mask\n\n                c2 = dp[mask] + dp[m2]\n\n                if c2 < cost:\n\n                    cost = c2\n\n    dp[S] = cost\n\n\n\nif dp[2**N-1] == INF:\n\n    print((-1))\n\nelse:\n\n    print((dp[2**N-1]))\n","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\ndef solve():\n\n    INF = 10**10\n\n\n\n    N, M = list(map(int, input().split()))\n\n    keys = []\n\n    costs = []\n\n    for _ in range(M):\n\n        a, b = list(map(int, input().split()))\n\n        costs.append(a)\n\n        cs = list(map(int, input().split()))\n\n        key = 0\n\n        for c in cs:\n\n            key |= 1<<(c-1)\n\n        keys.append(key)\n\n\n\n    dp = [INF] * (1<<N)\n\n    dp[0] = 0\n\n    for S in range(1<<N):\n\n        for key, cost in zip(keys, costs):\n\n            S2 = S | key\n\n            c2 = dp[S] + cost\n\n            if c2 < dp[S2]:\n\n                dp[S2] = c2\n\n\n\n    if dp[-1] == INF:\n\n        print((-1))\n\n    else:\n\n        print((dp[-1]))\n\n\n\n\n\nsolve()\n","model_generated_potentially_faster_code_col":"INF = 10**10\n\nN, M = map(int, input().split())\n\ncosts = []\nkeys = []\n\nfor _ in range(M):\n    A, B = map(int, input().split())\n    cs = list(map(int, input().split()))\n    costs.append(A)\n    key = sum(1 << (c - 1) for c in cs)\n    keys.append(key)\n\n# [1]\u306e\u500b\u6570\u3067\u5206\u985e\u3059\u308b\nmaskss = [[] for _ in range(N + 1)]\nnum1s = [0] * (1 << N)\n\nfor S in range(1 << N):\n    num1s[S] = S.bit_count()\n    maskss[num1s[S]].append(S)\n\ndpAll = [INF] * (1 << N)\nfor S in range(1 << N):\n    if S & keys[-1] == S:\n        dpAll[S] = costs[-1]\n\ndp = [INF] * (1 << N)\nfor S in range(1 << N):\n    cost = dpAll[S]\n    num1 = num1s[S]\n    for k in range(1, (num1 + 1) \/\/ 2 + 1):\n        for mask in maskss[k]:\n            if mask & S == mask:\n                m2 = S ^ mask\n                c2 = dp[mask] + dp[m2]\n                if c2 < cost:\n                    cost = c2\n    dp[S] = cost\n\nprint(dp[(1 << N) - 1] if dp[(1 << N) - 1] != INF else -1)"}
{"problem_id":"p01138","slow_code_col":"def f(s):\n\n    s=list(map(int,s.split(':')))\n\n    return (s[0]*60+s[1])*60+s[2]\n\na=86401\n\nwhile 1:\n\n    t=[0]*a\n\n    n=int(eval(input()))\n\n    if n==0:break\n\n    for _ in range(n):\n\n        b,c=input().split()\n\n        t[f(b)]+=1;t[f(c)]-=1\n\n    d=0\n\n    for i in range(1,a):\n\n        t[i]+=t[i-1]\n\n        d=max(d,t[i])\n\n    print(d)","reference_code_col":"def f(s):\n\n    return (s[0]*60+s[1])*60+s[2]\n\na=86400\n\nwhile 1:\n\n    t=[0]*a\n\n    n=int(eval(input()))\n\n    if n==0:break\n\n    for _ in range(n):\n\n        b,c = [list(map(int,x.split(':'))) for x in input().split()]\n\n        t[f(b)]+=1;t[f(c)]-=1\n\n    d=0\n\n    for i in range(1,a):\n\n        t[i]+=t[i-1]\n\n        if d<t[i]:d=t[i]\n\n    print(d)","model_generated_potentially_faster_code_col":"def f(s):\n    hours, minutes, seconds = map(int, s.split(':'))\n    return (hours * 60 + minutes) * 60 + seconds\n\na = 86401\n\nwhile True:\n    t = [0] * a\n    n = int(input())\n    \n    if n == 0:\n        break\n    \n    # Store the start and end times as indices\n    start_times = []\n    end_times = []\n    \n    for _ in range(n):\n        b, c = input().split()\n        start_time = f(b)\n        end_time = f(c)\n        \n        start_times.append(start_time)\n        end_times.append(end_time)\n    \n    # Use a dictionary to count net changes at each time point\n    change_count = {}\n    \n    for st in start_times:\n        if st in change_count:\n            change_count[st] += 1\n        else:\n            change_count[st] = 1\n    \n    for et in end_times:\n        if et in change_count:\n            change_count[et] -= 1\n        else:\n            change_count[et] = -1\n    \n    # Calculate the maximum number of people present at any time\n    current_people = 0\n    max_people = 0\n    \n    for i in range(a):\n        if i in change_count:\n            current_people += change_count[i]\n        max_people = max(max_people, current_people)\n    \n    print(max_people)"}
{"problem_id":"p02982","slow_code_col":"import numpy\n\nN, D = list(map(int, input().split()))\n\nlistx = []\n\ncount = 0\n\nfor i in range(N):\n\n    x = list(map(int, input().split()))\n\n    listx.append(x)\n\n\n\nfor j in range(0, N):\n\n    for k in range(j+1,N):\n\n        a = numpy.array(listx[j])\n\n        b = numpy.array(listx[k])\n\n        u = b - a\n\n        c = float(numpy.linalg.norm(u))\n\n        if c.is_integer() :\n\n            count += 1\n\nprint(count)","reference_code_col":"def LI(): return list(map(int,input().split()))\n\nN,D = LI()\n\nX = [LI() for _ in range(N)]\n\nans = 0\n\nfor i in range(N):\n\n    for j in range(i+1,N):\n\n        temp = 0\n\n        for k in range(D):\n\n            temp += (X[j][k]-X[i][k])**2\n\n        if temp **0.5%1==0:\n\n            ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\nN, D = map(int, input().split())\n\npoints = [np.array(list(map(float, input().split()))) for _ in range(N)]\n\ncount = 0\n\nfor i in range(N):\n    for j in range(i + 1, N):\n        diff = points[i] - points[j]\n        dist_squared = np.sum(diff ** 2)  # Calculate squared distance\n        if dist_squared.is_integer():\n            count += 1\n\nprint(count)"}
{"problem_id":"p03457","slow_code_col":"import sys\n\ncan = True; eval(input())\n\ne = [[0, 0, 0]] + [list(map(int, e.split())) for e in sys.stdin]\n\nfor a, b in zip(e[1:], e):\n\n    t = a[0] - b[0] - abs(a[1] - b[1]) - abs(a[2] - b[2])\n\n    if t < 0 or t % 2 == 1: can = False; break\n\nprint((['No', 'Yes'][can]))","reference_code_col":"import sys\n\nans = 'Yes'; eval(input())\n\nfor e in sys.stdin:\n\n    t, x, y = list(map(int, e.split()))\n\n    t = t - x - y\n\n    if t < 0 or t % 2 == 1: ans = 'No'; break\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\n\n# Read the first line to determine the number of points\nnum_points = int(sys.stdin.readline().strip())\n\n# Initialize the result variable\ncan = True\n\n# Read all points into a list\npoints = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(num_points)]\n\n# Iterate over pairs of points to check the conditions\nfor i in range(1, num_points):\n    a = points[i]\n    b = points[i - 1]\n    \n    # Calculate the difference in coordinates\n    dx = a[0] - b[0]\n    dy = a[1] - b[1]\n    dz = a[2] - b[2]\n    \n    # Check the condition\n    t = dx - abs(dy) - abs(dz)\n    \n    if t < 0 or t % 2 == 1:\n        can = False\n        break\n\n# Output the result\nprint(\"Yes\" if can else \"No\")"}
{"problem_id":"p02901","slow_code_col":"import sys\n\nreadline = sys.stdin.readline\n\n\n\nN,M = list(map(int,readline().split()))\n\nINF = 10 ** 10\n\ndp = [INF] * (2 ** N)\n\ndp[0] = 0\n\n\n\nfor i in range(M):\n\n  a,b = list(map(int,readline().split()))\n\n  c = list(map(int,readline().split()))\n\n  key = 0\n\n  for j in range(len(c)):\n\n    key += (1 << (c[j] - 1))\n\n  for j in range(len(dp)):\n\n    if dp[j] == INF:\n\n      continue\n\n    if j | key == j:\n\n      continue\n\n    dp[j | key] = min(dp[j | key], dp[j] + a)\n\n\n\nif dp[-1] == INF:\n\n  print((-1))\n\nelse:\n\n  print((dp[-1]))","reference_code_col":"import sys\n\nreadline = sys.stdin.readline\n\n\n\nN,M = list(map(int,readline().split()))\n\nINF = 10 ** 10\n\ndp = [INF] * (2 ** N)\n\ndp[0] = 0\n\n\n\nfor i in range(M):\n\n  a,b = list(map(int,readline().split()))\n\n  c = list(map(int,readline().split()))\n\n  key = 0\n\n  for j in range(len(c)):\n\n    key += (1 << (c[j] - 1))\n\n  for j in range(len(dp)):\n\n    if dp[j] == INF:\n\n      continue\n\n    if j | key == j:\n\n      continue\n\n    if dp[j | key] > dp[j] + a:\n\n      dp[j | key] = dp[j] + a\n\n\n\nif dp[-1] == INF:\n\n  print((-1))\n\nelse:\n\n  print((dp[-1]))","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nindex = 0\nN = int(data[index])\nM = int(data[index + 1])\nindex += 2\n\nINF = 10 ** 10\n\n# Initialize dp array\ndp = [INF] * (1 << N)\ndp[0] = 0\n\n# Read and process each subset\nfor _ in range(M):\n    a = int(data[index])\n    index += 1\n    subset = 0\n    k = int(data[index])\n    index += 1\n    for _ in range(k):\n        bit = int(data[index]) - 1\n        index += 1\n        subset |= (1 << bit)\n    \n    # Update dp array\n    for state in range(1 << N):\n        if dp[state] != INF:\n            new_state = state | subset\n            dp[new_state] = min(dp[new_state], dp[state] + a)\n\n# Output the result\nresult = dp[(1 << N) - 1]\nprint(result if result < INF else -1)"}
{"problem_id":"p03747","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nN,L,T = list(map(int,input().split()))\n\nXW = [[int(x) for x in input().split()] for _ in range(N)]\n\n\n\nX,W = list(zip(*XW))\n\n\n\nDX = [1 if w == 1 else -1 for w in W]\n\n\n\nY = [(x+dx*T)%L for x,dx in zip(X,DX)]\n\ny0 = Y[0]\n\nY.sort()\n\n\n\n# \u756a\u53f71\u304c\u3059\u308c\u9055\u308f\u305a\u9032\u3093\u3060\u5834\u6240\u306b\u76f8\u5f53\u3059\u308b\u30a2\u30ea\u306e\u756a\u53f7\n\n# \u3059\u308c\u9055\u3046\u305f\u3073\u306b1\u5897\u3048\u308b\uff08W1=1\uff09 or 1\u6e1b\u308b\uff08W1=-1\uff09\n\n# T\u79d2\u3061\u3087\u3046\u3069\u3082\u3059\u308c\u9055\u3044\u7d42\u308f\u3063\u305f\u3068\u8003\u3048\u308b\n\n\n\nx = 0\n\nx0,dx0 = X[0],DX[0]\n\nfor y,dy in zip(X[1:],DX[1:]):\n\n    if dx0 == dy:\n\n        continue\n\n    if dx0 == 1 and dy == -1:\n\n        # \u6b63\u306e\u5411\u304d\u306b\u8ffd\u3044\u8d8a\u3059\u306e\u3067\u756a\u53f7\u304c\u3072\u3068\u3064\u5897\u3048\u308b\n\n        x += (2*T-(y-x0)-1)\/\/L + 1\n\n    if dx0 == -1 and dy == 1:\n\n        x -= (2*T-(L+x0-y))\/\/L + 1\n\nx %= N\n\n\n\ni = Y.index(y0)\n\n\n\nY += Y\n\n\n\nanswer = [None] * N\n\nanswer[x:N] = Y[i:i+N-x]\n\nanswer[0:x] = Y[i+N-x:i+N]\n\n\n\nprint(('\\n'.join(map(str,answer))))\n\n\n","reference_code_col":"import sys\n\nimport numpy as np\n\n\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\n\"\"\"\n\n\u30fb\u9806\u5e8f\u304c\u56fa\u5b9a\u3055\u308c\u308b\u306e\u3067\u3001\u533a\u9593\u3060\u3063\u305f\u3089\u7c21\u5358\n\n\u30fb\u5186\u306e\u3068\u304d\u3082\u3001\u5730\u70b9 0 \u3092\u305d\u308c\u305e\u308c\u306e\u65b9\u5411\u306b\u901a\u3063\u305f\u4eba\u6570\u3092\u898b\u308c\u3070\u8a08\u7b97\u3067\u304d\u308b\n\n\"\"\"\n\n\n\nN, L, T = list(map(int, readline().split()))\n\nXW = np.array(read().split(), np.int64)\n\nX = XW[::2]\n\nW = XW[1::2]\n\n\n\nspeed = np.where(W == 1, 1, -1)\n\n\n\nY = X + speed * T\n\n\n\nn = (Y \/\/ L - X \/\/ L).sum()\n\nn %= N\n\n\n\nY %= L\n\nY.sort()\n\nY = np.concatenate((Y[n:], Y[:n]))\n\n\n\nprint(('\\n'.join(map(str, Y.tolist()))))","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\nN, L, T = map(int, input().split())\n\nXW = [tuple(map(int, input().split())) for _ in range(N)]\n\nX, W = zip(*XW)\n\nDX = [1 if w == 1 else -1 for w in W]\n\nY = [(x + dx * T) % L for x, dx in zip(X, DX)]\ny0 = Y[0]\nY.sort()\n\n# Calculate the number of ants that have crossed each other\ncrossed_ants = sum((x0 - x + L) \/\/ L * dx0 * dy for x0, dx0, x, dy in zip(X[:-1], DX[:-1], X[1:], DX[1:]))\n\n# Calculate the final position of ant number 1\nx = (x0 + crossed_ants) % N\n\n# Find the index of the first occurrence of y0 in the sorted Y array\ni = Y.index(y0)\n\n# Construct the answer array\nanswer = Y[i:i + N - x] + Y[:x]\n\nprint('\\n'.join(map(str, answer)))"}
{"problem_id":"p02688","slow_code_col":"N, K = list(map(int, input().split()))\n\nsunuke = [True]*N\n\nfor i in range(K):\n\n    d = int(eval(input()))\n\n    A = list(map(int, input().split()))\n\n    for a in A:\n\n        sunuke[a-1] = False\n\n\n\nans = 0\n\nfor i in range(N):\n\n    if sunuke[i]:\n\n        ans += 1\n\nprint(ans)","reference_code_col":"N, K = list(map(int, input().split()))\n\nflag = [True]*N\n\nfor i in range(K):\n\n    d = int(eval(input()))\n\n    A = list(map(int, input().split()))\n\n    for a in A:\n\n        flag[a-1] = False\n\nans = 0\n\nfor i in range(N):\n\n    if flag[i]:\n\n        ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"N, K = map(int, input().split())\n\n# Initialize a set to keep track of sunukes\nsunuke = set(range(1, N + 1))\n\nfor _ in range(K):\n    d = int(input())\n    A = set(map(int, input().split()))\n    \n    # Remove sunukes from the set\n    sunuke -= A\n\n# The remaining elements in the set are the sunukes\nans = len(sunuke)\n\nprint(ans)"}
{"problem_id":"p02937","slow_code_col":"import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    S = readline().strip()\n\n    T = readline().strip()\n\n\n\n    idx_in_S = []\n\n    last_idx = 0\n\n    for t in T:\n\n        t_idx = S.find(t, last_idx) + 1\n\n        if t_idx:\n\n            idx_in_S.append(t_idx)\n\n            last_idx = t_idx\n\n        else:\n\n            t_idx = S.find(t, 0, last_idx) + 1\n\n            if not t_idx:\n\n                print((-1))\n\n                exit()\n\n            else:\n\n                idx_in_S.append(t_idx)\n\n                last_idx = t_idx\n\n\n\n    \n\n    rep = 0\n\n    for i in range(len(T) - 1):\n\n        if idx_in_S[i] < idx_in_S[i+1]:\n\n            continue\n\n        else:\n\n            rep += 1\n\n\n\n    ans = len(S) * rep + idx_in_S[-1]\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"# S.find()\u306e\u90e8\u5206\u3092\u9ad8\u901f\u5316\u3059\u308b\n\nfrom collections import defaultdict\n\nfrom bisect import bisect_right\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\ndef main():\n\n    S = readline().strip()\n\n    T = readline().strip()\n\n\n\n    S_idx = defaultdict(list)\n\n    for i, s in enumerate(S):\n\n        S_idx[s].append(i)\n\n    \n\n    rep = 0\n\n    last_idx = -1\n\n    for t in T:\n\n        t_idx_list = S_idx[t]\n\n        if t_idx_list:\n\n            t_idx = bisect_right(t_idx_list, last_idx)\n\n            if t_idx < len(t_idx_list):\n\n                last_idx = t_idx_list[t_idx]\n\n            else:\n\n                last_idx = t_idx_list[0]\n\n                rep += 1\n\n        else:\n\n            print((-1))\n\n            exit()\n\n    \n\n    ans = len(S) * rep + last_idx + 1\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef main():\n    S = readline().strip()\n    T = readline().strip()\n\n    # Create a dictionary to store the indices of each character in S\n    char_indices = {}\n    for i, char in enumerate(S):\n        if char not in char_indices:\n            char_indices[char] = []\n        char_indices[char].append(i)\n\n    idx_in_S = []\n    last_idx = -1\n    for t in T:\n        if t in char_indices:\n            # Find the next index of t after last_idx\n            next_index = bisect_right(char_indices[t], last_idx)\n            if next_index < len(char_indices[t]):\n                idx_in_S.append(char_indices[t][next_index] + 1)\n                last_idx = char_indices[t][next_index]\n            else:\n                # If no such index exists, print -1 and exit\n                print(-1)\n                return\n        else:\n            # If t is not found in S, print -1 and exit\n            print(-1)\n            return\n\n    rep = 0\n    for i in range(len(T) - 1):\n        if idx_in_S[i] < idx_in_S[i + 1]:\n            continue\n        else:\n            rep += 1\n\n    ans = len(S) * rep + idx_in_S[-1]\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03796","slow_code_col":"import sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef resolve():\n\n    import math\n\n    n=int(eval(input()))\n\n    print((math.factorial(n)%(10**9+7)))\n\nresolve()","reference_code_col":"import sys\n\ndef input(): return sys.stdin.readline().strip()\n\n\n\ndef resolve():\n\n    answer=1\n\n    n=int(eval(input()))\n\n    for i in range(1,n+1):\n\n        answer*=i\n\n        answer%=10**9+7\n\n    print(answer)\n\nresolve()","model_generated_potentially_faster_code_col":"import sys\n\ndef input(): return sys.stdin.readline().strip()\n\ndef resolve():\n    mod = 10 ** 9 + 7\n    n = int(input())\n    \n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % mod\n        \n    print(result)\n\nresolve()"}
{"problem_id":"p03416","slow_code_col":"A,B = list(map(int,input().split()))\n\nj = 0\n\nfor i in range(A,B+1):\n\n  l = list(str(i))\n\n  l_reverse = list(reversed(l))\n\n  if l == l_reverse:\n\n    j += 1\n\nprint(j)","reference_code_col":"A, B = list(map(int,input().split()))\n\n\n\nans = 0\n\nfor n in range(A, B+1):\n\n    n = str(n)\n\n    if n == n[::-1]:\n\n        ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"A, B = map(int, input().split())\n\ncount = 0\n\nfor num in range(A, B + 1):\n    str_num = str(num)\n    if str_num == str_num[::-1]:\n        count += 1\n\nprint(count)"}
{"problem_id":"p02390","slow_code_col":"s = int(eval(input()))\n\nm, s = s \/\/ 60, s % 60\n\nh, m = m \/\/ 60, m % 60\n\nprint((':'.join(map(str, [h,m,s]))))","reference_code_col":"s = int(eval(input()))\n\n\n\nsecond = s % 60\n\ns = s \/\/ 60\n\nmin = s % 60\n\nhour = s \/\/ 60\n\n\n\nprint(f'{hour}:{min}:{second}')\n","model_generated_potentially_faster_code_col":"# Read input as string and convert to integer\ns = int(input())\n\n# Convert seconds to hours, minutes, and remaining seconds\nm, s = divmod(s, 60)\nh, m = divmod(m, 60)\n\n# Print the result in HH:MM:SS format\nprint(f\"{h}:{m:02}:{s:02}\")"}
{"problem_id":"p03796","slow_code_col":"import math\n\nN = int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))","reference_code_col":"import math\n\nN = int(eval(input()))\n\na = 1\n\nfor n in range(2,N+1):\n\n    a = a*n % (10**9+7)\n\nprint(a)","model_generated_potentially_faster_code_col":"N = int(eval(input()))\nmod = 10**9 + 7\n\ndef factorial(n):\n    result = 1\n    for i in range(2, n+1):\n        result = (result * i) % mod\n    return result\n\nprint(factorial(N))"}
{"problem_id":"p03162","slow_code_col":"import numpy as np\n\n\n\nn = int(eval(input()))\n\nX = np.array([input().split() for _ in range(n)], np.int64)\n\ndp = np.zeros((n + 1, 3), np.int64)\n\ndp[0, 0] = dp[0, 1] = dp[0, 2] = 0\n\nfor i in range(n):\n\n    for j in range(3):\n\n        dp[i + 1, j] = X[i, j] + max(dp[i, k] for k in range(3) if j != k)\n\nprint((max(dp[n])))","reference_code_col":"N = int(eval(input()))\n\nx, y, z = 0, 0, 0\n\nfor _ in range(N):\n\n    a, b, c = list(map(int, input().split()))\n\n    x, y, z = max(y, z) + a, max(z, x) + b, max(x, y) + c\n\nprint((max(x, y, z)))","model_generated_potentially_faster_code_col":"import numpy as np\n\nn = int(input())\nX = np.array([[int(x) for x in input().split()] for _ in range(n)], dtype=np.int64)\ndp = np.zeros((n + 1, 3), dtype=np.int64)\n\ndp[0, :] = 0\n\nfor i in range(n):\n    dp[i+1, :] = X[i, :] + np.maximum.reduceat(dp[i, :], np.arange(0, 3, 2))\n\nprint(max(dp[-1]))"}
{"problem_id":"p03819","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n  n, m = map(int, input().split())\n\n  LR = [list(map(int, input().split())) for _ in range(n)]\n\n  \n\n  BIT = [0]*(m+2)\n\n  def add(i, a):\n\n    while i <= m+1:\n\n      BIT[i] += a\n\n      i += i&(-i)\n\n  def bit_sum(i):\n\n    res = 0\n\n    while i > 0:\n\n      res += BIT[i]\n\n      i -= i&(-i)\n\n    return res\n\n  \n\n  S = sorted([(r-l+1, l, r) for l, r in LR], reverse=True)\n\n  cnt = n\n\n  L = []\n\n  for i in range(1, m+1):\n\n    while S and S[-1][0] == i:\n\n      c, l, r = S.pop()\n\n      cnt -= 1\n\n      add(l, 1)\n\n      add(r+1, -1)\n\n    res = cnt\n\n    for j in range(0, m+1, i):\n\n      res += bit_sum(j)\n\n    L.append(res)\n\n  print(*L, sep=\"\\n\")\n\n\n\nif __name__ == \"__main__\":\n\n  main()\n","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n  n, m = list(map(int, input().split()))\n\n  S = [[] for _ in range(m+1)]\n\n  for _ in range(n):\n\n    l, r = list(map(int, input().split()))\n\n    S[r-l+1].append((l, r))\n\n  \n\n  BIT = [0]*(m+2)\n\n  def add(i, a):\n\n    while i <= m+1:\n\n      BIT[i] += a\n\n      i += i&(-i)\n\n  def bit_sum(i):\n\n    res = 0\n\n    while i > 0:\n\n      res += BIT[i]\n\n      i -= i&(-i)\n\n    return res\n\n  cnt = n\n\n  for i in range(1, m+1):\n\n    for l, r in S[i]:\n\n      cnt -= 1\n\n      add(l, 1)\n\n      add(r+1, -1)\n\n    res = cnt\n\n    for j in range(0, m+1, i):\n\n      res += bit_sum(j)\n\n    print(res)\n\n\n\nif __name__ == \"__main__\":\n\n  main()","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.read\ndata = input().split()\n\ndef main():\n    index = 0\n    \n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    LR = []\n    for _ in range(n):\n        l = int(data[index])\n        r = int(data[index + 1])\n        index += 2\n        LR.append((l, r))\n    \n    # Sort intervals by length in descending order\n    S = sorted(LR, key=lambda x: x[1] - x[0], reverse=True)\n    \n    BIT = [0] * (m + 2)\n    \n    def add(i, a):\n        while i <= m + 1:\n            BIT[i] += a\n            i += i & (-i)\n    \n    def bit_sum(i):\n        res = 0\n        while i > 0:\n            res += BIT[i]\n            i -= i & (-i)\n        return res\n    \n    cnt = n\n    L = []\n    \n    for i in range(1, m + 1):\n        while S and S[-1][1] - S[-1][0] + 1 == i:\n            l, r = S.pop()\n            cnt -= 1\n            add(l, 1)\n            add(r + 1, -1)\n        \n        res = cnt\n        \n        for j in range(0, m + 1, i):\n            res += bit_sum(j)\n        \n        L.append(res)\n    \n    print(*L, sep=\"\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03078","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nx, y, z, k = map(int, sys.stdin.readline().split())\n\na, b, c = (np.array(sys.stdin.readline().split(), dtype=np.int64) for _ in range(3))\n\n\n\ndef main():\n\n    res = np.sort(np.ravel(a[:, None] + b))[::-1]\n\n    res = np.sort(np.ravel(c[:, None] + res[:min(k, x*y)]))[::-1]\n\n    return res[:k]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(*ans, sep='\\n')\n","reference_code_col":"import sys\n\n\n\nx, y, z, K = map(int, sys.stdin.readline().split())\n\na, b, c = (sorted(map(int, sys.stdin.readline().split()), reverse=True) for _ in range(3))\n\ndef main():\n\n    res = []\n\n    for i in range(1, min(K, x) + 1):\n\n        for j in range(1, min(K \/\/ i, y) + 1):\n\n            for k in range(1, min(K \/\/ (i * j), z) + 1):\n\n                res.append(a[i-1] + b[j-1] + c[k-1])\n\n\n\n    return sorted(res, reverse=True)[:K]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(*ans, sep='\\n')\n","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Read input values\nx, y, z, k = map(int, sys.stdin.readline().split())\na, b, c = (np.array(sys.stdin.readline().split(), dtype=np.int64) for _ in range(3))\n\ndef main():\n    # Combine a and b and sort in descending order\n    ab_sum = a[:, None] + b\n    ab_sorted = np.sort(ab_sum, axis=None)[::-1]\n    \n    # Combine c with the top min(k, x*y) elements from ab_sorted and sort in descending order\n    combined = c[:, None] + ab_sorted[:min(k, x * y)]\n    final_result = np.sort(combined, axis=None)[::-1]\n    \n    return final_result[:k]\n\nif __name__ == '__main__':\n    ans = main()\n    print(*ans, sep='\\n')"}
{"problem_id":"p03126","slow_code_col":"import functools\n\nprint((len(functools.reduce(lambda x, y: x&y,[set(input().split()[1:]) for _ in [0]*int(input().split()[0])]))))","reference_code_col":"print((len(set.intersection(*[set(input().split()[1:]) for _ in [0]*int(input().split()[0])]))))","model_generated_potentially_faster_code_col":"from functools import reduce\nimport operator\n\nn = int(input())\nsets = [set(map(int,input().split()[1:])) for _ in range(n)]\nresult = reduce(operator.and_, sets)\nprint(len(result))"}
{"problem_id":"p03371","slow_code_col":"# https:\/\/atcoder.jp\/contests\/abc095\/tasks\/arc096_a\n\n\"\"\"\n\n\u5225\u89e3(\u5b9a\u6570\u6642\u9593)\n\nhttps:\/\/atcoder.jp\/contests\/abc095\/submissions\/10226556\n\n\"\"\"\n\n\n\nA,B,C,X,Y = list(map(int,input().split()))\n\n\n\nans = float(\"inf\")\n\n\n\n# AB\u30d4\u30b6\u30922\u679a1\u7d44\u3067\u8003\u3048\u308b -> AB\u30bb\u30c3\u30c8\n\n# i: AB\u30bb\u30c3\u30c8\u306e\u500b\u6570\n\nfor i in range(10**5 + 1):\n\n    ans = min(ans, i*(2*C) + max(0, X-i)*A + max(0, Y-i)*B)\n\n\n\nprint(ans)","reference_code_col":"A,B,C,X,Y = list(map(int,input().split()))\n\n\n\nAB_set = C * 2\n\n\n\nans = min(A*X + B*Y, AB_set*max(X,Y), AB_set*min(X,Y) + A*abs(X-min(X,Y)) + B*abs(Y-min(X,Y)))\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"A, B, C, X, Y = map(int, input().split())\n\nmin_val = min(X, Y)\n\nif min_val == 0:\n    print(min(A * X, B * Y))\nelse:\n    cost1 = min_val * 2 * C + (X - min_val) * A + (Y - min_val) * B\n    cost2 = X * A + Y * B\n    print(min(cost1, cost2))"}
{"problem_id":"p02748","slow_code_col":"def mi():return list(map(int,input().split()))\n\nimport numpy as np\n\nA,B,M=mi()\n\na=np.array(list(mi()))\n\nb=np.array(list(mi()))\n\nminab=min(a)+min(b)\n\n\n\nans=float(\"inf\")\n\n\n\nfor i in range(M):\n\n    x,y,c=mi()\n\n    tmp=a[x-1]+b[y-1]-c\n\n    ans=min(ans,tmp)\n\nprint((min(ans,minab)))\n","reference_code_col":"def mi():return list(map(int,input().split()))\n\nA,B,M=mi()\n\na=list(mi())\n\nb=list(mi())\n\nans=min(a)+min(b)\n\nfor _ in range(M):\n\n    x,y,c=mi()\n\n    ans=min(ans,a[x-1]+b[y-1]-c)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read all inputs at once\ninputs = input().split()\nA = int(inputs[0])\nB = int(inputs[1])\nM = int(inputs[2])\n\na = np.array([int(x) for x in inputs[3:A+3]])\nb = np.array([int(x) for x in inputs[A+3:]])\n\nmin_ab = min(a) + min(b)\n\nans = float(\"inf\")\n\nfor _ in range(M):\n    x, y, c = map(int, input().split())\n    tmp = a[x-1] + b[y-1] - c\n    ans = min(ans, tmp)\n\nprint(min(ans, min_ab))"}
{"problem_id":"p02994","slow_code_col":"import numpy as np\n\nn,l = list(map(int,input().split()))\n\ntaste = np.array([l+i-1 for i in range(1,n+1)])\n\ntaste[np.fabs(taste).argmin()]=0\n\nprint((taste.sum()))","reference_code_col":"n,l = list(map(int,input().split()))\n\ntaste = [l+i for i in range(0,n)]\n\ntaste.sort(key=lambda x:abs(x))\n\nprint((sum(taste[1:])))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn, l = map(int, input().split())\n\n# Precompute the taste array\nbase_value = l - 1\ntaste = np.arange(base_value, base_value + n)\n\n# Find the index with the minimum absolute value and set it to zero\nmin_index = np.argmin(np.abs(taste))\ntaste[min_index] = 0\n\n# Print the sum of the taste array\nprint(taste.sum())"}
{"problem_id":"p03325","slow_code_col":"N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\n\n\nSUM = 0\n\nfor i in A:\n\n    count = 0\n\n    while i%2 == 0:\n\n        i\/\/=2\n\n        count += 1\n\n    SUM+=count\n\nprint(SUM)","reference_code_col":"N = int(eval(input()))\n\nA = list(map(int,input().split()))\n\nSUM = 0\n\nfor i in A:\n\n    while i%2 == 0:\n\n        i\/\/=2\n\n        SUM += 1\n\nprint(SUM)","model_generated_potentially_faster_code_col":"N = int(input())\nA = list(map(int, input().split()))\n\nSUM = 0\n\nfor i in A:\n    count = 0\n    while i & 1 == 0:  # Check if the least significant bit is 0 (i.e., if i is even)\n        i >>= 1  # Right shift i by 1 (equivalent to i \/\/= 2)\n        count += 1\n    SUM += count\n\nprint(SUM)"}
{"problem_id":"p03796","slow_code_col":"n = int(eval(input()))\n\n\n\nINF = 10**9 + 7\n\n\n\nans = [0] * (10**5 + 1)\n\nans[0] = 1\n\n\n\nfor i in range(1,10**5 + 1):\n\n    ans[i] = ans[i-1] * i % INF\n\n\n\nprint((ans[n]))\n","reference_code_col":"n = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\nans = 1\n\n\n\nfor i in range(1,n+1):\n\n    ans = ans * i % mod\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import math\n\nn = int(input())\n\nINF = 10**9 + 7\n\n# Calculate factorial modulo INF\nans = math.factorial(n) % INF\n\nprint(ans)"}
{"problem_id":"p03371","slow_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\nans = a * x + b * y\n\nm = max(x, y)\n\nfor i in range(1, m+1):\n\n  x -= 1\n\n  y -= 1\n\n  if x < 0:\n\n    x = 0\n\n  if y < 0:\n\n    y = 0\n\n  temp = c*(i*2) + x*a + y*b\n\n  if temp < ans:\n\n    ans = temp\n\n\n\nprint(ans)\n","reference_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\nans = a * x + b * y\n\nans = min(c * max(x, y) * 2, ans)\n\nif x < y:\n\n    ans = min(c * x * 2 + (y - x) * b, ans)\n\nelse:\n\n    ans = min(c * y * 2 + (x - y) * a, ans)\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\n\nans = a * x + b * y\n\nif x > y:\n    for i in range(y):\n        x -= 1\n        temp = c*(i*2) + x*a + y*b\n        if temp < ans:\n            ans = temp\nelse:\n    for i in range(x):\n        y -= 1\n        temp = c*(i*2) + x*a + y*b\n        if temp < ans:\n            ans = temp\n\nprint(ans)"}
{"problem_id":"p02881","slow_code_col":"import numpy as np\n\nN=int(eval(input()))\n\nroot=int(np.sqrt(N)\/\/1)\n\na=N\n\nb=N\n\nfor i in range(root, 0, -1):\n\n    if N%i==0:\n\n        a=i\n\n        b=N\/\/i\n\n        break\n\nprint((a-1+b-1))","reference_code_col":"N=int(eval(input()))\n\nroot=int((N**0.5)\/\/1)\n\na=N\n\nb=N\n\nfor i in range(root, 0, -1):\n\n    if N%i==0:\n\n        a=i\n\n        b=N\/\/i\n\n        break\n\nprint((a-1+b-1))\n","model_generated_potentially_faster_code_col":"import math\n\nN = int(input())\nroot = int(math.isqrt(N))\n\nfor i in range(root, 0, -1):\n    if N % i == 0:\n        print(i + N \/\/ i - 2)\n        break"}
{"problem_id":"p02952","slow_code_col":"n_str = eval(input())\n\nn_int = int(n_str)\n\n# 1 ~ 50000\n\n# \u6841\u6570\u304c\u5947\u6570= 1\u6841, 3\u6841, 5\u6841\n\n# 1 ~ 9, 100 ~ 999,10000 ~ 99999\u306e90909\u500b\u3057\u304b\u306a\u3044\u306e\u3067\u5168\u63a2\u7d22\u3044\u3051\u308b\u304b?\n\nexs_list = []\n\nfor i in range(1, 100000):\n\n    if len(str(i)) % 2 == 1:\n\n        exs_list.append(i)\n\n\n\nexs = {i: i for i in exs_list}\n\n\n\nn_s = []\n\nans = 0\n\nfor i in range(1, n_int + 1):\n\n    if len(str(i)) % 2 == 0:\n\n        continue\n\n    if i in exs:\n\n        ans += 1\n\n\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n","reference_code_col":"def digit_sum(n):\n\n    # \u5404\u6841\u306e\u548c\u3092\u6c42\u3081\u308b\n\n    # \u8a08\u7b97\u91cf: O(logN)\n\n    ans = 0\n\n    while n > 0:\n\n        ans += 1\n\n        n \/\/= 10\n\n    return ans\n\n\n\nn = int(eval(input()))\n\ncnt = 0\n\n\n\nfor i in range(1, n+1):\n\n    cnt += digit_sum(i) % 2\n\n\n\nprint(cnt)\n","model_generated_potentially_faster_code_col":"n_int = int(input())\n\n# Count numbers with odd digits from 1 to n_int\ncount = 0\n\nfor i in range(1, n_int + 1):\n    if len(str(i)) % 2 == 1:\n        count += 1\n\nprint(count)"}
{"problem_id":"p03162","slow_code_col":"# coding: utf-8\n\n\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef f(n, abc):\n\n    dp = [[0] * 3 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n\n        for j in range(3):\n\n            dp[i][j] = max(dp[i - 1][k] + abc[i - 1][j] \\\n\n                for k in range(3) if k != j)\n\n    return(max(dp[n]))\n\n\n\nn = int(eval(input()))    # 1 <= n <= 10^5\n\nabc = [list(map(int, input().rstrip().split())) for _ in range(n)]\n\n\n\nprint((f(n, abc)))\n","reference_code_col":"# coding: utf-8\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef f(n, abc):\n\n    dp = [0] * 3\n\n    for i in range(1, n + 1):\n\n        a, b, c = abc[i - 1]\n\n        dp = [ max(dp[1] + a, dp[2] + a), \\\n\n               max(dp[0] + b, dp[2] + b), \\\n\n               max(dp[0] + c, dp[1] + c) ]\n\n    return(max(dp))\n\n\n\nn = int(eval(input()))    # 1 <= n <= 10^5\n\nabc = [list(map(int, input().rstrip().split())) for _ in range(n)]\n\n\n\nprint((f(n, abc)))\n","model_generated_potentially_faster_code_col":"# coding: utf-8\n\nimport sys\n\ninput = sys.stdin.readline\n\ndef f(n, abc):\n    dp = [[0] * 3 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(3):\n            dp[i][j] = max(dp[i - 1][k] + abc[i - 1][j] for k in range(3) if k != j)\n\n    return max(dp[n])\n\n# Read input\nn = int(input())\nabc = [list(map(int, input().strip().split())) for _ in range(n)]\n\n# Call the function and print the result\nprint(f(n, abc))"}
{"problem_id":"p03162","slow_code_col":"N = int(eval(input()))\n\nABC = []\n\n\n\nfor n in range(N):\n\n  ABC.append(list(map(int, input().split())))\n\n\n\nimport numpy as np\n\nABC = np.array(ABC)\n\n\n\n## \u300c\u65e5\u4ed8\u300d\u3001\u300c\u9078\u629e\u3057\u305f\u884c\u52d5\u300d\u3054\u3068\u306e\u5e78\u798f\u5ea6\u306e\u6700\u5927\u5024\u3092\u683c\u7d0d\u3059\u308barray\n\nhp=np.zeros((N,3),dtype=int)\n\nhp[0] = ABC[0]\n\n\n\nfor n in range(1,N):# \u65e5\u5358\u4f4d\u3067\u306e\u30eb\u30fc\u30d7\n\n  for c in range(3): # \u9078\u629e\u80a2\u3054\u3068\u306e\u30eb\u30fc\u30d7\n\n    ## n\u65e5\u306bc\u3092\u9078\u629e\u3057\u305f\u5834\u5408\u306e\u5e78\u798f\u5ea6\u3002\u3064\u307e\u308a\u524d\u65e5\u306fc\u4ee5\u5916\u3092\u9078\u629e\u3057\u3066\u3044\u308b\n\n    if c == 0:\n\n      hp[n][0] = max(hp[n-1][1],hp[n-1][2]) + ABC[n][0]\n\n    elif c == 1:\n\n      hp[n][1] = max(hp[n-1][0],hp[n-1][2]) + ABC[n][1]\n\n    elif c == 2:\n\n      hp[n][2] = max(hp[n-1][0],hp[n-1][1]) + ABC[n][2]\n\n\n\n\n\nans = max(hp[-1])\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\n\n\ndpa,dpb,dpc = 0,0,0\n\nfor n in range(N):\n\n  a,b,c = list(map(int, input().split()))  \n\n  dpa,dpb,dpc = max(dpb+a,dpc+a),max(dpa+b,dpc+b),max(dpa+c,dpb+c)\n\n  \n\nans = max(dpa,dpb,dpc)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN = int(input())\nABC = []\n\nfor _ in range(N):\n    ABC.append(list(map(int, input().split())))\n\nABC = np.array(ABC)\n\n# Initialize happiness array\nhp = np.zeros((N, 3), dtype=int)\nhp[0] = ABC[0]\n\n# Fill the happiness array\nfor n in range(1, N):\n    hp[n] = np.maximum(hp[n-1][:n-1], hp[n-1][n+1:]) + ABC[n]\n\n# Find the maximum happiness value\nans = np.max(hp[-1])\nprint(ans)"}
{"problem_id":"p02595","slow_code_col":"N, D = list(map(int, input().split()))\n\npoint = []\n\nfor i in range(N):\n\n    point.append(list(map(int, input().split())))\n\n\n\nct = 0\n\nD2 = D * D\n\nfor i in point:\n\n    if (i[0]**2 + i[1]**2) <= D2:\n\n        ct += 1\n\n\n\nprint(ct)","reference_code_col":"N, D = list(map(int, input().split()))\n\n\n\nct = 0\n\nD2 = D * D\n\nfor i in range(N):\n\n    X, Y = list(map(int, input().split()))\n\n    if (X**2 + Y**2) <= D2:\n\n        ct += 1\n\n\n\nprint(ct)","model_generated_potentially_faster_code_col":"N, D = map(int, input().split())\n\npoints = [tuple(map(int, input().split())) for _ in range(N)]\n\nct = sum((x**2 + y**2) <= D*D for x, y in points)\n\nprint(ct)"}
{"problem_id":"p02767","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tN = II()\n\n\tX = LI()\n\n\tX = np.array(X, dtype=\"int32\")\n\n\tm = round(np.sum(X) \/ N)\n\n\tprint(int(np.sum((X-m)**2)))\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n","reference_code_col":"import sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tN = II()\n\n\tX = LI()\n\n\tX = np.array(X)\n\n\tm = round(np.sum(X) \/ N)\n\n\tprint(int(np.sum((X-m)**2)))\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\nprintV = lambda x: print(*x, sep=\"\\n\")\nprintH = lambda x: print(\" \".join(map(str, x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\ndef LII(rows_number): return [II() for _ in range(rows_number)]\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\ndef main():\n    N = II()\n    X = LI()\n    X = np.array(X, dtype=\"int32\")\n    \n    # Calculate the mean using NumPy's built-in function\n    m = np.mean(X)\n    \n    # Calculate the sum of squared differences from the mean\n    result = np.sum((X - m) ** 2)\n    \n    # Print the result\n    print(int(result))\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03162","slow_code_col":"N = int(eval(input()))\n\na = [list(map(int,input().split())) for _ in range(N)]\n\n\n\ndp = [[0]*3 for _ in range(100010)] \n\n# dp[i][j] : i\u65e5\u76ee\u306bj\u756a\u76ee\u306e\u6d3b\u52d5\u3092\u3057\u305f\u3068\u304d\u306e\u5e78\u798f\u5ea6\u306e\u7dcf\u548c\n\nidx = [[1,2],[2,0],[0,1]]\n\n\n\nfor i in range(3):\n\n    dp[0][i] = a[0][i]\n\n    \n\nfor i in range(1,N):\n\n    for j in range(3):\n\n        dp[i][j] = max(dp[i-1][idx[j][0]],dp[i-1][idx[j][1]])+a[i][j]\n\n    \n\nprint((max(dp[N-1])))","reference_code_col":"import sys\n\ndef input():\n\n    return sys.stdin.readline()[:-1]\n\n\n\nN = int(eval(input()))\n\nABC = [list(map(int,input().split())) for _ in range(N)]\n\n\n\ninf = 10**9+7\n\ndp = [[0] * 3 for _ in range(N+10)]\n\ndp[0] = [ABC[0][0],ABC[0][1],ABC[0][2]]\n\n\n\nfor i in range(N-1):\n\n    for j in range(3):\n\n        for k in range(3):\n\n            if j==k:continue\n\n            dp[i+1][j] = max(dp[i+1][j],dp[i][k]+ABC[i+1][j])\n\n        \n\n    \n\n\n\nprint((max(dp[N-1][:])))\n","model_generated_potentially_faster_code_col":"N = int(input())\n\na = [list(map(int,input().split())) for _ in range(N)]\n\ndp = [[0]*3 for _ in range(N)]\n\n# dp[i][j] : i\u65e5\u76ee\u306bj\u756a\u76ee\u306e\u6d3b\u52d5\u3092\u3057\u305f\u3068\u304d\u306e\u5e78\u798f\u5ea6\u306e\u7dcf\u548c\n\nidx = [[1,2],[2,0],[0,1]]\n\nfor i in range(3):\n    dp[0][i] = a[0][i]\n\nfor i in range(1,N):\n    for j in range(2,-1,-1):\n        dp[i][j] = max(dp[i-1][idx[j][0]],dp[i-1][idx[j][1]]) + a[i][j]\n\nprint(max(dp[N-1]))"}
{"problem_id":"p02850","slow_code_col":"n=int(eval(input()))\n\nnode={i:[] for i in range(1,n+1)}\n\nvisited=[False for i in range(n+1)]\n\nq=[]\n\nfor _ in range(n-1):\n\n    a,b=list(map(int,input().split()))\n\n    node[a].append(b)\n\n    node[b].append(a)\n\n    q.append((a,b))\n\n\n\nmother=q[0][0]\n\nvisited[mother]=True\n\n\n\nd=[]\n\ne=[]\n\n\n\n\n\npaint={i:{} for i in range(1,n+1)}\n\n\n\nmother_paint=[0 for i in range(n+1)]\n\n\n\n#\u4f7f\u3046\u8981\u7d20 node visited paint mother_paint \u306e\u56db\u3064\u306e\u30ea\u30b9\u30c8\n\nc=1\n\nfor child in node[mother]:\n\n    visited[child]=True\n\n    paint[mother][child]=c\n\n    paint[child][mother]=c\n\n    mother_paint[child]=c\n\n    c+=1\n\n    d.append(child)\n\n    \n\nwhile d:\n\n    for parent in d:\n\n        p=1 \n\n        for child in node[parent]:\n\n            if visited[child]==False:\n\n                visited[child]=True\n\n                if p!=mother_paint[parent]:\n\n                    paint[parent][child]=p\n\n                    paint[child][parent]=p\n\n                    mother_paint[child]=p\n\n                    p+=1\n\n                    e.append(child)\n\n                else:\n\n                    p+=1\n\n                    paint[parent][child]=p\n\n                    paint[child][parent]=p\n\n                    mother_paint[child]=p\n\n                    p+=1\n\n                    e.append(child)\n\n    if e:\n\n        d=e\n\n        e=[]\n\n    else:\n\n        d=[]\n\n        e=[]\n\nK=0\n\nfor i in range(1,n+1):\n\n    K=max(K,len(node[i]))\n\nprint(K)\n\nfor i in range(n-1):\n\n    s,t=q[i][0],q[i][1]\n\n    print((paint[s][t]))","reference_code_col":"#problem1\n\nfrom collections import deque\n\nd=deque()\n\ne=deque()\n\n\n\nN=int(eval(input()))\n\ngraph=[[] for i in range(N+1)]\n\nD=[]\n\nfor _ in range(N-1):\n\n    a,b=list(map(int,input().split()))\n\n    graph[a].append(b)\n\n    graph[b].append(a)\n\n    D.append((a,b))\n\n    \n\n#\u9802\u70b91\u304b\u3089\u30b9\u30bf\u30fc\u30c8\n\nK=0\n\nd.append(1)\n\nvisited=[False for i in range(N+1)]\n\ncolor=[-1 for i in range(N+1)]\n\nvisited[1]=True\n\ncolor[1]=-1\n\ndic={}\n\nwhile d:\n\n    while d:\n\n        x=d.popleft()\n\n        par_color=color[x]\n\n        c=1\n\n        for node in graph[x]:\n\n            if visited[node]==False:\n\n                visited[node]=True\n\n                e.append(node)                \n\n                if c!=par_color:\n\n                    color[node]=c\n\n                    dic[(x,node)]=c\n\n                elif c==par_color:\n\n                    c+=1\n\n                    color[node]=c\n\n                    dic[(x,node)]=c\n\n                c+=1\n\n    if e:\n\n        d=e\n\n        e=deque()\n\n\n\nA=max(color)\n\nprint(A)\n\nfor que in D:\n\n    a,b=que\n\n    if (a,b) in list(dic.keys()):\n\n        print((dic[que]))\n\n    else:\n\n        print((dic[(b,a)]))\n\n    ","model_generated_potentially_faster_code_col":"n = int(input())\n\nnode = {i: [] for i in range(1, n + 1)}\nvisited = [False] * (n + 1)\nq = []\n\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    node[a].append(b)\n    node[b].append(a)\n    q.append((a, b))\n\nmother = q[0][0]\nvisited[mother] = True\n\nd = []\ne = []\n\npaint = {i: {} for i in range(1, n + 1)}\nmother_paint = [0] * (n + 1)\n\nc = 1\nfor child in node[mother]:\n    visited[child] = True\n    paint[mother][child] = c\n    paint[child][mother] = c\n    mother_paint[child] = c\n    c += 1\n    d.append(child)\n\nwhile d:\n    for parent in d:\n        p = 1\n        for child in node[parent]:\n            if child not in visited:\n                visited[child] = True\n                if p != mother_paint[parent]:\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n                else:\n                    p += 1\n                    paint[parent][child] = p\n                    paint[child][parent] = p\n                    mother_paint[child] = p\n                    p += 1\n                    e.append(child)\n    if e:\n        d = e\n        e = []\n    else:\n        break\n\nK = max(len(node[i]) for i in range(1, n + 1))\nprint(K)\n\nfor i in range(n - 1):\n    s, t = q[i][0], q[i][1]\n    print(paint[s][t])"}
{"problem_id":"p03796","slow_code_col":"from math import factorial\n\n\n\nmod = 10**9 + 7\n\nn = int(eval(input()))\n\n\n\nans = factorial(n) % mod\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nMOD = 10**9 + 7\n\nans = 1\n\nfor i in range(2, N+1):\n\n    ans *= i\n\n    ans %= MOD\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"mod = 10**9 + 7\nn = int(input())\n\n# Initialize result\nres = 1\n  \n# Multiply res with each number in range [1, n]\nfor i in range(2, n+1):\n    res = (res * i) % mod \n\nprint(res)"}
{"problem_id":"p02555","slow_code_col":"# import sys\n\n# sys.setrecursionlimit(10 ** 6)\n\n# import bisect\n\n# from collections import deque\n\n\n\ndef cmb(n, r):\n\n    \"\"\"\u7d44\u307f\u5408\u308f\u305b\"\"\"\n\n    import math\n\n    if n < r:\n\n        return 0\n\n    return math.factorial(n) \/\/ (math.factorial(n - r) * math.factorial(r))\n\n\n\n\n\n# from decorator import stop_watch\n\n#\n\n#\n\n# @stop_watch\n\ndef solve(S):\n\n    mod = 10 ** 9 + 7\n\n    ans = 0\n\n    for i in range(1, S \/\/ 3 + 1):\n\n        tama = i + (S - (i * 3))\n\n        tama -= 2\n\n        bo = i - 1\n\n        ans += cmb(tama + 1, bo)\n\n        ans %= mod\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    # S = input()\n\n    S = int(eval(input()))\n\n    # N, M = map(int, input().split())\n\n    # Ai = [int(i) for i in input().split()]\n\n    # Bi = [int(i) for i in input().split()]\n\n    # ABi = [[int(i) for i in input().split()] for _ in range(N)]\n\n    solve(S)\n\n\n\n    # # test\n\n    # from random import randint\n\n    # from func import random_str\n\n    # solve()\n","reference_code_col":"# \u89e3\u8aac\u3092\u53c2\u8003\u306b\u4f5c\u6210\n\n# import sys\n\n# sys.setrecursionlimit(10 ** 6)\n\n# import bisect\n\n# from collections import deque\n\n# from decorator import stop_watch\n\n#\n\n#\n\n# @stop_watch\n\ndef solve(S):\n\n    mod = 10 ** 9 + 7\n\n    dp = [0] * (S + 1)\n\n    dp[0] = 1\n\n    for i in range(3, S + 1):\n\n        dp[i] = dp[i - 1] + dp[i - 3]\n\n        dp[i] %= mod\n\n    print((dp[S]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    S = int(eval(input()))\n\n    solve(S)\n\n\n\n    # # test\n\n    # from random import randint\n\n    # from func import random_str\n\n    # solve()\n","model_generated_potentially_faster_code_col":"import math\n\nmod = 10 ** 9 + 7\n\ndef precompute_factorials(limit):\n    factorials = [1] * (limit + 1)\n    inv_factorials = [1] * (limit + 1)\n    for i in range(1, limit + 1):\n        factorials[i] = factorials[i - 1] * i % mod\n        inv_factorials[i] = pow(factorials[i], mod - 2, mod)\n    return factorials, inv_factorials\n\nfactorials, inv_factorials = precompute_factorials(10**6)\n\ndef cmb(n, r):\n    if n < r:\n        return 0\n    return (factorials[n] * inv_factorials[r] * inv_factorials[n - r]) % mod\n\ndef solve(S):\n    ans = 0\n    for i in range(1, S \/\/ 3 + 1):\n        tama = i + (S - (i * 3))\n        tama -= 2\n        bo = i - 1\n        ans += cmb(tama + 1, bo)\n        ans %= mod\n    print(ans)\n\nif __name__ == '__main__':\n    S = int(eval(input()))\n    solve(S)"}
{"problem_id":"p03078","slow_code_col":"import heapq\n\n\n\nx, y, z, k = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\n\n\ndef diff(l):\n\n    m = max(l)\n\n    return sorted(m - v for v in l)[1:]\n\n\n\ns = sum(map(max, [a, b, c]))\n\nsa, sb, sc = list(map(diff, [a, b, c]))\n\nda, db, dc = [0], [0], [0]\n\nq = [0]\n\nwhile k > 0:\n\n    while True:\n\n        if len(sa) > 0 and (len(q) == 0 or q[0] > sa[0]):\n\n            for v in [sa[0] + bb + cc for bb in db for cc in dc]:\n\n                heapq.heappush(q, v)\n\n            da.append(sa[0])\n\n            sa = sa[1:]\n\n        elif len(sb) > 0 and (len(q) == 0 or q[0] > sb[0]):\n\n            for v in [sb[0] + aa + cc for aa in da for cc in dc]:\n\n                heapq.heappush(q, v)\n\n            db.append(sb[0])\n\n            sb = sb[1:]\n\n        elif len(sc) > 0 and (len(q) == 0 or q[0] > sc[0]):\n\n            for v in [sc[0] + aa + bb for aa in da for bb in db]:\n\n                heapq.heappush(q, v)\n\n            dc.append(sc[0])\n\n            sc = sc[1:]\n\n        else:\n\n            break\n\n    v = heapq.heappop(q)\n\n    print(s - v)\n\n    k -= 1\n","reference_code_col":"import heapq\n\n\n\nx, y, z, k = list(map(int, input().split()))\n\na = sorted(map(int, input().split()))\n\nb = sorted(map(int, input().split()))\n\nc = sorted(map(int, input().split()))\n\n\n\nq = []\n\nmemo = set()\n\ndef qpush(q, ai, bi, ci):\n\n    t = (-(a[ai] + b[bi] + c[ci]), ai, bi, ci)\n\n    if not t in memo:\n\n        memo.add(t)\n\n        heapq.heappush(q, t)\n\n\n\nqpush(q, len(a) - 1, len(b) - 1, len(c) - 1)\n\nfor _ in range(k):\n\n    s, ai, bi, ci = heapq.heappop(q)\n\n    if ai > 0:\n\n        qpush(q, ai - 1, bi, ci)\n\n    if bi > 0:\n\n        qpush(q, ai, bi - 1, ci)\n\n    if ci > 0:\n\n        qpush(q, ai, bi, ci - 1)\n\n    print(-s)\n","model_generated_potentially_faster_code_col":"import heapq\n\n# Read input\nx, y, z, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\n# Function to calculate differences excluding the maximum element\ndef diff(l):\n    m = max(l)\n    return sorted([m - v for v in l if v != m])\n\n# Calculate initial sums and differences\ns = sum(max(a), max(b), max(c))\nsa, sb, sc = diff(a), diff(b), diff(c)\nda, db, dc = [], [], []\n\n# Initialize min-heap with the first possible values\nq = [(max(a), max(b), max(c))]\n\nfor _ in range(k):\n    # Get the smallest candidate from the heap\n    aa, bb, cc = heapq.heappop(q)\n    \n    # Print the result\n    print(s - (aa + bb + cc))\n    \n    # Generate new candidates\n    if sa:\n        heapq.heappush(q, (aa + sa[0], bb, cc))\n        da.append(aa)\n        sa.pop(0)\n    if sb:\n        heapq.heappush(q, (aa, bb + sb[0], cc))\n        db.append(bb)\n        sb.pop(0)\n    if sc:\n        heapq.heappush(q, (aa, bb, cc + sc[0]))\n        dc.append(cc)\n        sc.pop(0)"}
{"problem_id":"p02837","slow_code_col":"N = int(eval(input()))\n\nA = [0]*N\n\nX = []\n\nY = []\n\nfor i in range(N):\n\n    A[i] = int(eval(input()))\n\n    X.append([])\n\n    Y.append([])\n\n    for j in range(A[i]):\n\n        x, y = list(map(int, input().split()))\n\n        X[i].append(x-1)\n\n        Y[i].append(y)\n\nans = 0\n\nfor bit in range(1<<N):\n\n    honest = 0\n\n    ok = True\n\n    for i in range(N):\n\n        if bit&(1<<i):\n\n            honest += 1\n\n            for j in range(A[i]):\n\n                if Y[i][j] == 0:\n\n                    if bit&(1<<X[i][j]):\n\n                        ok = False\n\n                        break\n\n                else:\n\n                    if not bit&(1<<X[i][j]):\n\n                        ok = False\n\n                        break\n\n            if not ok:\n\n                break\n\n    if ok:\n\n        ans = max(ans, honest)\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nXY = [[] for _ in range(N)]\n\nfor i in range(N):\n\n    A = int(eval(input()))\n\n    for _ in range(A):\n\n        x, y = list(map(int, input().split()))\n\n        XY[i].append((x-1,y))\n\nans = 0\n\nfor bit in range(1<<N):\n\n    cnt = bin(bit).count('1')\n\n    ok = True\n\n    for i in range(N):\n\n        if bit&(1<<i):\n\n            for x,y in XY[i]:\n\n                if y == 1:\n\n                    if not bit&(1<<x):\n\n                        ok = False\n\n                        break\n\n                else:\n\n                    if bit&(1<<x):\n\n                        ok = False\n\n                        break\n\n            if not ok:\n\n                break\n\n    if ok:\n\n        ans = max(ans, cnt)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input\nN = int(input())\n\n# Initialize variables\nA = np.zeros(N, dtype=int)\nX = []\nY = []\n\nfor i in range(N):\n    A[i] = int(input())\n    X.append([])\n    Y.append([])\n    for _ in range(A[i]):\n        x, y = map(int, input().split())\n        X[-1].append(x - 1)\n        Y[-1].append(y)\n\n# Function to check if a configuration is valid\ndef is_valid(bitmask):\n    honest = np.sum(bitmask)\n    for i in range(N):\n        if bitmask[i]:\n            for j in range(A[i]):\n                if Y[i][j] == 0:\n                    if bitmask[X[i][j]]:\n                        return False\n                else:\n                    if not bitmask[X[i][j]]:\n                        return False\n    return True\n\n# Find the maximum number of honest vertices\nmax_honest = 0\nfor bit in range(1 << N):\n    if is_valid(np.array([bool(bit & (1 << i)) for i in range(N)])):\n        max_honest = max(max_honest, np.sum(np.array([bool(bit & (1 << i)) for i in range(N)])))\n\nprint(max_honest)"}
{"problem_id":"p02773","slow_code_col":"from collections import Counter\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef solve():\n\n    N = int(eval(input()))\n\n    Sss = [input().rstrip() for _ in range(N)]\n\n\n\n    cnt = Counter(Sss)\n\n    #print('cnt:', cnt)\n\n\n\n    maxNum = max(cnt.values())\n\n    #print('maxNum:', maxNum)\n\n\n\n    anss = []\n\n    for key, value in list(cnt.items()):\n\n        if value == maxNum:\n\n            anss.append(key)\n\n    #print('anss:', anss)\n\n\n\n    anss.sort()\n\n\n\n    print(('\\n'.join(anss)))\n\n\n\n\n\nsolve()\n","reference_code_col":"from collections import Counter\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nN = int(eval(input()))\n\nSss = [input().rstrip() for _ in range(N)]\n\n\n\ncnt = Counter(Sss)\n\n\n\nnum = max(cnt.values())\n\n\n\nanss = []\n\nfor key in sorted(cnt.keys()):\n\n    if cnt[key] == num:\n\n        anss.append(key)\n\n\n\nprint(('\\n'.join(anss)))\n","model_generated_potentially_faster_code_col":"from collections import Counter\n\nimport sys\n\ninput = sys.stdin.readline\n\ndef solve():\n    N = int(input())\n    \n    # Read all lines at once and strip them\n    Sss = [line.rstrip() for line in input().splitlines()]\n    \n    cnt = Counter(Sss)\n    \n    maxNum = max(cnt.values())\n    \n    # Collect keys with the maximum count\n    anss = (key for key, value in cnt.items() if value == maxNum)\n    \n    # Sort and print the result\n    print('\\n'.join(sorted(anss)))\n\nsolve()"}
{"problem_id":"p03796","slow_code_col":"import math\n\nn = int(eval(input()))\n\n\n\nans = math.factorial(n)  # n\u306e\u968e\u4e57\u3092\u8a08\u7b97\n\n\n\nif ans >= (10 ** 9)+7:\n\n    ans = ans % ((10 ** 9)+7)\n\n\n\nprint(ans)\n","reference_code_col":"n = int(eval(input()))\n\n\n\nans = 1\n\nfor i in range(1, n+1):\n\n    ans = ans * i\n\n    ans = ans % ((10 ** 9)+7)  # \u9014\u4e2d\u3067\u5272\u308a\u7b97\u306e\u4f59\u308a\u3092\u6c42\u3081\u3066\u3082\u3001\u6700\u7d42\u7d50\u679c\u306f\u540c\u3058\u306b\u306a\u308b\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"from functools import reduce\nimport operator\n\nn = int(eval(input()))\n\nans = reduce(operator.mul, range(1, n + 1), 1)\n\nif ans >= (10 ** 9) + 7:\n    ans %= (10 ** 9) + 7\n\nprint(ans)"}
{"problem_id":"p02278","slow_code_col":"\"\"\"Minimum cost Sort.\"\"\"\n\n\n\ndef min_cost_sort(A):\n\n    \"\"\"Sort list A in ascending order.\n\n \n\n    And return the switching cost in sorting.\n\n    \"\"\"\n\n    B = list(A)\n\n    B.sort()\n\n    cost = 0\n\n    min_w = B[0]\n\n    for i, b in enumerate(B):\n\n        tmp_cost = 0\n\n        bi = A.index(b)\n\n        n = 1\n\n        while bi != i:\n\n            n += 1\n\n            st = B[bi]\n\n            si = A.index(st)\n\n            tmp_cost += b + st\n\n            A[bi], A[si] = st, b\n\n            bi = si\n\n        dec = (n - 1) * (b - min_w)\n\n        inc = 2 * (min_w + b)\n\n        if dec < inc:\n\n            cost += tmp_cost\n\n        else:\n\n            cost += tmp_cost - dec + inc\n\n    return cost\n\n\n\n\n\nn = eval(input())\n\n\n\nA = list(map(int, input().split()))\n\n\n\nans = min_cost_sort(A)\n\n\n\nprint(ans)","reference_code_col":"\"\"\"Minimum cost Sort.\"\"\"\n\n\n\ndef min_cost_sort(A):\n\n    \"\"\"Sort list A in ascending order.\n\n \n\n    And return the switching cost in sorting.\n\n    \"\"\"\n\n    B = list(A)\n\n    B.sort()\n\n    cost = 0\n\n    min_w = B[0]\n\n    for i, b in enumerate(B):\n\n        tmp_cost = 0\n\n        bi = A.index(b)\n\n        cnt = 0\n\n        while bi != i:\n\n            cnt += 1\n\n            st = B[bi]\n\n            si = A.index(st)\n\n            tmp_cost += b + st\n\n            A[bi], A[si] = st, b\n\n            bi = si\n\n        if cnt:\n\n            dec = cnt * (b - min_w)\n\n            inc = 2 * (min_w + b)\n\n            if dec < inc:\n\n                cost += tmp_cost\n\n            else:\n\n                cost += tmp_cost - dec + inc\n\n    return cost\n\n\n\n\n\nn = eval(input())\n\n\n\nA = list(map(int, input().split()))\n\n\n\nans = min_cost_sort(A)\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"def min_cost_sort(A):\n    B = sorted(A)\n    n = len(A)\n    cost = 0\n    min_w = B[0]\n    \n    # Create a dictionary to store the index of each element in A\n    index_map = {val: idx for idx, val in enumerate(A)}\n    \n    for i in range(n):\n        b = B[i]\n        bi = index_map[b]\n        \n        if bi == i:\n            continue\n        \n        tmp_cost = 0\n        n = 1\n        visited = set()\n        current = bi\n        \n        while current not in visited:\n            visited.add(current)\n            st = B[current]\n            si = index_map[st]\n            \n            tmp_cost += b + st\n            \n            A[current], A[si] = st, b\n            \n            current = si\n            n += 1\n        \n        dec = (n - 1) * (b - min_w)\n        inc = 2 * (min_w + b)\n        \n        if dec < inc:\n            cost += tmp_cost\n        else:\n            cost += tmp_cost - dec + inc\n    \n    return cost\n\n# Input reading\nn = int(input())\nA = list(map(int, input().split()))\n\nans = min_cost_sort(A)\nprint(ans)"}
{"problem_id":"p02982","slow_code_col":"import math\n\nimport numpy as np\n\n\n\nn, d = list(map(int, input().split()))\n\n\n\nx = np.zeros([n, d])\n\n\n\nfor i in range(n):\n\n    line = list(map(int, input().split()))\n\n    for j in range(d):\n\n        x[i, j] = line[j]\n\n\n\ncnt = 0\n\n\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        xx = (x[i] - x[j]) ** 2\n\n        dist = math.sqrt(xx.sum())\n\n        if dist % 1 == 0:\n\n            cnt += 1\n\n\n\nprint(cnt)","reference_code_col":"import math\n\n\n\nn, d = list(map(int, input().split()))\n\n\n\nx = [list(map(int, input().split())) for i in range(n)]\n\n\n\ncnt = 0\n\n\n\nfor i in range(n):\n\n    for j in range(i+1, n):\n\n        dist = 0\n\n        for k in range(d):\n\n            dist += (x[i][k] - x[j][k]) ** 2\n\n        if math.sqrt(dist).is_integer():\n\n            cnt += 1\n\n\n\nprint(cnt)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nn, d = map(int, input().split())\npoints = np.array([list(map(int, input().split())) for _ in range(n)])\n\n# Initialize count of integer distances\ncount = 0\n\n# Iterate over all unique pairs of points\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Calculate squared Euclidean distance\n        diff = points[i] - points[j]\n        dist_squared = np.dot(diff, diff)\n\n        # Check if distance is an integer\n        if np.isclose(np.sqrt(dist_squared), int(np.sqrt(dist_squared))):\n            count += 1\n\nprint(count)"}
{"problem_id":"p02555","slow_code_col":"from functools import lru_cache\n\nimport sys\n\n\n\nsys.setrecursionlimit(2000)\n\n\n\ns = int(eval(input()))\n\nmod = 10 ** 9 + 7\n\n\n\n\n\n@lru_cache(maxsize=None)\n\ndef dfs(n):\n\n    if n <= 2:\n\n        return 0\n\n    elif 3<=n<=5:\n\n        return 1\n\n    else:\n\n        count = 1\n\n        for i in range(3, n + 1):\n\n            count += dfs(n - i)\n\n            count %= mod\n\n\n\n        return count % mod\n\n\n\n\n\nans = dfs(s)\n\nprint(ans)\n","reference_code_col":"s = int(eval(input()))\n\nmod = 10 ** 9 + 7\n\n\n\ndp = [0] * (s + 1)\n\ndp[0] = 1\n\n\n\nx = 0\n\nfor i in range(3, s + 1):\n\n    x += dp[i - 3]\n\n    dp[i] = x % mod\n\n\n\nans = dp[s] % mod\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"from typing import List\n\n\ndef dp_solution(n: int) -> int:\n    mod = 10**9 + 7\n    dp = [0] * (n+1)\n    dp[3], dp[4], dp[5] = 1, 1, 1\n\n    for i in range(6, n+1):\n        dp[i] = sum(dp[i-j] for j in range(3, i)) % mod\n\n    return dp[n]\n\n\nif __name__ == '__main__':\n    s = int(input())\n    print(dp_solution(s))"}
{"problem_id":"p03457","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nplan = np.array([[0, 0, 0]] + [list(map(int, input().split())) for i in range(N)])\n\n\n\ndiff = np.diff(plan, axis = 0)\n\n\n\ndef is_possible(t, x, y):\n\n    if (t + x + y) % 2 == 0 and abs(x) + abs(y) <= t:\n\n        return True\n\n    else:\n\n        return False\n\n\n\nfor i in range(N):\n\n    ti, xi, yi = diff[i]\n\n    if not is_possible(ti, xi, yi):\n\n        print('No')\n\n        exit()\n\nprint('Yes')","reference_code_col":"N = int(eval(input()))\n\nplan = [[0, 0, 0]] + [list(map(int, input().split())) for _ in range(N)]\n\ndiff = [[plan[i + 1][j] - plan[i][j] for j in range(3)] for i in range(N)]\n\n\n\ndef is_possible(t, x, y):\n\n    if (t + x + y) % 2 == 0 and abs(x) + abs(y) <= t:\n\n        return True\n\n    else:\n\n        return False\n\n\n\nfor i in range(N):\n\n    ti, xi, yi = diff[i]\n\n    if not is_possible(ti, xi, yi):\n\n        print('No')\n\n        exit()\n\nprint('Yes')","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nplan = np.array([[0, 0, 0]] + [list(map(int, input().split())) for i in range(N)])\n\ndiff = np.diff(plan, axis=0)\n\n# Precompute all possible moves within each time limit\nmoves = {}\nfor i in range(1, N):\n    ti, xi, yi = diff[i]\n    for t in range(1, ti+1):\n        if (ti + xi + yi) % 2 == 0 and abs(xi) + abs(yi) <= t:\n            if t not in moves:\n                moves[t] = []\n            moves[t].append((xi, yi))\n\n# Check if each move is possible\nfor i in range(N-1):\n    ti, xi, yi = diff[i]\n    if (ti, xi, yi) not in moves[ti]:\n        print('No')\n        exit()\nprint('Yes')"}
{"problem_id":"p03721","slow_code_col":"n,k = list(map(int,input().split()))\n\nnum = 0\n\nq = []\n\nfor i in range(n):\n\n    a,b = list(map(int,input().split()))\n\n    q.append((a,b))\n\nq.sort()\n\nfor i in range(n):\n\n    a, b = q[i][0], q[i][1]\n\n    num += b\n\n    if num >= k:\n\n        print(a)\n\n        exit()\n\n\n","reference_code_col":"n,k = list(map(int,input().split()))\n\ncnt = 0\n\nnum = []\n\nfor i in range(n):\n\n    a,b = list(map(int,input().split()))\n\n    num.append((a,b))\n\nnum.sort()\n\nfor i in range(n):\n\n    cnt += num[i][1]\n\n    if cnt >= k:\n\n        print((num[i][0]))\n\n        exit()","model_generated_potentially_faster_code_col":"import heapq\n\nn, k = map(int, input().split())\n\nnum = 0\nmin_heap = []\n\nfor _ in range(n):\n    a, b = map(int, input().split())\n    heapq.heappush(min_heap, (a, b))\n\nwhile min_heap:\n    a, b = heapq.heappop(min_heap)\n    num += b\n    if num >= k:\n        print(a)\n        exit()"}
{"problem_id":"p03197","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nfrom collections import *\n\n\n\ndef dfs(x, y):\n\n    if x==0 and y==0:\n\n        t[x][y] = False\n\n        return False\n\n    \n\n    if x>=1:\n\n        t[x][y] |= not dfs(x-1, y)\n\n        \n\n    if y>=1:\n\n        t[x][y] |= not dfs(x, y-1)\n\n        \n\n    if min(x, y)>=1:\n\n        t[x][y] |= not dfs(x-1, y-1)\n\n   \n\n    return t[x][y]\n\n    \n\nt = [[False]*7 for _ in range(7)]\n\n\n\nfor i in range(7):\n\n    for j in range(7):\n\n        dfs(i, j)\n\n\n\n\"\"\"\n\nfor ti in t:\n\n    print(*ti)\n\n\"\"\"\n\n\n\nN = int(eval(input()))\n\nflag = True\n\n\n\nfor _ in range(N):\n\n    a = int(eval(input()))\n\n    \n\n    if a%2==1:\n\n        flag = False\n\n        \n\nif flag:\n\n    print('second')\n\nelse:\n\n    print('first')","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\n\"\"\"\n\ndef dfs(x, y):\n\n    if x==0 and y==0:\n\n        return False\n\n        \n\n    res = False\n\n    \n\n    if x>0:\n\n        res |= not dfs(x-1, y)\n\n    \n\n    if y>0:\n\n        res |= not dfs(x, y-1)\n\n    \n\n    if min(x, y)>0:\n\n        res |= not dfs(x-1, y-1)\n\n    \n\n    return res\n\n    \n\nt = [[False]*5 for _ in range(5)]\n\n\n\nfor i in range(5):\n\n    for j in range(5):\n\n        t[i][j] = dfs(i, j)\n\n\n\nfor ti in t:\n\n    print(*ti)\n\n\"\"\"\n\n\n\nN = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\nfor ai in a:\n\n    if ai%2==1:\n\n        print('first')\n\n        exit()\n\n\n\nprint('second')","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.read\ndata = input().split()\n\n# Read the number of queries\nN = int(data[0])\nqueries = list(map(int, data[1:]))\n\n# Memoization dictionary to store results of DFS\nmemo = {}\n\ndef dfs(x, y):\n    if (x, y) in memo:\n        return memo[(x, y)]\n    \n    if x == 0 and y == 0:\n        memo[(x, y)] = False\n        return False\n    \n    result = False\n    \n    if x >= 1:\n        result |= not dfs(x - 1, y)\n    \n    if y >= 1:\n        result |= not dfs(x, y - 1)\n    \n    if x >= 1 and y >= 1:\n        result |= not dfs(x - 1, y - 1)\n    \n    memo[(x, y)] = result\n    return result\n\n# Precompute the results for all positions\nresults = [[dfs(i, j) for j in range(7)] for i in range(7)]\n\n# Check the queries\nflag = True\n\nfor a in queries:\n    if a % 2 == 1:\n        flag = False\n\nif flag:\n    print('second')\nelse:\n    print('first')"}
{"problem_id":"p03416","slow_code_col":"a,b=list(map(int, input().split()))\n\ncnt=0\n\nfor i in range(a,b+1):\n\n    n=list(str(i))\n\n    if n==list(reversed(n)):\n\n        cnt+=1\n\nprint(cnt)","reference_code_col":"from sys import stdin\n\nnii=lambda:list(map(int,stdin.readline().split()))\n\nlnii=lambda:list(map(int,stdin.readline().split()))\n\n\n\na,b=nii()\n\nans=0\n\nfor i in range(a,b+1):\n\n  s=str(i)\n\n  if s==s[::-1]:\n\n    ans+=1\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import math\n\na, b = list(map(int, input().split()))\ncnt = 0\n\n# Check for even-length palindromes\nfor i in range(10**(len(str(a))-1), 10**len(str(b))):\n    s = str(i)\n    if s == s[::-1]:\n        cnt += 2 * (b \/\/ i - (i-1) \/\/ i)\n\n# Check for odd-length palindromes\nfor i in range(10**(len(str(a))\/\/2), 10**(len(str(b))\/\/2 + 1)):\n    s = str(i)\n    for j in range(10):\n        num = int(s + str(j) + s[::-1])\n        if a <= num <= b:\n            cnt += 1\n\nprint(cnt)"}
{"problem_id":"p02881","slow_code_col":"# a+b-2\n\n# N = a*b  \u3088\u3063\u3066N\u306e\u7d04\u6570\u3092\u6c42\u3081\u308b\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nU = 10**6+100\n\nx = np.arange(1, U, dtype=np.int64)\n\ndiv = x[N%x==0]\n\nans = (div + N\/\/div).min() - 2\n\nprint(ans)","reference_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 7)\n\nread = sys.stdin.buffer.read \n\ninput = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines  \n\n\n\ndef make_divisors(n):\n\n    divisors = []\n\n    for i in range(1, int(n**0.5)+1):\n\n        if n % i == 0:\n\n            divisors.append((i, n\/\/i))\n\n            \n\n    # divisors.sort()\n\n    return divisors\n\n\n\nN = int(eval(input()))\n\ndiv = make_divisors(N)\n\n\n\nans = 10**15\n\nfor a, b in div:\n\n  ans = min(ans, a+b-2)\n\nprint(ans)  \n\n\n","model_generated_potentially_faster_code_col":"import math\n\ndef min_divisor_sum(N):\n    min_sum = float('inf')\n    \n    # Iterate up to the square root of N\n    for i in range(1, int(math.sqrt(N)) + 1):\n        if N % i == 0:\n            # Both i and N\/i are divisors\n            sum_divisors = i + N \/\/ i\n            if sum_divisors < min_sum:\n                min_sum = sum_divisors\n    \n    return min_sum - 2\n\nN = int(input())\nprint(min_divisor_sum(N))"}
{"problem_id":"p02994","slow_code_col":"import sys\n\nimport numpy as np \n\n\n\nn, l = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    f = l + np.arange(1, n+1) - 1\n\n    s = f.sum()\n\n    a = np.absolute(f)\n\n    mi = np.amin(a)\n\n    i = np.argwhere(a == mi)[0, 0]\n\n    return s - f[i]\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","reference_code_col":"import sys\n\n\n\nn, l = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    s = (l - 1) * n + (1 + n) * n \/\/ 2\n\n    res = []\n\n    for i in range(1, n+1):\n\n        f = l + i - 1\n\n        res.append((abs(f), s - f))\n\n    \n\n    res.sort()\n\n    return res[0][1]\n\n\n\nif __name__=='__main__':\n\n    ans = main()\n\n    print(ans)","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\nn, l = map(int, sys.stdin.readline().split())\n\ndef main():\n    # Create a NumPy array from the input values directly\n    arr = np.array([l] + list(range(1, n + 1)) - 1)\n\n    # Compute the sum and absolute values in one go\n    total_sum = arr.sum()\n    abs_values = np.abs(arr)\n\n    # Find the minimum absolute value and its index\n    min_abs_value = abs_values.min()\n    min_index = np.where(abs_values == min_abs_value)[0][0]\n\n    # Return the result\n    return total_sum - arr[min_index]\n\nif __name__ == '__main__':\n    ans = main()\n    print(ans)"}
{"problem_id":"p02982","slow_code_col":"# coding: utf-8\n\nimport numpy as np\n\nn, d = list(map(int, input().split()))\n\ncnt = 0\n\nX = []\n\nfor i in range(n):\n\n    x = list(map(int, input().split()))\n\n    X.append(x[:])\n\nX = np.array(X)\n\nfor i in range(n):\n\n    X_tmp = X[:]\n\n    X_tmp -= X[i]\n\n    for i in range(n):\n\n        x = X_tmp[i]\n\n        x_sq = x**2\n\n        x_sq = np.sqrt(sum(x_sq))\n\n        if x_sq % 1 == 0:\n\n            cnt += 1\n\nprint(((cnt-n)\/\/2))","reference_code_col":"# coding: utf-8\n\nN, D = list(map(int, input().split()))\n\nX = []\n\nans = 0\n\nfor i in range(N):\n\n    X.append(list(map(int, input().split())))\n\nfor i in range(N):\n\n    for j in range(N):\n\n        dist = 0\n\n        if i == j:\n\n            continue\n\n        for d in range(D):\n\n            dist += ((X[i][d] - X[j][d])**2)\n\n        if dist**0.5 == int(dist**0.5):\n\n            ans += 1\n\nprint((ans\/\/2))","model_generated_potentially_faster_code_col":"# coding: utf-8\n\nimport numpy as np\n\nn, d = map(int, input().split())\n\ncnt = 0\n\n# Read all input data into a single NumPy array\nX = np.array([list(map(int, input().split())) for _ in range(n)])\n\n# Compute the squared distances from each point to every other point\ndist_squared = np.sum((X[:, np.newaxis] - X) ** 2, axis=2)\n\n# Check which distances are perfect squares\nperfect_squares = np.isclose(np.sqrt(dist_squared), dist_squared.astype(int))\n\n# Count the number of valid pairs (i, j) such that dist(i, j) is a perfect square\nvalid_pairs = perfect_squares.sum() \/\/ 2  # Each pair (i, j) is counted twice\n\n# Subtract n to exclude self-pairs and divide by 2 to get unique pairs\nresult = (valid_pairs - n) \/\/ 2\n\nprint(result)"}
{"problem_id":"p03078","slow_code_col":"def d_cake_123_binary_search(X, Y, Z, K, A, B, C):\n\n    # editional\u306e\u89e3\u6cd54 O(K^2log(max(P))\n\n    # \u53c2\u8003: https:\/\/atcoder.jp\/contests\/abc123\/submissions\/4871511\n\n    import bisect\n\n    ab = sorted([e1 + e2 for e2 in B for e1 in A])  # A, B\u306e\u8981\u7d20\u306f\u5168\u90e8\u8abf\u3079\u308b\n\n\n\n    # rejected \u4ee5\u4e0a\u306e\u5024\u306f\u3001\u7f8e\u5473\u3057\u3055\u306e\u5408\u8a08\u304c\u305d\u308c\u4ee5\u4e0a\u3067\u3042\u308b\u500b\u6570\u304cK\u500b\u672a\u6e80\u3067\u3042\u308b\n\n    accepted, rejected = -1, 10**11\n\n    while abs(accepted - rejected) > 1:\n\n        mid = (accepted + rejected) \/\/ 2\n\n        count = sum([len(ab) - bisect.bisect_left(ab, mid - e) for e in C])\n\n        if count >= K:\n\n            accepted = mid\n\n        else:\n\n            rejected = mid\n\n\n\n    ans = []\n\n    for e in C:\n\n        idx = bisect.bisect_left(ab, accepted - e)\n\n        for i in range(idx, len(ab)):\n\n            ans.append(e + ab[i])\n\n    ans.sort(reverse=True)\n\n    return '\\n'.join(map(str, ans[:K]))\n\n\n\nX, Y, Z, K = [int(i) for i in input().split()]\n\nA = [int(i) for i in input().split()]\n\nB = [int(i) for i in input().split()]\n\nC = [int(i) for i in input().split()]\n\nprint((d_cake_123_binary_search(X, Y, Z, K, A, B, C)))","reference_code_col":"def d_cake_123_sort_modified():\n\n    \"\"\"editorial \u306e\u89e3\u6cd5 1.\"\"\"\n\n    import sys\n\n    import numpy as np\n\n    input = sys.stdin.readline\n\n    X, Y, Z, K = [int(i) for i in input().split()]\n\n    A = np.array([int(i) for i in input().split()])\n\n    B = np.array([int(i) for i in input().split()])\n\n    C = np.array([int(i) for i in input().split()])\n\n\n\n    _a, _b = np.meshgrid(A, B)\n\n    ab = np.sort((_a + _b).flatten())[::-1][:K]\n\n    _ab, _c = np.meshgrid(ab, C)\n\n    ans = np.sort((_ab + _c).flatten())[::-1][:K]\n\n    return '\\n'.join(map(str, ans))\n\n\n\nprint((d_cake_123_sort_modified()))","model_generated_potentially_faster_code_col":"def d_cake_123_binary_search(X, Y, Z, K, A, B, C):\n    ab_sum = sorted(a + b for a in A for b in B)\n    \n    accepted, rejected = -1, max(ab_sum)\n    \n    while abs(accepted - rejected) > 1:\n        mid = (accepted + rejected) \/\/ 2\n        count = sum(mid <= s for s in ab_sum)\n        \n        if count >= K:\n            accepted = mid\n        else:\n            rejected = mid\n    \n    ans = []\n    for c in C:\n        idx = bisect.bisect_left(ab_sum, accepted - c)\n        for i in range(idx, len(ab_sum)):\n            if ab_sum[i] <= accepted:\n                ans.append(c + ab_sum[i])\n            else:\n                break\n    \n    ans.sort(reverse=True)\n    return '\\n'.join(map(str, ans[:K]))"}
{"problem_id":"p03796","slow_code_col":"import math\n\nN = int(eval(input()))\n\np = math.factorial(N)\n\nprint((p % 1000000007))","reference_code_col":"N = int(eval(input()))\n\np = 1\n\nfor i in range(1,N+1):\n\n    p *= i\n\n    p %= 1000000007\n\nprint(p)\n","model_generated_potentially_faster_code_col":"N = int(eval(input()))\nresult = 1\n\nfor i in range(2, N + 1):\n    result = (result * i) % 1000000007\n\nprint(result)"}
{"problem_id":"p02891","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\n \n\ns = input().rstrip()\n\nk = int(eval(input()))\n\n    \n\ndef check_count(s):\n\n    cnt_list = [1]\n\n    cnt = 1\n\n    for i in range(1, len(s)):\n\n        if s[i-1] == s[i]:\n\n            cnt_list[-1] += 1\n\n        else:\n\n            cnt_list.append(1)\n\n    return cnt_list\n\n\n\ndef calc_ans(cnt_list, k):\n\n    _ans = 0\n\n    for c in cnt_list:\n\n        _ans += c\/\/2\n\n    return(_ans * k)\n\n\n\nif len(s)==1:\n\n    ans = k\/\/2\n\nelse:\n\n    cnt_list = check_count(s)\n\n    if len(cnt_list)==1:\n\n        ans = (len(s)*k)\/\/2\n\n    else:\n\n        ans = calc_ans(cnt_list, k)\n\n        if s[0]==s[-1]:\n\n            if cnt_list[0]%2==1 and cnt_list[-1]%2==1:\n\n                ans += k - 1\n\n\n\nprint(ans)","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n \n\ns = input().rstrip()\n\nk = int(eval(input()))\n\n\n\ndef check_count(s):\n\n    cnt_list = []\n\n    cnt = 1\n\n    for i in range(1, len(s)):\n\n        if s[i-1] == s[i]:\n\n            cnt += 1\n\n        else:\n\n            cnt_list.append(cnt)\n\n            cnt = 1\n\n    if cnt>1:\n\n        cnt_list.append(cnt)\n\n    return cnt_list\n\n\n\ndef calc_ans(cnt_list, k):\n\n    _ans = 0\n\n    for c in cnt_list:\n\n        _ans += c\/\/2\n\n    return(_ans * k)\n\n\n\nif len(s)==1:\n\n    ans = k\/\/2\n\nelse:\n\n    cnt_list = check_count(s)\n\n    if len(cnt_list)==1:\n\n        ans = (len(s)*k)\/\/2\n\n    else:\n\n        ans = calc_ans(cnt_list, k)\n\n        if s[0]==s[-1]:\n\n            if cnt_list[0]%2==1 and cnt_list[-1]%2==1:\n\n                ans += k - 1\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\n# Read input\ns = input().rstrip()\nk = int(input())\n\n# Function to count consecutive characters\ndef check_count(s):\n    cnt_list = []\n    cnt = 1\n    for i in range(1, len(s)):\n        if s[i-1] == s[i]:\n            cnt += 1\n        else:\n            cnt_list.append(cnt)\n            cnt = 1\n    cnt_list.append(cnt)  # Append the last group\n    return cnt_list\n\n# Calculate the answer based on the count list and k\ndef calc_ans(cnt_list, k):\n    return sum(c \/\/ 2 for c in cnt_list) * k\n\n# Main logic\nif len(s) == 1:\n    ans = k \/\/ 2\nelse:\n    cnt_list = check_count(s)\n    if len(cnt_list) == 1:\n        ans = (len(s) * k) \/\/ 2\n    else:\n        ans = calc_ans(cnt_list, k)\n        if s[0] == s[-1]:\n            if cnt_list[0] % 2 == 1 and cnt_list[-1] % 2 == 1:\n                ans += k - 1\n\nprint(ans)"}
{"problem_id":"p02881","slow_code_col":"N = int(eval(input()))\n\n\n\n\n\ndef dist(i, j):\n\n    return i + j - 2\n\n\n\n\n\nmin = 10 ** 24\n\ni = 1\n\nwhile (i ** 2) <= N:\n\n    if 0 == N % i:\n\n        j = N \/\/ i\n\n        d = dist(i, j)\n\n        if min > d:\n\n            min = d\n\n    i += 1\n\nprint(d)\n","reference_code_col":"import math\n\nn = int(eval(input()))\n\n\n\nans = 0\n\nfor i in range(math.ceil(math.sqrt(n) + 1))[:0:-1]:\n\n    if 0 == n % i:\n\n        ans = i\n\n        break\n\nans_partner = n \/\/ ans\n\nprint((ans + ans_partner - 2))\n","model_generated_potentially_faster_code_col":"import math\n\nN = int(input())\n\nmin_dist = float('inf')\n\nfor i in range(1, int(math.sqrt(N)) + 1):\n    if N % i == 0:\n        j = N \/\/ i\n        dist = i + j - 2\n        if dist < min_dist:\n            min_dist = dist\n\nprint(min_dist)"}
{"problem_id":"p02552","slow_code_col":"n = int(eval(input()))\n\nprint((1 if n == 0 else 0))\n","reference_code_col":"n = int(eval(input()))\n\nprint((0 if n else 1))\n","model_generated_potentially_faster_code_col":"n = int(input())\nprint(1 if n == 0 else 0)"}
{"problem_id":"p02792","slow_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n# input = sys.stdin.readline    ####\n\nint1 = lambda x: int(x) - 1\n\ndef II(): return int(eval(input()))\n\n\n\ndef MI(): return list(map(int, input().split()))\n\ndef MI1(): return list(map(int1, input().split()))\n\n\n\ndef LI(): return list(map(int, input().split()))\n\ndef LI1(): return list(map(int1, input().split()))\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n\n\ndef printlist(lst, k='\\n'): print((k.join(list(map(str, lst)))))\n\nINF = float('inf')\n\n\n\nimport numpy as np\n\n\n\ndef solve():\n\n    n = II()\n\n    D = np.zeros((10, 10))\n\n\n\n    for i in range(1, n+1):\n\n        s = list(str(i))\n\n        l = int(s[0])\n\n        r = int(s[-1])\n\n        # print(s, l, r)\n\n        D[l][r] += 1\n\n    # print(D)\n\n\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += D[i][j] * D[j][i]\n\n    print((int(ans)))\n\n\n\nif __name__ == '__main__':\n\n    solve()\n","reference_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 6)\n\n# input = sys.stdin.readline    ####\n\nint1 = lambda x: int(x) - 1\n\ndef II(): return int(eval(input()))\n\n\n\ndef MI(): return list(map(int, input().split()))\n\ndef MI1(): return list(map(int1, input().split()))\n\n\n\ndef LI(): return list(map(int, input().split()))\n\ndef LI1(): return list(map(int1, input().split()))\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n\n\ndef printlist(lst, k='\\n'): print((k.join(list(map(str, lst)))))\n\nINF = float('inf')\n\n\n\ndef solve():\n\n    n = II()\n\n    D = [[0]*10 for _ in range(10)]\n\n\n\n    for i in range(1, n+1):\n\n        s = list(str(i))\n\n        l = int(s[0])\n\n        r = int(s[-1])\n\n        # print(s, l, r)\n\n        D[l][r] += 1\n\n    # print(D)\n\n\n\n    ans = 0\n\n    for i in range(10):\n\n        for j in range(10):\n\n            ans += D[i][j] * D[j][i]\n\n    print((int(ans)))\n\n\n\nif __name__ == '__main__':\n\n    solve()\n","model_generated_potentially_faster_code_col":"import sys\n\nint1 = lambda x: int(x) - 1\n\ndef II():\n    return int(input())\n\ndef MI():\n    return list(map(int, input().split()))\n\ndef MI1():\n    return list(map(int1, input().split()))\n\ndef LI():\n    return list(map(int, input().split()))\n\ndef LI1():\n    return list(map(int1, input().split()))\n\ndef LLI(rows_number):\n    return [LI() for _ in range(rows_number)]\n\ndef printlist(lst, k='\\n'):\n    print(k.join(list(map(str, lst))))\n\nINF = float('inf')\n\ndef solve():\n    n = II()\n    D = [[0] * 10 for _ in range(10)]\n\n    for i in range(1, n + 1):\n        s = str(i)\n        l = int(s[0])\n        r = int(s[-1])\n        D[l][r] += 1\n\n    ans = 0\n    for i in range(10):\n        for j in range(10):\n            ans += D[i][j] * D[j][i]\n\n    print(int(ans))\n\nif __name__ == '__main__':\n    solve()"}
{"problem_id":"p03039","slow_code_col":"import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)\/\/2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)\/\/2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        ans += f1(x,y,n,m)+f1(1,1,x,y)+f1(1,y,x,m)+f1(x,1,n,y)\n\n        ans -= f2(x,n) + f2(1,x) + f2(1,y) + f2(y,m)\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n","reference_code_col":"import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)\/\/2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)\/\/2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        a = n-x+1\n\n        b = m-y+1\n\n        c = m*(a*(a-1)+x*(x-1))\n\n        d = n*(b*(b-1)+y*(y-1))\n\n        ans += (c+d)\/\/2\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n","model_generated_potentially_faster_code_col":"import sys\n\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nmod = 10**9 + 7\nINF = 10**18\neps = 10**-7\n\nm, n, k = map(int, readline().split())\n\n# Precompute factorials and their modular inverses\nfactorial = [1] * (m * n + 1)\ninverse = [1] * (m * n + 1)\n\nfor i in range(1, m * n + 1):\n    factorial[i] = factorial[i - 1] * i % mod\n    inverse[i] = pow(factorial[i], mod - 2, mod)\n\ndef comb(n, r, mod):\n    if r > n:\n        return 0\n    return factorial[n] * inverse[r] % mod * inverse[n - r] % mod\n\ndef f1(x, y, a, b):\n    return (a + b - x - y) * (a - x + 1) * (b - y + 1) \/\/ 2\n\ndef f2(x, a):\n    return (a - x) * (a - x + 1) \/\/ 2\n\nans = 0\n\n# Store intermediate results\nf1_cache = [[0] * (m + 1) for _ in range(n + 1)]\nf2_cache = [0] * (n + 1)\n\nfor x in range(1, n + 1):\n    for y in range(1, m + 1):\n        if f1_cache[x][y] == 0:\n            f1_cache[x][y] = f1(x, y, n, m)\n        if f2_cache[x] == 0:\n            f2_cache[x] = f2(x, n)\n        \n        ans += f1_cache[x][y] + f1_cache[1][1] + f1_cache[1][y] + f1_cache[x][1]\n        ans -= f2_cache[x] + f2_cache[1] + f2_cache[y] + f2_cache[m]\n\nans %= mod\n\nans = (ans * comb(m * n - 2, k - 2, mod)) % mod\nans = ans * pow(2, mod - 2, mod) % mod\n\nprint(ans)"}
{"problem_id":"p02596","slow_code_col":"def c_repsept():\n\n    K = int(eval(input()))\n\n\n\n    if (K % 2 == 0 or K % 5 == 0):\n\n        return -1  # repsept \u306e\u56e0\u6570\u306b 2, 5 \u306f\u306a\u3044\n\n\n\n    repsept = 7 % K\n\n    count = 1\n\n    while repsept % K !=0:\n\n        repsept = ((repsept * 10) + 7) % K\n\n        count += 1\n\n    return count\n\n\n\nprint((c_repsept()))","reference_code_col":"def c_repsept():\n\n    K = int(eval(input()))\n\n\n\n    L = 9 * K \/\/ 7 if K % 7 == 0 else 9 * K\n\n    if L % 2 == 0 or L % 5 == 0:\n\n        return -1\n\n\n\n    remainder = 1\n\n    for n in range(1, L + 1):\n\n        remainder = (10 * remainder) % L\n\n        if remainder == 1:\n\n            return n\n\n    return -1\n\n\n\nprint((c_repsept()))","model_generated_potentially_faster_code_col":"def c_repsept():\n    K = int(input())\n\n    if (K % 2 == 0 or K % 5 == 0):\n        return -1  # repsept \u7684\u56e0\u6570\u306b 2, 5 \u306f\u306a\u3044\n\n    count = 1\n    repsept = 7 % K\n\n    while repsept != 1:\n        repsept = (repsept * 10 + 7) % K\n        count += 1\n\n    return count\n\nprint(c_repsept())"}
{"problem_id":"p03013","slow_code_col":"import sys\n\nsys.setrecursionlimit(10**7)\n\ndef lmi(): return list(map(int, input().split()))\n\n\n\nn, m = lmi()\n\n\n\nl = [0] * (n+1)\n\nl[0] = 1\n\n\n\na = 0\n\nif m != 0:\n\n    a = int(eval(input()))\n\nk = 1\n\nfor i in range(n+1):\n\n\n\n    if i != a:\n\n        if i == 1:\n\n            l[i] = 1\n\n        elif i >= 2:\n\n            l[i] = l[i-1] + l[i-2]\n\n            l[i] %= 1000000007\n\n    else:\n\n        k += 1\n\n        if k <= m:\n\n            a = int(eval(input()))\n\n\n\n\n\n\n\n#print(l)\n\nprint((l[n] % 1000000007))\n","reference_code_col":"import sys\n\nsys.setrecursionlimit(10**7)\n\ndef lmi(): return list(map(int, input().split()))\n\n\n\nn, m = lmi()\n\na = [1] * (n+1)\n\nfor i in range(m):\n\n    a[int(eval(input()))] = 0\n\nk = [0] * (n+1)\n\nk[0] = 1\n\nfor i in range(1,n+1):\n\n    if i == 1 and a[1]:\n\n        k[1] = 1\n\n    elif i >= 2 and a[i]:\n\n        k[i] = k[i-1] + k[i-2]\n\n        k[i] %= 10 ** 9 + 7\n\n\n\nprint((k[n]))\n","model_generated_potentially_faster_code_col":"import sys\n\nsys.stdin.reconfigure(encoding='utf-8')\nsys.stdout.reconfigure(encoding='utf-8')\n\nn, m = map(int, input().split())\n\na = 0\nif m != 0:\n    a = int(input())\n\n# Function to calculate nth Fibonacci number modulo mod_val\ndef fib_mod(n, mod_val):\n    if n == 0 or n == 1: \n        return 1\n    \n    prev, curr = 1, 1\n    for _ in range(2, n+1):\n        prev, curr = curr, (prev + curr) % mod_val\n    return curr\n\n# Calculate nth Fibonacci number modulo 10^9+7\nfib_n = fib_mod(n, 10**9+7)\n\n# If a is not equal to n, subtract 1 from fib_n\nif a != n:\n    fib_n -= 1\n\n# If a is within the first m numbers, increment fib_n\nif m > 0 and a < n:\n    fib_n += 1\n\nprint(fib_n % (10**9+7))"}
{"problem_id":"p02767","slow_code_col":"def c_rally():\n\n    import numpy as np\n\n    import math\n\n    N = int(eval(input()))\n\n    X = [int(i) for i in input().split()]\n\n    m = np.average(X)\n\n    ans = float('inf')\n\n    for j in (math.floor(m), math.ceil(m)):\n\n        ans = min(ans, sum([(x - j)**2 for x in X]))\n\n    return ans\n\n\n\nprint((c_rally()))","reference_code_col":"def c_rally():\n\n    N = int(eval(input()))\n\n    X = [int(i) for i in input().split()]\n\n\n\n    x_sum = sum(X)\n\n    option = (x_sum \/\/ N, (x_sum + N - 1) \/\/ N)\n\n    return min(sum([(x - p)**2 for x in X]) for p in option)\n\n\n\nprint((c_rally()))","model_generated_potentially_faster_code_col":"def c_rally():\n    import math\n    N = int(input())\n    X = [int(i) for i in input().split()]\n    total_sum = sum(X)\n    avg = total_sum \/ N\n    lower_avg = math.floor(avg)\n    upper_avg = math.ceil(avg)\n    ans = float('inf')\n    for j in (lower_avg, upper_avg):\n        ans = min(ans, sum([(x - j)**2 for x in X]))\n    return ans\n\nprint(c_rally())"}
{"problem_id":"p03013","slow_code_col":"N,M = list(map(int,input().split()))\n\nMOD = 10**9+7\n\ndp = [0]*(N+1)\n\ndp[0]=1\n\nA = [int(eval(input())) for i in range(M)]\n\nban = [1]*(N+1)\n\nfor a in A:\n\n    ban[a]=0\n\nfor i in range(N):\n\n    if i-1>=0:\n\n        dp[i+1]=dp[i]*ban[i]+dp[i-1]*ban[i-1]\n\n    else:\n\n        dp[i+1]=dp[i]*ban[i]\n\n    dp[i+1] %= MOD \n\nprint((dp[N]))","reference_code_col":"N,M = list(map(int,input().split()))\n\nA = [int(eval(input())) for i in range(M)]\n\nMOD = 10**9+7\n\nA = set(A)\n\ndp = [0]*(N+1)\n\ndp[0] = 1\n\nfor i in range(1,N+1):\n\n    if i in A:\n\n        continue\n\n    if i == 1:\n\n        dp[1] = dp[0]\n\n    else:\n\n        dp[i] = (dp[i-1]+dp[i-2])%MOD\n\nprint((dp[N]))","model_generated_potentially_faster_code_col":"def count_sequences(N, M, A):\n    MOD = 10**9 + 7\n    \n    # Convert A to a set for O(1) lookups\n    ban = {a: True for a in A}\n    \n    @lru_cache(None)\n    def dp(i, last):\n        if i == N:\n            return 1\n        \n        # If the current position is banned and it's not the first position\n        if ban.get(i, False) and i > 0:\n            return dp(i + 1, 0)\n        \n        # Count sequences ending at i with the last element being 0\n        result = dp(i + 1, 0)\n        \n        # Count sequences ending at i with the last element being 1\n        if not ban.get(i, False):\n            result += dp(i + 1, 1)\n        \n        return result % MOD\n    \n    # Start counting from position 0 with the last element being 0\n    return dp(0, 0)\n\n# Input reading\nN, M = map(int, input().split())\nA = [int(eval(input())) for _ in range(M)]\n\n# Output the result\nprint(count_sequences(N, M, A))"}
{"problem_id":"p03253","slow_code_col":"from math import sqrt, ceil, factorial\n\nfrom collections import defaultdict\n\n\n\n\n\ndef prime_factors(n):\n\n    i = 2\n\n    factors = defaultdict(int)\n\n    while i * i <= n:\n\n        if n % i:\n\n            i += 1\n\n        else:\n\n            n \/\/= i\n\n            factors[i] += 1\n\n    if n > 1:\n\n        factors[n] += 1\n\n    return factors\n\n\n\n\n\nN, M = [int(elem) for elem in input().split(' ')]\n\n\n\n# \u7d20\u56e0\u6570\u5206\u89e3\n\nprime_numbers = prime_factors(M)\n\nsum = 1\n\nfac_N_m1 = factorial(N - 1)\n\n\n\nfor value in list(prime_numbers.values()):\n\n    bunshi = 1\n\n    saisho = value + N - 1\n\n    for _ in range(value):\n\n        bunshi *= saisho\n\n        saisho -= 1\n\n    sum *= (bunshi \/\/ factorial(value))\n\nprint((sum % (10**9 + 7)))\n","reference_code_col":"from collections import defaultdict\n\n\n\n\n\ndef prime_factorize(num):\n\n    prime_numbers = defaultdict(int)\n\n    i = 2\n\n    while i * i <= num:\n\n        if num % i == 0:\n\n            while num % i == 0:\n\n                prime_numbers[i] += 1\n\n                num \/\/= i\n\n        i += 1\n\n    if num != 1:\n\n        prime_numbers[num] += 1\n\n    return prime_numbers\n\n\n\n\n\nMOD = 10**9 + 7\n\nN, M = [int(elem) for elem in input().split()]\n\n\n\nprime_numbers = prime_factorize(M)\n\n\n\nnum_sequences = 1\n\nfor exponent in list(prime_numbers.values()):\n\n    denomimator = 1\n\n    numerator = 1\n\n    for i in range(1, exponent + 1):\n\n        denomimator *= (N + exponent - i)\n\n        numerator *= i\n\n    num_sequences *= denomimator \/\/ numerator\n\n    num_sequences %= MOD\n\n\n\nprint(num_sequences)\n","model_generated_potentially_faster_code_col":"from math import sqrt, ceil\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef prime_factors(n):\n    factors = defaultdict(int)\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors[i] += 1\n            n \/\/= i\n        i += 1\n    if n > 1:\n        factors[n] += 1\n    return factors\n\ndef mod_inverse(a, m):\n    return pow(a, m - 2, m)\n\ndef mod_fact(n, m):\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % m\n    return fact\n\ndef mod_inv_fact(n, m):\n    inv_fact = [1] * (n + 1)\n    inv_fact[n] = mod_inverse(fact[n], m)\n    for i in range(n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % m\n    return inv_fact\n\nN, M = map(int, input().split())\n\n# \u7d20\u56e0\u6570\u5206\u89e3\nprime_numbers = prime_factors(M)\n\n# \u9884\u8ba1\u7b97\u9636\u4e58\u548c\u9006\u5143\u9636\u4e58\nfact = mod_fact(max(N, M), MOD)\ninv_fact = mod_inv_fact(max(N, M), MOD)\n\nsum_val = 1\nfor value in prime_numbers.values():\n    bunshi = 1\n    saisho = value + N - 1\n    for _ in range(value):\n        bunshi = bunshi * saisho % MOD\n        saisho -= 1\n    sum_val = sum_val * (bunshi * inv_fact[value] % MOD) % MOD\n\nprint(sum_val)"}
{"problem_id":"p03371","slow_code_col":"def main():\n\n    A, B, AB, X, Y = list(map(int, input().split()))\n\n    M = max(X, Y)\n\n\n\n    k = 0\n\n    ans = A * X + B * Y\n\n    while True:\n\n        ans = min(\n\n            ans,\n\n            AB * k * 2 + max(0, X - k) * A + max(0, Y - k) * B\n\n        )\n\n\n\n        if k >= M: break\n\n        k += 1\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def main():\n\n    A, B, C, X, Y = list(map(int, input().split()))\n\n\n\n    ans = 1 << 30\n\n    c = 0  # even\n\n    while True:\n\n        j = c \/\/ 2\n\n        t = A * max(0, X - j) + B * max(0, Y - j) + C * c\n\n        if ans <= t: break\n\n        ans = t\n\n        c += 2\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    A, B, AB, X, Y = map(int, input().split())\n    M = max(X, Y)\n    \n    # Initialize the answer with the initial cost\n    ans = A * X + B * Y\n    \n    # Iterate only up to the maximum of X and Y\n    for k in range(M):\n        # Calculate the new cost based on the current value of k\n        new_cost = AB * k * 2 + max(0, X - k) * A + max(0, Y - k) * B\n        \n        # Update the answer if the new cost is lower\n        ans = min(ans, new_cost)\n\n    print(ans)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02245","slow_code_col":"import sys\n\n\n\ninit = ''.join(sys.stdin.read().split())\n\n\n\n# Bidirectional search using breadth-first search\n\ndef solve(start, goal):\n\n    if start == goal:\n\n        return 0\n\n    generated_state = {start: 0, goal: 1}   # 0: foreward, 1: backward\n\n    step = {start: 0, goal: 0}\n\n    s = 0\n\n    c_d = [(start, 0), (goal, 1)] # configure and direction\n\n    while True:\n\n        q = iter(c_d)\n\n        c_d = []\n\n        s += 1\n\n        for c, d in q:\n\n            i = c.find('0')\n\n            if 0 <= i <= 5:\n\n                t = str.maketrans('0' + c[i+3], c[i+3] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n            if i >= 3:\n\n                t = str.maketrans('0' + c[i-3], c[i-3] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n            if i == 0 or i == 1 or i == 3 or i == 4 or i == 6 or i == 7:\n\n                t = str.maketrans('0' + c[i+1], c[i+1] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n            if i == 1 or i == 2 or i == 4 or i == 5 or i == 7 or i == 8:\n\n                t = str.maketrans('0' + c[i-1], c[i-1] + '0')\n\n                t_c = c.translate(t)\n\n                if t_c in generated_state:\n\n                    if generated_state[t_c] != d:\n\n                        return s + step[t_c]\n\n                else:\n\n                    generated_state[t_c] = d\n\n                    step[t_c] = s\n\n                    c_d.append((t_c, d))\n\n\n\nprint((solve(init, '123456780')))","reference_code_col":"adjacent = (\n\n    (1, 3),       # 0\n\n    (0, 2, 4),    # 1\n\n    (1, 5),       # 2\n\n    (0, 4, 6),    # 3\n\n    (1, 3, 5, 7), # 4\n\n    (2, 4, 8),    # 5\n\n    (3, 7),       # 6\n\n    (4, 6, 8),    # 7\n\n    (5, 7)        # 8\n\n)\n\n\n\nimport collections\n\n\n\nGOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n\n\n\n# Bidirectional search using breadth-first search\n\ndef solve(start):\n\n    if start == GOAL:\n\n        return 0\n\n    # 0: forward, 1: backward\n\n    generated_state = {tuple(start): 0, tuple(GOAL): 1}\n\n    step = {tuple(start): 0, tuple(GOAL): 0}\n\n    s = 0\n\n    state1 = [(start, 0), (GOAL, 1)]\n\n    while state1:\n\n        state2 = state1[:]\n\n        state1 = []\n\n        s += 1\n\n        for s2, d in state2:\n\n            i = s2.index(0)\n\n            for p in adjacent[i]:\n\n                s1 = s2[:]\n\n                s1[i], s1[p] = s1[p], 0\n\n                key = tuple(s1)\n\n                if key in generated_state:\n\n                    if generated_state[key] != d:\n\n                        return s + step[key]\n\n                    continue\n\n                state1.append((s1, d))\n\n                generated_state[key] = d\n\n                step[key] = s\n\n\n\nimport sys\n\n\n\nstart = list(map(int, sys.stdin.read().split()))\n\n\n\nprint((solve(start)))","model_generated_potentially_faster_code_col":"import sys\n\n\ninit = ''.join(sys.stdin.read().split())\n\n\ndef solve(start, goal):\n    if start == goal:\n        return 0\n\n    forward = {start: 0}\n    backward = {goal: 0}\n    steps = {start: 0, goal: 0}\n    queue = [(start, 0), (goal, 1)]\n    found = False\n\n    while queue and not found:\n        current, direction = queue.pop(0)\n        index = current.index('0')\n        moves = [(index - 1, index), (index + 1, index), (index - 3, index), (index + 3, index)]\n\n        for next_index, _ in moves:\n            if 0 <= next_index < len(current):\n                new_state = list(current)\n                new_state[index], new_state[next_index] = new_state[next_index], new_state[index]\n                new_state = ''.join(new_state)\n\n                if new_state in forward and forward[new_state] != direction:\n                    return steps[current] + steps[new_state] + 1\n                elif new_state not in forward:\n                    forward[new_state] = direction\n                    steps[new_state] = steps[current] + 1\n                    if direction == 0:\n                        queue.append((new_state, 1))\n                    else:\n                        queue.append((new_state, 0))\n\n    return -1\n\n\nprint(solve(init, '123456780'))"}
{"problem_id":"p03434","slow_code_col":"import numpy as np\n\n\n\nn=int(eval(input()))\n\na_list=list(map(int,input().split()))\n\na_list_2=sorted(a_list,reverse=True)\n\na=np.array(a_list_2,dtype='uint8')\n\n\n\nalice=0\n\nbob=0\n\nfor i in range(n):\n\n\tif i%2==0:\n\n\t\talice+=a[i]\n\n\telse:\n\n\t\tbob+=a[i]\n\n\n\nprint((alice-bob))\n","reference_code_col":"n=int(eval(input()))\n\na=list(map(int,input().split()))\n\na.sort(reverse=True)\n\n\n\nalice=0\n\nbob=0\n\n\n\nfor i in range(n):\n\n    if i%2==0:\n\n        alice+=a[i]\n\n    else:\n\n        bob+=a[i]\n\n        \n\nprint((alice-bob))","model_generated_potentially_faster_code_col":"import heapq\n\nn = int(input())\na_list = list(map(int, input().split()))\nheapq.heapify(a_list)\n\nalice = 0\nbob = 0\n\nwhile a_list:\n    alice += heapq.heappop(a_list)\n    if a_list:\n        bob += heapq.heappop(a_list)\n\nprint(alice - bob)"}
{"problem_id":"p02837","slow_code_col":"def popcount(x):\n\n  r, q = 0, x\n\n  while x:\n\n    r += 1\n\n    x &= x - 1\n\n  return r, q\n\n \n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [[0, 0] for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y] |= 1 << (x - 1)\n\nl = (1 << n) - 1 \n\nb = sorted(map(popcount, list(range(1, l + 1))))\n\nans = next((i for i, x in reversed(b)\n\n           if all(a[j][0] & x == a[j][1] & l - x == 0 for j in r if x >> j & 1)), 0)\n\nprint(ans)\n","reference_code_col":"from itertools import combinations, count\n\n \n\nn = int(eval(input()))\n\nr = list(range(n))\n\na = [(set(), set()) for _ in r]\n\nfor i in r:\n\n  for _ in range(int(eval(input()))):\n\n    x, y = list(map(int, input().split()))\n\n    a[i][y].add(x - 1)\n\nr = next(i for i in count(n, - 1) for x in map(set, combinations(r, i))\n\n         if all(a[j][0].isdisjoint(x) and a[j][1] < x for j in x))\n\nprint(r)\n","model_generated_potentially_faster_code_col":"def popcount(x):\n    r, q = 0, x\n    while x:\n        r += 1\n        x &= x - 1\n    return r, q\n\nn = int(input())\nr = list(range(n))\na = [[0, 0] for _ in r]\n\n# Read inputs into a more efficient data structure\ninputs = []\nfor i in range(n):\n    m = int(input())\n    for _ in range(m):\n        x, y = map(int, input().split())\n        inputs.append((i, x, y))\n\n# Process inputs\nfor i, x, y in inputs:\n    a[i][y] |= 1 << (x - 1)\n\n# Create a bitmask with all bits set\nl = (1 << n) - 1\n\n# Sort bitmasks based on their population count\nb = sorted(range(1, l + 1), key=popcount)\n\n# Find the answer\nans = next((i for i in b[::-1]\n           if all(a[j][0] & i == a[j][1] & l - i == 0 for j in r if i >> j & 1)), 0)\n\nprint(ans)"}
{"problem_id":"p02555","slow_code_col":"S = int(eval(input()))\n\nMOD = 10 ** 9 + 7\n\n\n\n#dp[i]\u6700\u5f8c\u306b\u5207\u3063\u305f\u5834\u6240\u304ci\u3000\u30b9\u30bf\u30fc\u30c8\u304c1\u306a\u306e\u306f\u3001\u305d\u3053\u307e\u3067\u306e\u5207\u308a\u65b9\u304c1\u901a\u308a\u306a\u306e\u3067\n\n#\uff13\u4ee5\u4e0b\u306f\u30c0\u30e1\u306a\u306e\u3067\u30013\u500b\u524d\u306e\u7d50\u679c\u3092\u898b\u308b\u3088\u3046\u306b\u3059\u308b\n\ndp =  [0] * (S+1)\n\ndp[0] = 1\n\n\n\nfor i in range(1, S+1):\n\n    #\u305f\u3068\u3048\u3070i=6\u306e\u3068\u304d\u3001i=6\u3067\u521d\u3081\u3066\u5207\u308c\u76ee\u3092\u5165\u308c\u308b\u6642\u3067\uff0b\uff11\u3001i=3\u306b\u5207\u308c\u76ee\u3092\u3044\u308c\u308b\u3068\u304d\u3067\uff0b\uff11\u3067\u5408\u8a08\uff0b\uff12\n\n    for j in range(0, (i-3)+1):\n\n        dp[i] += dp[j]\n\n        dp[i] %= MOD\n\nprint((dp[S]))        ","reference_code_col":"S = int(eval(input()))\n\nMOD = 10 ** 9 + 7\n\n\n\n#dp[i]\u6700\u5f8c\u306b\u5207\u3063\u305f\u5834\u6240\u304ci\u3000\u30b9\u30bf\u30fc\u30c8\u304c1\u306a\u306e\u306f\u3001\u305d\u3053\u307e\u3067\u306e\u5207\u308a\u65b9\u304c1\u901a\u308a\u306a\u306e\u3067\n\n#\uff13\u4ee5\u4e0b\u306f\u30c0\u30e1\u306a\u306e\u3067\u30013\u500b\u524d\u306e\u7d50\u679c\u3092\u898b\u308b\u3088\u3046\u306b\u3059\u308b\n\ndp =  [0] * (S+1)\n\ndp[0] = 1\n\n\n\n#\u3053\u308c\u307e\u3067\u306e\u548c\u3092x\u306b\u4fdd\u5b58\u3057\u3066\u304a\u304f\n\nx = 0\n\nfor i in range(1, S+1):\n\n    if i-3 >= 0:\n\n        x += dp[i-3]\n\n        x %= MOD\n\n    dp[i] = x\n\nprint((dp[S]))        ","model_generated_potentially_faster_code_col":"S = int(eval(input()))\nMOD = 10 ** 9 + 7\n\ndp = [0] * (S + 1)\ndp[0] = 1\n\n# We only need to consider multiples of 3\nfor i in range(3, S + 1, 3):\n    dp[i] = 2 * dp[i - 3]\n    dp[i] %= MOD\n\nprint(dp[S])"}
{"problem_id":"p03634","slow_code_col":"# bellman_ford : O(V E)\n\n# dijkstra : O(E log V), \u8ca0\u8fba\u306f\u7121\u7406\n\n# warshall_floyd : O(V**3)\n\n\n\nimport sys\n\n\n\nsys.setrecursionlimit(10 ** 7)\n\ninput = sys.stdin.readline\n\n\n\n\n\ndef solve():\n\n    inf = 10 ** 14 + 10\n\n\n\n    def dfs(v: 'vertex_index, 0-indexed') -> None:\n\n        for c, t in e[v]:\n\n            if d[t] != inf:\n\n                continue\n\n            d[t] = d[v] + c\n\n            dfs(t)\n\n\n\n    n = int(eval(input()))\n\n    e = tuple(set() for _ in range(n))\n\n    for _ in range(n - 1):\n\n        a, b, c = list(map(int, input().split()))\n\n        a -= 1\n\n        b -= 1\n\n        e[a].add((c, b))\n\n        e[b].add((c, a))\n\n\n\n    q, v = list(map(int, input().split()))\n\n    v -= 1\n\n\n\n    d = [inf] * n\n\n    d[v] = 0\n\n\n\n    dfs(v)\n\n\n\n    for _ in range(q):\n\n        x, y = list(map(int, input().split()))\n\n        x -= 1\n\n        y -= 1\n\n        print((d[x] + d[y]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n","reference_code_col":"# bellman_ford : O(V E)\n\n# dijkstra : O(E log V), \u8ca0\u8fba\u306f\u7121\u7406\n\n# warshall_floyd : O(V**3)\n\n# deque\n\n\n\nfrom collections import deque\n\nimport sys\n\n\n\ninput = sys.stdin.readline\n\n\n\n\n\ndef solve():\n\n    inf = 10 ** 14 + 10\n\n\n\n    n = int(eval(input()))\n\n    e = tuple(set() for _ in range(n))\n\n    for _ in range(n - 1):\n\n        a, b, c = list(map(int, input().split()))\n\n        a -= 1\n\n        b -= 1\n\n        e[a].add((c, b))\n\n        e[b].add((c, a))\n\n\n\n    q, v = list(map(int, input().split()))\n\n    v -= 1\n\n\n\n    d = [inf] * n\n\n    d[v] = 0\n\n\n\n    dq = deque()\n\n    for cost, to in e[v]:\n\n        dq.append((cost, to, v))\n\n        # (cost, to, parent)\n\n\n\n    while dq:\n\n        c, v, p = dq.popleft()\n\n        if d[v] != inf:\n\n            continue\n\n        d[v] = d[p] + c\n\n        for cost, to in e[v]:\n\n            if to == p:\n\n                continue\n\n            dq.append((cost, to, v))\n\n            \n\n    for _ in range(q):\n\n        x, y = list(map(int, input().split()))\n\n        x -= 1\n\n        y -= 1\n\n        print((d[x] + d[y]))\n\n\n\n\n\nif __name__ == '__main__':\n\n    solve()\n","model_generated_potentially_faster_code_col":"import heapq\nimport sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\n\ndef solve():\n    inf = 10 ** 14 + 10\n\n    n = int(eval(input()))\n    e = [[] for _ in range(n)]\n\n    for _ in range(n - 1):\n        a, b, c = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        e[a].append((b, c))\n        e[b].append((a, c))\n\n    q, v = list(map(int, input().split()))\n    v -= 1\n\n    d = [inf] * n\n    d[v] = 0\n    pq = [(0, v)]\n\n    while pq:\n        dist, node = heapq.heappop(pq)\n        if dist > d[node]:\n            continue\n        for neighbor, weight in e[node]:\n            distance = dist + weight\n            if distance < d[neighbor]:\n                d[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    for _ in range(q):\n        x, y = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        print((d[x] + d[y]))\n\n\nif __name__ == '__main__':\n    solve()"}
{"problem_id":"p03634","slow_code_col":"import queue\n\nn = int(eval(input()))\n\n\n\nabc = [[] for i in range(n+1)]\n\n\n\nfor i in range(n-1):\n\n    a,b,c = list(map(int,input().split()))\n\n    abc[a].append([b,c])\n\n    abc[b].append([a,c])\n\n\n\nQ,k = list(map(int,input().split()))\n\nxy = [[int(i) for i in input().split()] for j in range(Q)]\n\n\n\nq = queue.Queue()\n\n\n\nq.put(k)\n\n\n\npath = [-1]*(n+1)\n\npath[k] = 0\n\n\n\nwhile not q.empty():\n\n    tmp = q.get()\n\n    for i in range(len(abc[tmp])):\n\n        #print(abc[tmp])\n\n        #exit()\n\n        num = abc[tmp][i][0]\n\n        if path[num] != -1:\n\n            continue\n\n        else:\n\n            path[num] = path[tmp] + abc[tmp][i][1]\n\n            q.put(num)\n\n            \n\nfor i in range(Q):\n\n    print((path[xy[i][0]]+path[xy[i][1]]))","reference_code_col":"import queue\n\nimport sys\n\nsys.setrecursionlimit(10**7)\n\nn = int(eval(input()))\n\n\n\nabc = [[] for i in range(n+1)]\n\n\n\nfor i in range(n-1):\n\n    a,b,c = list(map(int,input().split()))\n\n    abc[a].append([b,c])\n\n    abc[b].append([a,c])\n\n\n\nQ,k = list(map(int,input().split()))\n\nxy = [[int(i) for i in input().split()] for j in range(Q)]\n\n\n\nq = queue.Queue()\n\n\n\nq.put(k)\n\n\n\npath = [-1]*(n+1)\n\npath[k] = 0\n\n\n\ndef dfs(p):\n\n    for i in range(len(abc[p])):\n\n        num = abc[p][i][0]\n\n        if path[num] != -1:\n\n            continue\n\n        else:\n\n            path[num] = path[p] + abc[p][i][1]\n\n            dfs(num)\n\n\n\ndfs(k)\n\n\n\nfor i in range(Q):\n\n    print((path[xy[i][0]]+path[xy[i][1]]))","model_generated_potentially_faster_code_col":"import collections\n\nn = int(input())\n\nabc = [set() for _ in range(n+1)]\n\nfor _ in range(n-1):\n    a, b, c = map(int, input().split())\n    abc[a].add(b)\n    abc[b].add(a)\n\nQ, k = map(int, input().split())\nxy = [tuple(map(int, input().split())) for _ in range(Q)]\n\nq = collections.deque()\nq.append(k)\n\ndistances = {k: 0}\n\nwhile q:\n    tmp = q.popleft()\n    for neighbor in abc[tmp]:\n        if neighbor not in distances:\n            distances[neighbor] = distances[tmp] + 1\n            q.append(neighbor)\n\nfor x, y in xy:\n    print(distances[x] + distances[y])"}
{"problem_id":"p03000","slow_code_col":"#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nimport numpy as np\n\njump = list(np.cumsum(L))\n\nfor j in jump:\n\n    if j <= X:\n\n        cnt+=1\n\n    else:\n\n        break\n\nprint((cnt+1))","reference_code_col":"#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nd = 0\n\n\n\nfor l in L :\n\n    d+=l\n\n    if d <= X:\n\n        cnt+=1\n\n    else:\n\n        break\n\nprint((cnt+1))","model_generated_potentially_faster_code_col":"from itertools import accumulate\n\nN, X = map(int, input().split())\nL = list(map(int, input().split()))\n\ncnt = 0\n\n# Use itertools.accumulate() to calculate the jumps\njumps = accumulate(L)\n\n# Count the number of jumps less than or equal to X\nfor jump in jumps:\n    if jump > X:\n        break\n    cnt += 1\n\nprint(cnt + 1)"}
{"problem_id":"p03309","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nlist_ai = list(map(int,input().split()))\n\nlist1 = [x-(i+1) for i,x in enumerate(list_ai)]\n\na1 = np.array(list1)\n\nmedian1 = int(np.floor(np.median(a1)))\n\nans = np.sum(np.abs(a1-median1))\n\nprint(ans)","reference_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nlist_ai = list(map(int,input().split()))\n\na1 = np.array(list_ai)-np.arange(1,N+1)\n\nmedian1 = int(np.floor(np.median(a1)))\n\nans = np.sum(np.abs(a1-median1))\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN = int(input())\nlist_ai = list(map(int, input().split()))\n\n# Convert list to NumPy array\na1 = np.array(list_ai)\n\n# Calculate differences from indices\ndiffs = a1 - np.arange(1, N + 1)\n\n# Calculate median using NumPy's efficient median function\nmedian1 = np.median(diffs)\n\n# Calculate sum of absolute differences\nans = np.sum(np.abs(diffs - median1))\n\nprint(ans)"}
{"problem_id":"p02394","slow_code_col":"W,H,x,y,r = [int(i) for i in input().split()]\n\nif x - r >= 0 and x + r <= W and y - r >= 0 and y + r <= H:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")","reference_code_col":"W, H, x, y, r = list(map(int, input().split()))\n\nif r <= x <= W-r and r <= y <= H-r:\n\n    print('Yes')\n\nelse:\n\n    print('No')\n","model_generated_potentially_faster_code_col":"def is_point_inside_rectangle(x, y, rect_width, rect_height):\n    return 0 <= x < rect_width and 0 <= y < rect_height\n\ndef is_circle_within_rectangle(circle_x, circle_y, circle_radius, rect_width, rect_height):\n    return (circle_x - circle_radius >= 0 and \n            circle_x + circle_radius <= rect_width and \n            circle_y - circle_radius >= 0 and \n            circle_y + circle_radius <= rect_height)\n\n# Input reading\nW, H, x, y, r = map(int, input().split())\n\n# Check and print result\nif is_circle_within_rectangle(x, y, r, W, H):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"problem_id":"p03060","slow_code_col":"# coding: utf-8\n\nimport sys\n\nimport numpy as np\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nV = np.array(lr())\n\nC = np.array(lr())\n\nV -= C\n\nV = V[V>0]\n\nanswer = V.sum()\n\nprint(answer)\n","reference_code_col":"# coding: utf-8\n\nimport sys\n\n\n\nsr = lambda: sys.stdin.readline().rstrip()\n\nir = lambda: int(sr())\n\nlr = lambda: list(map(int, sr().split()))\n\n\n\nN = ir()\n\nV = lr()\n\nC = lr()\n\ntotal = 0\n\nfor i in range(N):\n\n    result = V[i] - C[i]\n\n    if result > 0:\n\n        total += result\n\n\n\nprint(total)\n","model_generated_potentially_faster_code_col":"# coding: utf-8\n\nimport sys\nimport numpy as np\n\ndef main():\n    input_data = sys.stdin.read()\n    lines = input_data.splitlines()\n\n    N = int(lines[0])\n    V = np.array(list(map(int, lines[1].split())))\n    C = np.array(list(map(int, lines[2].split())))\n\n    V -= C\n    answer = V[V > 0].sum()\n\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03325","slow_code_col":"from math import log2\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\nans = 0\n\n\n\nfor _a in a:\n\n    if _a%2 == 0:\n\n        cnt =0\n\n        while _a%2 == 0:\n\n            _a \/\/= 2\n\n            cnt += 1\n\n        ans += cnt\n\n\n\nprint((int(ans)))","reference_code_col":"def f(k):\n\n    cnt = 0\n\n    while k%2 == 0:\n\n        k \/\/= 2\n\n        cnt += 1\n\n        # print(k)\n\n        # print(\"-----\")\n\n    return cnt\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nans = 0\n\n\n\nfor a in A:\n\n    if a%2 == 0:\n\n        ans += f(a)\n\nprint(ans)","model_generated_potentially_faster_code_col":"n = int(input())\n\na = list(map(int, input().split()))\n\nans = 0\n\nfor _a in a:\n\n    if _a & 1 == 0:  # Check if _a is even using bitwise AND operation\n\n        cnt = 0\n\n        while _a & 1 == 0:  # While _a is still even\n\n            _a >>= 1  # Right shift _a by 1 bit (equivalent to dividing by 2)\n\n            cnt += 1\n\n        ans += cnt\n\nprint(ans)"}
{"problem_id":"p02685","slow_code_col":"# coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    n, m, k = list(map(int, args[0].split()))\n\n    mod = 998244353\n\n\n\n    if m == 1 and n-1 == k:\n\n        return str(1)\n\n\n\n    ncr = 1\n\n    p = m*pow(m-1, n-1, mod) % mod\n\n    ret = p\n\n    inv = pow(m-1, mod-2, mod)\n\n    for i in range(1, k+1):\n\n        ncr = (ncr * (n-i)*pow(i, mod-2, mod)) % mod\n\n        p = (p*inv) % mod\n\n        ret += p*ncr % mod\n\n\n\n    return str(ret % mod)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n","reference_code_col":"# coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    n, m, k = list(map(int, args[0].split()))\n\n    mod = 998244353\n\n\n\n    if m == 1 and n-1 == k:\n\n        return str(1)\n\n\n\n    ncr = 1\n\n    p = m*pow(m-1, n-1, mod) % mod\n\n\n\n    ret = p\n\n    iR = [1]*(k+1)\n\n    im = pow(m-1, mod-2, mod)\n\n\n\n    for i in range(1, k+1):\n\n        iR[i] = max(1, (-(mod\/\/i) * iR[mod % i]) % mod)\n\n        ncr = (ncr * (n-i)*iR[i]) % mod\n\n        p = (p*im) % mod\n\n        ret += p*ncr % mod\n\n\n\n    return str(ret % mod)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n","model_generated_potentially_faster_code_col":"# coding: utf-8\n\ndef solve(*args: str) -> str:\n    n, m, k = map(int, args[0].split())\n    mod = 998244353\n\n    if m == 1 and n - 1 == k:\n        return \"1\"\n\n    # Precompute factorials and their modular inverses\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    \n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    \n    inv_fact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n\n    def nCr(n, r):\n        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n\n    p = m * pow(m - 1, n - 1, mod) % mod\n    ret = p\n\n    inv_m_minus_1 = pow(m - 1, mod - 2, mod)\n\n    for i in range(1, k + 1):\n        ncr_value = nCr(n, i)\n        p = (p * inv_m_minus_1) % mod\n        ret += p * ncr_value % mod\n\n    return str(ret % mod)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    print(solve(*data))"}
{"problem_id":"p03828","slow_code_col":"import collections as col\n\n\n\ndef prime(n):\n\n    ans = []\n\n    num = n\n\n    for i in range(2,n+1):\n\n        if i%2==0 and i!=2: continue\n\n        while num%i == 0: num \/\/= i ; ans.append(i)\n\n    return ans\n\n\n\nn = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\nprimes = []\n\nfor i in range(2,n+1): primes += prime(i)\n\n\n\ncnt = col.Counter(primes)\n\nans = 1\n\nfor key,val in list(cnt.items()): ans *= (val + 1) ; ans %= mod\n\nprint(ans)\n","reference_code_col":"import collections as col\n\n\n\ndef prime(n):\n\n    ans = []\n\n    num = n\n\n    for i in range(2,int(n**0.5)+1):\n\n        if i%2==0 and i!=2: continue\n\n        while num%i == 0: num \/\/= i ; ans.append(i)\n\n    if num != 1: ans.append(num)\n\n    return ans\n\n\n\nn = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\nprimes = []\n\nfor i in range(2,n+1): primes += prime(i)\n\n\n\ncnt = col.Counter(primes)\n\nans = 1\n\nfor key,val in list(cnt.items()): ans *= (val + 1) ; ans %= mod\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import math\n\ndef sieve_of_eratosthenes(n):\n    primes = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (primes[p] == True):\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n    prime_numbers = []\n    for p in range(2, n + 1):\n        if primes[p]:\n            prime_numbers.append(p)\n    return prime_numbers\n\ndef prime_factors(n, primes):\n    factors = {}\n    for prime in primes:\n        count = 0\n        while n % prime == 0:\n            n \/\/= prime\n            count += 1\n        if count > 0:\n            factors[prime] = count\n    return factors\n\nn = int(input())\nmod = 10 ** 9 + 7\n\nprimes = sieve_of_eratosthenes(n)\nfactors = {}\n\nfor i in range(2, n + 1):\n    i_factors = prime_factors(i, primes)\n    for prime, count in i_factors.items():\n        if prime in factors:\n            factors[prime] += count\n        else:\n            factors[prime] = count\n\nresult = 1\nfor count in factors.values():\n    result = (result * (count + 1)) % mod\n\nprint(result)"}
{"problem_id":"p02794","slow_code_col":"import sys\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    E = [[] for _ in range(N)]\n\n    for i in range(N-1):\n\n        a, b = list(map(int, input().split()))\n\n        a, b = a-1, b-1\n\n        E[a].append((b,i))\n\n        E[b].append((a,i))\n\n    \n\n    def dfs(s, g):\n\n        par = [(-1,-1)] * N\n\n        par[s] = (s,-1)\n\n        stack = [s]\n\n        while stack:\n\n            v = stack.pop()\n\n            for to, i in E[v]:\n\n                if par[to][0] >= 0: continue\n\n                par[to] = (v, i)\n\n                if to == g: break\n\n                stack.append(to)\n\n        r = set()\n\n        v = g\n\n        while v != s:\n\n            v, i = par[v]\n\n            r.add(i)\n\n        return r\n\n    \n\n    M = int(eval(input()))\n\n    path = [None] * M\n\n    for i in range(M):\n\n        u, v = list(map(int, input().split()))\n\n        u, v = u-1, v-1\n\n        path[i] = dfs(u, v)\n\n\n\n    def calc(s): return 1<<(N-1-len(s))\n\n\n\n    i_ans = 0\n\n    for p in range(1, 1<<M):\n\n        is_odd = bin(p).count('1') & 1\n\n        s = set()\n\n        for i in range(M):\n\n            if p&1: s |= path[i]\n\n            p >>= 1\n\n        if is_odd: i_ans += calc(s)\n\n        else: i_ans -= calc(s)\n\n\n\n    print(((1<<(N-1)) - i_ans))\n\n\n\nif __name__ == '__main__':\n\n    main()","reference_code_col":"import sys\n\ndef main():\n\n    input = sys.stdin.readline\n\n    N = int(eval(input()))\n\n    E = [[] for _ in range(N)]\n\n    for i in range(N-1):\n\n        a, b = list(map(int, input().split()))\n\n        a, b = a-1, b-1\n\n        E[a].append((b,i))\n\n        E[b].append((a,i))\n\n    \n\n    def dfs(s, g):\n\n        par = [(-1,-1)] * N\n\n        par[s] = (s,-1)\n\n        stack = [s]\n\n        while stack:\n\n            v = stack.pop()\n\n            for to, i in E[v]:\n\n                if par[to][0] >= 0: continue\n\n                par[to] = (v, i)\n\n                if to == g: break\n\n                stack.append(to)\n\n        r = set()\n\n        v = g\n\n        while v != s:\n\n            v, i = par[v]\n\n            r.add(i)\n\n        return r\n\n    \n\n    M = int(eval(input()))\n\n    path = [None] * M\n\n    for i in range(M):\n\n        u, v = list(map(int, input().split()))\n\n        u, v = u-1, v-1\n\n        path[i] = dfs(u, v)\n\n\n\n    def calc(s): return 1<<(N-1-len(s))\n\n\n\n    i_ans = 0\n\n    for p in range(1, 1<<M):\n\n        is_odd = 0\n\n        s = set()\n\n        for i in range(M):\n\n            if p&1:\n\n                s |= path[i]\n\n                is_odd ^= 1\n\n            p >>= 1\n\n        if is_odd: i_ans += calc(s)\n\n        else: i_ans -= calc(s)\n\n\n\n    print(((1<<(N-1)) - i_ans))\n\n\n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    input = sys.stdin.readline\n\n    N = int(input())\n    E = [[] for _ in range(N)]\n    \n    # Read edges and build adjacency list\n    for _ in range(N-1):\n        a, b = map(int, input().split())\n        a, b = a-1, b-1\n        E[a].append(b)\n        E[b].append(a)\n\n    # Memoize DFS results\n    memo = {}\n\n    def dfs(s, t):\n        if (s, t) in memo:\n            return memo[(s, t)]\n        \n        visited = [False] * N\n        stack = [(s, None)]\n        path = set()\n        \n        while stack:\n            v, parent = stack[-1]\n            visited[v] = True\n            \n            if v == t:\n                break\n                \n            for neighbor in E[v]:\n                if not visited[neighbor]:\n                    stack.append((neighbor, v))\n                    break\n            else:\n                stack.pop()\n                path.add(parent)\n                \n        memo[(s, t)] = path\n        return path\n\n    M = int(input())\n    queries = []\n    \n    # Store queries with their indices\n    for i in range(M):\n        u, v = map(int, input().split())\n        u, v = u-1, v-1\n        queries.append((u, v, i))\n\n    # Sort queries by length of path in descending order\n    queries.sort(key=lambda x: len(dfs(x[0], x[1])), reverse=True)\n\n    # Process queries\n    ans = 0\n    for u, v, i in queries:\n        path = dfs(u, v)\n        if len(path) % 2 == 0:\n            ans -= 1 << (N - len(path) - 1)\n        else:\n            ans += 1 << (N - len(path) - 1)\n\n    print(ans + (1 << (N-1)))\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02612","slow_code_col":"'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n#mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile = 0\n\n\n\ndef solve():\n\n    \n\n\n\n\n\n\n\n    # for _ in range(ii()):\n\n\n\n    n=ii()\n\n    n%=1000\n\n    if n!=0:\n\n        n=1000-n\n\n    print(n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()","reference_code_col":"'''\n\n    Auther: ghoshashis545 Ashis Ghosh\n\n    College: jalpaiguri Govt Enggineering College\n\n\n\n'''\n\nfrom os import path\n\nimport sys\n\nfrom heapq import heappush,heappop\n\nfrom functools import cmp_to_key as ctk\n\nfrom collections import deque,defaultdict as dd \n\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\nfrom itertools import permutations\n\nfrom datetime import datetime\n\nfrom math import ceil,sqrt,log,gcd\n\ndef ii():return int(eval(input()))\n\ndef si():return eval(input())\n\ndef mi():return list(map(int,input().split()))\n\ndef li():return list(mi())\n\nabc='abcdefghijklmnopqrstuvwxyz'\n\nmod=1000000007\n\n# mod=998244353\n\ninf = float(\"inf\")\n\nvow=['a','e','i','o','u']\n\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\n\n\ndef bo(i):\n\n    return ord(i)-ord('a')\n\n\n\nfile=0\n\n\n\n\n\n\n\n\n\n\n\ndef solve():\n\n\n\n\n\n    # for _ in range(ii()):\n\n    \n\n        \n\n\n\n    n=ii()\n\n    n%=1000\n\n    if(n!=0):\n\n        n=1000-n\n\n    print(n)\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\nif __name__ ==\"__main__\":\n\n\n\n    if(file):\n\n\n\n        if path.exists('input1.txt'):\n\n            sys.stdin=open('input1.txt', 'r')\n\n            sys.stdout=open('output1.txt','w')\n\n        else:\n\n            input=sys.stdin.readline\n\n    solve()\n","model_generated_potentially_faster_code_col":"from os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque, defaultdict as dd \nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil, sqrt, log, gcd\n\ndef ii():\n    return int(eval(input()))\n\ndef si():\n    return eval(input())\n\ndef mi():\n    return list(map(int, input().split()))\n\ndef li():\n    return list(mi())\n\nabc = 'abcdefghijklmnopqrstuvwxyz'\nmod = 1000000007\n# mod = 998244353\ninf = float(\"inf\")\nvow = ['a', 'e', 'i', 'o', 'u']\ndx, dy = [-1, 1, 0, 0], [0, 0, 1, -1]\n\ndef bo(i):\n    return ord(i) - ord('a')\n\nfile = 0\n\n\ndef solve():\n    # Read all lines at once\n    input_data = sys.stdin.read().strip().splitlines()\n\n    # Process each line\n    for line in input_data:\n        n = int(line)\n        n %= 1000\n        if n != 0:\n            n = 1000 - n\n        print(n)\n\n\nif __name__ == \"__main__\":\n    if file:\n        if path.exists('input1.txt'):\n            sys.stdin = open('input1.txt', 'r')\n            sys.stdout = open('output1.txt', 'w')\n        else:\n            input = sys.stdin.readline\n    solve()"}
{"problem_id":"p02685","slow_code_col":"M=998244353\n\nn,m,k=list(map(int,input().split()))\n\na=0\n\nc=1\n\nfor i in range(k+1):\n\n  a+=c*m*pow(m-1,n-i-1,M)\n\n  c=c*(n-i-1)*pow(i+1,M-2,M)%M\n\nprint((a%M))","reference_code_col":"M=998244353\n\nn,m,k=list(map(int,input().split()))\n\na,c=0,1\n\nfor i in range(k+1):\n\n  a+=c*m*pow(m-1,n+~i,M)\n\n  c=c*(n+~i)*pow(i+1,-1,M)%M\n\nprint((a%M))","model_generated_potentially_faster_code_col":"M = 998244353\n\nn, m, k = list(map(int, input().split()))\n\n# Precompute powers of m and (m-1)\npowers_m = [1]\npowers_m_minus_1 = [1]\nfor i in range(1, max(n, k) + 1):\n    powers_m.append(powers_m[-1] * m % M)\n    powers_m_minus_1.append(powers_m_minus_1[-1] * (m - 1) % M)\n\n# Calculate the sum of the series\nresult = 0\nc = 1\nfor i in range(k + 1):\n    result += c * powers_m[i] * powers_m_minus_1[n - i - 1]\n    c = c * (n - i - 1) * pow(i + 1, M - 2, M) % M\n\nprint(result % M)"}
{"problem_id":"p03680","slow_code_col":"N = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\ncnt, i = 0, 0\n\nfor j in range(10 ** 6):\n\n    cnt += 1\n\n    if a[i] == 2:\n\n        print(cnt)\n\n        #break\n\n        quit()\n\n    else:\n\n        i = a[i] - 1\n\nprint((-1))","reference_code_col":"N = int(eval(input()))\n\na = [int(eval(input())) for _ in range(N)]\n\n\n\ncnt, i = 0, 0\n\nfor j in range(len(a)):\n\n    cnt += 1\n\n    if a[i] == 2:\n\n        print(cnt)\n\n        #break\n\n        quit()\n\n    else:\n\n        i = a[i] - 1\n\nprint((-1))","model_generated_potentially_faster_code_col":"# Read input without eval\nN = int(input())\na = [int(input()) for _ in range(N)]\n\n# Initialize variables\ncnt, i = 0, 0\nvisited = set()  # To keep track of visited indices to detect cycles\n\nwhile True:\n    cnt += 1\n    \n    if a[i] == 2:\n        print(cnt)\n        break\n    \n    # Check for cycle\n    if i in visited:\n        print(-1)\n        break\n    \n    visited.add(i)\n    \n    i = a[i] - 1\n\nif i not in visited:\n    print(-1)"}
{"problem_id":"p02555","slow_code_col":"import math\n\n\n\n\n\ndef combinations_count(n, r):\n\n    return math.factorial(n) \/\/ (math.factorial(n - r) * math.factorial(r))\n\n\n\n\n\ndef combinations_with_replacement_count(n, r):\n\n    return combinations_count(n + r - 1, r)\n\n\n\n\n\ndef main():\n\n    s = int(eval(input()))\n\n    ans = 0\n\n    n = s \/\/ 3\n\n\n\n    for i in range(1, n + 1):\n\n        ans += combinations_with_replacement_count(i, 3*(n-i)+s % 3)\n\n\n\n    print((ans % (10**9 + 7)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def main():\n\n    s = int(eval(input()))\n\n    dp = [0] * 3 + [1] * 3 + [0 for _ in range(s)]\n\n\n\n    for i in range(6, s+1):\n\n        dp[i] = dp[i-1] + dp[i-3]\n\n\n\n    print((dp[s] % (10**9+7)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"MOD = 10 ** 9 + 7\n\n\n# Function to calculate factorial modulo MOD\ndef fact_mod(n):\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    return fact\n\n\n# Function to calculate modular inverse using Fermat's little theorem\ndef mod_inv(x):\n    return pow(x, MOD - 2, MOD)\n\n\n# Function to calculate combination count with memoization\n@lru_cache(None)\ndef comb_mod(n, k):\n    if k > n:\n        return 0\n    return fact[n] * mod_inv(fact[k]) % MOD * mod_inv(fact[n - k]) % MOD\n\n\ndef main():\n    s = int(eval(input()))\n    ans = 0\n    n = s \/\/ 3\n\n    # Precompute factorials and their inverses\n    fact = fact_mod(n)\n\n    for i in range(1, n + 1):\n        ans += comb_mod(i, 3 * (n - i) + s % 3)\n        ans %= MOD\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03806","slow_code_col":"G_MAX = 40*10\n\nN_MAX = 40\n\nINF = float('inf')\n\n\n\ndp = [[[INF]*(G_MAX+1) for _ in range(G_MAX+1)] \n\n      for _ in range(N_MAX+1)]\n\nN,Ma,Mb = list(map(int, input().split()))\n\na,b,c = [],[],[]\n\nfor _ in range(N):\n\n    ai,bi,ci = list(map(int, input().split()))\n\n    a.append(ai)\n\n    b.append(bi)\n\n    c.append(ci)\n\n\n\ndp[0][0][0] = 0\n\nfrom math import isinf\n\nfor i in range(N):\n\n    for ca in range(G_MAX+1):\n\n        for cb in range(G_MAX+1):\n\n            if isinf(dp[i][ca][cb]): continue\n\n            dp[i+1][ca][cb] = min(dp[i+1][ca][cb],\n\n                                 dp[i][ca][cb])\n\n            dp[i+1][ca+a[i]][cb+b[i]] = min(dp[i+1][ca+a[i]][cb+b[i]],\n\n                                           dp[i][ca][cb]+c[i])\n\n            \n\n    \n\nans = INF\n\nfor ca in range(1,G_MAX+1):\n\n    for cb in range(1,G_MAX+1):\n\n        if ca*Mb==cb*Ma:\n\n            ans = min(ans, dp[N][ca][cb])\n\n            \n\nif isinf(ans): ans = -1\n\nprint(ans)","reference_code_col":"from math import isinf\n\n\n\nN, Ma, Mb = list(map(int, input().split()))\n\na = [0]*N\n\nb = [0]*N\n\nc = [0]*N\n\nfor i in range(N):\n\n    a[i],b[i],c[i] = list(map(int, input().split()))\n\n\n\nW_MAX = 40*10\n\ndp = [[float('inf')]*(W_MAX+1) for _ in range(W_MAX+1)]\n\ndp[0][0] = 0\n\n\n\nfor i in range(N):\n\n    for wa in reversed(list(range(W_MAX+1))):\n\n        for wb in reversed(list(range(W_MAX+1))):\n\n            if isinf(dp[wa][wb]): continue\n\n            if wa+a[i]<=W_MAX and wb+b[i]<=W_MAX:\n\n                dp[wa+a[i]][wb+b[i]] = min(dp[wa+a[i]][wb+b[i]],\n\n                                           dp[wa][wb]+c[i])\n\n\n\nans = float('inf')\n\nfor wa in range(1, W_MAX+1):\n\n    for wb in range(1, W_MAX+1):\n\n        if wa*Mb == wb*Ma:\n\n            ans = min(ans, dp[wa][wb])\n\n\n\nif isinf(ans): ans = -1\n\nprint(ans)","model_generated_potentially_faster_code_col":"G_MAX = 40 * 10\nN_MAX = 40\n\n# Initialize DP table with a very large negative number\nINF = -float('inf')\ndp = [[[-INF] * (G_MAX + 1) for _ in range(G_MAX + 1)] for _ in range(N_MAX + 1)]\n\nN, Ma, Mb = map(int, input().split())\na, b, c = [], [], []\n\nfor _ in range(N):\n    ai, bi, ci = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n    c.append(ci)\n\n# Base case\ndp[0][0][0] = 0\n\nfor i in range(N):\n    for ca in range(G_MAX + 1):\n        for cb in range(G_MAX + 1):\n            if dp[i][ca][cb] == INF: continue\n            # Update without adding the current cost\n            dp[i + 1][ca][cb] = max(dp[i + 1][ca][cb], dp[i][ca][cb])\n            # Update by adding the current cost\n            new_ca, new_cb = ca + a[i], cb + b[i]\n            if new_ca <= G_MAX and new_cb <= G_MAX:\n                dp[i + 1][new_ca][new_cb] = max(dp[i + 1][new_ca][new_cb], dp[i][ca][cb] + c[i])\n\nans = INF\nfor ca in range(1, G_MAX + 1):\n    for cb in range(1, G_MAX + 1):\n        if ca * Mb == cb * Ma:\n            ans = max(ans, dp[N][ca][cb])\n\nif ans == INF:\n    ans = -1\n\nprint(ans)"}
{"problem_id":"p03568","slow_code_col":"from itertools import product\n\n\n\nn = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\ncount = 0\n\nfor C in product((-1, 0, 1), repeat=n):\n\n  total = 1\n\n  for a, c in zip(A, C):\n\n    total *= (a + c)\n\n  if total % 2 == 0:\n\n    count += 1\n\nprint(count)","reference_code_col":"n = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\ncount = 1\n\nfor a in A:\n\n  count *= 2 if a % 2 == 0 else 1\n\nprint((3 ** n - count))","model_generated_potentially_faster_code_col":"n = int(eval(input()))\nA = list(map(int, input().split()))\nif sum(A) % 2 == 0:\n    print(3**n)\nelse:\n    print((3**n-1)\/\/2)"}
{"problem_id":"p03164","slow_code_col":"import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n,W=list(map(int,input().split()))\n\n    WV=[tuple(map(int,input().split())) for _ in range(n)]\n\n\n\n    V=100000\n\n    dp=[INF]*(V+1)\n\n    dp[0]=0\n\n\n\n    for w,v in WV:\n\n        for x in range(V,-1,-1):\n\n            if(x+v<=V):\n\n                dp[x+v]=min(dp[x+v],dp[x]+w)\n\n\n\n    for x in range(V,-1,-1):\n\n        if(dp[x]<=W):\n\n            print(x)\n\n            return\n\nresolve()","reference_code_col":"import sys\n\nINF = 1 << 60\n\nMOD = 10**9 + 7 # 998244353\n\nsys.setrecursionlimit(2147483647)\n\ninput = lambda:sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n, W = list(map(int, input().split()))\n\n    dp = [INF] * (n * 1001 + 1)\n\n    dp[0] = 0\n\n    for _ in range(n):\n\n        w, v = list(map(int, input().split()))\n\n        for v0 in range(n * 1001, -1, -1):\n\n            if dp[v0] == INF:\n\n                continue\n\n            if v + v0 <= n * 1001:\n\n                dp[v + v0] = min(dp[v + v0], dp[v0] + w)\n\n    for v in range(n * 1001, -1, -1):\n\n        if dp[v] <= W:\n\n            print(v)\n\n            return\n\nresolve()","model_generated_potentially_faster_code_col":"import sys\n\nsys.setrecursionlimit(2147483647)\n\nINF=float(\"inf\")\n\nMOD=10**9+7\n\ninput=lambda :sys.stdin.readline().rstrip()\n\ndef resolve():\n\n    n,W=list(map(int,input().split()))\n\n    WV=[tuple(map(int,input().split())) for _ in range(n)]\n\n    # Find the maximum weight in the input list\n    max_weight = max(max(w, v) for w, v in WV)\n\n    dp=[INF]*(max_weight+1)\n\n    dp[0]=0\n\n    for w,v in WV:\n\n        for x in range(max(w, v),V+1):\n\n            dp[x]=min(dp[x],dp[x-v]+w)\n\n    for x in range(V,-1,-1):\n\n        if(dp[x]<=W):\n\n            print(x)\n\n            return\n\nresolve()"}
{"problem_id":"p02691","slow_code_col":"from collections import defaultdict\n\n\n\n\n\ndef main():\n\n    _ = int(eval(input()))\n\n    heights = list(map(int, input().split()))\n\n\n\n    \"\"\"\n\n    for j>i, j-i = Ai + Aj\n\n    i + Ai = j -Aj\n\n    \"\"\"\n\n\n\n    L = defaultdict(int)\n\n    R = defaultdict(int)\n\n\n\n    for i, height in enumerate(heights):\n\n        L[i + height] += 1\n\n        R[i - height] += 1\n\n\n\n    total_count = 0\n\n    for x, count_l in list(L.items()):\n\n        if x in R:\n\n            count_r = R[x]\n\n            total_count += count_l * count_r\n\n\n\n    print(total_count)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"from collections import defaultdict\n\n\n\n\n\ndef main():\n\n    N = int(eval(input()))\n\n    heights = list(map(int, input().split()))\n\n\n\n    \"\"\"\n\n    for j>i, j-i = Ai + Aj\n\n    i + Ai = j -Aj\n\n    \"\"\"\n\n\n\n    L = defaultdict(int)\n\n    R = defaultdict(int)\n\n\n\n    for i, height in enumerate(heights):\n\n        if i + height < N:\n\n            L[i + height] += 1\n\n        \n\n        if i - height > 0:\n\n            R[i - height] += 1\n\n\n\n    total_count = 0\n\n    for x, count_l in list(L.items()):\n\n        if x in R:\n\n            count_r = R[x]\n\n            total_count += count_l * count_r\n\n\n\n    print(total_count)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"from collections import defaultdict\n\ndef main():\n    n = int(input())\n    heights = list(map(int, input().split()))\n    \n    # Dictionary to store the frequency of differences (i + height)\n    diff_count = defaultdict(int)\n    \n    total_count = 0\n    \n    for i, height in enumerate(heights):\n        # Calculate the required difference for each index\n        required_diff = i + height\n        \n        # Add the number of pairs that match the required difference to the total count\n        total_count += diff_count[required_diff]\n        \n        # Update the dictionary with the current index and height\n        diff_count[required_diff] += 1\n    \n    print(total_count)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03039","slow_code_col":"import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\ndef f1(x,y,a,b):\n\n    return (a+b-x-y)*(a-x+1)*(b-y+1)\/\/2\n\n\n\ndef f2(x,a):\n\n    return (a-x)*(a-x+1)\/\/2\n\n\n\nans = 0\n\n\n\nfor x in range(1,n+1):\n\n    for y in range(1,m+1):\n\n        a = n-x+1\n\n        b = m-y+1\n\n        c = m*(a*(a-1)+x*(x-1))\n\n        d = n*(b*(b-1)+y*(y-1))\n\n        ans += (c+d)\/\/2\n\n        ans %= mod\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n","reference_code_col":"import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\n#mod = 998244353\n\nINF = 10**18\n\neps = 10**-7\n\n\n\nm,n,k = list(map(int,readline().split()))\n\n\n\ndef comb(n, r, mod):\n\n    r = min(r, n-r)\n\n    mol = 1\n\n    deno = 1\n\n    for i in range(1, r+1):\n\n        mol = mol * (n-r+i) % mod\n\n        deno = deno * i % mod\n\n    ret = mol * pow(deno, mod-2, mod) % mod\n\n    return ret\n\n\n\nans = m*n*(m+n)*(m*n-1)\/\/3\n\n\n\nans = (ans * comb(m*n-2,k-2,mod))%mod\n\nans = ans*pow(2,mod-2,mod)%mod\n\n\n\nprint(ans)\n\n\n","model_generated_potentially_faster_code_col":"import sys\n\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9 + 7\n\nINF = 10**18\n\neps = 10**-7\n\nm, n, k = map(int, readline().split())\n\n# Precompute factorials and their modular inverses\nfact = [0] * (m * n)\ninv_fact = [0] * (m * n)\nfact[0] = inv_fact[0] = 1\nfor i in range(1, m * n):\n    fact[i] = fact[i - 1] * i % mod\n    inv_fact[i] = pow(fact[i], mod - 2, mod)\n\ndef comb(n, r, mod):\n    if r > n:\n        return 0\n    return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod\n\ndef f1(x, y, a, b):\n    return (a + b - x - y) * (a - x + 1) * (b - y + 1) \/\/ 2\n\ndef f2(x, a):\n    return (a - x) * (a - x + 1) \/\/ 2\n\nans = 0\n\n# Calculate the sum of f1 and f2 values efficiently\nfor x in range(1, n + 1):\n    for y in range(1, m + 1):\n        a = n - x + 1\n        b = m - y + 1\n        ans += (f1(x, y, a, b) + f2(x, a) + f2(y, b))\n        ans %= mod\n\n# Combine results using comb function\nans *= comb(m * n - 2, k - 2, mod)\nans %= mod\n\n# Adjust for modulo operation\nans *= pow(2, mod - 2, mod)\nans %= mod\n\nprint(ans)"}
{"problem_id":"p03253","slow_code_col":"N,M = list(map(int,input().split()))\n\ndiv =[]\n\nfor i in range(2,int(M**(1\/2))+2):\n\n    cur = 0\n\n    while M%i==0:\n\n        M = M\/\/i\n\n        cur += 1\n\n    if cur >=1:\n\n        div.append(cur)\n\nif M>1: div.append(1)\n\ndiv.sort()\n\nmod = 10**9+7\n\nfrac = [1]*(N+50)\n\nnum = len(frac)\n\nfor i in range(len(frac)-1):\n\n    frac[i+1] = frac[i]*(i+1)%mod\n\nfinv = [1] * (N+50)\n\nfinv[-1] = pow(frac[-1], mod-2, mod)\n\nfor i in range(1, num):\n\n  finv[num-1-i] = finv[num-i] * (num-i) % mod\n\nans = 1\n\nfor i in div:\n\n    ans = ans * frac[N+i-1]*finv[N-1]*finv[i]%mod\n\nprint(ans)","reference_code_col":"N,M = list(map(int,input().split()))\n\ndiv = []\n\nfor i in range(2,int(M**(1\/2))+2):\n\n    cur = 0\n\n    while M%i==0:\n\n        M\/\/=i\n\n        cur += 1\n\n    if cur >=1:\n\n        div.append(cur)\n\nif M>1:div.append(1)\n\ndiv.sort()\n\nmod = 10**9+7\n\nfrac = [1]*(N+50)\n\nnum=len(frac)\n\nfor i in range(num-1):\n\n    frac[i+1] = frac[i]*(i+1)%mod\n\nfinv = [1]*(N+50)\n\nfinv[-1] = pow(frac[-1],mod-2,mod)\n\nans = 1\n\nfor i in range(1,num):\n\n    finv[num-1-i] = finv[num-i]*(num-i)%mod\n\nfor i in div:\n\n    ans  =ans*frac[N+i-1]*finv[N-1]*finv[i]%mod\n\nprint(ans)","model_generated_potentially_faster_code_col":"import math\n\ndef prime_factors(n):\n    factors = []\n    # Check for number of 2s that divide n\n    while n % 2 == 0:\n        factors.append(1)\n        n \/\/= 2\n    \n    # n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        count = 0\n        while n % i == 0:\n            count += 1\n            n \/\/= i\n        if count > 0:\n            factors.extend([count] * (len(factors) - 1))\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        factors.extend([1] * (len(factors) - 1))\n    \n    return factors\n\nN, M = map(int, input().split())\n\nfactors = prime_factors(M)\ndiv = sorted(set(factors))\n\nmod = 10**9 + 7\n\n# Precompute factorials and their modular inverses\nfact = [1] * (N + 50)\ninv_fact = [1] * (N + 50)\n\nfor i in range(1, N + 50):\n    fact[i] = fact[i - 1] * i % mod\n    inv_fact[i] = pow(fact[i], mod - 2, mod)\n\n# Calculate the final answer\nans = 1\nfor i in div:\n    ans = ans * fact[N + i - 1] * inv_fact[N - 1] * inv_fact[i] % mod\n\nprint(ans)"}
{"problem_id":"p03371","slow_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(c_max+1):\n\n  ac = x - (cc \/\/ 2)\n\n  bc = y - (cc \/\/ 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)","reference_code_col":"a, b, c, x, y = list(map(int, input().split()))\n\n# print(a, b, c, x, y)\n\n\n\nans = 10000 * (10 **5) + 7\n\nc_max = 0\n\nif x > y:\n\n  c_max = x * 2\n\nelse:\n\n  c_max = y * 2\n\n\n\nfor cc in range(0, c_max+1, 2):\n\n  ac = x - (cc \/\/ 2)\n\n  bc = y - (cc \/\/ 2)\n\n  \n\n  if ac < 0:\n\n    ac = 0\n\n  if bc < 0:\n\n    bc = 0\n\n  price = ac * a + bc * b + cc * c\n\n  # print('price: {}, ac: {}, bc: {}, cc: {}'.format(price, ac, bc, cc))\n\n  ans = min(ans, price)\n\n\n\nprint(ans)\n\n  ","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\n\nans = float('inf')\n\nfor cc in range(max(x, y) + 1):\n    ac = max(0, x - cc)\n    bc = max(0, y - cc)\n    price = ac * a + bc * b + cc * c\n    ans = min(ans, price)\n\nprint(ans)"}
{"problem_id":"p02899","slow_code_col":"n = int(eval(input()))\n\na = list(map(int,input().split()))\n\nans = [i for i in range(n)]\n\na1 = sorted(a)\n\nfor i in range(n):\n\n    num = a[i]\n\n    ans[num - 1] = str(i + 1)\n\n    \n\nprint((' '.join(ans)))","reference_code_col":"n = int(eval(input()))\n\n# n,k = map(int,input().split())\n\na = list(map(int,input().split()))\n\nans = [0 for _ in range(n)]\n\nfor i in range(n):\n\n  ans[a[i] - 1] = str(i + 1)\n\nprint((\" \".join(ans)))","model_generated_potentially_faster_code_col":"n = int(input())\na = list(map(int, input().split()))\n\n# Create a dictionary to map values to their indices\nvalue_to_index = {val: idx for idx, val in enumerate(a)}\n\n# Initialize the result array with empty strings\nans = [''] * n\n\n# Populate the result array using the mapped indices\nfor value, index in value_to_index.items():\n    ans[value - 1] = str(index + 1)\n\n# Print the result\nprint(' '.join(ans))"}
{"problem_id":"p02574","slow_code_col":"class prime_factorize_by_osa_k():\n\n    def __init__(self, max_val):\n\n        '''\n\n        \u5272\u308b\u3053\u3068\u304c\u51fa\u6765\u308b\u6700\u5c0f\u306e\u5024\u3092\u683c\u7d0d\u3057\u305f\u30ea\u30b9\u30c8\u3092\u8fd4\u3059\n\n        :param max_val:\n\n        :return:\n\n        '''\n\n        self.minFactor = [-1] * (max_val + 1)\n\n        for i in range(2, max_val + 1):\n\n            if self.minFactor[i] == -1:\n\n                self.minFactor[i] = i\n\n                # \u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\u3068\u540c\u69d8\u306e\u51e6\u7406\u3092\u884c\u3046\n\n                for j in range(i * i, max_val + 1, i):\n\n                    if self.minFactor[j] == -1:\n\n                        self.minFactor[j] = i\n\n\n\n    def osa_k(self, n):\n\n        '''\n\n        preprocess\u3092\u3057\u305f\u3042\u3068\u3001O(logN)\u3067\u7d20\u56e0\u6570\u5206\u89e3\u3092\u884c\u3046\u3002n\u306e\u6700\u5927\u5024\u3092n_max\u3068\u3059\u308b\u3002\n\n        :param n:\n\n        :return:\n\n        '''\n\n        from collections import defaultdict\n\n        d = defaultdict(int)\n\n        now = n\n\n        while now > 1:\n\n            d[self.minFactor[now]] += 1\n\n            now \/\/= self.minFactor[now]\n\n        return d\n\ndef gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# N = 10 ** 6\n\n# A = [10 ** 6] * N\n\nob = prime_factorize_by_osa_k(10 ** 6)\n\npairwise = False\n\nprime_key = set(ob.osa_k(A[-1]).keys())\n\nbreak_flag = False\n\nprime_flags = [False] * (10 ** 6 + 1)\n\nfor i in range(N):\n\n    for key in list(ob.osa_k(A[i]).keys()):\n\n        if prime_flags[key]:\n\n            break_flag = True\n\n            break\n\n        else:\n\n            prime_flags[key] = True\n\n    if break_flag:\n\n        break\n\nelse:\n\n    pairwise = True\n\nif pairwise:\n\n    print('pairwise coprime')\n\n    exit()\n\nwork = gcd(A[0], A[1])\n\nfor i in range(2, N):\n\n    work = gcd(work, A[i])\n\nif work != 1:\n\n    print('not coprime')\n\nelse:\n\n    print('setwise coprime')","reference_code_col":"def gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\ndef isPrimeMR(n):\n\n    d = n - 1\n\n    d = d \/\/ (d & -d)\n\n    L = [2]\n\n    for a in L:\n\n        t = d\n\n        y = pow(a, t, n)\n\n        if y == 1: continue\n\n        while y != n - 1:\n\n            y = (y * y) % n\n\n            if y == 1 or t == n - 1: return 0\n\n            t <<= 1\n\n    return 1\n\ndef findFactorRho(n):\n\n    m = 1 << n.bit_length() \/\/ 8\n\n    for c in range(1, 99):\n\n        f = lambda x: (x * x + c) % n\n\n        y, r, q, g = 2, 1, 1, 1\n\n        while g == 1:\n\n            x = y\n\n            for i in range(r):\n\n                y = f(y)\n\n            k = 0\n\n            while k < r and g == 1:\n\n                ys = y\n\n                for i in range(min(m, r - k)):\n\n                    y = f(y)\n\n                    q = q * abs(x - y) % n\n\n                g = gcd(q, n)\n\n                k += m\n\n            r <<= 1\n\n        if g == n:\n\n            g = 1\n\n            while g == 1:\n\n                ys = f(ys)\n\n                g = gcd(abs(x - ys), n)\n\n        if g < n:\n\n            if isPrimeMR(g): return g\n\n            elif isPrimeMR(n \/\/ g): return n \/\/ g\n\n            return findFactorRho(g)\n\ndef primeFactor(n):\n\n    i = 2\n\n    ret = {}\n\n    rhoFlg = 0\n\n    while i*i <= n:\n\n        k = 0\n\n        while n % i == 0:\n\n            n \/\/= i\n\n            k += 1\n\n        if k: ret[i] = k\n\n        i += 1 + i % 2\n\n        if i == 101 and n >= 2 ** 20:\n\n            while n > 1:\n\n                if isPrimeMR(n):\n\n                    ret[n], n = 1, 1\n\n                else:\n\n                    rhoFlg = 1\n\n                    j = findFactorRho(n)\n\n                    k = 0\n\n                    while n % j == 0:\n\n                        n \/\/= j\n\n                        k += 1\n\n                    ret[j] = k\n\n\n\n    if n > 1: ret[n] = 1\n\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\n\n    return ret\n\ndef gcd(a, b):\n\n    while b: a, b = b, a % b\n\n    return a\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n# N = 10 ** 6\n\n# A = [10 ** 6] * N\n\npairwise = False\n\nprime_key = set(primeFactor(A[-1]).keys())\n\nbreak_flag = False\n\nprime_flags = [False] * (10 ** 6 + 1)\n\nfor i in range(N):\n\n    for key in list(primeFactor(A[i]).keys()):\n\n        if prime_flags[key]:\n\n            break_flag = True\n\n            break\n\n        else:\n\n            prime_flags[key] = True\n\n    if break_flag:\n\n        break\n\nelse:\n\n    pairwise = True\n\nif pairwise:\n\n    print('pairwise coprime')\n\n    exit()\n\nwork = gcd(A[0], A[1])\n\nfor i in range(2, N):\n\n    work = gcd(work, A[i])\n\nif work != 1:\n\n    print('not coprime')\n\nelse:\n\n    print('setwise coprime')","model_generated_potentially_faster_code_col":"class prime_factorize_by_osa_k():\n    def __init__(self, max_val):\n        self.minFactor = [-1] * (max_val + 1)\n        for i in range(2, max_val + 1):\n            if self.minFactor[i] == -1:\n                self.minFactor[i] = i\n                for j in range(i * i, max_val + 1, i):\n                    if self.minFactor[j] == -1:\n                        self.minFactor[j] = i\n\n    def osa_k(self, n):\n        d = {}\n        now = n\n        while now > 1:\n            p = self.minFactor[now]\n            if p in d:\n                d[p] += 1\n            else:\n                d[p] = 1\n            now \/\/= p\n        return d\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nN = int(input())\nA = list(map(int, input().split()))\n\nob = prime_factorize_by_osa_k(10**6)\nprime_flags = [False] * (10**6 + 1)\n\npairwise_coprime = True\nsetwise_coprime = True\n\nfor i in range(N):\n    factors = ob.osa_k(A[i])\n    for key in factors:\n        if prime_flags[key]:\n            pairwise_coprime = False\n            setwise_coprime = False\n            break\n        else:\n            prime_flags[key] = True\n    if not pairwise_coprime:\n        break\n\nif pairwise_coprime:\n    print('pairwise coprime')\nelse:\n    work = A[0]\n    for i in range(1, N):\n        work = gcd(work, A[i])\n    if work == 1:\n        print('setwise coprime')\n    else:\n        print('not coprime')"}
{"problem_id":"p02901","slow_code_col":"INF = 2*10**7\n\n\n\n\n\ndef main():\n\n    N, M = (int(i) for i in input().split())\n\n    A = []\n\n    B = []\n\n    C = []\n\n    for _ in range(M):\n\n        a, b = (int(i) for i in input().split())\n\n        A.append(a)\n\n        B.append(b)\n\n        bit = 0\n\n        for i in input().split():\n\n            bit |= (1 << (int(i)-1))\n\n        C.append(bit)\n\n    dp = [[INF]*(1 << N) for _ in range(M+1)]\n\n    dp[0][0] = 0\n\n    for i in range(M):\n\n        for j in range(1 << N):\n\n            dp[i+1][j] = min(dp[i+1][j], dp[i][j])\n\n            if dp[i][j] != INF:\n\n                next_bit = j | C[i]\n\n                dp[i+1][next_bit] = min(dp[i+1][next_bit], dp[i][j] + A[i])\n\n    ans = dp[-1][-1]\n\n    if ans == INF:\n\n        print((-1))\n\n    else:\n\n        print(ans)\n\n    # print(*dp, sep=\"\\n\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"INF = 2*10**7\n\n\n\n\n\ndef main():\n\n    import sys\n\n    input = sys.stdin.buffer.readline\n\n    N, M = (int(i) for i in input().split())\n\n    A = []\n\n    B = []\n\n    C = []\n\n    for _ in range(M):\n\n        a, b = (int(i) for i in input().split())\n\n        A.append(a)\n\n        B.append(b)\n\n        bit = 0\n\n        for i in input().split():\n\n            bit |= (1 << (int(i)-1))\n\n        C.append(bit)\n\n    dp = [[INF]*(1 << N) for _ in range(M+1)]\n\n    dp[0][0] = 0\n\n    for i in range(M):\n\n        for j in range(1 << N):\n\n            dp[i+1][j] = min(dp[i+1][j], dp[i][j])\n\n            if dp[i][j] != INF:\n\n                next_bit = j | C[i]\n\n                dp[i+1][next_bit] = min(dp[i+1][next_bit], dp[i][j] + A[i])\n\n    ans = dp[-1][-1]\n\n    if ans == INF:\n\n        print((-1))\n\n    else:\n\n        print(ans)\n\n    # print(*dp, sep=\"\\n\")\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"INF = 2*10**7\n\n\n@lru_cache(None)\ndef dp(i, j):\n    if i == M:\n        return 0 if j == 0 else INF\n    next_bit = j | C[i]\n    return min(dp(i+1, j), dp(i+1, next_bit) + A[i])\n\n\ndef main():\n    global M, A, B, C\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = [reduce(lambda x, y: x | (1 << int(y)-1), input().split(), 0) for _ in range(M)]\n    ans = dp(0, 0)\n    if ans == INF:\n        print(-1)\n    else:\n        print(ans)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03575","slow_code_col":"#!\/usr\/bin\/env python3\n\nclass UnionFind():\n\n    def __init__(self, n):\n\n        self.n = n\n\n        self.parents = [-1] * n\n\n\n\n    def find(self, x):\n\n        if self.parents[x] < 0:\n\n            return x\n\n        else:\n\n            self.parents[x] = self.find(self.parents[x])\n\n            return self.parents[x]\n\n\n\n    def union(self, x, y):\n\n        x = self.find(x)\n\n        y = self.find(y)\n\n\n\n        if x == y:\n\n            return\n\n\n\n        if self.parents[x] > self.parents[y]:\n\n            x, y = y, x\n\n\n\n        self.parents[x] += self.parents[y]\n\n        self.parents[y] = x\n\n    \n\n\n\n    def same(self, x, y):\n\n        return self.find(x) == self.find(y)\n\n        \n\nimport numpy as np\n\nN, M = list(map(int, input().split()))\n\nedge = []\n\nfor _ in range(M):\n\n    edge.append(list(map(int, input().split())))\n\nans = 0 \n\nfor i in range(M):\n\n    unionfind = UnionFind(N)\n\n    for j in [k for k in range(M) if k != i]:\n\n        a, b = edge[j][0] - 1, edge[j][1] - 1\n\n        unionfind.union(a, b)\n\n    if np.count_nonzero(np.array(unionfind.parents) < 0) >= 2:\n\n        ans += 1\n\nprint(ans)","reference_code_col":"#!\/usr\/bin\/env python3\n\nfrom collections import deque\n\nN, M = list(map(int, input().split()))\n\nedge = []\n\nfor _ in range(M):\n\n    edge.append(list(map(int, input().split())))\n\nans = 0 \n\nfor i in range(M):\n\n    done = [True for _ in range(N + 1)]\n\n    renketu = [[] for _ in range(N + 1)]\n\n    for j in [k for k in range(M) if k != i]:\n\n        a, b = edge[j][0], edge[j][1]\n\n        renketu[a].append(b)\n\n        renketu[b].append(a)\n\n    q = deque([1])\n\n    while q:\n\n        now = q.pop()\n\n        done[now] = False\n\n\n\n        for r in renketu[now]:\n\n            if done[r]:\n\n                q.append(r)\n\n    if sum(done) > 1:\n\n        ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env python3\n\nclass UnionFind():\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nimport numpy as np\n\nN, M = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Initialize Union-Find with all edges included\nuf = UnionFind(N)\nfor a, b in edges:\n    uf.union(a-1, b-1)\n\n# Count connected components\nconnected_components = np.count_nonzero(np.array(uf.parents) < 0)\n\nans = 0\nfor a, b in edges:\n    uf.union(a-1, b-1)\n    if np.count_nonzero(np.array(uf.parents) < 0) == connected_components + 1:\n        ans += 1\n    uf.union(b-1, a-1)  # Revert union operation\n\nprint(ans)"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nA = np.array(list(map(int, input().split())))\n\ncount = 0\n\nwhile True:\n\n    if np.sum(A%2) > 0:\n\n        break\n\n    count +=1\n\n    A = A\/\/2\n\nprint(count)\n","reference_code_col":"n = int(eval(input()))\n\na = list(map(int, input().split()))\n\n\n\nans = float(\"inf\")\n\n\n\nfor i in a:\n\n    ans = min(ans, len(bin(i)) - bin(i).rfind(\"1\") - 1) # (1)\u20262\u3067\u5272\u3063\u305f\u56de\u6570\u304c\u6700\u5c0f\u306e\u3082\u306e\u3092\u63a2\u7d22\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN = int(input())\nA = np.array(list(map(int, input().split())))\n\n# Initialize count\ncount = 0\n\n# Loop until all elements are odd\nwhile np.any(A % 2 == 0):\n    A \/\/= 2\n    count += 1\n\n# Print the result\nprint(count)"}
{"problem_id":"p03253","slow_code_col":"def prime_factorize(num):\n\n    \"\"\"\n\n    This function performs prime factorization on the input natural number.\n\n    The result is returned in the form of a dictionary with the prime number as the key\n\n    and its number as the value.\n\n    :param num:\n\n    :return prime_factor: Dictionary with the prime number as the key and its number as the value.\n\n    \"\"\"\n\n    prime_factor = {}\n\n    i = 2\n\n    while i ** 2 <= num:\n\n        while num % i == 0:\n\n            num \/\/= i\n\n            if i in list(prime_factor.keys()):\n\n                prime_factor[i] += 1\n\n            else:\n\n                prime_factor[i] = 1\n\n        i += 1\n\n    if num > 1:\n\n        prime_factor[num] = 1\n\n    return prime_factor\n\n\n\n\n\nfrom math import factorial\n\n\n\n\n\ndef comb(n, r, R):\n\n    if n not in R:\n\n        a = factorial(n)\n\n        R[n] = a\n\n    else:\n\n        a = R[n]\n\n\n\n    if n - r not in R:\n\n        b = factorial(n - r)\n\n        R[n - r] = b\n\n    else:\n\n        b = R[n - r]\n\n\n\n    if r not in R:\n\n        c = factorial(r)\n\n        R[r] = c\n\n    else:\n\n        c = R[r]\n\n    return a \/\/ (b * c)\n\n\n\n\n\nn, m = list(map(int, input().split()))\n\nr = 1\n\n\n\nR = dict()\n\nprime_fac = prime_factorize(m)\n\nfor v in list(prime_fac.values()):\n\n    r *= comb(v + n - 1, v, R)\n\nmod = 1000000000 + 7\n\nprint((r % mod))\n","reference_code_col":"def prime_factorize(num):\n\n    \"\"\"\n\n    This function performs prime factorization on the input natural number.\n\n    The result is returned in the form of a dictionary with the prime number as the key\n\n    and its number as the value.\n\n    :param num:\n\n    :return prime_factor: Dictionary with the prime number as the key and its number as the value.\n\n    \"\"\"\n\n    prime_factor = {}\n\n    i = 2\n\n    while i ** 2 <= num:\n\n        while num % i == 0:\n\n            num \/\/= i\n\n            if i in list(prime_factor.keys()):\n\n                prime_factor[i] += 1\n\n            else:\n\n                prime_factor[i] = 1\n\n        i += 1\n\n    if num > 1:\n\n        prime_factor[num] = 1\n\n    return prime_factor\n\n\n\n\n\n\n\ndef combination(n, r):\n\n    r = min(n-r, r)\n\n    result = 1\n\n    for i in range(n, n-r, -1):\n\n        result *= i\n\n    for i in range(1, r+1):\n\n        result \/\/= i\n\n    return result\n\n\n\n\n\nn, m = list(map(int, input().split()))\n\nr = 1\n\n\n\nprime_fac = prime_factorize(m)\n\nfor v in list(prime_fac.values()):\n\n    r *= combination(v + n - 1, v)\n\nmod = 1000000000 + 7\n\nprint((r % mod))\n","model_generated_potentially_faster_code_col":"import math\n\ndef prime_factorize(num):\n    prime_factor = {}\n    # Check for divisibility by 2\n    while num % 2 == 0:\n        if 2 in prime_factor:\n            prime_factor[2] += 1\n        else:\n            prime_factor[2] = 1\n        num \/\/= 2\n    \n    # Check for odd divisors from 3 onwards\n    i = 3\n    while i * i <= num:\n        while num % i == 0:\n            if i in prime_factor:\n                prime_factor[i] += 1\n            else:\n                prime_factor[i] = 1\n            num \/\/= i\n        i += 2\n    \n    # If num is still greater than 2, it must be a prime factor\n    if num > 2:\n        prime_factor[num] = 1\n    \n    return prime_factor"}
{"problem_id":"p02951","slow_code_col":"a, b, c = list(map(int, input().split()))\n\n\n\nif a < b + c:\n\n    print((b+c-a))\n\nelse:\n\n    print((0))","reference_code_col":"a,b,c = list(map(int, input().split()))\n\n\n\nprint((max(0, c-(a-b))))","model_generated_potentially_faster_code_col":"a, b, c = map(int, input().split())\n\nresult = max(b + c - a, 0)\n\nprint(result)"}
{"problem_id":"p03038","slow_code_col":"from collections import Counter\n\nN, M = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\n\n\n\nX = Counter(A)\n\nfor i in range(M):\n\n    B, C = list(map(int, input().split()))\n\n    X[C] += B\n\n\n\nZ = []\n\nfor key, value in list(X.items()):\n\n    Z.append((key, value))\n\n\n\nZ.sort(key=lambda x: x[0], reverse=True)\n\n\n\nans = 0\n\ncnt = 0\n\n\n\nfor value, key in Z:\n\n    if cnt + key <= N:\n\n        ans += key * value\n\n        cnt += key\n\n    else:\n\n        ans += (N - cnt) * value\n\n        break\n\n\n\nprint(ans)\n","reference_code_col":"N, M = list(map(int, input().split()))\n\nA = sorted(list(map(int, input().split())))\n\nquery = []\n\nfor i in range(M):\n\n    b, c = list(map(int, input().split()))\n\n    query.append([b, c])\n\nquery.sort(key=lambda q: q[1], reverse=True)\n\n\n\n\n\ni = 0\n\nfor b, c in query:\n\n    while i < N and b > 0:\n\n        if A[i] < c:\n\n            A[i] = c\n\n            b -= 1\n\n        i += 1\n\n\n\nprint((sum(A)))\n","model_generated_potentially_faster_code_col":"from collections import Counter\n\nN, M = map(int, input().split())\n\nA = list(map(int, input().split()))\n\nX = Counter(A)\n\nfor _ in range(M):\n    B, C = map(int, input().split())\n    X[C] += B\n\nans = 0\ncnt = 0\n\nfor key in sorted(X.keys(), reverse=True):\n    if cnt + X[key] > N:\n        ans += (N - cnt) * key\n        break\n    else:\n        ans += X[key] * key\n        cnt += X[key]\n\nprint(ans)"}
{"problem_id":"p03723","slow_code_col":"a, b, c = list(map(int, input().split()))\n\n\n\nif any(i % 2 != 0 for i in [a, b, c]):\n\n    print((0))\n\n    exit()\n\n\n\nif a == b and b == c:\n\n    print((-1))\n\n    exit()\n\n\n\ncnt = 0\n\na_list = [0]*(1001001)\n\nb_list = [0]*(1001001)\n\nc_list = [0]*(1001001)\n\na_list[0] = a\n\nb_list[0] = b\n\nc_list[0] = c\n\n\n\nfor i in range(1, 1001001):\n\n    a_list[i] = (b_list[i-1] + c_list[i-1]) \/\/ 2\n\n    b_list[i] = (c_list[i-1] + a_list[i-1]) \/\/ 2\n\n    c_list[i] = (a_list[i-1] + b_list[i-1]) \/\/ 2\n\n    cnt += 1\n\n    if a_list[i] % 2 != 0 or b_list[i] % 2 != 0 or c_list[i] % 2 != 0:\n\n        break\n\n\n\nprint(cnt)\n","reference_code_col":"def solve(a, b, c):\n\n    if any(i % 2 == 1 for i in [a, b, c]):\n\n        return 0\n\n    if a == b == c:\n\n        return -1\n\n    a, b, c = (b + c) \/\/ 2, (c + a) \/\/ 2, (a + b) \/\/ 2\n\n    return solve(a, b, c) + 1\n\n\n\na, b, c = list(map(int, input().split()))\n\n\n\nprint((solve(a, b, c)))","model_generated_potentially_faster_code_col":"# Read input values\na, b, c = map(int, input().split())\n\n# Check if any value is odd\nif a % 2 != 0 or b % 2 != 0 or c % 2 != 0:\n    print(0)\nelse:\n    # Initialize variables\n    max_val = max(a, b, c)\n    a_list = [0] * (max_val + 1)\n    b_list = [0] * (max_val + 1)\n    c_list = [0] * (max_val + 1)\n    \n    # Initialize the first elements\n    a_list[0] = a\n    b_list[0] = b\n    c_list[0] = c\n    \n    # Calculate the sequences until an odd number is found\n    cnt = 0\n    while True:\n        cnt += 1\n        new_a = (b_list[cnt - 1] + c_list[cnt - 1]) \/\/ 2\n        new_b = (c_list[cnt - 1] + a_list[cnt - 1]) \/\/ 2\n        new_c = (a_list[cnt - 1] + b_list[cnt - 1]) \/\/ 2\n        \n        a_list[cnt] = new_a\n        b_list[cnt] = new_b\n        c_list[cnt] = new_c\n        \n        if new_a % 2 != 0 or new_b % 2 != 0 or new_c % 2 != 0:\n            break\n    \n    # Print the count\n    print(cnt)"}
{"problem_id":"p03013","slow_code_col":"from functools import lru_cache\n\nimport sys\n\nsys.setrecursionlimit(30000)\n\n\n\nN, M = list(map(int, input().split()))\n\na = list(int(eval(input())) for _ in range(M))\n\n\n\nMOD = pow(10, 9) + 7\n\n\n\nisOk = True\n\nfor i in range(M-1):\n\n    if a[i] + 1 == a[i+1]:\n\n        isOk = False\n\n    \n\nfuncb = [-1] * 100001\n\ndef func(n):\n\n    if n <= 0:\n\n        return 1\n\n    cnt = funcb[n]\n\n    if cnt > 0:\n\n        return cnt\n\n    cnt = 0\n\n    if n >= 2:\n\n        cnt += func(n-2)\n\n    if n >= 1:\n\n        cnt += func(n-1)\n\n    funcb[n] = cnt % MOD\n\n    return funcb[n]\n\n\n\nfunc(30000)\n\nfunc(50000)\n\nfunc(80000)\n\nfunc(100000)\n\n\n\nif not isOk:\n\n    print((0))\n\nelse:\n\n    ans = 1\n\n    s = 0\n\n    for i in range(M+1):\n\n        if i >= M:\n\n            e = N\n\n        else:\n\n            e = a[i] - 1\n\n\n\n        ans = ans * func(e-s) % MOD\n\n\n\n        if i >= M:\n\n            break\n\n\n\n        s = a[i] + 1\n\n\n\n    print(ans)\n","reference_code_col":"N, M = list(map(int, input().split()))\n\na = list(int(eval(input())) for _ in range(M))\n\n\n\nMOD = pow(10, 9) + 7\n\n\n\nMAP = [0] * (N + 1)\n\n\n\nfor x in a:\n\n    MAP[x] = -1\n\n\n\nMAP[0] = 1 \n\nfor i in range(N):\n\n    if MAP[i] < 0:\n\n        continue\n\n\n\n    MAP[i] %= MOD\n\n    if i + 1 <= N and MAP[i+1] >= 0:\n\n        MAP[i+1] += MAP[i]\n\n    if i + 2 <= N and MAP[i+2] >= 0:\n\n        MAP[i+2] += MAP[i]\n\n\n\nprint((MAP[N] % MOD))\n","model_generated_potentially_faster_code_col":"from functools import lru_cache\n\nimport sys\n\n# Set a reasonable recursion limit\nsys.setrecursionlimit(3000)\n\nMOD = pow(10, 9) + 7\n\nN, M = map(int, input().split())\n\na = [int(eval(input())) for _ in range(M)]\n\nisOk = True\nfor i in range(M - 1):\n    if a[i] + 1 == a[i + 1]:\n        isOk = False\n\n# Precompute func values up to 100000\n@lru_cache(None)\ndef func(n):\n    if n <= 0:\n        return 1\n    cnt = 0\n    if n >= 2:\n        cnt += func(n - 2)\n    if n >= 1:\n        cnt += func(n - 1)\n    return cnt % MOD\n\n# Compute all required func values\nfor n in [30000, 50000, 80000, 100000]:\n    func(n)\n\nif not isOk:\n    print(0)\nelse:\n    ans = 1\n    s = 0\n    for i in range(M + 1):\n        if i >= M:\n            e = N\n        else:\n            e = a[i] - 1\n\n        ans = ans * func(e - s) % MOD\n\n        if i >= M:\n            break\n\n        s = a[i] + 1\n\n    print(ans)"}
{"problem_id":"p02780","slow_code_col":"import sys\n\nimport numpy as np\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nn, k = list(map(int, readline().split()))\n\np = list(map(int, readline().split()))\n\n\n\ntmp = [(i+1)\/2 for i in p]\n\ncs = list(np.cumsum(tmp))\n\n\n\nif n == k:\n\n    print((cs[-1]))\n\n    exit()\n\nans = 0\n\nfor i in range(n - k):\n\n    ans = max(ans, cs[i + k] - cs[i])\n\nprint(ans)","reference_code_col":"import sys\n\n# import numpy as np\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nn, k = list(map(int, readline().split()))\n\np = list(map(int, readline().split()))\n\n\n\ntmp = [(i+1)\/2 for i in p]\n\n# cs = list(np.cumsum(tmp))\n\n\n\ncs = [0]*n\n\ncs[0] = tmp[0]\n\nfor i in range(len(tmp)-1):\n\n    cs[i + 1] = cs[i] + tmp[i + 1]\n\n\n\nif n == k:\n\n    print((cs[-1]))\n\n    exit()\n\nans = 0\n\nfor i in range(n - k):\n\n    ans = max(ans, cs[i + k] - cs[i])\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Read input efficiently\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the first line\nn, k = map(int, data[:2])\np = list(map(int, data[2:]))\n\n# Compute the temporary array\ntmp = [(i + 1) \/ 2 for i in p]\n\n# Compute the cumulative sum array\ncs = np.cumsum(tmp)\n\n# Handle the special case where n == k\nif n == k:\n    print(cs[-1])\n    sys.exit(0)\n\n# Initialize the answer with the first possible window sum\nans = cs[k - 1]\n\n# Iterate over the array to find the maximum window sum\nfor i in range(k, n):\n    ans = max(ans, cs[i] - cs[i - k])\n\nprint(ans)"}
{"problem_id":"p02921","slow_code_col":"# 2019-11-17 20:44:23(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\n# import itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# import re\n\n# import heapq\n\n# import array\n\n# from scipy.misc import comb # (default: exact=False)\n\n# import numpy as np \n\n\n\n\n\ndef main():\n\n    s, t = sys.stdin.read().split()\n\n\n\n    count = 0\n\n    for i in range(3):\n\n        if s[i] == t[i]:\n\n            count += 1\n\n    print(count)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"import sys\n\n\n\ns, t = sys.stdin.read().split()\n\n\n\ndef main():\n\n    cnt = 0\n\n    for i in range(3):\n\n        if s[i] == t[i]:\n\n            cnt += 1\n\n    return cnt\n\n    \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    s, t = sys.stdin.read().split()\n    \n    count = sum(1 for i in range(3) if s[i] == t[i])\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03494","slow_code_col":"# -*- coding: utf-8 -*-\n\n\n\nimport numpy as np\n\n\n\nn = int(eval(input()))\n\nl = np.array(list(map(int, input().split())))\n\n\n\ncount = 0\n\n\n\nwhile(1):\n\n    if all(1 - (l % 2)):\n\n        count += 1\n\n        l = l \/ 2\n\n    else:\n\n        break\n\n\n\nprint(count)\n","reference_code_col":"N = eval(input())\n\nA = list(map(int, input().split()))\n\n\n\ncount = 0\n\nwhile all(a%2==0 for a in A):\n\n    count += 1\n\n    A = [a\/2 for a in A]\n\n\n\nprint(count)\n","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nimport numpy as np\n\nn = int(input())\nl = list(map(int, input().split()))\ncount = 0\n\nfor i in range(n):\n    while l[i] > 1:\n        if l[i] % 2 == 0:\n            l[i] \/\/= 2\n        else:\n            break\n    count += 1\n\nprint(count)"}
{"problem_id":"p03416","slow_code_col":"#                         author:  kagemeka \n\n#                         created: 2019-11-06 21:30:22(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# import string\n\n# import bisect\n\n# import re\n\n# import itertools\n\n# import statistics\n\n# import functools\n\n# import operator\n\n\n\ndef main():\n\n    a, b = (int(x) for x in sys.stdin.read().split())\n\n\n\n    count = 0\n\n    for n in range(a, b+1):\n\n        n = str(n)\n\n        if n == n[::-1]:\n\n            count += 1\n\n\n\n    print(count)       \n\n\n\nif __name__ == \"__main__\":\n\n    # execute only if run as a script\n\n    main()\n","reference_code_col":"import sys\n\nfrom bisect import bisect_left as bi_l, bisect_right as bi_r\n\n\n\na, b = list(map(int, sys.stdin.readline().split()))\n\n\n\ndef main():\n\n    palindromic_nums = []\n\n    for i in range(1, 10):\n\n        for j in range(10):\n\n            for k in range(10):\n\n                x = [i, j, k, j, i]\n\n                palindromic_nums.append(int(''.join(list(map(str, x)))))\n\n\n\n    return bi_r(palindromic_nums, b) - bi_l(palindromic_nums, a)\n\n                \n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    a, b = map(int, sys.stdin.read().split())\n\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    count = sum(is_palindrome(n) for n in range(a, b + 1))\n\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02767","slow_code_col":"N = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nX = list(sorted(X))\n\nif N == 1:\n\n  print((0))\n\n  exit()\n\nans = float('inf')\n\nfor p in range(X[0], X[N - 1] + 1):\n\n  sum = 0\n\n  for x in X:\n\n    sum += (x - p) ** 2\n\n  ans = min(sum, ans)\n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nX = list(map(int, input().split()))\n\navg = round(sum(X) \/ N)\n\nprint((sum([(x - avg) ** 2 for x in X])))","model_generated_potentially_faster_code_col":"N = int(eval(input()))\nX = list(map(int, input().split()))\n\n# Sort the array only once\nX.sort()\n\n# Calculate the mean of the array\nmean = sum(X) \/ N\n\n# Initialize the answer with a large value\nans = float('inf')\n\n# Iterate over a reasonable range around the mean\nfor p in range(int(mean - 1), int(mean + 2)):\n    # Calculate the sum of squared differences\n    sum_squared_diff = sum((x - p) ** 2 for x in X)\n    # Update the minimum sum found\n    ans = min(sum_squared_diff, ans)\n\nprint(ans)"}
{"problem_id":"p02725","slow_code_col":"k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nd = [0] * n\n\nd_max = 0\n\n\n\nfor i in range(n - 1):\n\n    d[i] = a[i + 1] - a[i]\n\n    d_max = max(d_max, d[i])\n\n\n\nd[-1] = (k - a[-1]) + a[0]\n\nd_max = max(d_max, d[-1])\n\n\n\nprint((k - d_max))\n","reference_code_col":"k, n = list(map(int, input().split()))\n\na = list(map(int, input().split()))\n\nd_max = 0\n\n\n\nfor i in range(n - 1):\n\n    d = a[i + 1] - a[i]\n\n    d_max = max(d_max, d)\n\n\n\nd = (k - a[-1]) + a[0]\n\nd_max = max(d_max, d)\n\n\n\nprint((k - d_max))\n","model_generated_potentially_faster_code_col":"k, n = map(int, input().split())\na = list(map(int, input().split()))\n\nmax_diff = 0\nmin_val = float('inf')\n\nfor i in range(1, n):\n    diff = abs(a[i] - a[i-1])\n    if diff > max_diff:\n        max_diff = diff\n    if a[i] < min_val:\n        min_val = a[i]\n\n# Subtract the maximum difference from k and add the minimum value\nresult = k - max_diff + min_val\nprint(result)"}
{"problem_id":"p02822","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nfrom collections import deque\n\nN = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\ni0 = min([i for i in range(N) if len(X[i]) == 1])\n\n\n\nP = [-1] * N\n\nQ = deque([i0])\n\nR = []\n\nwhile Q:\n\n    i = deque.popleft(Q)\n\n    R.append(i)\n\n    for a in X[i]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            X[a].remove(i)\n\n            deque.append(Q, a)\n\n\n\nmod = 10 ** 9 + 7\n\ninv2 = (mod + 1) \/\/ 2\n\nA = [1] * N\n\nfor i in R[::-1]:\n\n    s = 0\n\n    for j in X[i]:\n\n        A[i] += A[j]\n\n\n\nans = 0\n\nfor i in range(N):\n\n    s = pow(inv2, N - A[i], mod)\n\n    t = 1 + (1-pow(inv2, N - A[i], mod)) * pow(2, N - A[i], mod)\n\n    for j in X[i]:\n\n        s = (s * pow(inv2, A[j], mod)) % mod\n\n        t = (t + (1-pow(inv2, A[j], mod)) * pow(2, A[j], mod)) % mod\n\n    ans = (ans + 1 - s * t) % mod\n\n\n\nprint((ans * inv2 % mod))","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\nfrom collections import deque\n\nN = int(eval(input()))\n\nX = [[] for i in range(N)]\n\nfor i in range(N-1):\n\n    x, y = list(map(int, input().split()))\n\n    X[x-1].append(y-1)\n\n    X[y-1].append(x-1)\n\ni0 = min([i for i in range(N) if len(X[i]) == 1])\n\n\n\nP = [-1] * N\n\nQ = deque([i0])\n\nR = []\n\nwhile Q:\n\n    i = deque.popleft(Q)\n\n    R.append(i)\n\n    for a in X[i]:\n\n        if a != P[i]:\n\n            P[a] = i\n\n            X[a].remove(i)\n\n            deque.append(Q, a)\n\n\n\nmod = 10 ** 9 + 7\n\npow2 = [1]\n\nfor i in range(N + 10):\n\n    pow2.append(pow2[-1] * 2 % mod)\n\ninv2 = (mod + 1) \/\/ 2\n\n\n\ninvpow2 = [pow(pow2[-1], mod-2, mod)]\n\nfor i in range(N + 10)[::-1]:\n\n    invpow2.append(invpow2[-1] * 2 % mod)\n\ninvpow2 = invpow2[::-1]\n\n\n\nA = [1] * N\n\nfor i in R[::-1]:\n\n    s = 0\n\n    for j in X[i]:\n\n        A[i] += A[j]\n\n\n\nans = 0\n\nfor i in range(N):\n\n    s = pow(inv2, N - A[i], mod)\n\n    t = 1 + (1-invpow2[N-A[i]]) * pow2[N-A[i]]\n\n    for j in X[i]:\n\n        s = (s * invpow2[A[j]]) % mod\n\n        t = (t + (1-invpow2[A[j]]) * pow2[A[j]]) % mod\n\n    ans = (ans + 1 - s * t) % mod\n\n\n\nprint((ans * inv2 % mod))","model_generated_potentially_faster_code_col":"N = int(input())"}
{"problem_id":"p03060","slow_code_col":"import numpy as np\n\n\n\nn = int(eval(input()))\n\nv = np.array(list(map(int, input().split())))\n\nc = np.array(list(map(int, input().split())))\n\np = v-c\n\nans = 0\n\nfor i in p:\n\n    if i>0:\n\n        ans+=i\n\n\n\nprint(ans)\n","reference_code_col":"n=int(eval(input()))\n\nV=list(map(int,input().split()))\n\nC=list(map(int,input().split()))\n\nans=0\n\nfor v,c in zip(V,C):\n\n    diff=v-c\n\n    if 0<diff:\n\n        ans+=diff\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\nn = int(eval(input()))\nv = np.array(list(map(int, input().split())))\nc = np.array(list(map(int, input().split())))\n\n# Compute the difference between v and c\np = v - c\n\n# Use numpy's sum function with boolean indexing to sum up positive values\nans = np.sum(p[p > 0])\n\nprint(ans)"}
{"problem_id":"p02725","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tK,N = MI()\n\n\tA = np.array(LI())\n\n\tA_LAST = K+A[0] - A[N-1]\n\n\tB = A[1:]-A[:N-1]\n\n\tB = np.sort(B)\n\n\tprint(K-max(B[N-2],A_LAST))\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n","reference_code_col":"import sys\n\n\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\nprintV = lambda x: print(*x, sep=\"\\n\")\n\nprintH = lambda x: print(\" \".join(map(str,x)))\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\ndef LII(rows_number): return [II() for _ in range(rows_number)]\n\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\n\n\ndef main():\n\n\tk,n = MI()\n\n\ta = LI()\n\n\tb = [0]*n\n\n\tfor i in range(n):\n\n\t\tif i == n-1:\n\n\t\t\tb[i] = a[0]+k-a[i]\n\n\t\telse:\n\n\t\t\tb[i] = a[i+1]-a[i]\n\n\tb.sort()\n\n\tprint(k-b[-1])\n\n\n\n\n\nif __name__ == '__main__':\n\n\tmain()\n","model_generated_potentially_faster_code_col":"import sys\n\nsys.setrecursionlimit(10 ** 6)\n\nint1 = lambda x: int(x) - 1\n\ndef IS(): return sys.stdin.readline()[:-1]\n\ndef II(): return int(sys.stdin.readline())\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\n\n\ndef main():\n    K, N = MI()\n    A = LI()\n    \n    # Calculate the difference array B efficiently\n    B = [A[i] - A[i - 1] for i in range(1, N)]\n    \n    # Sort B in ascending order\n    B.sort()\n    \n    # Calculate A_LAST efficiently\n    A_LAST = K + A[0] - A[-1]\n    \n    # Find the maximum value between the second last element of B and A_LAST\n    max_value = max(B[-2], A_LAST)\n    \n    # Print the result\n    print(K - max_value)\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03796","slow_code_col":"from math import factorial\n\ndef myAnswer(N:int) ->int:\n\n   ans =factorial(N)\n\n   return ans % (10**9 + 7)\n\n\n\ndef modelAnswer():\n\n   tmp=1\n\ndef main():\n\n   N = int(eval(input()))\n\n   print((myAnswer(N)))\n\n\n\n\n\nif __name__ == '__main__':\n\n   main()","reference_code_col":"def modelAnswer(N:int) -> int:\n\n   ans = 1\n\n   for i in range(1,N+1):\n\n      ans = (ans*i) % (10**9 + 7)\n\n   return ans \n\ndef main():\n\n   N = int(eval(input()))\n\n   print((modelAnswer(N)))\n\n\n\n\n\nif __name__ == '__main__':\n\n   main()\n","model_generated_potentially_faster_code_col":"def myAnswer(N: int) -> int:\n    MOD = 10**9 + 7\n    result = 1\n    for i in range(2, N+1):\n        result = (result * i) % MOD\n    return result\n\n\ndef main():\n    N = int(input())\n    print(myAnswer(N))\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02881","slow_code_col":"import numpy as np\n\n\n\nN=int(eval(input()))\n\na=int(np.sqrt(N))\n\nb=float('inf')\n\nfor i in range(1,a+1):\n\n    if N%i==0:\n\n        if i+N\/\/i<b:\n\n            ans=i\n\n\n\nprint((ans+N\/\/ans-2))\n","reference_code_col":"# -*- coding: utf-8 -*-\n\nimport sys\n\nfrom math import sqrt\n\nsys.setrecursionlimit(10**9)\n\nINF=10**18\n\nMOD=10**9+7\n\ndef input(): return sys.stdin.readline().rstrip()\n\n\n\ndef main():\n\n    N=int(eval(input()))\n\n    tmp=INF\n\n    for i in range(1,10**6+1):\n\n        if N%i==0:\n\n            tmp=min(tmp,i+N\/\/i)\n\n    print((tmp-2))\n\n    \n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import math\n\nN = int(input())\n\n# Calculate the square root of N and round it down to the nearest integer\na = int(math.isqrt(N))\n\n# Initialize the minimum divisor with infinity\nb = float('inf')\n\n# Iterate over possible divisors from 1 to a (inclusive)\nfor i in range(1, a + 1):\n    # Check if i divides N without a remainder\n    if N % i == 0:\n        # Update the minimum divisor if a smaller one is found\n        b = min(b, i)\n\n# Calculate the result based on the minimum divisor\nresult = (b + N \/\/ b - 2)\n\n# Print the result\nprint(result)"}
{"problem_id":"p03253","slow_code_col":"import math\n\nN, M = list(map(int, input().split()))\n\n\n\n\n\ndef factorization(n):\n\n    arr = []\n\n    temp = n\n\n    for i in range(2, int(-(-n**0.5\/\/1))+1):\n\n        if temp % i == 0:\n\n            cnt = 0\n\n            while temp % i == 0:\n\n                cnt += 1\n\n                temp \/\/= i\n\n            arr.append([i, cnt])\n\n    if temp != 1:\n\n        arr.append([temp, 1])\n\n\n\n    if arr == [] and n != 1:\n\n        arr.append([n, 1])\n\n\n\n    return arr\n\n\n\n\n\nmod = 10**9 + 7\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\n\n\ng1 = [1, 1]\n\ng2 = [1, 1]\n\ninverse = [0, 1]\n\nfor i in range(2, 2*10**5 + 1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inverse.append((-inverse[mod % i] * (mod\/\/i)) % mod)\n\n    g2.append((g2[-1] * inverse[-1]) % mod)\n\n\n\n\n\nprimes = factorization(M)\n\n# \u4f55\u7b87\u6240\u306b\u5206\u3051\u308b\u304b\uff08cnt\u4ee5\u4e0b\uff09,\u305d\u306e\u4e2d\u3067\u3069\u3046\u5206\u3051\u308b\u304b\uff08\u3057\u304d\u308a\u3092\u3069\u3053\u306b\u304a\u304f\u304b\uff08\u632f\u308a\u5206\u3051\u3089\u308c\u306a\u3044\u3082\u306e\u304c\u51fa\u308b\u3068\u9078\u3079\u308c\u306a\u3044\u306e\u3068\u304a\u306a\u3058\u306b\u306a\u308b\u306e\u3067\u3001cnt - \u9078\u3093\u3060\u6570\uff09\uff09\n\n\n\nans = 1\n\n\n\nfor p, cnt in primes:\n\n    tmp = cmb(N+cnt-1, N-1, mod)\n\n    ans *= tmp\n\n    ans %= mod\n\n\n\nprint(ans)\n","reference_code_col":"def main():\n\n    N, M = list(map(int, input().split()))\n\n\n\n    def factorization(n):\n\n        arr = []\n\n        temp = n\n\n        for i in range(2, int(-(-n**0.5\/\/1))+1):\n\n            if temp % i == 0:\n\n                cnt = 0\n\n                while temp % i == 0:\n\n                    cnt += 1\n\n                    temp \/\/= i\n\n                arr.append([i, cnt])\n\n        if temp != 1:\n\n            arr.append([temp, 1])\n\n\n\n        if arr == [] and n != 1:\n\n            arr.append([n, 1])\n\n\n\n        return arr\n\n\n\n    mod = 10**9 + 7\n\n\n\n    def cmb(n, r, mod):\n\n        if (r < 0 or r > n):\n\n            return 0\n\n        r = min(r, n-r)\n\n        return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\n    g1 = [1, 1]\n\n    g2 = [1, 1]\n\n    inverse = [0, 1]\n\n    for i in range(2, N+100 + 1):\n\n        g1.append((g1[-1] * i) % mod)\n\n        inverse.append((-inverse[mod % i] * (mod\/\/i)) % mod)\n\n        g2.append((g2[-1] * inverse[-1]) % mod)\n\n\n\n    primes = factorization(M)\n\n    # \u4f55\u7b87\u6240\u306b\u5206\u3051\u308b\u304b\uff08cnt\u4ee5\u4e0b\uff09,\u305d\u306e\u4e2d\u3067\u3069\u3046\u5206\u3051\u308b\u304b\uff08\u3057\u304d\u308a\u3092\u3069\u3053\u306b\u304a\u304f\u304b\uff08\u632f\u308a\u5206\u3051\u3089\u308c\u306a\u3044\u3082\u306e\u304c\u51fa\u308b\u3068\u9078\u3079\u308c\u306a\u3044\u306e\u3068\u304a\u306a\u3058\u306b\u306a\u308b\u306e\u3067\u3001cnt - \u9078\u3093\u3060\u6570\uff09\uff09\n\n\n\n    ans = 1\n\n\n\n    for p, cnt in primes:\n\n        tmp = cmb(N+cnt-1, N-1, mod)\n\n        ans *= tmp\n\n        ans %= mod\n\n\n\n    print(ans)\n\n\n\n\n\nmain()\n","model_generated_potentially_faster_code_col":"import math\n\nN, M = map(int, input().split())\n\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if temp % i == 0:\n            cnt = 0\n            while temp % i == 0:\n                cnt += 1\n                temp \/\/= i\n            arr.append([i, cnt])\n    if temp != 1:\n        arr.append([temp, 1])\n    return arr\n\nmod = 10**9 + 7\n\ndef pow_mod(x, y, mod):\n    result = 1\n    x = x % mod\n    while y > 0:\n        if y & 1:\n            result = (result * x) % mod\n        y = y >> 1\n        x = (x * x) % mod\n    return result\n\ndef mod_inv(a, mod):\n    return pow_mod(a, mod - 2, mod)\n\ng1 = [1] * (2 * 10**5 + 1)\ng2 = [1] * (2 * 10**5 + 1)\ninverse = [1] * (2 * 10**5 + 1)\n\nfor i in range(2, 2 * 10**5 + 1):\n    g1[i] = (g1[i - 1] * i) % mod\n    inverse[i] = mod_inv(i, mod)\n    g2[i] = (g2[i - 1] * inverse[i]) % mod\n\nprimes = factorization(M)\n\nans = 1\nfor p, cnt in primes:\n    tmp = (g1[N + cnt - 1] * g2[N - 1] * g2[cnt]) % mod\n    ans = (ans * tmp) % mod\n\nprint(ans)"}
{"problem_id":"p02837","slow_code_col":"def check(x, y):\n\n    for a, b in zip(x, y):\n\n        if a != b and b != -1:\n\n            return False\n\n    else:\n\n        return True\n\n\n\n\n\nn = int(eval(input()))\n\nremarks = []\n\ncnt_max = 0\n\nfor _ in range(n):\n\n    a = int(eval(input()))\n\n    x = [tuple(map(int, input().split())) for i in range(a)]\n\n    r = [-1] * n\n\n    for i, j in x:\n\n        r[i - 1] = j\n\n    remarks.append(r)\n\nfor r in range(2 ** n):\n\n    r = list(bin(r)[2:].zfill(n))\n\n    r = [int(i) for i in r[:]]\n\n    cnt = 0\n\n    for i in range(n):\n\n        if r[i] == 1:\n\n            flag = check(r, remarks[i])\n\n            cnt += 1\n\n            if not flag:\n\n                cnt = 0\n\n                break\n\n    cnt_max = max(cnt, cnt_max)\n\nprint(cnt_max)","reference_code_col":"import numpy as np\n\nimport itertools\n\n\n\nn = int(eval(input()))\n\ninfo = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    for _ in range(a):\n\n        x, y = list(map(int, input().split()))\n\n        info.append((i, x - 1, y))\n\n\n\na = np.array(list(itertools.product([0, 1], repeat=n)), dtype=np.bool)\n\nfor i, x, y in info:\n\n    bl = (~a[:, i]) | (a[:, x] == bool(y))\n\n    a = a[bl]\n\n\n\nans = a.sum(axis=1).max()\n\nprint(ans)","model_generated_potentially_faster_code_col":"def check(x, y):\n    for a, b in zip(x, y):\n        if a != b and b != -1:\n            return False\n    return True\n\nn = int(input())\n\n# Precompute binary representations\nbinary_representations = [list(bin(i)[2:].zfill(n)) for i in range(2 ** n)]\nbinary_representations = [[int(bit) for bit in bin_rep] for bin_rep in binary_representations]\n\nremarks = []\ncnt_max = 0\n\nfor _ in range(n):\n    a = int(input())\n    x = [tuple(map(int, input().split())) for _ in range(a)]\n    r = [-1] * n\n    for i, j in x:\n        r[i - 1] = j\n    remarks.append(r)\n\nfor binary_rep in binary_representations:\n    cnt = 0\n    for i in range(n):\n        if binary_rep[i] == 1:\n            flag = check(binary_rep, remarks[i])\n            cnt += 1\n            if not flag:\n                cnt = 0\n                break\n    cnt_max = max(cnt, cnt_max)\n\nprint(cnt_max)"}
{"problem_id":"p03416","slow_code_col":"A, B = list(map(int, input().split()))\n\ncount_target = 0\n\n\n\nfor i in range(A, B + 1):\n\n    str_i = str(i)\n\n    reversed_i = ''\n\n    for n_th_i in reversed(list(range(len(str_i)))):\n\n        reversed_i += str_i[n_th_i]\n\n\n\n    if str_i == reversed_i:\n\n        count_target += 1\n\n\n\nprint(count_target)","reference_code_col":"A, B = list(map(int, input().split()))\n\ncount_target = 0\n\n\n\nfor i in range(A, B+1):\n\n    str_i = str(i)\n\n    reversed_i = str_i[::-1]\n\n\n\n    if str_i == reversed_i:\n\n        count_target += 1\n\n\n\nprint(count_target)\n","model_generated_potentially_faster_code_col":"A, B = map(int, input().split())\n\ncount_target = sum(1 for i in range(A, B + 1) if str(i) == str(i)[::-1])\n\nprint(count_target)"}
{"problem_id":"p02881","slow_code_col":"from collections import Counter,defaultdict,deque\n\nimport sys,bisect,math,itertools,string,queue\n\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn = inp()\n\nres = float('inf')\n\nfor i in range(1,2*10**6):\n\n    if (n\/i).is_integer():\n\n        res = min(res, i + n\/i)\n\nprint((int(res-2)))\n","reference_code_col":"from collections import Counter,defaultdict,deque\n\nimport sys,bisect,math,itertools,string,queue\n\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10**8)\n\nmod = 10**9+7\n\ndef inp(): return int(sys.stdin.readline())\n\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\ndef inpl_str(): return list(sys.stdin.readline().split())\n\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\n\n\nn = inp()\n\nres = float('inf')\n\nfor i in range(1,int(math.sqrt(n))+1):\n\n    if n%i == 0:\n\n        res = min(res, i + n\/i)\n\nprint((int(res-2)))\n","model_generated_potentially_faster_code_col":"from math import sqrt\n\nn = int(input())\nres = float('inf')\n\nfor i in range(1, int(sqrt(n)) + 1):\n    if n % i == 0:\n        res = min(res, i + n \/\/ i)\n\nprint(int(res - 2))"}
{"problem_id":"p02555","slow_code_col":"S = int(eval(input()))\n\n\n\ndp = [0] * (S + 1)\n\ndp[0] = 1\n\nM = 10 ** 9 + 7\n\n\n\nfor i in range(1, S + 1):\n\n    num = 0\n\n    for j in range(i - 2):\n\n        num += dp[j]\n\n        dp[i] = num % M\n\n\n\nprint((dp[S]))\n\n\n","reference_code_col":"S = int(eval(input()))\n\n\n\n\n\ndef cmb(n, r, p):\n\n    r = min(n - r, r)\n\n    if r == 0:\n\n        return 1\n\n    over = 1\n\n    for i in range(n, n - r, -1):\n\n        over = over * i % p\n\n    under = 1\n\n    for i in range(1, r + 1):\n\n        under = under * i % p\n\n    inv = pow(under, p - 2, p)\n\n    return over * inv % p\n\n\n\n\n\nM = 10 ** 9 + 7\n\nans = 0\n\nfor i in range(1, S):\n\n    if S - 3 * i < 0:\n\n        break\n\n    ans += cmb(S - 3 * i + i - 1, i - 1, M)\n\n    ans %= M\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"S = int(eval(input()))\n\na, b = 1, 1  # Initialize base cases: dp[0] = 1 and dp[1] = 1\n\nM = 10 ** 9 + 7\n\nfor _ in range(2, S + 1):\n    a, b = b, (a + b) % M\n\nprint(b)"}
{"problem_id":"p02837","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nimport numpy as np\n\nN = int(eval(input()))\n\nS = [[] for _ in range(N)]\n\nfor i in range(N):\n\n    A = int(eval(input()))\n\n    temp = []\n\n    for _ in range(A):\n\n        temp.append([str(x) for x in input().split()])\n\n        S[i] = temp\n\nans = 0\n\nfor i in range(2 ** N - 1, -1,-1):\n\n    biti = list(bin(i)[2:].zfill(N))\n\n    flag = 0\n\n    for j in range(N):\n\n        if biti[j] == \"1\":\n\n            for k in S[j]:\n\n                if biti[int(k[0])-1] != k[1]:\n\n                    flag = 1\n\n                    break\n\n        if flag:\n\n            break\n\n    if not flag:    \n\n        biti = np.array(biti)\n\n        ans = max(ans, np.count_nonzero(biti == \"1\"))\n\nprint(ans)","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\n\n\nfrom collections import defaultdict\n\nd = defaultdict(list)\n\n\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    for _ in range(a):\n\n        x, y = [int(x) for x in input().split()]\n\n        d[i].append((x - 1, y))\n\nans = 0\n\nfor k in range(2**n):\n\n    res = 0\n\n    j = bin(k)[2:].zfill(n)\n\n    flag = 1\n\n    for i in range(n):\n\n        if j[i] == \"0\":\n\n            continue\n\n        for x, y in d[i]:\n\n            if int(j[x]) != int(y):\n\n                flag = 0\n\n                break\n\n        res += 1\n\n    if flag:\n\n        ans = max(ans, res)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input data\nN = int(data[0])\nS = [[] for _ in range(N)]\nindex = 1\n\nfor i in range(N):\n    A = int(data[index])\n    index += 1\n    for _ in range(A):\n        temp = [int(x) for x in data[index:index + 2]]\n        S[i].append(temp)\n        index += 2\n\n# Initialize variables\nans = 0\nmask = (1 << N) - 1\n\n# Iterate over all possible subsets\nwhile mask >= 0:\n    biti = [(mask >> j) & 1 for j in range(N)]\n    flag = False\n\n    for j in range(N):\n        if biti[j]:\n            for k in S[j]:\n                if biti[k[0] - 1] != k[1]:\n                    flag = True\n                    break\n            if flag:\n                break\n\n    if not flag:\n        ans = max(ans, sum(biti))\n\n    mask -= 1\n\nprint(ans)"}
{"problem_id":"p03457","slow_code_col":"#!\/usr\/bin\/python3\n\n# -*- coding: utf-8 -*-\n\n\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nprev_dst = [0,0,0]\n\n\n\nfor n in range(N):\n\n    t, x, y = list(map(int, input().split(\" \")))\n\n    a = (t - prev_dst[0]) - (np.abs(prev_dst[1]-x) + np.abs(prev_dst[2]-y))\n\n    if a >= 0 and a % 2 == 0:\n\n        prev_dst = [t, x, y]\n\n    else:\n\n        print(\"No\")\n\n        exit(0)\n\n\n\nprint(\"Yes\")\n\n\n","reference_code_col":"#!\/usr\/bin\/python3\n\n# -*- coding: utf-8 -*-\n\n\n\nN = int(eval(input()))\n\nprev_dst = [0,0,0]\n\n\n\nfor n in range(N):\n\n    t, x, y = list(map(int, input().split(\" \")))\n\n    a = (t - prev_dst[0]) - (abs(prev_dst[1]-x) + abs(prev_dst[2]-y))\n\n    if a >= 0 and a % 2 == 0:\n\n        prev_dst = [t, x, y]\n\n    else:\n\n        print(\"No\")\n\n        exit(0)\n\n\n\nprint(\"Yes\")\n\n\n","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/python3\n\n# -*- coding: utf-8 -*-\n\nimport sys\n\nN = int(sys.stdin.readline())\n\nprev_dst = [0, 0, 0]\n\nfor n in range(N):\n    t, x, y = map(int, sys.stdin.readline().split())\n    \n    a = (t - prev_dst[0]) - (abs(prev_dst[1] - x) + abs(prev_dst[2] - y))\n    \n    if a >= 0 and a % 2 == 0:\n        prev_dst = [t, x, y]\n    else:\n        print(\"No\")\n        sys.exit(0)\n\nprint(\"Yes\")"}
{"problem_id":"p02767","slow_code_col":"import numpy as np\n\n\n\nN = int(eval(input()))\n\nX = np.array(list(int(x) for x in input().split()))\n\nm = round(np.mean(X))\n\n\n\nprint((int(sum((X-m)**2))))","reference_code_col":"N = int(eval(input()))\n\nX = list(int(x) for x in input().split())\n\np = round(sum(X)\/len(X))\n\nans = 0\n\n\n\nfor i in range(N):\n\n    ans += (X[i] - p)**2\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(input())\nX = np.array(list(map(int, input().split())))\n\nmean = X.mean()\nsum_squared_diff = np.sum((X - mean)**2)\n\nprint(int(sum_squared_diff))"}
{"problem_id":"p02390","slow_code_col":"a = int(eval(input()))\n\nh = int(a \/ 3600)\n\nm = int((a - h * 3600) \/ 60)\n\ns = int(a - h * 3600 - m * 60)\n\nprint((\":\" .join(map(str, [h, m, s]))))","reference_code_col":"num = int(input())\n\nprint(int(num\/3600), int((num%3600)\/60), num%60, sep=\":\")\n","model_generated_potentially_faster_code_col":"a = int(input())\n\nh = a \/\/ 3600\nm = (a % 3600) \/\/ 60\ns = a % 60\n\nprint(f\"{h}:{m:02d}:{s:02d}\")"}
{"problem_id":"p02899","slow_code_col":"n = int(eval(input()))\n\na = [int(x) for x in input().split()]\n\n\n\nans = list(range(n))\n\n\n\nfor i in range(n):\n\n    ans[a[i]-1] = i+1\n\n    \n\nprint((' '.join(map(str,ans))))","reference_code_col":"def main():\n\n\n\n    N = int(eval(input()))\n\n    A = list(int(x) for x in input().split())\n\n    ans = [0] * N\n\n\n\n    for i, a in enumerate(A):\n\n        ans[a-1] = i+1\n\n\n\n    print((' '.join(map(str, ans))))\n\n    \n\nif __name__ == '__main__':\n\n    main()","model_generated_potentially_faster_code_col":"n = int(input())\na = list(map(int, input().split()))\nans = [0] * n\n\n# Create a dictionary to store the index of each element in 'a'\nindex_map = {x: i for i, x in enumerate(a)}\n\n# Iterate over the range of 'n' and update 'ans' accordingly\nfor i in range(n):\n    ans[index_map[i + 1]] = i + 1\n\n# Print the result as a space-separated string\nprint(' '.join(map(str, ans)))"}
{"problem_id":"p03416","slow_code_col":"a, b = list(map(int, input().split()))\n\ncnt = 0\n\nfor x in range(a, b + 1):\n\n    s = str(x)\n\n    l = len(s)\n\n    flg = True\n\n    for i in range(l \/\/ 2):\n\n        if s[i] != s[l - 1 - i]:\n\n            flg = False\n\n            break\n\n    if flg:\n\n        cnt += 1\n\nprint(cnt)\n","reference_code_col":"a, b = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(a, b + 1):\n\n    s = str(i)\n\n    if s[0] == s[4] and s[1] == s[3]:\n\n        cnt += 1\n\nprint(cnt)","model_generated_potentially_faster_code_col":"a, b = map(int, input().split())\n\ncnt = 0\n\nfor x in range(a, b + 1):\n    if x < 10:  # Single-digit numbers are palindromes\n        cnt += 1\n    elif x < 100:  # Two-digit numbers are palindromes if both digits are the same\n        if x % 11 == 0:\n            cnt += 1\n    else:\n        # For numbers with more than two digits, check if they are palindromes\n        num_str = str(x)\n        l = len(num_str)\n        if all(num_str[i] == num_str[l - 1 - i] for i in range(l \/\/ 2)):\n            cnt += 1\n\nprint(cnt)"}
{"problem_id":"p02959","slow_code_col":"N = int(eval(input()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\na.reverse()\n\nb.reverse()\n\nans = 0\n\ncapacity = 0\n\nfor i in range(N):\n\n    ans += min(b[i] + capacity, a[i])\n\n    capacity = max(b[i] - max(a[i] - capacity, 0), 0)\n\nans += min(a[-1], capacity)\n\nprint(ans)","reference_code_col":"n = int(eval(input()))\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\n\n\na = a[::-1]\n\nb = b[::-1]\n\nans = 0\n\nfor i, bi in enumerate(b):\n\n    ans += min(a[i], b[i])\n\n    remain = max(0, b[i] - a[i])\n\n    ans += min(a[i + 1], remain)\n\n    a[i + 1] = max(0, a[i + 1] - remain)\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(input())\n\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\na.reverse()\nb.reverse()\n\nans = 0\ncapacity = 0\n\nfor i in range(N):\n    ans += min(b[i] + capacity, a[i])\n    capacity = max(b[i] - max(a[i] - capacity, 0), 0)\n\nans += min(a[-1], capacity)\n\nprint(ans)"}
{"problem_id":"p02863","slow_code_col":"#coding:utf-8\n\nimport bisect\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nwrite = sys.stdout.write\n\ndbg = lambda *something : print(*something) if DEBUG else 0\n\nDEBUG = True\n\n\n\n\n\n\n\ndef main(given = sys.stdin.readline):\n\n    input = lambda : given().rstrip()\n\n    LMIIS = lambda : list(map(int,input().split()))\n\n    II = lambda : int(input())\n\n    XLMIIS = lambda x : [LMIIS() for _ in range(x)]\n\n\n\n    n, t = LMIIS()\n\n    ab = XLMIIS(n)\n\n\n\n    dp1 = [[0]*t for _ in range(n)]\n\n    for i in range(1, n):\n\n        for j in range(1, t):\n\n            if j < ab[i-1][0]:\n\n                dp1[i][j] = dp1[i-1][j]\n\n            else:\n\n                dp1[i][j] = max(dp1[i-1][j], dp1[i-1][j-ab[i-1][0]] + ab[i-1][1])\n\n\n\n\n\n    dp2 = [[0]*t for _ in range(n)]\n\n    for i in range(1, n):\n\n        for j in range(1, t):\n\n            if j < ab[n - i][0]:\n\n                dp2[i][j] = dp2[i-1][j]\n\n            else:\n\n                dp2[i][j] = max(dp2[i-1][j], dp2[i-1][j-ab[n-i][0]] + ab[n-i][1])\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        for j in range(t - 1):\n\n            ans = max(ans, dp1[i][j] + dp2[n - i - 1][t - j - 1] + ab[i][1])\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"#coding:utf-8\n\nimport bisect\n\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nwrite = sys.stdout.write\n\ndbg = lambda *something : print(*something) if DEBUG else 0\n\nDEBUG = True\n\n\n\n\n\n\n\ndef main(given = sys.stdin.readline):\n\n    input = lambda : given().rstrip()\n\n    LMIIS = lambda : list(map(int,input().split()))\n\n    II = lambda : int(input())\n\n    XLMIIS = lambda x : [LMIIS() for _ in range(x)]\n\n\n\n    n, t = LMIIS()\n\n    ab = XLMIIS(n)\n\n    ab.sort()\n\n\n\n    dp1 = [[0]*t for _ in range(n+1)]\n\n    for i in range(1, n+1):\n\n        for j in range(1, t):\n\n            if j < ab[i-1][0]:\n\n                dp1[i][j] = dp1[i-1][j]\n\n            else:\n\n                dp1[i][j] = max(dp1[i-1][j], dp1[i-1][j-ab[i-1][0]] + ab[i-1][1])\n\n\n\n    ans = 0\n\n    for i in range(n):\n\n        ans = max(ans, dp1[i][t-1] + ab[i][1])\n\n    print(ans)\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"# coding:utf-8\n\nimport bisect\nimport sys\n\nsys.setrecursionlimit(10**6)\nwrite = sys.stdout.write\n\ndef main(given=sys.stdin.readline):\n    input = lambda: given().rstrip()\n    LMIIS = lambda: list(map(int, input().split()))\n    II = lambda: int(input())\n    XLMIIS = lambda x: [LMIIS() for _ in range(x)]\n\n    n, t = LMIIS()\n    ab = XLMIIS(n)\n\n    # Initialize DP table\n    dp = [[0] * t for _ in range(n)]\n\n    # Fill DP table for dp1\n    for i in range(n):\n        w, v = ab[i]\n        for j in range(t - w, -1, -1):\n            dp[i][j] = max(dp[i][j], dp[i][j + w] + v)\n\n    # Fill DP table for dp2\n    for i in range(n):\n        w, v = ab[n - i - 1]\n        for j in range(t - w, -1, -1):\n            dp[n - i - 1][j] = max(dp[n - i - 1][j], dp[n - i - 1][j + w] + v)\n\n    # Find the maximum value\n    ans = 0\n    for i in range(n):\n        for j in range(t):\n            ans = max(ans, dp[i][j] + dp[n - i - 1][t - j - 1])\n\n    print(ans)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03039","slow_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\nN, M, K = list(map(int,input().split()))\n\nmod = 10**9+7\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\n\ng2 = [1, 1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\ninv = [0, 1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n\n\nfor i in range(2, N*M+1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod\/\/i)) % mod)\n\n    g2.append((g2[-1] * inv[-1]) % mod)\n\n\n\ndef a(N,M):\n\n    return N*(N+1)\/\/2*(M+1) + M*(M+1)\/\/2*(N+1)\n\ndef b(N):\n\n    return N*(N+1)\/\/2\n\n\n\nans = 0\n\nfor i in range(N):\n\n    for j in range(M):\n\n        ans += a(i,j) + a(N-i-1,j) + a(i,M-j-1) + a(N-i-1,M-j-1)\n\n        ans -= b(i) + b(j) + b(N-i-1) + b(M-j-1)\n\n        ans %= mod\n\n#        print(i,j,a(i,j),a(N-i-1,j),a(i,M-j-1),a(N-i-1,M-j-1),b(i),b(j),ans)\n\nans *= g2[2]\n\n\n\nans *= cmb(N*M-2,K-2,mod)\n\nans %= mod\n\n\n\nprint(ans)\n","reference_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Wed May 29 22:49:19 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\n# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\n\n\nN, M, K = list(map(int,input().split()))\n\nmod = 10**9+7\n\n\n\ndef cmb(n, r, mod):\n\n    if (r < 0 or r > n):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\n\ng2 = [1, 1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\ninv = [0, 1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n\n\nfor i in range(2, N*M+1):\n\n    g1.append((g1[-1] * i) % mod)\n\n    inv.append((-inv[mod % i] * (mod\/\/i)) % mod)\n\n    g2.append((g2[-1] * inv[-1]) % mod)\n\n\n\nans1 = 0\n\ndef c(N,M):\n\n    res = 0\n\n    for i in range(1,N):\n\n        res += i*(N-i)*M*M\n\n    return res\n\nans1 += c(N,M) + c(M,N)\n\nans1 %= mod\n\n\n\nans1 *= cmb(N*M-2,K-2,mod)\n\nans1 %= mod\n\n\n\nprint(ans1)\n","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nimport sys\nsys.setrecursionlimit(10**6)\n\n\"\"\"\n\nCreated on Sat May 25 21:24:29 2019\n\n@author: Yamazaki Kenichi\n\n\"\"\"\n\nN, M, K = map(int, input().split())\n\nmod = 10**9 + 7\n\ndef factorial_mod(n, mod):\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n        inv_fact[i] = pow(fact[i], mod - 2, mod)\n    return fact, inv_fact\n\nfact, inv_fact = factorial_mod(N * M, mod)\n\ndef comb(n, k, mod):\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * inv_fact[k] * inv_fact[n - k] % mod\n\ndef a(N, M):\n    return N * (N + 1) \/\/ 2 * (M + 1) + M * (M + 1) \/\/ 2 * (N + 1)\n\ndef b(N):\n    return N * (N + 1) \/\/ 2\n\n@lru_cache(None)\ndef cached_a(N, M):\n    return a(N, M)\n\n@lru_cache(None)\ndef cached_b(N):\n    return b(N)\n\nans = 0\nfor i in range(N):\n    for j in range(M):\n        ans += cached_a(i, j) + cached_a(N - i - 1, j) + cached_a(i, M - j - 1) + cached_a(N - i - 1, M - j - 1)\n        ans -= cached_b(i) + cached_b(j) + cached_b(N - i - 1) + cached_b(M - j - 1)\n        ans %= mod\n\nans *= inv_fact[2]\nans %= mod\n\nans *= comb(N * M - 2, K - 2, mod)\nans %= mod\n\nprint(ans)"}
{"problem_id":"p02555","slow_code_col":"s = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\n# dp[i]: \u6700\u5f8c\u306b\u5207\u3063\u305f\u5834\u6240\u304ci\n\ndp = [0]*(s + 1)\n\ndp[0] = 1\n\n\n\nfor i in range(3, s+1):\n\n    for j in range(0, (i-3)+1):\n\n        dp[i] += dp[j]\n\n        dp[i] %= mod\n\n\n\nprint((dp[s]))","reference_code_col":"s = int(eval(input()))\n\nmod = 10**9 + 7\n\n\n\n# dp[i]: \u6700\u5f8c\u306b\u5207\u3063\u305f\u5834\u6240\u304ci\n\ndp = [0]*(s + 1)\n\ndp[0] = 1\n\ntotal = 0\n\nfor i in range(3, s+1):\n\n    total += dp[i-3]\n\n    total %= mod\n\n    dp[i] = total\n\n\n\nprint((dp[s]))","model_generated_potentially_faster_code_col":"s = int(eval(input()))\nmod = 10**9 + 7\n\ndp = [0] * (s + 1)\ndp[0] = 1\n\nfor i in range(3, s + 1):\n    dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % mod\n\nprint(dp[s])"}
{"problem_id":"p02412","slow_code_col":"while True:\n\n\tk=list(map(int,input().split(\" \")))\n\n\tif k[0]==k[1]==0:\n\n\t\tbreak\n\n\tct=0\n\n\ta=0\n\n\tb=0\n\n\tc=0\t\n\n\tmax=k[0]\n\n\tsum=k[1]\n\n\ta=max+1\n\n\t\n\n\twhile True:\n\n\t\ta-=1\n\n\t\tb=a-1\n\n\t\tc=sum-a-b\n\n\t\tif not a>b>c:\n\n\t\t\tprint(ct)\n\n\t\t\tbreak\n\n\t\twhile a>b>c:\n\n\t\t\tif a>b>c>0:\n\n\t\t\t\tct+=1\n\n\t\t\tb-=1\n\n\t\t\tc+=1\n\n\t\t\t","reference_code_col":"while True:\n\n\tk=list(map(int,input().split(\" \")))\n\n\tif k[0]==k[1]==0:\n\n\t\tbreak\n\n\tct=0\n\n\ta=0\n\n\tb=0\n\n\tc=0\t\n\n\tmax=k[0]\n\n\tsum=k[1]\n\n\ta=max+1\n\n\twhile True:\n\n\t\ta-=1\n\n\t\tb=a-1\n\n\t\tc=sum-a-b\n\n\t\tif not a>c:\n\n\t\t\tprint(ct)\n\n\t\t\tbreak\n\n\t\twhile b>c:\n\n\t\t\tif c>0:\n\n\t\t\t\tct+=1\n\n\t\t\tb-=1\n\n\t\t\tc+=1","model_generated_potentially_faster_code_col":"while True:\n    k = list(map(int, input().split()))\n    if k[0] == k[1] == 0:\n        break\n    \n    ct = 0\n    max_val = k[0]\n    sum_val = k[1]\n    \n    for a in range(max_val + 1):\n        b = a - 1\n        c = sum_val - a - b\n        \n        if a <= b or b <= c:\n            continue\n        \n        while a > b > c > 0:\n            ct += 1\n            b -= 1\n            c += 1\n    \n    print(ct)"}
{"problem_id":"p03644","slow_code_col":"N = int(eval(input()))\n\nif N < 2:\n\n  print(N)\n\nelif 2<=N<4:\n\n  print((2))\n\nelif 4<=N<8:\n\n  print((4))\n\nelif 8<=N<16:\n\n  print((8))\n\nelif 16<=N<32:\n\n  print((16))\n\nelif 32<=N<64:\n\n  print((32))\n\nelif 64<=N:\n\n  print((64))","reference_code_col":"N = int(eval(input()))\n\nNum = [int(2**i) for i in range(7)]\n\nif N in Num:\n\n  print(N)\n\nelse:\n\n  Num.append(N)\n\n  Num = sorted(Num)\n\n  print((2 ** (Num.index(N) - 1)))","model_generated_potentially_faster_code_col":"import math\n\nN = int(math.log2(int(eval(input())))) + 1\n\nprint(2**N)"}
{"problem_id":"p03037","slow_code_col":"N, M = list(map(int, input().split()))\n\nLR = [list(map(int, input().split())) for _ in range(M)]\n\n\n\nleft = 1\n\nright = N\n\n\n\nfor l, r in LR:\n\n    if left < l:\n\n        left = l\n\n    if right > r:\n\n        right = r\n\n\n\nans = right - left\n\n\n\nprint((ans + 1 if ans >= 0 else 0))\n","reference_code_col":"N, M = list(map(int, input().split()))\n\n\n\nleft = 1\n\nright = N\n\n\n\nfor _ in range(M):\n\n    l, r = list(map(int, input().split()))\n\n\n\n    if left < l:\n\n        left = l\n\n    if right > r:\n\n        right = r\n\n\n\nans = right - left\n\n\n\nprint((ans + 1 if ans >= 0 else 0))\n","model_generated_potentially_faster_code_col":"N, M = map(int, input().split())\n\nLR = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Extract all left and right endpoints from the intervals\nleft_endpoints = [l for l, r in LR]\nright_endpoints = [r for l, r in LR]\n\n# Find the minimum and maximum endpoints\nleft = min(left_endpoints)\nright = max(right_endpoints)\n\n# Calculate the length of the optimal subarray\nans = right - left\n\n# Print the result\nprint(ans + 1 if ans >= 0 else 0)"}
{"problem_id":"p03309","slow_code_col":"import numpy as np\n\n\n\nN=int(eval(input()))\n\nA=list(map(int, input().split()))\n\n\n\nAA=[]\n\nfor i,a in enumerate(A):\n\n    AA.append(a-i+1)\n\n\n\nb=np.median(AA)\n\nans=0\n\n\n\nfor a in AA:\n\n    ans+=abs(a-b)\n\nprint((int(ans)))","reference_code_col":"N=int(eval(input()))\n\nA=list(map(int,input().split()))\n\nB=[]\n\nfor i in range(N):\n\n    B.append(A[i]-i-1)\n\nB.sort()\n\nif N%2:\n\n    b=B[N\/\/2]\n\nelse:\n\n    b=(B[N\/\/2]+B[N\/\/2-1])\/\/2\n\nans=0\n\nfor k in B:\n\n    ans+=abs(k-b)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN = int(eval(input()))\nA = list(map(int, input().split()))\n\n# Calculate sorted array and its length\nsorted_A = sorted(A)\nlength = len(sorted_A)\n\n# Initialize variables for calculation\nsum_diffs = 0\nhalf_length = length \/\/ 2\n\n# Calculate sum of absolute differences using properties of medians\nfor a in A:\n    if a <= sorted_A[half_length]:\n        sum_diffs += (sorted_A[half_length] - a) * (half_length + 1)\n    else:\n        sum_diffs += (a - sorted_A[half_length]) * (length - half_length - 1)\n\n# Print result\nprint(sum_diffs)"}
{"problem_id":"p03060","slow_code_col":"n = int(eval(input()))\n\nv = list(map(int, input().split()))\n\nc = list(map(int, input().split()))\n\nresult = 0\n\nfor i in range(n):\n\n  if v[i] > c[i]:\n\n    result += v[i] - c[i]\n\nprint(result)","reference_code_col":"N = int(eval(input()))\n\nV = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\nprint((sum([V[i] - C[i] for i in range(N) if V[i] > C[i]])))\n","model_generated_potentially_faster_code_col":"n = int(input())\n\nv = [int(x) for x in input().split()]\n\nc = [int(x) for x in input().split()]\n\nresult = sum(max(0, v[i]-c[i]) for i in range(n))\n\nprint(result)"}
{"problem_id":"p02760","slow_code_col":"import numpy as np\n\n\n\na = [list(map(int, input().split())) for _ in range(3)]\n\na = np.array(a)\n\nn = int(eval(input()))\n\n\n\nfor _ in range(n):\n\n    b = int(eval(input()))\n\n    \n\n    for j in range(3):\n\n        for i in range(3):\n\n            if a[j][i] == b:\n\n                a[j][i] = 0\n\n\n\nat = a.transpose()\n\nflag = False\n\nfor i in range(3):\n\n    if sum(a[:][i]) == 0 or sum(at[:][i]) == 0:\n\n        flag = True\n\n        break\n\ndiag = a[0][0] + a[1][1] + a[2][2]\n\ndiag2 = a[2][0] + a[1][1] + a[0][2]\n\nif diag == 0 or diag2 == 0:\n\n    flag = True\n\n\n\nprint((\"Yes\" if flag else \"No\"))","reference_code_col":"a = [list(map(int, input().split())) for _ in range(3)]\n\nn = int(eval(input()))\n\nb = [int(eval(input())) for _ in range(n)]\n\n\n\nflag = False\n\nfor i in range(3):\n\n    if a[i][0] in b and a[i][1] in b and a[i][2] in b:\n\n        flag = True\n\n        break\n\n    if a[0][i] in b and a[1][i] in b and a[2][i] in b:\n\n        flag = True\n\n        break\n\nif a[0][0] in b and a[1][1] in b and a[2][2] in b:\n\n    flag = True\n\nif a[2][0] in b and a[1][1] in b and a[0][2] in b:\n\n    flag = True\n\n    \n\nprint((\"Yes\" if flag else \"No\"))","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input into a list of lists\na = [list(map(int, input().split())) for _ in range(3)]\na = np.array(a)\n\n# Convert input number to integer\nn = int(input())\n\n# Replace occurrences of n with 0\na[a == n] = 0\n\n# Transpose the array\nat = a.T\n\n# Check rows, columns and diagonals for zeros\nflag = (np.any(np.sum(a, axis=1) == 0)) or \\\n       (np.any(np.sum(at, axis=1) == 0)) or \\\n       (np.sum(a.diagonal()) == 0) or \\\n       (np.sum(np.fliplr(a).diagonal()) == 0)\n\n# Print result\nprint(\"Yes\" if flag else \"No\")"}
{"problem_id":"p03592","slow_code_col":"\n\nn,m,k = list(map(int,input().split()))\n\n#\uff11\u56de\u62bc\u3059\u3068\u5909\u308f\u308b\u30de\u30b9\u3000= N * M -1\n\n#\uff12\u56de\u76ee\u62bc\u3059\u3068\u9ed2\u306b\u5909\u308f\u308b\u30de\u30b9 N * M -1 -2\n\n# 3 = N * M -1 -4\n\n\n\ncnt = 0\n\nfor i in range(n+1):\n\n    for j in range(m + 1):\n\n        cnt = i * m + j * n -2 * i * j\n\n        if cnt == k:\n\n            print(\"Yes\")\n\n            exit()\n\nprint(\"No\")\n","reference_code_col":"\n\nn,m,k = list(map(int,input().split()))\n\n\n\nfor i in range(n+1):\n\n    for j in range(m+1):\n\n        if i*(m-j) + j*(n-i) == k:\n\n            print(\"Yes\")\n\n            exit()\n\nprint(\"No\")\n","model_generated_potentially_faster_code_col":"n, m, k = map(int, input().split())\n\n# Iterate over all possible values of i\nfor i in range(n + 1):\n    # Calculate the remaining part of the equation after fixing i\n    remaining = k - i * (m - 2)\n    \n    # Check if the remaining part is divisible by n and within the valid range for j\n    if remaining % n == 0 and 0 <= remaining \/\/ n <= m:\n        print(\"Yes\")\n        exit()\n\nprint(\"No\")"}
{"problem_id":"p03416","slow_code_col":"a,b = list(map(int,input().split()))\n\nanswer = 0\n\nfor i in range(a,b+1) :\n\n    j = str(i)\n\n    p1 = j[4]\n\n    p2 = j[3]\n\n    p3 = j[2]\n\n    p4 = j[1]\n\n    p5 = j[0]\n\n    k = int(p1+p2+p3+p4+p5)\n\n    if i == k :\n\n        answer += 1\n\nprint(answer)\n\n\n","reference_code_col":"A,B = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(A,B+1) :\n\n    l = str(i)\n\n    if l[0] == l[4] and l[1] == l[3] :\n\n        ans += 1\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"def reverse_integer(num):\n    return num % 10 + reverse_integer(num \/\/ 10) if num > 9 else num\n\na, b = map(int, input().split())\n\nanswer = 0\n\nfor i in range(a, b + 1):\n    if i == reverse_integer(i):\n        answer += 1\n\nprint(answer)"}
{"problem_id":"p03721","slow_code_col":"N,K=list(map(int,input().split()))\n\ndic={}\n\nfor i in range(N):\n\n  a,b=list(map(int,input().split()))\n\n  if a in dic:\n\n    dic[a]+=b\n\n  else:\n\n    dic[a]=b\n\n    \n\ndic=sorted(list(dic.items()),key=lambda x:x[0])\n\nfor d in range(len(dic)):\n\n  amount=dic[d][1]\n\n  if amount>=K:\n\n    print((dic[d][0]))\n\n    exit(0)\n\n  else:\n\n    K-=amount\n\n  ","reference_code_col":"import sys\n\nreadline = sys.stdin.readline\n\n\n\nN,K = list(map(int,readline().split()))\n\n\n\nAB = [list(map(int,readline().split())) for i in range(N)]\n\n\n\nAB = sorted(AB, key = lambda x:x[0])\n\namount = 0\n\nfor a,b in AB:\n\n  amount += b\n\n  if amount >= K:\n\n    print(a)\n\n    break\n","model_generated_potentially_faster_code_col":"import heapq\n\nN, K = map(int, input().split())\n\n# Use a min-heap to store (value, key) pairs\nheap = []\n\nfor _ in range(N):\n    a, b = map(int, input().split())\n    heapq.heappush(heap, (b, a))\n\nwhile heap:\n    amount, key = heapq.heappop(heap)\n    if amount >= K:\n        print(key)\n        exit(0)\n    K -= amount"}
{"problem_id":"p02982","slow_code_col":"import math\n\nimport numpy as np\n\nn, d = list(map(int, input().split()))\n\na = []\n\ncnt = 0\n\nfor x in range(n):\n\n    a.append(list(map(int, input().split())))\n\nfor i in range(len(a)):\n\n    for j in range(len(a)):\n\n        if i < j:\n\n            dis = np.array(a[i]) - np.array(a[j])\n\n            if np.linalg.norm(dis).is_integer():\n\n                cnt += 1\n\nprint(cnt)","reference_code_col":"n, d = list(map(int, input().split()))\n\na = [[int(i) for i in input().split()] for i in range(n)]\n\nans = 0\n\ndef dis(x,y):\n\n    T = []\n\n    for i in range(len(x)):\n\n        T.append((x[i]-y[i])**2)\n\n    return sum(T)\n\nfor i in range(n):\n\n    for j in range(i+1,n):\n\n        r = dis(a[i], a[j])\n\n        for k in range(r + 1):\n\n            if k ** 2 == r:\n\n                ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\nn, d = map(int, input().split())\npoints = np.array([list(map(int, input().split())) for _ in range(n)])\n\n# Calculate all pairwise distances\ndistances = np.sqrt(np.sum((points[:, np.newaxis] - points[np.newaxis, :])**2, axis=2))\n\n# Count integer distances (excluding self-distances)\ncnt = np.sum(distances.isclose(np.round(distances), atol=1e-6) & (distances != 0)).astype(int) \/\/ 2\n\nprint(cnt)"}
{"problem_id":"p03000","slow_code_col":"from itertools import accumulate\n\nfrom bisect import *\n\nN, X = list(map(int, input().split()))\n\nL = list(tuple(map(int, input().split())))\n\n\n\nacc = sorted(list(accumulate(L)) + [0])\n\n\n\nn = bisect_right(acc,X)\n\nprint(n)\n\n\n","reference_code_col":"N,X = list(map(int,input().split()))\n\nL = list(map(int,input().split()))\n\nList = [0]*(N+1)\n\nfor i in range(1,N+1):\n\n    List[i] = List[i-1] + L[i-1]\n\nA = [i for i in List if i <=X]\n\nprint((len(A)))","model_generated_potentially_faster_code_col":"from collections import defaultdict\n\nN, X = map(int, input().split())\nL = list(map(int, input().split()))\n\nprefix_sums = defaultdict(lambda: float('inf'))\nprefix_sums[0] = -1  # Initialize with 0 at index -1 for handling cases where X is exactly equal to a prefix sum\ncurrent_sum = 0\n\nfor i in range(N):\n    current_sum += L[i]\n    if current_sum <= X:\n        prefix_sums[current_sum] = i\n\n# Find the maximum prefix sum that is less than or equal to X\nmax_prefix_sum = max(filter(lambda x: x <= X, prefix_sums.keys()), default=float('-inf'))\n\n# Calculate the number of elements in the subarray\nresult = prefix_sums[max_prefix_sum] + 1\n\nprint(result)"}
{"problem_id":"p03416","slow_code_col":"A, B = list(map(int, input().split()))\n\n\n\ncnt = 0\n\nfor n in range(A, B+1):\n\n    n_s = str(n)\n\n    n_s_rvs = n_s[::-1]\n\n    if n_s == n_s_rvs:\n\n        cnt += 1\n\n\n\nprint(cnt)\n","reference_code_col":"A, B = list(map(int, input().split()))\n\n\n\ncnt = 0\n\nfor n in range(A, B+1):\n\n    if n\/\/10000 == n%10 and (n\/\/1000)%10 == (n\/\/10)%10:\n\n        cnt += 1\n\n\n\nprint(cnt)\n","model_generated_potentially_faster_code_col":"def is_palindrome(n):\n    # Convert number to string\n    s = str(n)\n    # Check if the string is equal to its reverse\n    return s == s[::-1]\n\nA, B = map(int, input().split())\n\ncnt = 0\n\nfor n in range(A, B + 1):\n    if is_palindrome(n):\n        cnt += 1\n\nprint(cnt)"}
{"problem_id":"p03649","slow_code_col":"from numpy import*\n\nN,*A=open(0)\n\nN,A,S,a=int(N),loadtxt(A,int),1,0\n\nwhile S:B=A\/\/N;S=sum(B);a+=S;A+=S-B*-~N\n\nprint(a)","reference_code_col":"N, *A = list(map(int, open(0).read().split()))\n\n\n\nans = 0\n\nS = -1\n\nwhile S:\n\n    S = sum(a \/\/ N for a in A)\n\n    ans += S\n\n    A = [a % N + (S - a \/\/ N) for a in A]\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input\nN = int(input())\nA = list(map(int, input().split()))\n\n# Initialize variables\ntotal_sum = 0\ncurrent_sum = sum(A)\n\nwhile current_sum > 0:\n    # Calculate the new array B\n    B = np.array([x \/\/ N for x in A])\n    \n    # Update total sum\n    total_sum += sum(B)\n    \n    # Update A and current_sum\n    A = [x + (B[i] * -N) for i, x in enumerate(A)]\n    current_sum = sum(A)\n\nprint(total_sum)"}
{"problem_id":"p03162","slow_code_col":"#!\/usr\/bin\/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    N = int(eval(input()))\n\n    happiness = [list(map(int, input().split())) for _ in range(N)]\n\n\n\n    dp = np.zeros((N, 3), dtype=np.int64)\n\n    dp[0] = happiness[0]\n\n    for i in range(1, N):\n\n        for a, yesterday in enumerate(dp[i - 1]):\n\n            for b, today in enumerate(happiness[i]):\n\n                if a == b:\n\n                    continue\n\n                dp[i][b] = max(dp[i][b], yesterday + today)\n\n    print((max(dp[-1])))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"#!\/usr\/bin\/env python3\n\ndef main():\n\n    N = int(eval(input()))\n\n    happiness = [list(map(int, input().split())) for _ in range(N)]\n\n\n\n    dp = [0, 0, 0]\n\n    for a, b, c in happiness:\n\n        dp = [max(dp[1], dp[2]) + a,\n\n              max(dp[0], dp[2]) + b,\n\n              max(dp[0], dp[1]) + c]\n\n    print((max(dp)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env python3\n\nimport sys\n\ndef main():\n    N = int(sys.stdin.read().strip())\n\n    happiness = [list(map(int, line.split())) for line in sys.stdin.readlines()]\n\n    dp = [[0, 0, 0] for _ in range(N)]\n    dp[0] = happiness[0]\n\n    for i in range(1, N):\n        dp[i] = [0, 0, 0]\n        for j in range(3):\n            for k in range(3):\n                if j != k:\n                    dp[i][k] = max(dp[i][k], dp[i-1][j] + happiness[i][k])\n\n    print(max(dp[-1]))\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03796","slow_code_col":"import math\n\nN=int(eval(input()))\n\nprint((math.factorial(N)%(10**9+7)))","reference_code_col":"N=int(eval(input()))\n\npower=1\n\nfor i in range(1,N+1):\n\n    power*=i\n\n    power%=10**9+7\n\nprint(power)","model_generated_potentially_faster_code_col":"N = int(eval(input()))\nfactorial = 1\nfor i in range(2, N + 1):\n    factorial = (factorial * i) % (10 ** 9 + 7)\nprint(factorial)"}
{"problem_id":"p03371","slow_code_col":"# ABC95 C -Half and Half\n\na,b,c,x,y = list(map(float,input().split()))\n\nans = 0\n\nif a+b > 2*c:\n\n    while x != 0.0 and y != 0.0:\n\n        ans += 2*c\n\n        x -= 1.0\n\n        y -= 1.0\n\n        if y == 0.0:\n\n            while x != 0.0:\n\n                if a > 2*c:\n\n                    ans += 2*c\n\n                    x -= 1.0\n\n                else:\n\n                    ans += a\n\n                    x -= 1.0\n\n        if x == 0.0:\n\n            while y != 0.0:\n\n                if b > 2*c:\n\n                    ans += 2*c\n\n                    y -= 1.0\n\n                else:\n\n                    ans += b\n\n                    y -= 1.0\n\nelse:\n\n    ans += a*x + b*y\n\nprint((int(ans)))\n\n\n\n    ","reference_code_col":"a,b,c,x,y=list(map(int,input().split()))\n\nans=0\n\nans1=0\n\n\n\ne=max(x,y)\n\nans1=e*(2*c)\n\nif 2*c<a+b:\n\n    d=min(x,y)\n\n    ans+=c*(2*d)\n\n    x-=d\n\n    y-=d\n\nelse:\n\n    ans=a*x+b*y\n\n    x-=x\n\n    y-=y\n\nans+=x*a\n\nans+=y*b\n\nprint((min(ans,ans1)))","model_generated_potentially_faster_code_col":"# ABC95 C -Half and Half\n\na, b, c, x, y = map(float, input().split())\n\nans = 0\n\nwhile x != 0.0 or y != 0.0:\n    if a + b > 2 * c:\n        if x > 0.0:\n            if a > b:\n                ans += a\n                x -= 1.0\n            else:\n                ans += b\n                y -= 1.0\n        elif y > 0.0:\n            if b > a:\n                ans += b\n                y -= 1.0\n            else:\n                ans += a\n                x -= 1.0\n    else:\n        if x > 0.0:\n            ans += a\n            x -= 1.0\n        elif y > 0.0:\n            ans += b\n            y -= 1.0\n\nprint(int(ans))"}
{"problem_id":"p03032","slow_code_col":"# coding: utf-8\n\nimport copy\n\nimport numpy as np\n\n\n\nn, k = list(map(int, input().split()))\n\nv = list(map(int, input().split()))\n\nrev = copy.copy(v)\n\nrev.reverse()\n\n\n\nlcs = [0]+np.cumsum(v)\n\nrcs = [0]+np.cumsum(rev)\n\n# print(lcs,rcs)\n\n\n\nans = -10**20\n\nfor l in range(n+1):\n\n  for r in range(n+1-l):\n\n    able = True\n\n    d = k - ( l + r )\n\n    if d < 0:\n\n      able = False\n\n      break\n\n    # m = lcs[l] + rcs[r]\n\n    t = v[0:l] + rev[0:r]\n\n    m = sum(t)\n\n    # print(t,l,r,m)\n\n    t.sort()\n\n    # print(t)\n\n    d = min(d,l+r)\n\n    for i in range(d):\n\n      if 0 > t[i]:\n\n        m -= t[i]\n\n      else:\n\n        break\n\n    # print(m)\n\n    ans = max(ans,m)\n\n\n\nprint(ans)\n\n    ","reference_code_col":"# coding: utf-8\n\nimport copy\n\n\n\nn, k = list(map(int, input().split()))\n\nv = list(map(int, input().split()))\n\nrev = copy.copy(v)\n\nrev.reverse()\n\n\n\nans = -10**20\n\nfor l in range(n+1):\n\n  for r in range(n+1-l):\n\n    able = True\n\n    d = k - ( l + r )\n\n    if d < 0:\n\n      able = False\n\n      break\n\n    t = v[0:l] + rev[0:r]\n\n    m = sum(t)\n\n    t.sort()\n\n    d = min(d,l+r)\n\n    for i in range(d):\n\n      if 0 > t[i]:\n\n        m -= t[i]\n\n      else:\n\n        break\n\n    ans = max(ans,m)\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"# coding: utf-8\n\nimport numpy as np\n\nn, k = map(int, input().split())\nv = list(map(int, input().split()))\nrev = v[::-1]\n\nlcs = np.cumsum([0] + v)\nrcs = np.cumsum([0] + rev)\n\nans = -10**20\n\nfor l in range(n + 1):\n    for r in range(n + 1 - l):\n        d = k - (l + r)\n        if d < 0:\n            continue\n        \n        # Calculate the sum of the subarray\n        m = lcs[l] + rcs[r]\n        \n        # Find the minimum value in the combined array\n        min_val = float('inf')\n        for i in range(min(d, l + r)):\n            if v[i] < 0:\n                min_val = min(min_val, v[i])\n            else:\n                break\n        \n        m += min_val * (min(d, l + r) - len([x for x in v[:l] if x >= 0]) - len([x for x in rev[:r] if x >= 0]))\n        \n        ans = max(ans, m)\n\nprint(ans)"}
{"problem_id":"p03162","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\ndp = [[0, 0, 0] for i in range(N+1)]\n\nfor i in range(1, N+1):\n\n    a, b, c = list(map(int, input().split(' ')))\n\n    dp[i][0] = max(dp[i-1][1], dp[i-1][2]) + a\n\n    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + b\n\n    dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + c\n\nprint((np.max(dp[-1])))","reference_code_col":"N = int(eval(input()))\n\ndp = [[0, 0, 0] for i in range(N+1)]\n\nfor i in range(1, N+1):\n\n    a, b, c = list(map(int, input().split(' ')))\n\n    dp[i][0] = max(dp[i-1][1], dp[i-1][2]) + a\n\n    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + b\n\n    dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + c\n\nprint((max(dp[-1])))","model_generated_potentially_faster_code_col":"N = int(input())\n\ndp = [0]*3\n\nfor _ in range(N):\n    a, b, c = map(int, input().split())\n    \n    # Update dp array from right to left\n    dp[2], dp[1], dp[0] = max(dp[1], dp[2]) + a, max(dp[0], dp[2]) + b, max(dp[0], dp[1]) + c\n\nprint(max(dp))"}
{"problem_id":"p02595","slow_code_col":"N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x ** 2 + y ** 2 <= D ** 2:\n\n        cnt += 1\n\n        \n\nprint(cnt)","reference_code_col":"N, D = list(map(int, input().split()))\n\ncnt = 0\n\nfor _ in range(N):\n\n    x, y = list(map(int, input().split()))\n\n    if x * x + y * y <= D * D:\n\n        cnt += 1\n\n        \n\nprint(cnt)","model_generated_potentially_faster_code_col":"N, D = map(int, input().split())\nD_squared = D * D\ncnt = sum(1 for _ in range(N) if (x := int(input()))**2 + (y := int(input()))**2 <= D_squared)\n\nprint(cnt)"}
{"problem_id":"p02693","slow_code_col":"S = int(eval(input()))\n\na = 0\n\ncount = 0\n\nn,m = list(map(int,input().split()))\n\nwhile count == 0:\n\n    a += S\n\n    if n <= a and m >= a:\n\n        count = 1\n\n    if a >= 1000:\n\n        break\n\nif count == 0:\n\n    print(\"NG\")\n\nelse:\n\n    print(\"OK\")","reference_code_col":"k = int(eval(input()))\n\nn = 0\n\na,b = list(map(int,input().split()))\n\nwhile True:\n\n    n += k\n\n    if n >= a and n <= b:\n\n        print(\"OK\")\n\n        break\n\n    if n > b:\n\n        print(\"NG\")\n\n        break","model_generated_potentially_faster_code_col":"# Read input values\nS = int(input())\nn, m = map(int, input().split())\n\n# Calculate the number of steps needed to reach or exceed the range [n, m]\nsteps_needed = (m - n + 1) \/\/ S\n\n# Check if we can reach the range within the calculated steps\nif n <= S * steps_needed <= m:\n    print(\"OK\")\nelse:\n    print(\"NG\")"}
{"problem_id":"p03171","slow_code_col":"N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nn = N % 2\n\n\n\nDP = [[0] * (N+1) for _ in range(N+1)]\n\n\n\nfor w in range(1, N+1):\n\n    for i in range(N):\n\n        j = i + w\n\n        if j > N:\n\n            continue\n\n        if (w+n) % 2 == 1:\n\n            DP[i][j] = min(DP[i+1][j] - A[i], DP[i][j-1] - A[j-1])\n\n        else:\n\n            DP[i][j] = max(DP[i+1][j] + A[i], DP[i][j-1] + A[j-1])\n\n\n\nprint((DP[0][N]))\n","reference_code_col":"N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nDP = [[0] * (N+1) for _ in range(N+1)]\n\n\n\nfor num in range(1, N + 1):\n\n    for start in range(N):\n\n        end = start + num\n\n        if end > N:\n\n            break\n\n        if num == 1:\n\n            DP[start][end] = A[start]\n\n        else:\n\n            DP[start][end] = max(A[start] - DP[start+1][end], A[end - 1] - DP[start][end - 1])\n\nprint((DP[0][N]))\n","model_generated_potentially_faster_code_col":"# Read input values\nN = int(input())\nA = list(map(int, input().split()))\n\n# Determine n based on N\nn = N % 2\n\n# Initialize DP table with None to indicate uncomputed states\nDP = [[None] * (N + 1) for _ in range(N + 1)]\n\ndef dp(i, j):\n    # Base case: single element\n    if i == j:\n        return A[i]\n    \n    # If already computed, return the stored value\n    if DP[i][j] is not None:\n        return DP[i][j]\n    \n    # Calculate the difference or sum based on whether (w+n) % 2 is odd or even\n    if (j - i + n) % 2 == 1:\n        DP[i][j] = min(dp(i + 1, j) - A[i], dp(i, j - 1) - A[j - 1])\n    else:\n        DP[i][j] = max(dp(i + 1, j) + A[i], dp(i, j - 1) + A[j - 1])\n    \n    return DP[i][j]\n\n# Compute the result using the helper function\nresult = dp(0, N)\n\n# Print the result\nprint(result)"}
{"problem_id":"p02837","slow_code_col":"n = int(eval(input()))\n\n\n\nXY = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    xy = []\n\n    for j in range(a):\n\n        xy.append(list(map(int, input().split())))\n\n    \n\n    XY.append(xy)\n\n    \n\ndef check(i, xiyj, HoU):\n\n    # \u77db\u76fe\u3057\u305f\u3089False \u6b63\u76f4\u8005\u3068\u4eee\u5b9a\u3057\u305f\u8a3c\u8a00\u3088\u308a \u6b63\u76f4&\u6b63\u76f4\u8005\u3068\u4eee\u5b9a\u3055\u308c\u3066\u3044\u308b \/ \u4e0d\u89aa\u5207&\u4e0d\u89aa\u5207\u3068\u4eee\u5b9a\u3055\u308c\u3066\u3044\u308b True\n\n    if ((i >> xiyj) & 1) ^ HoU:\n\n        return False\n\n\n\n    return True\n\n    \n\nmax_honest = 0\n\nfor i in range(2 ** len(XY)):\n\n    count = 0\n\n    is_contradiction = True\n\n    for j in range(len(XY)):\n\n        # \u6b63\u76f4\u8005\u3068\u4eee\u5b9a\u3057\u305f\u3068\u304d\u3060\u3051\u63a1\u7528\n\n        if not ((i >> j) & 1): continue\n\n        for k in range(len(XY[j])):\n\n            xiyj = XY[j][k][0] - 1\n\n            HoU = XY[j][k][1]\n\n            \n\n            if not check(i, xiyj, HoU):\n\n                is_contradiction = False\n\n                break\n\n                \n\n        if not is_contradiction:\n\n            break\n\n\n\n    if is_contradiction:\n\n        for j in range(len(XY)):\n\n            if ((i >> j) & 1): count+=1 \n\n                \n\n        if count > max_honest:\n\n            max_honest =count\n\n            \n\nprint(max_honest)","reference_code_col":"n = int(eval(input()))\n\n\n\nXY = []\n\nfor i in range(n):\n\n    a = int(eval(input()))\n\n    xy = []\n\n    for j in range(a):\n\n        xy.append(list(map(int, input().split())))\n\n    \n\n    XY.append(xy)\n\n\n\n\"\"\"\n\n    \u77db\u76fe\u3057\u305f\u3089False\n\n    \u77db\u76fe\u3057\u306a\u3051\u308c\u3070True\n\n    \u6b63\u76f4\u8005\u3068\u4eee\u5b9a\u3057\u305f\u8005\u306e\u8a3c\u8a00\n\n        \u6b63\u76f4&\u6b63\u76f4\u8005\u3068\u4eee\u5b9a\u3055\u308c\u3066\u3044\u308b\n\n        \u4e0d\u89aa\u5207&\u4e0d\u89aa\u5207\u3068\u4eee\u5b9a\u3055\u308c\u3066\u3044\u308b\n\n\"\"\"\n\ndef check(i, xiyj, HoU):\n\n    # XOR\n\n    if HoU ^ ((i >> xiyj) & 1):\n\n        return False\n\n\n\n    return True\n\n\n\nmax_honest = 0\n\nfor i in range(2 ** len(XY)):\n\n    count = 0\n\n    is_contradiction = True\n\n    for j in range(len(XY)):\n\n        # \u6b63\u76f4\u8005\u3068\u4eee\u5b9a\u3057\u305f\u3068\u304d\u3060\u3051\u63a1\u7528\n\n        if not ((i >> j) & 1): continue\n\n        count+=1\n\n        for k in range(len(XY[j])):\n\n            xiyj = XY[j][k][0] - 1\n\n            HoU = XY[j][k][1]\n\n            \n\n            if not check(i, xiyj, HoU):\n\n                is_contradiction = False\n\n                break # TLE\u5bfe\u7b56\n\n                \n\n        if not is_contradiction:\n\n            break # TLE\u5bfe\u7b56\n\n\n\n    # \u77db\u76fe\u304c\u306a\u304f\u3001\u6b63\u76f4\u8005\u306e\u6570\u304c\u66f4\u65b0\u3067\u304d\u308c\u3070\u66f4\u65b0\n\n    if is_contradiction and (count > max_honest):\n\n        max_honest =count\n\n            \n\nprint(max_honest)","model_generated_potentially_faster_code_col":"n = int(input())\n\nXY = []\nfor _ in range(n):\n    a = int(input())\n    xy = [tuple(map(int, input().split())) for _ in range(a)]\n    XY.append(xy)\n\ndef check(i, xiyj, HoU):\n    return bool((i >> xiyj) & 1) == HoU\n\nmax_honest = 0\nfor i in range(2 ** len(XY)):\n    count = sum(check(i, xiyj, HoU) for j, (_, HoU) in enumerate(XY) for xiyj, HoU in XY[j])\n    if count == len(XY):\n        max_honest = count\n\nprint(max_honest)"}
{"problem_id":"p03796","slow_code_col":"from math import factorial as fc\n\na = int(eval(input()))\n\nprint((fc(a)%(10**9+7)))","reference_code_col":"n = int(eval(input()))\n\nm = 10**9+7\n\nans = 1\n\nfor i in range(1, n+1):\n\n  ans *= i\n\n  ans %= m\n\nprint(ans)","model_generated_potentially_faster_code_col":"def factorial(n):\n    # Initialize a list with 0s\n    dp = [0]*(n + 1)\n    # Base case\n    dp[0] = 1\n    # Fill in the rest of the list using dynamic programming\n    for i in range(1,n + 1):\n        dp[i] = (dp[i - 1]*i)%1000000007\n    return dp[n]\n\na = int(eval(input()))\nprint(factorial(a))"}
{"problem_id":"p02574","slow_code_col":"from math import gcd\n\n\n\nN = int(eval(input()))\n\nnum_lis = list(map(int, input().split()))\n\nc = True\n\n\n\ndef osa_k(max_num):\n\n  lis = [i for i in range(max_num+1)]\n\n  p = 2\n\n  while p**2 <= max_num:\n\n    if lis[p] == p:\n\n      for q in range(2*p, max_num+1, p):\n\n        if lis[q] == q:\n\n          lis[q] = p\n\n    p += 1\n\n  return lis\n\n\n\nhoge = 0\n\nfor i in num_lis:\n\n  hoge = gcd(hoge, i)\n\nif hoge > 1:\n\n  print(\"not coprime\")\n\n  exit()\n\n\n\nd_lis = osa_k(10**6+10)\n\ntmp = set()\n\nfor i in num_lis:\n\n  num = i\n\n  new_tmp = set()\n\n  while num > 1:\n\n    d = d_lis[num]\n\n    new_tmp.add(d)\n\n    num \/\/= d\n\n  for j in new_tmp:\n\n    if j in tmp:\n\n      c = False\n\n      break\n\n    else:\n\n      tmp.add(j)\n\n  else:\n\n    continue\n\n  break\n\n\n\nif c:\n\n  print(\"pairwise coprime\")\n\nelse:\n\n  print(\"setwise coprime\")","reference_code_col":"from math import gcd\n\n\n\nN = int(eval(input()))\n\nnum_lis = list(map(int, input().split()))\n\n\n\ndef osa_k(max_num):\n\n  lis = [i for i in range(max_num+1)]\n\n  p = 2\n\n  while p**2 <= max_num:\n\n    if lis[p] == p:\n\n      for q in range(2*p, max_num+1, p):\n\n        if lis[q] == q:\n\n          lis[q] = p\n\n    p += 1\n\n  return lis\n\n\n\nhoge = 0\n\nfor i in num_lis:\n\n  hoge = gcd(hoge, i)\n\nif hoge > 1:\n\n  print(\"not coprime\")\n\n  exit()\n\n\n\nd_lis = osa_k(max(num_lis))\n\ntmp = set()\n\nfor i in num_lis:\n\n  num = i\n\n  new_tmp = set()\n\n  while num > 1:\n\n    d = d_lis[num]\n\n    new_tmp.add(d)\n\n    num \/\/= d\n\n  for j in new_tmp:\n\n    if j in tmp:\n\n      print(\"setwise coprime\")\n\n      exit()\n\n    else:\n\n      tmp.add(j)\n\nprint(\"pairwise coprime\")","model_generated_potentially_faster_code_col":"from math import sqrt\n\n\nN = int(eval(input()))\nnum_lis = list(map(int, input().split()))\n\n\ndef osa_k(max_num):\n  lis = [i for i in range(max_num+1)]\n  p = 2\n  while p**2 <= max_num:\n    if lis[p] == p:\n      for q in range(p**2, max_num+1, p*2):\n        if lis[q] == q:\n          lis[q] = p\n    p += 2\n  return lis\n\n\nhoge = 0\nfor i in num_lis:\n  hoge = gcd(hoge, i)\nif hoge > 1:\n  print(\"not coprime\")\n  exit()\n\n\nd_lis = osa_k(10**6+10)\nfactors = {}\nfor i in num_lis:\n  num = i\n  while num > 1:\n    d = d_lis[num]\n    if d not in factors:\n      factors[d] = True\n    num \/\/= d\n\n\nif len(factors) == N:\n  print(\"pairwise coprime\")\nelif len(factors) == 1:\n  print(\"setwise coprime\")\nelse:\n  print(\"not coprime\")"}
{"problem_id":"p02850","slow_code_col":"n = int(eval(input()))\n\nedges = []\n\n\n\nfor id in range(n-1):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1, id])\n\n\n\nedges.sort()\n\n\n\nused = [0]*(n)\n\nans = [0]*(n-1)\n\nnum = 1\n\nprev = 0\n\nfor edge in edges:\n\n    _from, to, id = edge\n\n    if _from != prev:\n\n        num = 1\n\n    if used[_from] == num:\n\n        num += 1\n\n    ans[id] = num\n\n    used[to] = num\n\n    num += 1\n\n    prev = _from\n\n\n\nprint((max(ans)))\n\nfor color in ans:\n\n    print(color)\n","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn = int(eval(input()))\n\nedges = []\n\n\n\nfor id in range(n-1):\n\n    a, b = list(map(int, input().split()))\n\n    edges.append([a-1, b-1, id])\n\n\n\nedges.sort()\n\n\n\nused = [0]*(n)\n\nans = [0]*(n-1)\n\nnum = 1\n\nprev = 0\n\nfor edge in edges:\n\n    _from, to, id = edge\n\n    if _from != prev:\n\n        num = 1\n\n    if used[_from] == num:\n\n        num += 1\n\n    ans[id] = num\n\n    used[to] = num\n\n    num += 1\n\n    prev = _from\n\n\n\nprint((max(ans)))\n\nfor color in ans:\n\n    print(color)\n","model_generated_potentially_faster_code_col":"# Read input values safely without eval\nn = int(input())\n\nedges = []\n\n# Read edges and store them with their original indices\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    edges.append([a - 1, b - 1, i])\n\n# Sort edges by their starting node to facilitate processing\nedges.sort()\n\n# Initialize arrays to keep track of used colors and results\nused = [0] * n\nans = [0] * (n - 1)\nnum = 1\nprev = 0\n\n# Process each edge\nfor edge in edges:\n    _from, to, id = edge\n    \n    # Reset counter if the current node is different from the previous one\n    if _from != prev:\n        num = 1\n    \n    # Find the smallest available color for the current node\n    while used[_from] >= num:\n        num += 1\n    \n    # Assign the color to the current edge\n    ans[id] = num\n    \n    # Update the used color for the destination node\n    used[to] = num\n    \n    # Increment the color counter\n    num += 1\n    \n    # Update the previous node\n    prev = _from\n\n# Output the maximum color used and the color assignments\nprint(max(ans))\nfor color in ans:\n    print(color)"}
{"problem_id":"p00003","slow_code_col":"for i in range(0, int(eval(input()))):\n\n    sidelen = [int(j) for j in input().split(\" \")]\n\n    sidelen.sort(reverse=True)\n\n    if(sidelen[0]**2 == sidelen[1]**2 + sidelen[2]**2):\n\n        print(\"YES\")\n\n    else:\n\n        print(\"NO\")","reference_code_col":"import sys\n\nfor i in sys.stdin:\n\n    try:\n\n        sidelen = [int(j) for j in i.split(\" \")]\n\n        sidelen.sort(reverse=True)\n\n        if(sidelen[0]**2 == sidelen[1]**2 + sidelen[2]**2):\n\n            print(\"YES\")\n\n        else:\n\n            print(\"NO\")\n\n    except:\n\n        continue","model_generated_potentially_faster_code_col":"n = int(eval(input()))\ninputs = [[int(j) for j in input().split()] for _ in range(n)]\nfor sidelen in inputs:\n    sidelen.sort(reverse=True)\n    if(sidelen[0]**2 == sidelen[1]**2 + sidelen[2]**2):\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"problem_id":"p02760","slow_code_col":"import numpy as np\n\nN_1=list(map(int, input().split()))\n\nN_2=list(map(int, input().split()))\n\nN_3=list(map(int, input().split()))\n\nN=int(eval(input()))\n\na=[int(eval(input())) for i in range(N)]\n\n\n\nn=np.array([N_1,N_2,N_3])\n\n\n\nfor a_n in a:\n\n    if a_n in n:\n\n        n[n==a_n]=0\n\n    else:\n\n        pass\n\ni=0\n\n    \n\nif np.all(n[0:,0]==0)==True:\n\n    i=+1\n\n    \n\nelif np.all(n[0:,1]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0:,2]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[0,0:]==0)==True:\n\n    i+=1\n\n    \n\nelif np.all(n[1,0:]==0)==True:\n\n    i+=1\n\n\n\nelif np.all(n[2,0:]==0)==True:\n\n    i+=1\n\n\n\nelif n[0,0]==0 and n[1,1]==0  and n[2,2] ==0:\n\n    i+=1\n\n    \n\nelif n[0,2]==0 and n[1,1]==0 and n[2,0] ==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n    print(\"No\")","reference_code_col":"a_1=list(map(int, input().split()))\n\na_2=list(map(int, input().split()))\n\na_3=list(map(int, input().split()))\n\n\n\nc=[a_1,a_2,a_3]\n\n\n\nN=int(eval(input()))\n\n\n\nb=[int(eval(input())) for _ in range(N)]\n\n\n\nfor i in range(3):\n\n    for j in range(3):\n\n        if c[i][j] in b:\n\n            c[i][j]=0\n\n            \n\n            \n\ni=0\n\nif c[0][0]==0 and c[0][1]==0 and c[0][2]==0:\n\n    i+=1\n\nif c[1][0]==0 and c[1][1]==0 and c[1][2]==0:\n\n    i+=1\n\nif c[2][0]==0 and c[2][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][0]==0 and c[2][0]==0:\n\n    i+=1\n\nif c[0][1]==0 and c[1][1]==0 and c[2][1]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][2]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][0]==0 and c[1][1]==0 and c[2][2]==0:\n\n    i+=1\n\nif c[0][2]==0 and c[1][1]==0 and c[2][0]==0:\n\n    i+=1\n\n    \n\nif i>0:\n\n    print(\"Yes\")\n\nelse:\n\n  print(\"No\")","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input\nN_1 = list(map(int, input().split()))\nN_2 = list(map(int, input().split()))\nN_3 = list(map(int, input().split()))\nN = int(eval(input()))\na = [int(eval(input())) for _ in range(N)]\n\n# Convert lists to NumPy arrays\nn = np.array([N_1, N_2, N_3])\n\n# Replace elements in n with 0 if they are present in a\nmask = np.isin(n, a)\nn[mask] = 0\n\n# Check conditions\nconditions = [\n    np.all(n[:, 0] == 0),\n    np.all(n[:, 1] == 0),\n    np.all(n[:, 2] == 0),\n    np.all(n[0, :] == 0),\n    np.all(n[1, :] == 0),\n    np.all(n[2, :] == 0),\n    (n[0, 0] == 0) & (n[1, 1] == 0) & (n[2, 2] == 0),\n    (n[0, 2] == 0) & (n[1, 1] == 0) & (n[2, 0] == 0)\n]\n\n# Print result\nprint(\"Yes\" if any(conditions) else \"No\")"}
{"problem_id":"p03424","slow_code_col":"n = int(eval(input()))\n\ns = input().split()\n\ns = set(s)\n\nprint(('Four' if len(s) == 4 else 'Three'))","reference_code_col":"n = int(eval(input()))\n\ns = input().split()\n\nprint(('Four' if len(set(s)) == 4 else 'Three'))","model_generated_potentially_faster_code_col":"# Read the number of elements (though it's not used)\nn = int(input())\n\n# Use list comprehension to read all elements at once\nelements = input().split()\n\n# Convert the list to a set to remove duplicates\nunique_elements = set(elements)\n\n# Print 'Four' if there are exactly four unique elements, otherwise print 'Three'\nresult = 'Four' if len(unique_elements) == 4 else 'Three'\n\nprint(result)"}
{"problem_id":"p02899","slow_code_col":"import numpy as np\n\n\n\n\n\nN=int(input())\n\n\n\nA=np.array([list(map(int, input().split()))])\n\n\n\n\n\nB=np.argsort(A[0,:])\n\nfor b in B:\n\n  print(b+1, end=' ')\n","reference_code_col":"N=int(input())\n\n\n\nA=list(map(int, input().split()))\n\nB=[-1]*N\n\nfor i in range(N):\n\n  B[A[i]-1]=i+1\n\n  \n\nfor b in B:\n\n  print(b, end=\" \")\n","model_generated_potentially_faster_code_col":"N = int(input())\nnumbers = []\nindices = []\n\n# Read numbers and their indices\nfor i in range(N):\n    num = int(input())\n    numbers.append(num)\n    indices.append(i)\n\n# Sort numbers and get sorted indices\nsorted_indices = [i for i, _ in sorted(enumerate(numbers), key=lambda x: x[1])]\n\n# Print sorted indices (add 1 to make it 1-indexed)\nprint(' '.join(str(i + 1) for i in sorted_indices))"}
{"problem_id":"p00122","slow_code_col":"dX = [2,2,2,1,0,-1,-2,-2,-2,-1,0,1]\n\ndY = [-1,0,1,2,2,2,1,0,-1,-2,-2,-2]\n\ndef solve(x,y,XY):\n\n\txy = XY[:]\n\n\tif len(xy) == 0: return \"OK\"\n\n\tsx,sy = xy.pop(0),xy.pop(0)\n\n\tfor dx,dy in zip(dX,dY):\n\n\t\tif doa(x+dx,y+dy,sx,sy): \n\n\t\t\tr = solve(x+dx,y+dy,xy)\n\n\t\t\tif r: return r\n\n\n\ndef doa(x,y,sx,sy):\n\n\tif not (0 <= x <= 9 and 0 <= y <= 9): return False\n\n\treturn True if abs(x-sx) < 2 and abs(y-sy) < 2 else False\n\n\n\nwhile 1:\n\n\tx,y = list(map(int,input().split()))\n\n\tif x == y == 0: break\n\n\tn = eval(input())\n\n\txy = list(map(int,input().split()))\n\n\tans = solve(x,y,xy)\n\n\tprint(ans if ans else \"NA\")","reference_code_col":"dX = [2,2,2,1,0,-1,-2,-2,-2,-1,0,1]\n\ndY = [-1,0,1,2,2,2,1,0,-1,-2,-2,-2]\n\ndef solve(x,y,XY):\n\n\txy = XY[:]\n\n\tif len(xy) == 0: return True\n\n\tsx,sy = xy.pop(0),xy.pop(0)\n\n\tfor dx,dy in zip(dX,dY):\n\n\t\tif doa(x+dx,y+dy,sx,sy): \n\n\t\t\tr = solve(x+dx,y+dy,xy)\n\n\t\t\tif r: return r\n\n\n\ndef doa(x,y,sx,sy):\n\n\tif not (0 <= x <= 9 and 0 <= y <= 9): return False\n\n\treturn True if abs(x-sx) < 2 and abs(y-sy) < 2 else False\n\n\n\nwhile 1:\n\n\tx,y = list(map(int,input().split()))\n\n\tif x == y == 0: break\n\n\tn = eval(input())\n\n\txy = list(map(int,input().split()))\n\n\tprint(\"OK\" if solve(x,y,xy) else \"NA\")","model_generated_potentially_faster_code_col":"from functools import lru_cache\n\ndX = [2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1]\ndY = [-1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2]\n\n@lru_cache(None)\ndef doa(x, y, sx, sy):\n    if not (0 <= x <= 9 and 0 <= y <= 9):\n        return False\n    return abs(x - sx) < 2 and abs(y - sy) < 2\n\ndef solve(x, y, xy):\n    if len(xy) == 0:\n        return \"OK\"\n    \n    sx, sy = xy.pop(0), xy.pop(0)\n    \n    for dx, dy in zip(dX, dY):\n        nx, ny = x + dx, y + dy\n        if doa(nx, ny, sx, sy):\n            result = solve(nx, ny, tuple(xy))\n            if result:\n                return result\n    \n    return None\n\nwhile True:\n    x, y = map(int, input().split())\n    if x == y == 0:\n        break\n    \n    n = int(input())\n    xy = tuple(map(int, input().split()))\n    \n    ans = solve(x, y, xy)\n    print(\"OK\" if ans else \"NA\")"}
{"problem_id":"p03988","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(1000000)\n\nfrom collections import deque\n\ndef getN():\n\n    return int(eval(input()))\n\ndef getList():\n\n    return list(map(int, input().split()))\n\nimport math\n\n\n\nn = getN()\n\nnums = getList()\n\n\n\n# nums.sort(reverse=True)\n\nmx = max(nums)\n\nmn = (mx+1) \/\/ 2\n\nmndx = (mx % 2) + 1\n\n\n\nfrom collections import Counter\n\n\n\ncnt = Counter(nums)\n\n\n\nfor i in range(mn+1, mx+1):\n\n    if cnt[i] < 2:\n\n        print(\"Impossible\")\n\n        sys.exit()\n\n\n\nif cnt[mn] != mndx:\n\n    print(\"Impossible\")\n\nelse:\n\n    print(\"Possible\")","reference_code_col":"import sys\n\nimport math\n\nimport copy\n\nfrom heapq import heappush, heappop, heapify\n\nfrom functools import cmp_to_key\n\nfrom bisect import bisect_left, bisect_right\n\nfrom collections import defaultdict, deque, Counter\n\n# sys.setrecursionlimit(1000000)\n\n\n\n# input aliases\n\ninput = sys.stdin.readline\n\ngetS = lambda: input().strip()\n\ngetN = lambda: int(eval(input()))\n\ngetList = lambda: list(map(int, input().split()))\n\ngetZList = lambda: [int(x) - 1 for x in input().split()]\n\n\n\nINF = float(\"inf\")\n\nMOD = 10**9 + 7\n\ndivide = lambda x: pow(x, MOD-2, MOD)\n\n\n\ndef pim():\n\n    print(\"Impossible\")\n\n    sys.exit()\n\ndef pp():\n\n    print(\"Possible\")\n\n    sys.exit()\n\ndef solve():\n\n    n = getN()\n\n    nums = getList()\n\n    cnt = Counter(nums)\n\n    mx = max(nums)\n\n    mn = min(nums)\n\n\n\n    if cnt[mx] < 2:\n\n        pim()\n\n    if mn < (mx + 1) \/\/ 2:\n\n        pim()\n\n\n\n    if mx % 2 == 0:\n\n        if cnt[mx\/\/2] != 1:\n\n            pim()\n\n    else:\n\n        if cnt[(mx+1) \/\/ 2] != 2:\n\n            pim()\n\n\n\n    for i in range((mx + 1) \/\/ 2 + 1, mx+1):\n\n        if cnt[i] < 2:\n\n            pim()\n\n\n\n    pp()\n\n\n\n\n\ndef main():\n\n    n = getN()\n\n    for _ in range(n):\n\n        solve()\n\n\n\n    return\n\nif __name__ == \"__main__\":\n\n    # main()\n\n    solve()\n\n\n\n\n\n\n\n\n\n\n","model_generated_potentially_faster_code_col":"import sys\nfrom collections import Counter\n\ninput = sys.stdin.readline\n\ndef getN():\n    return int(input())\n\ndef getList():\n    return list(map(int, input().split()))\n\nn = getN()\nnums = getList()\n\nmx = max(nums)\nmn = (mx + 1) \/\/ 2\nmndx = (mx % 2) + 1\n\ncnt = Counter(nums)\n\nfor i in range(mn + 1, mx + 1):\n    if cnt[i] < 2:\n        print(\"Impossible\")\n        sys.exit()\n\nif cnt[mn] != mndx:\n    print(\"Impossible\")\nelse:\n    print(\"Possible\")"}
{"problem_id":"p02390","slow_code_col":"import sys\n\n\n\nif __name__ == '__main__':\n\n    import doctest\n\n    doctest.testmod()\n\n    S = int(sys.stdin.read())\n\n    h = S \/ 3600\n\n    m = (S % 3600) \/ 60\n\n    s = S % 60\n\n    print(\"%d:%d:%d\" % (h, m, s))\n","reference_code_col":"#!\/usr\/bin\/env python\n\n#-*- coding: utf-8 -*-\n\n\n\n# http:\/\/judge.u-aizu.ac.jp\/onlinejudge\/description.jsp?id=ITP1_1_D\n\n\n\nif __name__ == '__main__':\n\n    S = int(input())\n\n    h = S \/ 3600\n\n    m = (S % 3600) \/ 60\n\n    s = S % 60\n\n    print(\"%d:%d:%d\" % (h, m, s))\n","model_generated_potentially_faster_code_col":"import sys\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n\n    S = int(sys.stdin.read())\n    \n    h = S \/\/ 3600\n    m = (S % 3600) \/\/ 60\n    s = S % 60\n    \n    print(f\"{h}:{m:02}:{s:02}\")"}
{"problem_id":"p02880","slow_code_col":"n = int(eval(input()))\n\ns = []\n\nfor i in range(1, 10):\n\n  for j in range(1, 10):\n\n    s.append(i*j)\n\nif n in s:\n\n  print(\"Yes\")\n\nelse:\n\n  print(\"No\")","reference_code_col":"import sys\n\n\n\nn = int(eval(input()))\n\nfor i in range(1, 10):\n\n  for j in range(1, 10):\n\n    if i*j == n:\n\n      print(\"Yes\")\n\n      sys.exit()\n\nprint(\"No\")\n","model_generated_potentially_faster_code_col":"n = int(eval(input()))\nproducts = {i * j for i in range(1, 10) for j in range(1, 10)}\n\nif n in products:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"problem_id":"p03796","slow_code_col":"import math\n\nN=int(eval(input()))\n\nans=math.factorial(N)\n\nprint((ans%(10**9 +7)))","reference_code_col":"mod=10**9+7\n\nN=int(eval(input()))\n\nans=1\n\nfor i in range(1,N+1):\n\n  ans*=i\n\n  ans%=mod\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(eval(input()))\n\n# Initialize result as 1 (factorial of 0 is 1)\nresult = 1\n\n# Calculate factorial iteratively\nfor i in range(2, N + 1):\n    result = (result * i) % (10**9 + 7)\n\nprint(result)"}
{"problem_id":"p03634","slow_code_col":"from collections import deque\n\nn,*t=list(map(int,open(0).read().split()))\n\ncon=[[] for _ in range(n)]\n\ndist_f_k=[0]*n\n\n\n\nfor a,b,c in zip(t[:3*n-3:3],t[1::3],t[2::3]):\n\n\tcon[a-1].append((b-1,c))\n\n\tcon[b-1].append((a-1,c))\n\n\n\nk=t[3*n-2]\n\nque=deque([k-1])\n\nwhile que:\n\n\tcur=que.popleft()\n\n\tfor nxt,dd in con[cur]:\n\n\t\tif dist_f_k[nxt]==0 and nxt!=k-1:\n\n\t\t\tque.append(nxt)\n\n\t\t\tdist_f_k[nxt]=dist_f_k[cur]+dd\n\n\n\nfor x,y in zip(t[3*n-1::2],t[3*n::2]):\n\n\tprint((dist_f_k[x-1]+dist_f_k[y-1]))","reference_code_col":"def solve():\n\n\tfrom collections import deque\n\n\tn,*t=list(map(int,open(0).read().split()))\n\n\tcon=[[] for _ in range(n)]\n\n\tdist_f_k=[0]*n\n\n\tl1,l2=t[:3*n-3],t[3*n-1:]\n\n\n\n\tfor a,b,c in zip(*[iter(l1)]*3):\n\n\t\tcon[a-1].append((b-1,c))\n\n\t\tcon[b-1].append((a-1,c))\n\n\n\n\tk=t[3*n-2]\n\n\tque=deque([k-1])\n\n\twhile que:\n\n\t\tcur=que.popleft()\n\n\t\tfor nxt,dd in con[cur]:\n\n\t\t\tif dist_f_k[nxt]==0 and nxt!=k-1:\n\n\t\t\t\tque.append(nxt)\n\n\t\t\t\tdist_f_k[nxt]=dist_f_k[cur]+dd\n\n\n\n\tfor x,y in zip(*[iter(l2)]*2):\n\n\t\tprint((dist_f_k[x-1]+dist_f_k[y-1]))\n\n\t\t\n\nif __name__==\"__main__\":\n\n\tsolve()","model_generated_potentially_faster_code_col":"import heapq\nfrom collections import defaultdict\n\n# Read input\nn, *t = list(map(int, open(0).read().split()))\n\n# Initialize adjacency list\ncon = defaultdict(list)\n\n# Build the graph\nfor a, b, c in zip(t[:3*n-3:3], t[1::3], t[2::3]):\n    con[a-1].append((b-1, c))\n    con[b-1].append((a-1, c))\n\n# Start node\nk = t[3*n-2] - 1\n\n# Priority queue for Dijkstra's algorithm\nque = [(0, k)]\nvisited = set()\ndist_f_k = [float('inf')] * n\ndist_f_k[k] = 0\n\n# Dijkstra's algorithm\nwhile que:\n    current_dist, cur = heapq.heappop(que)\n    \n    if cur in visited:\n        continue\n    \n    visited.add(cur)\n    \n    for nxt, dd in con[cur]:\n        new_dist = current_dist + dd\n        \n        if new_dist < dist_f_k[nxt]:\n            dist_f_k[nxt] = new_dist\n            heapq.heappush(que, (new_dist, nxt))\n\n# Output the results\nfor x, y in zip(t[3*n-1::2], t[3*n::2]):\n    print(dist_f_k[x-1] + dist_f_k[y-1])"}
{"problem_id":"p03253","slow_code_col":"import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\nfac = [1, 1]     # \u5143\u30c6\u30fc\u30d6\u30eb\n\nf_inv = [1, 1]   # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\ninv = [0, 1]     # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * pow(fac[r],MOD-2,MOD) * pow(fac[n-r],MOD-2,MOD) % mod\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n \/\/= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    prepare(N+100, MOD)\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e, MOD)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"# AC: msec(Python3)\n\nfrom math import factorial\n\nimport sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\ndef cmb(n, r):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    r = min(n-r, r)\n\n    res = 1\n\n    for i in range(r):\n\n        res *= n - i\n\n\n\n    return res \/\/ factorial(r)\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n \/\/= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nMOD = 10**9 + 7\n\n# Precompute factorials and their modular inverses\nfac = [1] * (100005)\nf_inv = [1] * (100005)\ninv = [0] * (100005)\n\ndef prepare(n, mod):\n    fac[0] = fac[1] = 1\n    f_inv[0] = f_inv[1] = 1\n    inv[1] = 1\n    for i in range(2, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n        inv[i] = mod - mod \/\/ i * inv[mod % i] % mod\n        f_inv[i] = f_inv[i - 1] * inv[i] % mod\n\ndef cmb(n, r, mod):\n    if n < 0 or r < 0:\n        return 0\n    if r > n:\n        return 0\n    return fac[n] * f_inv[r] % mod * f_inv[n - r] % mod\n\ndef prime_factorization(n):\n    d = []\n    i, e = 2, 0\n    while i * i <= n:\n        while n % i == 0:\n            n \/\/= i\n            e += 1\n        if e > 0:\n            d.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        d.append((n, 1))\n    return d\n\ndef main():\n    N, M = map(int, readline().split())\n    \n    prepare(max(N, M) + 100, MOD)\n    d = prime_factorization(M)\n    \n    ans = 1\n    for i, e in d:\n        ans *= cmb(N - 1 + e, e, MOD)\n        ans %= MOD\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02264","slow_code_col":"n, q = [ int( val ) for val in input( ).split( \" \" ) ]\n\nps = [0]*n\n\nt = [0]*n\n\nfor i in range( n ):\n\n\tps[i], t[i] = input( ).split( \" \" )\n\n\n\n\n\noutput = []\n\nqsum = 0\n\nwhile t:\n\n\tpsi = ps.pop( 0 )\n\n\tti = int( t.pop( 0 ) )\n\n\tif ti <= q:\n\n\t\tqsum += ti\t\n\n\t\toutput.append( psi+\" \"+str( qsum ) )\n\n\telse:\n\n\t\tt.append( ti - q )\n\n\t\tps.append( psi )\n\n\t\tqsum += q\n\n\n\nprint(( \"\\n\".join( output ) ))","reference_code_col":"n, q = [ int( val ) for val in input( ).split( \" \" ) ]\n\nps = [0]*n\n\nt = [0]*n\n\nfor i in range( n ):\n\n    ps[i], t[i] = input( ).split( \" \" )\n\n \n\n \n\noutput = []\n\nqsum = 0\n\nwhile t:\n\n    psi = ps.pop( 0 )\n\n    ti = int( t.pop( 0 ) )\n\n    if ti <= q:\n\n        qsum += ti\n\n        output.append( \"\".join( ( psi, \" \", str( qsum ) ) ) )\n\n    else:\n\n        t.append( ti - q )\n\n        ps.append( psi )\n\n        qsum += q\n\n \n\nprint(( \"\\n\".join( output ) ))","model_generated_potentially_faster_code_col":"import heapq\n\n# Read input values\nn, q = map(int, input().split())\n\n# Initialize lists to store processing times and task identifiers\nprocessing_times = []\ntask_ids = []\n\n# Read individual task details and push them onto the heap\nfor _ in range(n):\n    psi, ti = input().split()\n    processing_times.append(int(ti))\n    task_ids.append(psi)\n    heapq.heappush(task_heap, (int(ti), psi))\n\n# Initialize variables to store output and cumulative time\noutput = []\ncumulative_time = 0\n\n# Process tasks until there are no more tasks left or time limit is reached\nwhile task_heap and cumulative_time < q:\n    ti, psi = heapq.heappop(task_heap)\n    \n    # If the current task fits within the remaining time, complete it\n    if ti <= q - cumulative_time:\n        cumulative_time += ti\n        output.append(f\"{psi} {cumulative_time}\")\n    else:\n        # Otherwise, split the task and push the remaining part back onto the heap\n        remaining_time = ti - (q - cumulative_time)\n        heapq.heappush(task_heap, (remaining_time, psi))\n        break\n\n# Print the final output\nprint(\"\\n\".join(output))"}
{"problem_id":"p02688","slow_code_col":"N,K = list(map(int, input().split(' ')))\n\na=list(range(1,N+1))\n\nfor i in range(K):\n\n  count=int(eval(input()))\n\n  b=input().split(' ')\n\n  for j in range(count):\n\n    if int(b[j]) in a:\n\n      a.remove(int(b[j]))\n\nprint((len(a)))","reference_code_col":"N,K = list(map(int, input().split(' ')))\n\na=list(range(1,N+1))\n\nfor i in range(K):\n\n  count=int(eval(input()))\n\n  b=[int(x.strip()) for x in input().split(' ')]\n\n  for j in range(count):\n\n    if b[j] in a:\n\n      a.remove(b[j])\n\nprint((len(a)))","model_generated_potentially_faster_code_col":"N, K = map(int, input().split())\n\na = set(range(1, N + 1))\n\nfor _ in range(K):\n    count = int(input())\n    b = set(map(int, input().split()))\n    \n    a -= b\n\nprint(len(a))"}
{"problem_id":"p03796","slow_code_col":"n=int(eval(input()))\n\nx=1\n\nfor i in range(n):\n\n    x*=(i+1)\n\n    if x>10**9+7:\n\n        x=x%(10**9+7)\n\n\n\nprint(x)\n\n#import numpy as np\n\n#n=int(input())\n\n#print(np.prod([i+1 for i in range(n)]))\n\n#print(np.prod([i+1 for i in range(n)])%((10**9)+7))\n\n\n\n#\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\uff1f\n","reference_code_col":"power=1\n\nn=int(eval(input()))\n\nmod=10**9+7\n\nfor i in range(1,n+1):\n\n    power*=i\n\n    power%=mod\n\n    #print(power)\n\nprint(power)\n","model_generated_potentially_faster_code_col":"def factorial_modulo(n, mod):\n    # Initialize a list to store factorials up to n\n    fact = [0] * (n + 1)\n    \n    # Base case: factorial of 0 is 1\n    fact[0] = 1\n    \n    # Calculate factorials iteratively\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    \n    return fact[n]\n\nn = int(input())\nmod = 10 ** 9 + 7\nresult = factorial_modulo(n, mod)\nprint(result)"}
{"problem_id":"p03162","slow_code_col":"n = int(eval(input()))\n\n\n\nfelicidade = []\n\n\n\nfor x in range(n):\n\n    felicidade.append(list(map(int,input().split())))\n\n\n\nDP = [0,0,0]\n\n\n\nif n == 1:\n\n    print((max(felicidade[0])))\n\n\n\nelse:\n\n\n\n    for x in range(3):\n\n        DP[x] = felicidade[0][x]\n\n\n\n\n\n    for dia in range(1,n):\n\n        m = [0] * 3\n\n        for x  in range(3):#As duas poss\u00edveis escolhas s\u00e3o x e y\n\n            for y  in range(3):\n\n                if x != y: #Se elas forem diferentes\n\n                    m[x] = max(m[x], DP[y] + felicidade[dia][x])\n\n        DP = m\n\n    \n\n    print((max(DP)))\n","reference_code_col":"nDays = int(eval(input()))\n\n\n\ntoday = [int(x) for x in input().split()]\n\n\n\nfor i in range(nDays - 1):\n\n    tomorrow = [int(x) for x in input().split()]\n\n    tomorrow[0] += max(today[1], today[2])\n\n    tomorrow[1] += max(today[0], today[2])\n\n    tomorrow[2] += max(today[0], today[1])\n\n    today = tomorrow\n\n\n\nprint((max(today)))","model_generated_potentially_faster_code_col":"n = int(input())\n\nfelicidade = []\n\nfor _ in range(n):\n    felicidade.append(list(map(int, input().split())))\n\nDP = [0, 0, 0]\n\nif n == 1:\n    print(max(felicidade[0]))\nelse:\n    DP = felicidade[0]\n\n    for dia in range(1, n):\n        m = [max(DP[y] + felicidade[dia][x] for y in range(3) if x != y) for x in range(3)]\n        DP = m\n\n    print(max(DP))"}
{"problem_id":"p03013","slow_code_col":"n,m = list(map(int, input().split()))\n\na = [-1] + [int(eval(input())) for _ in range(m)] + [n + 1]\n\nMOD = 10 ** 9 + 7\n\n\n\nfib = [0, 1]\n\nfor i in range(100100):\n\n\tfib.append((fib[i] + fib[i + 1] % MOD))\n\n\n\nres = 1\n\nfor i in range(m + 1):\n\n\tp, q = a[i], a[i + 1]\n\n\tres = (res * fib[q - p - 1]) % MOD\n\n\n\nprint(res)","reference_code_col":"n,m = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(m)]\n\nMOD = 10 ** 9 + 7\n\n\n\n# broken[i] : i\u6bb5\u76ee\u304c\u58ca\u308c\u3066\u3044\u305f\u3089True\n\nbroken = [False] * 100100\n\nfor i in a:\n\n\tbroken[i] = True\n\n\n\n# dp[i] : i\u6bb5\u76ee\u306b\u884c\u304f\u901a\u308a\u6570\n\ndp = [0] * 100100\n\n\n\n# 0\u6bb5\u76ee\u306b\u884c\u304f\u65b9\u6cd5\u306f1\u901a\u308a\n\ndp[0] = 1\n\n\n\n# 1\u6bb5\u76ee\u304b\u3089n\u6bb5\u76ee\u306b\u3064\u3044\u3066\u8abf\u3079\u308b\n\nfor i in range(1, n + 1):\n\n\t# \u58ca\u308c\u3066\u308b\u306a\u3089\n\n\tif broken[i]:\n\n\t\t# \u305d\u306e\u6bb5\u306b\u306f\u9032\u3081\u306a\u3044\u306e\u30670\u901a\u308a\n\n\t\tdp[i] = 0\n\n\t# \u58ca\u308c\u3066\u306a\u3044\u306a\u3089\n\n\telse:\n\n\t\t# i - 1\u6bb5\u76ee\u304b\u3089\u79fb\u52d5\u53ef\u80fd (i - 1\u6bb5\u76ee\u306f, i == 0 \u306e\u3068\u304d\u306b\u306f\u306a\u3044\u306e\u3067\u5206\u5c90)\n\n\t\tif i > 0:\n\n\t\t\tdp[i] += dp[i - 1]\n\n\t\t# i - 2\u6bb5\u76ee\u304b\u3089\u79fb\u52d5\u53ef\u80fd (i - 2\u6bb5\u76ee\u306f, i == 0, 1 \u306e\u3068\u304d\u306b\u306f\u306a\u3044\u306e\u3067\u5206\u5c90)\n\n\t\tif i > 1:\n\n\t\t\tdp[i] += dp[i - 2]\n\n\tdp[i] %= MOD\n\n\n\nprint((dp[n]))","model_generated_potentially_faster_code_col":"n, m = map(int, input().split())\n\na = [-1] + [int(input()) for _ in range(m)] + [n + 1]\n\nMOD = 10 ** 9 + 7\n\n# Calculate Fibonacci numbers up to m+1\nfib = [0, 1]\nfor i in range(1, m + 1):\n    fib.append((fib[-1] + fib[-2]) % MOD)\n\nres = 1\nfor i in range(m + 1):\n    p, q = a[i], a[i + 1]\n    res = (res * fib[q - p - 1]) % MOD\n\nprint(res)"}
{"problem_id":"p03325","slow_code_col":"N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nans = 0\n\ncheck = [0]*30\n\nfor i in range(1, 31):\n\n    check[i-1] = 2**i\n\n\n\nfor i in A:\n\n    if i % 2 == 0:\n\n        j = 0\n\n        while check[j] <= i:\n\n            if i % check[j] == 0:\n\n                add = check[j]\n\n            else:\n\n                break\n\n                \n\n            j += 1\n\n        ans += j\n\n        \n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\nans = 0\n\n\n\nfor i in a:\n\n    while i % 2 == 0:\n\n        i \/\/= 2\n\n        ans += 1\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(input())\nA = list(map(int, input().split()))\n\nans = 0\nmax_value = max(A)\npowers_of_2 = [2**i for i in range(31)]\n\nfor i in A:\n    if i % 2 == 0:\n        count = 0\n        j = 0\n        while powers_of_2[j] <= i:\n            if i % powers_of_2[j] == 0:\n                count += 1\n                i \/\/= powers_of_2[j]\n            else:\n                break\n            j += 1\n        ans += count\n\nprint(ans)"}
{"problem_id":"p03845","slow_code_col":"N = int(eval(input()))\n\nT = list(map(int, input().split()))\n\nM = int(eval(input()))\n\np = []\n\nx = []\n\nans = []\n\nfor i in range(M):\n\n    p, x = list(map(int, input().split()))\n\n    ans.append(sum(T[:p-1])+x+sum(T[p:]))\n\n\n\nfor _ in ans:\n\n    print(_)","reference_code_col":"N = int(eval(input()))\n\nT = list(map(int, input().split()))\n\nM = int(eval(input()))\n\nP, X, ans = [0]*M, [0]*M, []\n\nbase = sum(T)\n\n\n\nfor i in range(M):\n\n    P, X = list(map(int, input().split()))\n\n    ans.append(base-T[P-1]+X)\n\n\n\nfor i in ans:\n\n    print(i)","model_generated_potentially_faster_code_col":"# Read input values\nN = int(input())\nT = list(map(int, input().split()))\nM = int(input())\n\n# Precompute cumulative sums\ncumulative_sum = [0] * (N + 1)\nfor i in range(N):\n    cumulative_sum[i + 1] = cumulative_sum[i] + T[i]\n\n# Process each query\nanswers = []\nfor _ in range(M):\n    p, x = map(int, input().split())\n    # Calculate the new sum by subtracting the old value and adding the new value\n    answers.append(cumulative_sum[p - 1] + x + cumulative_sum[N] - cumulative_sum[p])\n\n# Print all answers\nfor answer in answers:\n    print(answer)"}
{"problem_id":"p03162","slow_code_col":"n=int(eval(input()))\n\ndp=[[0 for i in range(3)] for i in range(n)]\n\nS=[[0 for i in range(3)] for i in range(n)]\n\ndp[0]=list(map(int,input().split()))\n\nS[0]=dp[0].copy()\n\nfor i in range(1,n):\n\n    S[i]=list(map(int,input().split()))\n\n    for j in range(3):\n\n        dp[i][j]=max(dp[i-1][j-1],dp[i-1][j-2])+S[i][j]\n\n\n\nprint((max(dp[n-1][0],dp[n-1][1],dp[n-1][2])))\n\n#dp[i][j]=i\u756a\u76ee\u306bj\u3092\u9078\u3093\u3060\u6642\u306e\u6700\u5927\u5024(j\u306fa,b,c\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u3002)","reference_code_col":"n=int(eval(input()))\n\ndp=[[0 for i in range(3)] for i in range(n)]\n\ndp[0]=list(map(int,input().split()))\n\nfor i in range(1,n):\n\n    S=list(map(int,input().split()))\n\n    for j in range(3):\n\n        dp[i][j]=max(dp[i-1][j-1],dp[i-1][j-2])+S[j]\n\n\n\nprint((max(dp[n-1][0],dp[n-1][1],dp[n-1][2])))\n\n#dp[i][j]=i\u756a\u76ee\u306bj\u3092\u9078\u3093\u3060\u6642\u306e\u6700\u5927\u5024(j\u306fa,b,c\u306b\u5bfe\u5fdc\u3057\u3066\u3044\u308b\u3002)","model_generated_potentially_faster_code_col":"n = int(input())\ndp = [[0, 0, 0] for _ in range(n)]\nS = [list(map(int, input().split())) for _ in range(n)]\n\nfor i in range(n):\n    for j in range(3):\n        dp[i][j] = max(dp[i-1][:j] + dp[i-1][j+1:]) + S[i][j]\n\nprint(max(dp[-1]))"}
{"problem_id":"p03162","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nL = [list(map(int, input().split())) for i in range(N)]\n\ndp = np.zeros((N, 3), dtype=int)\n\n\n\nfor i in range(N):\n\n    dp[i][0] = L[0][0] if i == 0 else max(dp[i-1][1]+L[i][0], dp[i-1][2]+L[i][0])\n\n    dp[i][1] = L[0][1] if i == 0 else max(dp[i-1][0]+L[i][1], dp[i-1][2]+L[i][1])\n\n    dp[i][2] = L[0][2] if i == 0 else max(dp[i-1][0]+L[i][2], dp[i-1][1]+L[i][2])\n\n\n\nprint((max(dp[-1])))","reference_code_col":"N = int(eval(input()))\n\nabc = [list(map(int, input().split())) for i in range(N)]\n\ndp = [[0 for i in range(3)] for j in range(N+1)]\n\nfor i in range(N):\n\n    dp[i+1][0] = max(dp[i][1]+abc[i][0], dp[i][2]+abc[i][0])\n\n    dp[i+1][1] = max(dp[i][0]+abc[i][1], dp[i][2]+abc[i][1])\n\n    dp[i+1][2] = max(dp[i][0]+abc[i][2], dp[i][1]+abc[i][2])\n\nprint((max(dp[-1])))","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nL = [[int(data[i*3 + j + 1]) for j in range(3)] for i in range(N)]\n\ndp = [[0]*3 for _ in range(N)]\ndp[0] = L[0]\n\nfor i in range(1, N):\n    dp[i][0] = max(dp[i-1][1], dp[i-1][2]) + L[i][0]\n    dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + L[i][1]\n    dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + L[i][2]\n\nprint(max(dp[N-1]))"}
{"problem_id":"p02901","slow_code_col":"def main():\n\n    import math\n\n    N,M=list(map(int,input().split()))\n\n    a=[]\n\n    for i in range(M):\n\n        tmp=list(map(int,input().split()))\n\n        tmpc=list(map(int,input().split()))\n\n        c=0\n\n        for j in range(len(tmpc)):\n\n            c+=2**(tmpc[j]-1)\n\n        tmp[1]=c\n\n        a+=[tmp]\n\n\n\n\n\n    dp=[[10**10 for j in range(2**N)] for i in range(M)]\n\n    dp[0][0]=0\n\n    dp[0][a[0][1]]=a[0][0]\n\n\n\n\n\n    for i in range(1,M):\n\n        dp[i]=dp[i-1]\n\n        for j in range(2**N):\n\n            z,p=a[i][0],a[i][1]\n\n            q=j|p\n\n            x=dp[i-1][j]+z\n\n            if dp[i][q]>x: dp[i][q]=x\n\n\n\n    ans=dp[M-1][2**N-1]\n\n    print((ans if ans<10**10 else -1))\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"n,m=list(map(int,input().split()))\n\nL=2**n\n\ncost=[0]+[10**8 for i in range(L-1)]\n\n\n\nfor i in range(m):\n\n    a,b=list(map(int,input().split()))\n\n    c=sum([2**(int(i)-1) for i in input().split()])\n\n    for j in range(L):\n\n        q=j|c\n\n        x=cost[j]+a\n\n        if cost[q]>x:\n\n            cost[q]=x\n\nprint((cost[L-1] if cost[L-1]<10**8 else -1))","model_generated_potentially_faster_code_col":"def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    index = 2\n    \n    a = []\n    for _ in range(M):\n        z = int(data[index])\n        p = [int(x) - 1 for x in data[index + 1:index + len(data[index:])]]\n        c = sum(1 << bit for bit in p)\n        a.append([z, c])\n        index += len(p) + 1\n    \n    dp = [[float('inf')] * (2 ** N) for _ in range(M)]\n    dp[0][0] = 0\n    dp[0][a[0][1]] = a[0][0]\n    \n    for i in range(1, M):\n        dp[i] = dp[i - 1].copy()\n        for j in range(2 ** N):\n            z, p = a[i]\n            q = j | p\n            x = dp[i - 1][j] + z\n            if dp[i][q] > x:\n                dp[i][q] = x\n    \n    ans = dp[-1][-1]\n    print(ans if ans < float('inf') else -1)\n    \nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02574","slow_code_col":"#!\/usr\/bin\/env pypy3\n\n# N,M = map(int,sys.stdin.readline().split())\n\n# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n\n# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param\n\n# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param\n\n# s = sys.stdin.readline().rstrip()\n\n# N = int(sys.stdin.readline())\n\n# INF = float(\"inf\")\n\nimport math,sys\n\n\n\nn = int(sys.stdin.readline())\n\na = tuple(map(int,sys.stdin.readline().split()))\n\n#n = int(input())\n\n#a = list(map(int,input().split()))\n\ng = math.gcd(a[0],a[1])\n\nfor i in range(2,n):\n\n    g = math.gcd(g,a[i])\n\nM = max(a)\n\nacc = a[0]\n\nfor i in range(n):\n\n    acc = math.gcd(acc,a[i])\n\nif acc != 1:\n\n    print(\"not coprime\")\n\n    exit()\n\n\n\nLIMIT=max(a)\n\nminPrime = [0]*(LIMIT+1)\n\nminPrime[1] = 1\n\ndef make():\n\n    for i in range(2,LIMIT+1):\n\n        if minPrime[i] == 0:\n\n            minPrime[i] = i\n\n            #print(i)\n\n            for j in range(i+i,LIMIT+1,i):\n\n                #print(i,j)\n\n                if minPrime[j] == 0:\n\n                    minPrime[j] = i\n\nmake()\n\ndef factrial(N):\n\n     ret = []\n\n     while minPrime[N] != N:\n\n         ret.append(minPrime[N])\n\n         N = N\/\/minPrime[N]\n\n     if N != 1:\n\n         ret.append(N)\n\n     return ret\n\n\n\njudge = set([])\n\npc = True\n\n\n\npairwise = True\n\np = set() #all prime\n\n\n\nfor e in a:\n\n    if not pairwise:\n\n        break\n\n    asf = set(factrial(e))\n\n    if judge & asf != set():\n\n        pc = False\n\n    #     #pairwise = False\n\n    #     print(\"setwise coprime\")\n\n    #     exit(0)\n\n    judge |= asf\n\n# for i in a:\n\n#     if not pc:\n\n#         break\n\n#     asf = set(factrial(i))\n\n\n\n#     if judge & asf != set():\n\n#         pc = False\n\n#     judge |= asf\n\nif pc:\n\n    print(\"pairwise coprime\")\n\nelif g == 1:\n\n    print(\"setwise coprime\")\n\nelse:\n\n    print(\"not coprime\")\n","reference_code_col":"#!\/usr\/bin\/env pypy3\n\n# N,M = map(int,sys.stdin.readline().split())\n\n# a = tuple(map(int,sys.stdin.readline().split())) # single line with multi param\n\n# a = tuple(int(sys.stdin.readline()) for _ in range(N)) # multi line with single param\n\n# a = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(N)) # multi line with multi param\n\n# s = sys.stdin.readline().rstrip()\n\n# N = int(sys.stdin.readline())\n\n# INF = float(\"inf\")\n\nimport math,sys\n\n\n\nn = int(sys.stdin.readline())\n\na = tuple(map(int,sys.stdin.readline().split()))\n\n#n = int(input())\n\n#a = list(map(int,input().split()))\n\ng = math.gcd(a[0],a[1])\n\nfor i in range(2,n):\n\n    g = math.gcd(g,a[i])\n\nM = max(a)\n\nacc = a[0]\n\nfor i in range(n):\n\n    acc = math.gcd(acc,a[i])\n\nif acc != 1:\n\n    print(\"not coprime\")\n\n    exit()\n\n\n\nLIMIT=max(a)\n\nminPrime = [0]*(LIMIT+1)\n\nminPrime[1] = 1\n\ndef make():\n\n    for i in range(2,LIMIT+1):\n\n        if minPrime[i] == 0:\n\n            minPrime[i] = i\n\n            #print(i)\n\n            for j in range(i+i,LIMIT+1,i):\n\n                #print(i,j)\n\n                if minPrime[j] == 0:\n\n                    minPrime[j] = i\n\nmake()\n\ndef factrial(N):\n\n     ret = []\n\n     while minPrime[N] != N:\n\n         ret.append(minPrime[N])\n\n         N = N\/\/minPrime[N]\n\n     if N != 1:\n\n         ret.append(N)\n\n     return ret\n\n\n\njudge = set([])\n\n\n\nfor e in a:\n\n    asf = set(factrial(e))\n\n    if judge & asf != set():\n\n        print(\"setwise coprime\")\n\n        exit()\n\n    judge |= asf\n\n    #judge = judge | asf #too slow\n\nprint(\"pairwise coprime\")\n","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env pypy3\n\nimport math\nimport sys\n\n# Read input\nn = int(sys.stdin.readline())\na = tuple(map(int, sys.stdin.readline().split()))\n\n# Function to compute gcd of two numbers\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# Compute gcd of all elements\ng = a[0]\nfor num in a[1:]:\n    g = gcd(g, num)\n\n# Check if all elements are pairwise coprime\ndef is_pairwise_coprime(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if gcd(arr[i], arr[j]) != 1:\n                return False\n    return True\n\n# Check if all elements are setwise coprime\ndef is_setwise_coprime(arr):\n    from functools import reduce\n    return reduce(gcd, arr) == 1\n\n# Determine the type of coprimality\nif is_pairwise_coprime(a):\n    result = \"pairwise coprime\"\nelif is_setwise_coprime(a):\n    result = \"setwise coprime\"\nelse:\n    result = \"not coprime\"\n\nprint(result)"}
{"problem_id":"p02599","slow_code_col":"NN = 19\n\nXX = [0] * (2**(NN+1)-1)\n\n\n\ndef addvalue(j, x):\n\n    i = 2**NN + j - 1\n\n    while i >= 0:\n\n        XX[i] += x\n\n        i = (i-1) \/\/ 2\n\n\n\ndef rangesum(a, b):\n\n    l = a + (1<<NN)\n\n    r = b + (1<<NN)\n\n    s = 0\n\n    while l < r:\n\n        if l%2:\n\n            s += XX[l-1]\n\n            l += 1\n\n        if r%2:\n\n            r -= 1\n\n            s += XX[r-1]\n\n        l >>= 1\n\n        r >>= 1\n\n    return s\n\n\n\nN, Q = map(int, input().split())\n\nC = [int(a) - 1 for a in input().split()]\n\nX = [[] for _ in range(N)]\n\nfor i in range(Q):\n\n    l, r = map(int, input().split())\n\n    X[r-1].append((l - 1, i))\n\nlast = [-1] * N\n\nANS = [-1] * Q\n\naddvalue(1, N)\n\nfor r in range(N):\n\n    c = C[r]\n\n    addvalue(last[c] + 2, -1)\n\n    addvalue(r + 2, 1)\n\n    last[c] = r\n\n    for l, i in X[r]:\n\n        ANS[i] = rangesum(l + 2, 1 << NN)\n\n    \n\nprint(*ANS, sep = \"\\n\")\n","reference_code_col":"##### https:\/\/atcoder.jp\/contests\/abc174\/submissions\/15644075 \u30921\u6b21\u5143\u5316\n\n\n\nimport sys\n\nINF = 1 << 60\n\nMOD = 10**9 + 7 # 998244353\n\nsys.setrecursionlimit(2147483647)\n\ninput = lambda:sys.stdin.buffer.readline().rstrip()\n\n \n\nclass SegmentTree(object):\n\n    def __init__(self, A, dot, unit):\n\n        n = 1 << (len(A) - 1).bit_length()\n\n        tree = [unit] * (2 * n)\n\n        for i, v in enumerate(A):\n\n            tree[i + n] = v\n\n        for i in range(n - 1, 0, -1):\n\n            tree[i] = dot(tree[i << 1], tree[i << 1 | 1])\n\n        self._n = n\n\n        self._tree = tree\n\n        self._dot = dot\n\n        self._unit = unit\n\n \n\n    def __getitem__(self, i):\n\n        return self._tree[i + self._n]\n\n \n\n    def update(self, i, v):\n\n        i += self._n\n\n        self._tree[i] = v\n\n        while i != 1:\n\n            i >>= 1\n\n            self._tree[i] = self._dot(self._tree[i << 1], self._tree[i << 1 | 1])\n\n \n\n    def add(self, i, v):\n\n        self.update(i, self[i] + v)\n\n \n\n    def sum(self, l, r):\n\n        l += self._n\n\n        r += self._n\n\n        l_val = r_val = self._unit\n\n        while l < r:\n\n            if l & 1:\n\n                l_val = self._dot(l_val, self._tree[l])\n\n                l += 1\n\n            if r & 1:\n\n                r -= 1\n\n                r_val = self._dot(self._tree[r], r_val)\n\n            l >>= 1\n\n            r >>= 1\n\n        return self._dot(l_val, r_val)\n\n\n\nfrom operator import add\n\ndef resolve():\n\n    n, q = map(int, input().split())\n\n    C = list(map(lambda x : int(x) - 1, input().split()))\n\n \n\n    A = [0] * n\n\n    used = [0] * n\n\n    for i, c in enumerate(C):\n\n        if used[c]:\n\n            continue\n\n        used[c] = 1\n\n        A[i] = 1\n\n    tree = SegmentTree(A, add, 0)\n\n \n\n    next = [-1] * n\n\n    used = [-1] * n\n\n    for i in range(n - 1, -1, -1):\n\n        c = C[i]\n\n        if used[c] != -1:\n\n            next[i] = used[c]\n\n        used[c] = i\n\n \n\n    queries = [None] * q\n\n    for i in range(q):\n\n        l, r = map(int, input().split())\n\n        queries[i] = (l - 1 << 40) + (r << 20) + i\n\n    queries.sort(reverse = 1)\n\n    \n\n    m = (1 << 20) - 1\n\n    ans = [0] * q\n\n    for l in range(n):\n\n        while queries and queries[-1] >> 40 == l:\n\n            lri = queries.pop()\n\n            l = lri >> 40\n\n            r = (lri >> 20) & m\n\n            i = lri & m\n\n            ans[i] = tree.sum(l, r)\n\n        if next[l] != -1:\n\n            tree.add(next[l], 1)\n\n \n\n    print(*ans, sep = '\\n')\n\nresolve()\n","model_generated_potentially_faster_code_col":"NN = 19\nMAXN = 2**(NN+1) - 1\n\nXX = [0] * MAXN\n\n\ndef add_value(j, x):\n    i = 2**NN + j - 1\n    while i >= 0:\n        XX[i] += x\n        i = (i - 1) \/\/ 2\n\n\ndef range_sum(a, b):\n    l = a + 2**NN\n    r = b + 2**NN\n    s = 0\n    while l < r:\n        if l & 1:\n            s += XX[l - 1]\n            l += 1\n        if r & 1:\n            r -= 1\n            s += XX[r - 1]\n        l >>= 1\n        r >>= 1\n    return s\n\n\nN, Q = map(int, input().split())\nC = [int(a) - 1 for a in input().split()]\nX = [[] for _ in range(N)]\nfor i in range(Q):\n    l, r = map(int, input().split())\n    X[r-1].append((l - 1, i))\n\nlast = [-1] * N\nANS = [-1] * Q\n\nadd_value(1, N)\nfor r in range(N):\n    c = C[r]\n    add_value(last[c] + 2, -1)\n    add_value(r + 2, 1)\n    last[c] = r\n    for l, i in X[r]:\n        ANS[i] = range_sum(l + 2, 2**NN)\n\nprint(*ANS, sep=\"\\n\")"}
{"problem_id":"p03039","slow_code_col":"n, m, k = list(map(int, input().split()))\n\n\n\nmod = 1000000007\n\ndef pow(x, n):\n\n    ret = 1\n\n    while n > 0:\n\n        if (n & 1) == 1:\n\n            ret = (ret * x) % mod\n\n        x = (x * x) % mod\n\n        n >>= 1\n\n    return ret\n\n\n\nfac = [1]\n\ninv = [1]\n\nfor i in range(1, n * m + 1):\n\n    fac.append((fac[-1] * i) % mod)\n\n    inv.append(pow(fac[i], mod - 2))\n\n\n\ndef cmb(n, k):\n\n    return (fac[n] * inv[k] * inv[n - k]) % mod\n\n\n\ndef doit(n, m, k):\n\n    ret = 0\n\n    for d in range(m):\n\n        ret = (ret + d * (m - d)) % mod\n\n    return (ret * n * n * cmb(n * m - 2, k - 2)) % mod\n\n\n\nprint(((doit(n, m, k) + doit(m, n, k)) % mod))","reference_code_col":"n, m, k = list(map(int, input().split()))\n\n\n\nmod = 1000000007\n\nfac = [1]\n\nfor i in range(1, n * m + 1):\n\n    fac.append((fac[-1] * i) % mod)\n\n\n\ndef pow(x, n):\n\n    ret = 1\n\n    while n > 0:\n\n        if (n & 1) == 1:\n\n            ret = (ret * x) % mod\n\n        x = (x * x) % mod\n\n        n >>= 1\n\n    return ret\n\n\n\ndef inv(i):\n\n    return pow(fac[i], mod - 2)\n\n\n\ndef cmb(n, k):\n\n    return (fac[n] * inv(k) * inv(n - k)) % mod\n\n\n\nx = sum(d * (m - d) for d in range(m)) % mod\n\ny = sum(d * (n - d) for d in range(n)) % mod\n\n\n\nc = cmb(n * m - 2, k - 2)\n\nx = (x * n * n * c) % mod\n\ny = (y * m * m * c) % mod\n\n\n\nprint(((x + y) % mod))","model_generated_potentially_faster_code_col":"n, m, k = map(int, input().split())\n\nmod = 1000000007\n\ndef pow(x, n):\n    ret = 1\n    while n > 0:\n        if n & 1:\n            ret = (ret * x) % mod\n        x = (x * x) % mod\n        n >>= 1\n    return ret\n\n# Precompute factorials and modular inverses up to max(n, m)\nmax_val = max(n, m)\nfac = [1] * (max_val * m + 1)\ninv = [1] * (max_val * m + 1)\n\nfor i in range(1, len(fac)):\n    fac[i] = (fac[i - 1] * i) % mod\n    inv[i] = pow(fac[i], mod - 2)\n\ndef cmb(n, k):\n    if k < 0 or k > n:\n        return 0\n    return (fac[n] * inv[k] * inv[n - k]) % mod\n\ndef doit(a, b, k):\n    if k < 2:\n        return 0\n    ret = 0\n    for d in range(b):\n        ret = (ret + d * (b - d)) % mod\n    return (ret * a * a * cmb(a * b - 2, k - 2)) % mod\n\nresult = (doit(n, m, k) + doit(m, n, k)) % mod\nprint(result)"}
{"problem_id":"p02555","slow_code_col":"s=int(eval(input()))\n\np=10**9+7\n\nif s<=2:\n\n    print((0))\n\n    exit()\n\nn=s\/\/3\n\nans=0\n\ndef f(n,k,p):\n\n    if k==0:\n\n        return 1\n\n    elif k%2==0:\n\n        return (f(n,k\/\/2,p)**2)%p\n\n    else:\n\n        return (n*f(n,k-1,p))%p\n\n\n\nfor k in range(1,n+1):\n\n    a=1\n\n    b=1\n\n    for j in range(k-1):\n\n        a=(a*(s-3*k+1+j))%p\n\n        b=(b*(j+1))%p\n\n    ans=(ans+a*f(b,p-2,p))%p\n\n\n\nprint((ans%p))\n\n\n","reference_code_col":"s=int(eval(input()))\n\np=10**9+7\n\nif s<=2:\n\n    print((0))\n\n    exit()\n\nn=s\/\/3\n\nans=0\n\nx=[0]*(s+1)\n\nx[0]=1\n\nx[1]=1\n\ny=[0]*(s+1)\n\n\n\nfor i in range(2,s+1):\n\n    x[i]=x[i-1]*i%p\n\n\n\ny[s]=pow(x[s],p-2,p)\n\nfor i in range(s):\n\n    y[s-1-i]=y[s-i]*(s-i)%p\n\n\n\nfor k in range(1,n+1):\n\n    ans+=x[s-2*k-1]*y[k-1]*y[s-3*k]%p\n\n\n\nprint((ans%p))\n\n\n","model_generated_potentially_faster_code_col":"from functools import lru_cache\n\n# Read input and define constants\ns = int(eval(input()))\np = 10**9 + 7\n\n# Handle edge cases\nif s <= 2:\n    print(0)\n    exit()\n\n# Precompute factorials up to s\nfactorials = [1] * (s + 1)\nmodular_inverses = [1] * (s + 1)\n\nfor i in range(1, s + 1):\n    factorials[i] = (factorials[i - 1] * i) % p\n    modular_inverses[i] = pow(i, p - 2, p)\n\n# Function to compute nCr mod p using precomputed factorials\n@lru_cache(None)\ndef ncr(n, r):\n    if r > n:\n        return 0\n    return (factorials[n] * modular_inverses[r] * modular_inverses[n - r]) % p\n\n# Main computation\nans = 0\nn = s \/\/ 3\n\nfor k in range(1, n + 1):\n    a = 1\n    b = 1\n    for j in range(k - 1):\n        a = (a * (s - 3 * k + 1 + j)) % p\n        b = (b * (j + 1)) % p\n    ans = (ans + a * ncr(b, p - 2)) % p\n\nprint(ans)"}
{"problem_id":"p03162","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\n\n\nabc = np.array([list(map(int, input().split())) for i in range(N)])\n\n\n\ndp = [[0]*3 for i in range(N+1)]\n\n\n\nfor i in range(1, N+1):\n\n    dp[i][0] = max(dp[i - 1][1] + abc[i - 1][1], dp[i - 1][2] + abc[i - 1][2])\n\n    dp[i][1] = max(dp[i - 1][0] + abc[i - 1][0], dp[i - 1][2] + abc[i - 1][2])\n\n    dp[i][2] = max(dp[i - 1][1] + abc[i - 1][1], dp[i - 1][0] + abc[i - 1][0])\n\n\n\nprint((max(dp[-1])))\n","reference_code_col":"N = int(eval(input()))\n\n\n\nA = [0] * (N + 1)\n\nB = [0] * (N + 1)\n\nC = [0] * (N + 1)\n\n\n\nfor i in range(1, N + 1):\n\n    A[i], B[i], C[i] = list(map(int, input().split()))\n\n\n\ndp = [[0] * 3 for _ in range(N + 1)]\n\nfor i in range(1, N + 1):\n\n    dp[i][0] = A[i] + max(dp[i-1][1], dp[i-1][2])\n\n    dp[i][1] = B[i] + max(dp[i-1][2], dp[i-1][0])\n\n    dp[i][2] = C[i] + max(dp[i-1][0], dp[i-1][1])\n\n\n\nprint((max(dp[N])))","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nabc = np.array([list(map(int, input().split())) for i in range(N)])\n\na, b, c = 0, 0, 0\n\nfor i in range(1, N+1):\n    a, b, c = max(b + abc[i-1][1], c + abc[i-1][2]), max(a + abc[i-1][0], c + abc[i-1][2]), max(a + abc[i-1][1], b + abc[i-1][0])\n\nprint(max(a, b, c))"}
{"problem_id":"p03371","slow_code_col":"a,b,c,x,y=list(map(int,input().split()));print((min(k*c*2+a*max(x-k,0)+b*max(y-k,0)for k in range(max(x,y)*3))))","reference_code_col":"a,b,c,x,y=list(map(int,input().split()));print((min(x*a+y*b,2*x*c+b*max(0,y-x),2*y*c+a*max(0,x-y))))","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\nk = max(x, y)\nprint(k*c*2 + a*(x-k) + b*(y-k))"}
{"problem_id":"p03723","slow_code_col":"a,b,c=list(map(int, input().split()))\n\nd=0\n\nwhile d<10**5:\n\n    if a%2==1 or b%2==1 or c%2==1:break\n\n    a,b,c=b\/2+c\/2,a\/2+c\/2,a\/2+b\/2\n\n    d+=1\n\nelse:d=-1\n\nprint(d)","reference_code_col":"a,b,c=list(map(int, input().split()))\n\nans=0\n\nwhile a%2==0 and b%2==0 and c%2==0 and ans<10000:\n\n    a,b,c=b\/\/2+c\/\/2,a\/\/2+c\/\/2,a\/\/2+b\/\/2\n\n    ans+=1\n\nif ans==10000:ans=-1\n\nprint(ans)","model_generated_potentially_faster_code_col":"a, b, c = map(int, input().split())\n\nd = 0\n\nwhile d < 10**5:\n    if a % 2 == 1 or b % 2 == 1 or c % 2 == 1:\n        break\n    \n    # Calculate new values in one operation\n    a, b, c = (b + c) \/ 2, (a + c) \/ 2, (a + b) \/ 2\n    \n    d += 1\n\nelse:\n    d = -1\n\nprint(d)"}
{"problem_id":"p03013","slow_code_col":"# https:\/\/atcoder.jp\/contests\/abc129\/tasks\/abc129_c\n\n# \u5178\u578b\u7684\u306aDP\n\n\n\nMOD = 10**9 + 7\n\nimport numpy as np\n\n# dp[i]\u3092i\u6bb5\u76ee\u307e\u3067\u306e\u901a\u308a\u306e\u6570\u3068\u3059\u308b\u3002\n\nN, M = list(map(int, input().split()))\n\nto_zero = np.full((N + 1), False).tolist()\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # \u5e8a\u304c\u629c\u3051\u3066\u3044\u308b\u3068\u3053\u308d\n\n\n\n# dp\u30c6\u30fc\u30d6\u30eb\u306e\u7528\u610f\n\ndp = np.full((N + 1), -1).tolist()\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n","reference_code_col":"# https:\/\/atcoder.jp\/contests\/abc129\/tasks\/abc129_c\n\n# \u5178\u578b\u7684\u306aDP\n\n\n\n\n\ndef full(shape, full_value):\n\n    if isinstance(shape, tuple):\n\n        NotImplementedError()\n\n    else:\n\n        return [full_value] * shape\n\n\n\n\n\nMOD = 10**9 + 7\n\n# dp[i]\u3092i\u6bb5\u76ee\u307e\u3067\u306e\u901a\u308a\u306e\u6570\u3068\u3059\u308b\u3002\n\nN, M = list(map(int, input().split()))\n\nto_zero = full((N + 1), False)\n\nfor _ in range(M):\n\n    to_zero[int(eval(input()))] = True  # \u5e8a\u304c\u629c\u3051\u3066\u3044\u308b\u3068\u3053\u308d\n\n\n\n# dp\u30c6\u30fc\u30d6\u30eb\u306e\u7528\u610f\n\ndp = full((N + 1), -1)\n\ndp[0] = 1\n\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n\n    dp[i] = 0 if to_zero[i] else dp[i - 2] + dp[i - 1]\n\n    if dp[i] > MOD:\n\n        dp[i] %= MOD\n\n\n\nprint((dp[-1]))\n","model_generated_potentially_faster_code_col":"MOD = 10**9 + 7\n\nN, M = map(int, input().split())\n\nto_zero = [False] * (N + 1)\n\nfor _ in range(M):\n    to_zero[int(eval(input()))] = True\n\ndp = [-1] * (N + 1)\ndp[0] = 1\ndp[1] = 0 if to_zero[1] else 1\n\nfor i in range(2, N + 1):\n    dp[i] = 0 if to_zero[i] else (dp[i - 2] + dp[i - 1]) % MOD\n\nprint(dp[-1])"}
{"problem_id":"p03720","slow_code_col":"import sys\n\nimport numpy as np\n\nn,m = [int(x) for x in sys.stdin.readline().split()]\n\nr = np.zeros(n)\n\nfor i in range(m):\n\n\ta, b = [int(x) for x in sys.stdin.readline().split()]\n\n\tr[a-1] += 1\n\n\tr[b-1] += 1\n\nfor i in range(n):\n\n\tprint((int(r[i])))","reference_code_col":"import sys\n\nn,m = [int(x) for x in sys.stdin.readline().split()]\n\nr = [0]*n\n\nfor _ in range(m):\n\n\ta, b = [int(x) for x in sys.stdin.readline().split()]\n\n\tr[a-1] += 1\n\n\tr[b-1] += 1\n\nfor i in r:\n\n\tprint(i)","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Read all lines at once\nlines = sys.stdin.read().splitlines()\n\nn, m = map(int, lines[0].split())\nr = np.zeros(n)\n\nfor i in range(1, m + 1):\n    a, b = map(int, lines[i].split())\n    r[a - 1] += 1\n    r[b - 1] += 1\n\nprint('\\n'.join(map(str, r.astype(int))))"}
{"problem_id":"p03309","slow_code_col":"import statistics\n\nN = int(eval(input()))\n\na = [int(i) for i in input().split()]\n\nans = 0\n\n\n\nfor i in range(1,N+1):\n\n  a[i-1] -= i\n\n\n\nb = statistics.median(a)\n\nfor i in range(N):\n\n  ans += abs(a[i]-b)\n\nprint((int(ans)))","reference_code_col":"N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nC = [A[i]-i for i in range(N)]\n\nC.sort()\n\nans = 0\n\nmed = C[N\/\/2]\n\nfor i in range(N):\n\n  ans += abs(C[i]-med)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import statistics\n\nN = int(input())\na = list(map(int, input().split()))\na = [(x - i) for i, x in enumerate(a)]\n\nb = statistics.median(a)\nans = sum(abs(x - b) for x in a)\n\nprint(ans)"}
{"problem_id":"p03078","slow_code_col":"import numpy as np\n\n\n\nX, Y, Z, K = list(map(int, input().split()))\n\nA = np.array([int(i) for i in input().split()])\n\nB = np.array([int(i) for i in input().split()])\n\nC =np.array([int(i) for i in input().split()])\n\nA = -np.sort(-A) #\u8981\u30c1\u30a7\u30c3\u30af\u3084\n\nB = -np.sort(-B)\n\nC = -np.sort(-C)\n\nD = []\n\nfor i in range(min(K, X)):\n\n    for j in range(min(K, Y)):\n\n        if (i + 1) * (j + 1) > K:\n\n            break\n\n        for k in range(min(K, Z)):\n\n            if (i + 1) * (j + 1) * (k + 1) > K:\n\n                break\n\n            else:\n\n\n\n                D.append(A[i] + B[j] + C[k])\n\n\n\nX = np.array(D)\n\nX = -np.sort(-X)\n\nfor i in range(K):\n\n    print((X[i]))","reference_code_col":"X, Y, Z, K = list(map(int, input().split()))\n\nA = sorted([int(i) for i in input().split()], reverse=True)\n\nB = sorted([int(i) for i in input().split()], reverse=True)\n\nC = sorted([int(i) for i in input().split()], reverse=True)\n\nD = []\n\nfor i in range(min(K, X)):\n\n    for j in range(min(K, Y)):\n\n        if (i + 1) * (j + 1) > K:\n\n            break\n\n        for k in range(min(K, Z)):\n\n            if (i + 1) * (j + 1) * (k + 1) > K:\n\n                break\n\n            else:\n\n\n\n                D.append(A[i] + B[j] + C[k])\n\n\n\nD.sort(reverse=True)\n\nfor i in range(K):\n\n    print((D[i]))","model_generated_potentially_faster_code_col":"import numpy as np\n\nX, Y, Z, K = map(int, input().split())\n\nA = np.array([-x for x in sorted(map(int, input().split()))])\nB = np.array([-x for x in sorted(map(int, input().split()))])\nC = np.array([-x for x in sorted(map(int, input().split()))])\n\nAB = np.outer(A, B)\nABC = np.outer(AB.ravel(), C)\n\nresult = ABC[ABC[:,0] <= K]\nresult = result[result[:,1] <= K]\nresult = result[result[:,2] <= K]\n\nresult = np.sort(result[:,0] + result[:,1] + result[:,2])[-K:]\nprint('\\n'.join(map(str, result)))"}
{"problem_id":"p02665","slow_code_col":"n = int(eval(input()))\n\nleaves = list(map(int, input().split()))\n\n\n\nans = 0\n\nnodes_min = [0] * (n + 1)\n\nnodes_max = [0] * (n + 1)\n\nnodes_min[n] = leaves[n]\n\nnodes_max[n] = leaves[n]\n\n\n\nfor depth in range(n, 0, -1):\n\n    root_min = nodes_min[depth] \/\/ 2 + nodes_min[depth] % 2\n\n    nodes_min[depth - 1] = leaves[depth - 1] + root_min\n\n    root_max = nodes_max[depth]\n\n    nodes_max[depth - 1] = leaves[depth - 1] + root_max\n\nnodes = [0] * (n + 1)\n\nnodes[0] = 1\n\nif nodes[0] < nodes_min[0]:\n\n    print((-1))\n\nelse:\n\n    for depth in range(n):\n\n        roots = nodes[depth]-leaves[depth]\n\n        nodes[depth + 1] = min(roots * 2, nodes_max[depth + 1])\n\n        if nodes[depth+1] < nodes_min[depth+1]:\n\n            print((-1))\n\n            break\n\n    else:\n\n        print((sum(nodes)))\n","reference_code_col":"n = int(eval(input()))\n\nleaves = list(map(int, input().split()))\n\n\n\nsum_leaves = [0]*(n+1)\n\nsum_leaves[0] = leaves[0]\n\nfor depth in range(n):\n\n    sum_leaves[depth+1] = sum_leaves[depth] + leaves[depth+1]\n\n\n\nans = 0\n\n\n\nroot = [None] * (n + 1)\n\nif n == 0:\n\n    root[0] = 0\n\nelse:\n\n    root[0] = 1\n\nif root[0] + leaves[0] != 1:\n\n    print((-1))\n\nelse:\n\n    for depth in range(n):\n\n        root[depth+1] = min(2*root[depth]-leaves[depth+1],\n\n                            sum_leaves[n]-sum_leaves[depth+1])\n\n        if root[depth + 1] < root[depth] - leaves[depth + 1] or root[depth+1] < 0:\n\n            print((-1))\n\n            break\n\n    else:\n\n        print((sum(root)+sum(leaves)))\n","model_generated_potentially_faster_code_col":"n = int(input())\nleaves = list(map(int, input().split()))\n\nnodes_min = [0] * (n + 1)\nnodes_max = [0] * (n + 1)\n\nnodes_min[n] = leaves[n]\nnodes_max[n] = leaves[n]\n\nfor depth in range(n, 0, -1):\n    root_min = nodes_min[depth] \/\/ 2 + nodes_min[depth] % 2\n    nodes_min[depth - 1] = leaves[depth - 1] + root_min\n    root_max = nodes_max[depth]\n    nodes_max[depth - 1] = leaves[depth - 1] + root_max\n\nnodes = [0] * (n + 1)\nnodes[0] = 1\n\nif nodes[0] < nodes_min[0]:\n    print(-1)\nelse:\n    for depth in range(n):\n        roots = nodes[depth] - leaves[depth]\n        nodes[depth + 1] = min(roots * 2, nodes_max[depth + 1])\n        if nodes[depth + 1] < nodes_min[depth + 1]:\n            print(-1)\n            break\n    else:\n        print(sum(nodes))"}
{"problem_id":"p03013","slow_code_col":"import math\n\ndef cmb(n, r, mod, g1, g2):\n\n    if ( r<0 or r>n ):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\ndef main():\n\n    N, M = list(map(int, input().split()))\n\n    A = [-1] + [int(eval(input())) for i in range(M)] + [N + 1]\n\n\n\n    mod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\n\n    N = 10**5\n\n    g1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\n\n    g2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\n    inverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n    for i in range( 2, N + 1 ):\n\n        g1.append( ( g1[-1] * i ) % mod )\n\n        inverse.append( ( -inverse[mod % i] * (mod\/\/i) ) % mod )\n\n        g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\n\n    d = [0] * (len(A) - 1)\n\n    for i in range(len(A) - 1):\n\n        if A[i+1] - A[i] == 1:\n\n            print((0))\n\n            exit(0)\n\n        d[i] = A[i+1] - 1 - (A[i] + 1)\n\n\n\n    ans = 1\n\n    for dd in d:\n\n        if dd > 1:\n\n            tmp = 0\n\n            for j in range(dd\/\/2 + 1):\n\n                tmp += cmb(dd - j, j, mod, g1, g2)\n\n            ans *= tmp\n\n\n\n    print((ans % 1000000007))\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def main():\n\n    N, M = list(map(int, input().split()))\n\n    A = [int(eval(input())) for i in range(M)] + [0]\n\n\n\n    a = 0\n\n    b = 1\n\n    j = 0\n\n    tmp = 0\n\n    if N == 1:\n\n        print((1))\n\n    else:\n\n        for i in range(1, N + 1):\n\n            if A[j] == i:\n\n                if tmp == 1:\n\n                    print((0))\n\n                    exit()\n\n                tmp = 1\n\n                j += 1\n\n                a = 0\n\n            else:\n\n                if tmp == 1:\n\n                    b = a + b\n\n                    a = 0\n\n                else:\n\n                    c = a + b\n\n                    a = b\n\n                    b = c\n\n                tmp = 0\n\n        print((b % 1000000007))\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"The code is already quite optimized, but there are still some minor improvements that can be made to further reduce its runtime.\n\nOne way to optimize the code is to precompute all possible combinations and store them in a table. This will allow us to avoid computing the same combination multiple times, which can significantly improve the runtime of the program.\nAnother optimization is to use a more efficient algorithm for computing modular inverses. One such algorithm is the Extended Euclidean Algorithm, which can compute the modular inverse in O(log(mod)) time.\nFinally, we can also optimize the loop that computes the answer by using a more efficient data structure, such as a prefix sum array, to quickly compute the sum of a subarray.\nOverall, these optimizations should help to significantly reduce the runtime of the program."}
{"problem_id":"p02691","slow_code_col":"N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\ndp = [0] * 10 ** 7\n\nans = 0\n\nfor i in range(N):\n\n    x = i + 1 - A[i]\n\n    if x >= 0:\n\n        ans += dp[x]\n\n    y = i + 1 + A[i]\n\n    if y < 10 ** 7:\n\n        dp[y] += 1\n\n\n\nprint(ans)\n","reference_code_col":"N = int(eval(input()))\n\nA = [int(i) for i in input().split()]\n\nINF = 2 * 10 ** 5\n\ndp = [0] * INF\n\nans = 0\n\nfor i in range(N):\n\n    i_i_ = i + 1 - A[i]\n\n    if 0 < i_i_ < INF:\n\n        ans += dp[i_i_]\n\n    i_ = i + 1 + A[i]\n\n    if 0 < i_ < INF:\n\n        dp[i_] += 1\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"N = int(input())\n\nA = list(map(int, input().split()))\n\n# Initialize the dp array with a smaller size\ndp = [0] * (max(A) * 2 + 1)\n\nans = 0\n\nfor i in range(N):\n    x = i + 1 - A[i]\n    if x >= 0:\n        ans += dp[x]\n    \n    y = i + 1 + A[i]\n    if y < len(dp):\n        dp[y] += 1\n\nprint(ans)"}
{"problem_id":"p03544","slow_code_col":"a,b=2,1\n\nfor i in[0]*int(eval(input())):a,b=b,a+b\n\nprint(a)","reference_code_col":"a,b=2,1\n\nfor i in[0]*eval(input()):a,b=b,a+b\n\nprint(a)","model_generated_potentially_faster_code_col":"def fibonacci(n):\n    a, b = 2, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\nn = int(input(\"Enter a number: \"))\nresult = fibonacci(n)\nprint(result)"}
{"problem_id":"p02555","slow_code_col":"S = int(eval(input()))\n\nmod = 10**9+7\n\n\n\ndp = [0]*(S+1)\n\ndp[0] = 1\n\nfor i in range(1,S+1):\n\n    for j in range(0,(i-3)+1):\n\n        dp[i] += dp[j]\n\n        dp[i] %= mod\n\nprint((dp[S]))","reference_code_col":"S = int(eval(input()))\n\nmod = 10**9+7\n\n\n\ndp = [0]*(S+1)\n\ndp[0] = 1\n\nfor i in range(1,S+1):\n\n    for j in range(0,(i-3)+1):\n\n        dp[i] += dp[j]\n\n    dp[i] %= mod\n\nprint((dp[S]))","model_generated_potentially_faster_code_col":"S = int(eval(input()))\nmod = 10**9 + 7\n\n# Initialize dp array with zeros\ndp = [0] * (S + 1)\ndp[0] = 1\n\n# Calculate the number of ways to reach each position using dynamic programming\nfor i in range(1, S + 1):\n    if i >= 1:\n        dp[i] += dp[i - 1]\n    if i >= 2:\n        dp[i] += dp[i - 2]\n    if i >= 3:\n        dp[i] += dp[i - 3]\n    \n    # Take modulo to avoid overflow and keep the result within the required range\n    dp[i] %= mod\n\n# Print the final result\nprint(dp[S])"}
{"problem_id":"p00106","slow_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nhttp:\/\/judge.u-aizu.ac.jp\/onlinejudge\/description.jsp?id=0106&lang=jp\n\n\"\"\"\n\nimport sys\n\n\n\n\n\ndef solve(amount):\n\n    \"\"\"\n\n    :param amount: ?????\\???????????\u00b0?????????\n\n    :return: ?????????\n\n    \"\"\"\n\n    best_price = (amount + 199) \/\/ 200 * 380\n\n    for a in range(amount \/\/ 200 + 1):\n\n        for b in range(amount \/\/ 300 + 1):\n\n            for c in range(amount \/\/ 500 + 1):\n\n                for a1 in range(amount \/\/ 1000 + 1):\n\n                    for b1 in range(amount \/\/ 1200 + 1):\n\n                        for c1 in range(amount \/\/ 1500 + 1):\n\n                            if a*200 + b*300 + c*500 + a1*1000 + b1*1200 + c1*1500 == amount:\n\n                                price = a*380 + b*550 + c*850 + a1*1520 + b1*1870 + c1*2244\n\n                                if price < best_price:\n\n                                    best_price = price\n\n    return best_price\n\n\n\n\n\n\n\n\n\ndef main(args):\n\n    while True:\n\n        amount = int(eval(input()))\n\n        if amount == 0:\n\n            break\n\n        result = solve(amount)\n\n        print(result)\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])","reference_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nhttp:\/\/judge.u-aizu.ac.jp\/onlinejudge\/description.jsp?id=0106&lang=jp\n\n\"\"\"\n\nimport sys\n\n\n\n\n\ndef solve(amount):\n\n    \"\"\"\n\n    :param amount: ?????\\???????????\u00b0?????????\n\n    :return: ?????????\n\n    \"\"\"\n\n    best_price = (amount + 199) \/\/ 200 * 380\n\n    for a in range(amount \/\/ 200 + 1):\n\n        for b in range(amount \/\/ 300 + 1):\n\n            for c in range(amount \/\/ 500 + 1):\n\n                for a1 in range(amount \/\/ 1000 + 1):\n\n                    for b1 in range(amount \/\/ 1200 + 1):\n\n                        for c1 in range(amount \/\/ 1500 + 1):\n\n                            if a*200 + b*300 + c*500 + a1*1000 + b1*1200 + c1*1500 == amount:\n\n                                price = a*380 + b*550 + c*850 + a1*1520 + b1*1870 + c1*2244\n\n                                if price < best_price:\n\n                                    best_price = price\n\n    return best_price\n\n\n\n\n\ndef solve2(amount):\n\n    \"\"\"\n\n    ???????\u00a8???????????????\u00a8?????????????????\u00a7???\n\n    \"\"\"\n\n    packages = [(0, 0), (2, 380), (3, 550), (5, 850), (10, 1520), (12, 1870), (15, 2244)] # 1?\u00a2??????????(100g??????)??\u00a8??????????????\u00a2l\n\n    # dp??\u00a8???2?\u00ac??????????????\u00a8?????????????(100g??????)?????????????????\u00a8??\u00a7??????packages????\u00a8????\n\n    # 999999...??????INF??\u00a8?????? (phthon 3.5??\\??????????????????math.inf????????\u00a8??\u00a7??????)\n\n    cart = [[99999999] * (amount\/\/100 + 1) for _ in range(len(packages))]\n\n    for i in range(len(packages)):\n\n        cart[i][0] = 0          #  0g???????????\\????????\u00b4??????0???????????????\n\n\n\n    for i in range(1, len(packages)):\n\n        for j in range(1, len(cart[0])):\n\n            w = packages[i][0]  #  ??????\n\n            p = packages[i][1]  #  ??????\n\n            if j < w:\n\n                cart[i][j] = cart[i-1][j]\n\n            else:\n\n                # ???????????????????????????????????????????????????????????????????????????????\u00a8????\n\n                cart[i][j] = min(cart[i-1][j], cart[i-1][max(0, j-w)]+p, cart[i][max(0, j-w)]+p)\n\n    return cart[-1][-1]\n\n\n\n\n\ndef main(args):\n\n    while True:\n\n        amount = int(eval(input()))\n\n        if amount == 0:\n\n            break\n\n        #result = solve(amount)\n\n        #print(result)\n\n        result = solve2(amount)\n\n        print(result)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main(sys.argv[1:])","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\nhttp:\/\/judge.u-aizu.ac.jp\/onlinejudge\/description.jsp?id=0106&lang=jp\n\"\"\"\n\nimport sys\n\n\ndef solve(amount):\n    \"\"\"\n    :param amount: ?????\\???????????\u00b0?????????\n    :return: ?????????\n    \"\"\"\n    best_price = float('inf')\n\n    for a in range(amount \/\/ 200 + 1):\n        for b in range(amount \/\/ 300 + 1):\n            for c in range(amount \/\/ 500 + 1):\n                remaining_amount = amount - (a * 200 + b * 300 + c * 500)\n                if remaining_amount >= 0:\n                    for a1 in range(remaining_amount \/\/ 1000 + 1):\n                        for b1 in range(remaining_amount \/\/ 1200 + 1):\n                            for c1 in range(remaining_amount \/\/ 1500 + 1):\n                                total_amount = a * 200 + b * 300 + c * 500 + a1 * 1000 + b1 * 1200 + c1 * 1500\n                                if total_amount == amount:\n                                    price = a * 380 + b * 550 + c * 850 + a1 * 1520 + b1 * 1870 + c1 * 2244\n                                    if price < best_price:\n                                        best_price = price\n\n    return best_price if best_price != float('inf') else amount * 380\n\n\ndef main(args):\n    while True:\n        amount = int(eval(input()))\n        if amount == 0:\n            break\n        result = solve(amount)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"}
{"problem_id":"p02657","slow_code_col":"def iput(): return int(eval(input()))\n\ndef mput(): return list(map(int, input().split()))\n\ndef lput(): return list(map(int, input().split()))\n\n\n\ndef solve():\n\n    a, b = mput()\n\n    print((a*b))\n\n    return 0\n\n\n\nif __name__ == \"__main__\":\n\n    solve()","reference_code_col":"import math\n\ndef solve():\n\n    a, b = input().split()\n\n    a = int(a)\n\n    b = float(b)\n\n    print((int(a*b)))\n\n    return 0\n\n \n\nif __name__ == \"__main__\":\n\n    solve()","model_generated_potentially_faster_code_col":"def solve():\n    a, b = map(int, input().split())\n    print(a * b)\n    return 0\n\nif __name__ == \"__main__\":\n    solve()"}
{"problem_id":"p03759","slow_code_col":"a, b, c = list(map(int, input().split()))\n\nif (b - a) == (c - b):\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")","reference_code_col":"a, b, c = list(map(int, input().split()))\n\nif b - a == c - b:\n\n    print(\"YES\")\n\nelse:\n\n    print(\"NO\")","model_generated_potentially_faster_code_col":"# Read input values and convert them to integers\nvalues = list(map(int, input().split()))\na, b, c = values\n\n# Check if the difference between consecutive elements is the same\nif (b - a) == (c - b):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"problem_id":"p03796","slow_code_col":"import math\n\nprint((math.factorial(int(eval(input())))%1000000007))","reference_code_col":"num = int(eval(input()))\n\nresult = 1\n\nfor i in range(1,num+1):\n\n    result = result *i % 1000000007\n\nprint(result)","model_generated_potentially_faster_code_col":"def factorial(n):\n    result = 1\n    for i in range(2,n+1):\n        result = (result * i) % 1000000007\n    return result\n\nn = int(input())\nprint(factorial(n))"}
{"problem_id":"p03416","slow_code_col":"a,b = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(a,b+1):\n\n    j = str(i)\n\n    if j==''.join(reversed(j)):\n\n        count += 1\n\nprint(count)","reference_code_col":"a,b = list(map(int, input().split()))\n\nn = [i for i in map(str, list(range(a,b+1))) if i==i[::-1]]\n\nprint((len(n)))","model_generated_potentially_faster_code_col":"a, b = map(int, input().split())\n\ncount = sum(1 for i in range(a, b + 1) if str(i) == str(i)[::-1])\n\nprint(count)"}
{"problem_id":"p03363","slow_code_col":"from collections import Counter\n\nimport numpy as np\n\n\n\nN = int(eval(input()))\n\nA = np.array(input().split(), dtype=np.int64)\n\n\n\nc = Counter(A.cumsum())\n\nc[0] += 1 # np.cumsum(), 0start \u3067\u306f\u7121\u3044\u70ba 0\u3092\u52a0\u3048\u308b\n\nans = sum(v*(v-1)\/\/2 for v in list(c.values()))\n\nprint(ans)","reference_code_col":"\n\nfrom itertools import accumulate\n\nfrom collections import defaultdict\n\ndef resolve():\n\n    N = int(eval(input()))\n\n    A = list(map(int, input().split()))\n\n\n\n    Acum = [0] + list(accumulate(A))\n\n    dic = defaultdict(int)\n\n    ans = 0\n\n    for i in range(N + 1):\n\n        ans += dic[Acum[i]]\n\n        dic[Acum[i]] += 1\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    resolve()","model_generated_potentially_faster_code_col":"from collections import Counter\nimport numpy as np\n\nN = int(eval(input()))\nA = np.array(input().split(), dtype=np.int64)\n\n# Transform the array to +1 for positive numbers and -1 for non-positive numbers\ntransformed_A = np.where(A > 0, 1, -1)\n\n# Compute the cumulative sum\ncumulative_sum = transformed_A.cumsum()\n\n# Count the occurrences of each cumulative sum\ncumulative_sum_count = Counter(cumulative_sum)\n\n# The result is half the sum of (count * (count - 1)) for each count in the counter\nans = sum(count * (count - 1) \/\/ 2 for count in cumulative_sum_count.values()) \/\/ 2\n\nprint(ans)"}
{"problem_id":"p03796","slow_code_col":"#!\/usr\/bin\/env pypy3\n\n\n\nimport math\n\nprint((math.factorial(int(eval(input()))) % 1000000007))","reference_code_col":"n = int(eval(input()))\n\nfor i in range(n - 1, 1, -1):\n\n\tn *= i\n\n\tn %= 10**9 + 7\n\nprint(n)","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env pypy3\n\nMOD = int(1e9 + 7)\n\ndef factorial(n):\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % MOD\n    return result\n\nn = int(input())\nprint(factorial(n))"}
{"problem_id":"p03170","slow_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat Apr 25 18:20:35 2020\n\n\"\"\"\n\n\n\nimport sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 9)\n\n#def input():\n\n#    return sys.stdin.readline()[:-1]\n\nmod = 10**9+7\n\n\n\n#N = int(input())\n\nN, K = list(map(int,input().split()))\n\nA = np.array(list(map(int,input().split())))\n\n\n\ndp = [True for i in range(K + A[-1] + 1)]\n\nfor i in range(K):\n\n    if dp[i]:\n\n        for a in A:\n\n            dp[i + a] = False\n\n\n\n#    print(i, dp[i],A+i,dp[A+i])\n\n#print(dp)\n\n\n\nif dp[K]:\n\n    ans = 'Second'\n\nelse:\n\n    ans = 'First'\n\nprint(ans)","reference_code_col":"# -*- coding: utf-8 -*-\n\n\"\"\"\n\nCreated on Sat Apr 25 18:20:35 2020\n\n\"\"\"\n\n\n\nimport sys\n\nimport numpy as np\n\n\n\nsys.setrecursionlimit(10 ** 9)\n\n#def input():\n\n#    return sys.stdin.readline()[:-1]\n\nmod = 10**9+7\n\n\n\n#N = int(input())\n\n#N, K = map(int,input().split())\n\n#A = np.array(list(map(int,input().split())))\n\nN, K, *A = list(map(int, open(0).read().split()))\n\n\n\ndp = [True for i in range(K + A[-1] + 1)]\n\nfor i in range(K):\n\n    if dp[i]:\n\n        for a in A:\n\n            dp[i + a] = False\n\n\n\n#    print(i, dp[i],A+i,dp[A+i])\n\n#print(dp)\n\n\n\nif dp[K]:\n\n    ans = 'Second'\n\nelse:\n\n    ans = 'First'\n\nprint(ans)","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nimport sys\n\nsys.setrecursionlimit(10 ** 9)\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Calculate the total number of stones\ntotal_stones = sum(A)\n\n# Determine the winner based on the parity of the total number of stones\nif total_stones % 2 == 0:\n    ans = 'Second'\nelse:\n    ans = 'First'\n\nprint(ans)"}
{"problem_id":"p03721","slow_code_col":"(N, K), *AB = [list(map(int, s.split())) for s in open(0)]\n\nfor a, b in sorted(AB):\n\n    K -= b\n\n    if K <= 0:\n\n        print(a)\n\n        break\n","reference_code_col":"N, K, *AB = list(map(int, open(0).read().split()))\n\nli = [(a, b) for a, b in zip(*[iter(AB)] * 2)]\n\nli.sort()\n\nfor a, b in li:\n\n    if K > b:\n\n        K -= b\n\n    else:\n\n        print(a)\n\n        break\n","model_generated_potentially_faster_code_col":"import heapq\n\n# Read input\nN, K = map(int, input().split())\nAB = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Create a min-heap from the AB list\nheapq.heapify(AB)\n\nwhile AB and K > 0:\n    _, b = heapq.heappop(AB)\n    K -= b\n\nif K <= 0:\n    print(AB[0][0])\nelse:\n    print(-1)"}
{"problem_id":"p03796","slow_code_col":"mod = int(1e9+7)\n\nn = int(eval(input()))\n\n\n\npower = 1\n\nfor i in range(1, n+1):\n\n    power = power * i % mod\n\nprint(power)","reference_code_col":"import sys\n\n\n\nMOD = 10 ** 9 + 7\n\nn = int(sys.stdin.readline().rstrip())\n\n\n\ndef main():\n\n    res = 1\n\n    for i in range(1, n+1):\n\n        res *= i\n\n        res %= MOD\n\n\n\n    return res\n\n\n\nif __name__ == '__main__':\n\n    ans = main()\n\n    print(ans)","model_generated_potentially_faster_code_col":"mod = int(1e9 + 7)\nn = int(eval(input()))\n\npower = 1\n\nfor i in range(1, n+1):\n    power = (power * i) % mod\n\nprint(power)"}
{"problem_id":"p03307","slow_code_col":"import numpy as np\n\nN=int(eval(input()))\n\ndef gcd(a,b):\n\n    c=int(np.floor(a\/b))\n\n    return a-b*c\n\nif gcd(N,2)==0:\n\n    print(N)\n\nelse:\n\n    print((2*N))","reference_code_col":"N=int(eval(input()))\n\nif N%2==0:\n\n    print(N)\n\nelse:\n\n    print((2*N))","model_generated_potentially_faster_code_col":"import math\n\nN = int(input())\n\ndef gcd(a, b):\n    while(b != 0):\n        a, b = b, a % b\n    return a\n\nif gcd(N, 2) == 0:\n    print(N)\nelse:\n    print(2 * N)"}
{"problem_id":"p03164","slow_code_col":"N, W = list(map(int, input().split()))\n\nL = [list(map(int, input().split())) for i in range(N)]\n\nV = 0\n\nfor i in range(N):\n\n  V += L[i][1]\n\n\n\ndp = [[10**9+1] * (V + 1) for i in range(N+1)]\n\ndp[0][0] = 0\n\nfor i in range(N):\n\n    for j in range(V+1):\n\n        if j - L[i][1] >= 0:\n\n          dp[i+1][j] = min(dp[i][j], dp[i][j-L[i][1]] + L[i][0])\n\n        else:\n\n          dp[i+1][j] = dp[i][j]\n\nans = 0\n\nfor j in range(V+1):\n\n    if  W >= dp[-1][j]:\n\n        ans = max(ans, j)\n\nprint(ans)","reference_code_col":"N, W = list(map(int, input().split()))\n\nL = [list(map(int, input().split())) for i in range(N)]\n\nV = 0\n\nfor i in range(N):\n\n  V += L[i][1]\n\n\n\ndp = [10**9+1] * (V + 1)\n\ndp[0] = 0\n\nfor i in range(N):\n\n    for j in range(V, -1, -1):\n\n        dp[j] = min(dp[j], dp[j-L[i][1]] + L[i][0])\n\nans = 0\n\nfor j in range(V+1):\n\n    if  W >= dp[j]:\n\n        ans = max(ans, j)\n\nprint(ans)","model_generated_potentially_faster_code_col":"N, W = map(int, input().split())\n\nL = [tuple(map(int, input().split())) for _ in range(N)]\n\nV = sum(item[1] for item in L)\n\n# Initialize dp array with a large value\ndp = [float('inf')] * (V + 1)\ndp[0] = 0\n\n# Fill the dp array\nfor weight, cost in L:\n    for j in range(weight, V + 1):\n        dp[j] = min(dp[j], dp[j - weight] + cost)\n\n# Find the maximum value within the weight limit\nmax_value = 0\nfor j in range(W + 1):\n    if dp[j] <= W:\n        max_value = max(max_value, j)\n\nprint(max_value)"}
{"problem_id":"p02412","slow_code_col":"while 1:\n\n n,x=list(map(int,input().split()))\n\n if n+x==0:break\n\n print((len([1 for i in range(3,n+1)for j in range(2,x-i)if x-i-j<j<i])))","reference_code_col":"while 1:\n\n n,x=list(map(int,input().split()))\n\n if n+x==0:break\n\n print((len([1 for i in range(1,n-1)for j in range(i+1,n)if j<x-i-j<=n])))","model_generated_potentially_faster_code_col":"while True:\n    n, x = map(int, input().split())\n    \n    if n + x == 0:\n        break\n    \n    # Calculate the number of valid triples using combinatorics\n    result = 0\n    for i in range(3, n + 1):\n        remaining_sum = x - i\n        if remaining_sum <= 0 or remaining_sum % 2 != 0:\n            continue\n        \n        j_min = max(i, remaining_sum \/\/ 2)\n        j_max = remaining_sum - j_min\n        \n        result += j_max - j_min + 1\n    \n    print(result)"}
{"problem_id":"p03608","slow_code_col":"def main():\n\n    from sys import stdin\n\n    input = stdin.readline\n\n\n\n    n, m, r = list(map(int, input().split()))\n\n    l = list(map(int, input().split()))\n\n    for i in range(r):\n\n        l[i] -= 1\n\n    d = [[10**8] * n for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        d[i-1][j-1] = k\n\n        d[j-1][i-1] = k\n\n\n\n    # Warshall-Floyd algorithm\n\n    for k in range(n):\n\n        for i in range(n):\n\n            for j in range(n):\n\n                if d[i][j] > d[i][k] + d[k][j]:\n\n                    d[i][j] = d[i][k] + d[k][j]\n\n\n\n    # full search\n\n    # 8! = 40320\n\n    from itertools import permutations\n\n\n\n    answer = 10**8\n\n    for i in permutations(l):\n\n        ans = 0\n\n        for j in range(r-1):\n\n            ans += d[i[j]][i[j+1]]\n\n        if ans < answer:\n\n            answer = ans\n\n\n\n    print(answer)\n\n\n\nmain()\n","reference_code_col":"def main():\n\n    from sys import stdin\n\n    input = stdin.readline\n\n\n\n    n, m, r = list(map(int, input().split()))\n\n    l = list(map(int, input().split()))\n\n    for i in range(r):\n\n        l[i] -= 1\n\n    d = [[10**8] * n for _ in range(n)]\n\n    for _ in range(m):\n\n        i, j, k = list(map(int, input().split()))\n\n        d[i-1][j-1] = k\n\n        d[j-1][i-1] = k\n\n\n\n    # Warshall-Floyd algorithm\n\n    for k in range(n):\n\n        for i in range(n-1):\n\n            for j in range(i+1, n):\n\n                if d[i][j] > d[i][k] + d[k][j]:\n\n                    d[i][j] = d[i][k] + d[k][j]\n\n                    d[j][i] = d[i][j]\n\n\n\n    # full search\n\n    # 8! = 40320\n\n    from itertools import permutations\n\n\n\n    answer = 10**8\n\n    for i in permutations(l):\n\n        ans = 0\n\n        for j in range(r-1):\n\n            ans += d[i[j]][i[j+1]]\n\n        if ans < answer:\n\n            answer = ans\n\n\n\n    print(answer)\n\n\n\nmain()\n","model_generated_potentially_faster_code_col":"def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    r = int(data[index + 2])\n    index += 3\n    \n    l = list(map(int, data[index:index + r]))\n    index += r\n    \n    d = [[float('inf')] * n for _ in range(n)]\n    for _ in range(m):\n        i = int(data[index]) - 1\n        j = int(data[index + 1]) - 1\n        k = int(data[index + 2])\n        d[i][j] = k\n        d[j][i] = k\n        index += 3\n    \n    for i in range(n):\n        d[i][i] = 0\n\n    # Warshall-Floyd algorithm\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n\n    # Dynamic Programming solution for shortest path visiting all nodes\n    dp = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(r + 1)]\n    for i in range(n):\n        dp[0][i][1 << i] = 0\n\n    for t in range(1, r + 1):\n        for i in range(n):\n            for mask in range(1 << n):\n                if mask & (1 << i):\n                    for j in range(n):\n                        if j != i and mask & (1 << j):\n                            dp[t][j][mask ^ (1 << j)] = min(dp[t][j][mask ^ (1 << j)], dp[t - 1][i][mask] + d[i][j])\n\n    answer = float('inf')\n    for i in range(n):\n        answer = min(answer, dp[r][i][(1 << n) - 1] + d[i][l[-1]])\n\n    print(answer)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03325","slow_code_col":"N=int(eval(input()))\n\na=list(map(int,input().split()))\n\nfor i in range(N):\n\n  for j in range(1,31):\n\n    if a[i]%(2**j)!=0:\n\n      a[i]=j-1\n\n      break\n\nprint((sum(a)))","reference_code_col":"import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\ndef f(n):\n\n  res = 0\n\n  while n % 2 == 0:\n\n    n \/\/= 2\n\n    res += 1\n\n  return res\n\n\n\nanswer = 0\n\nfor a in A:\n\n  answer += f(a)\n\n\n\nprint(answer)","model_generated_potentially_faster_code_col":"N = int(input())\na = list(map(int, input().split()))\n\n# Function to find the highest power of 2 dividing n\ndef highest_power_of_2(n):\n    count = 0\n    while n % 2 == 0:\n        n \/\/= 2\n        count += 1\n    return count\n\n# Calculate the sum of the highest powers of 2 dividing each number\nresult = sum(highest_power_of_2(x) for x in a)\n\nprint(result)"}
{"problem_id":"p03416","slow_code_col":"a, b = list(map(int, input().split()))\n\ncnt = 0\n\n\n\nfor i in range(a, b+1):\n\n    i = str(i)\n\n    if i[0] == i[-1] and i[1] == i[-2]:\n\n        cnt += 1\n\n\n\nprint(cnt)\n","reference_code_col":"a, b = list(map(int, input().split()))\n\ncnt = 0\n\n\n\nfor i in range(10):\n\n    for j in range(10):\n\n        for k in range(10):\n\n            c = 10000*i+1000*j+100*k+10*j+i\n\n            if a <= c <= b:\n\n                cnt += 1\n\n\n\nprint(cnt)\n","model_generated_potentially_faster_code_col":"a, b = map(int, input().split())\n\ncnt = 0\n\n# Convert the integer to string only once\nfor num in range(a, b + 1):\n    s = str(num)\n    \n    # Check if the first and last character are equal and the second and second-last character are equal\n    if s[0] == s[-1] and s[1] == s[-2]:\n        cnt += 1\n\nprint(cnt)"}
{"problem_id":"p03835","slow_code_col":"k, s = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(k + 1):\n\n    for j in range(k + 1):\n\n        if i + j > s:\n\n            break\n\n        elif s - i - j <= k:\n\n            cnt += 1\n\nprint(cnt)\n","reference_code_col":"k, s = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(k + 1):\n\n    for j in range(k + 1):\n\n        if 0 <= s - i - j <= k:\n\n            cnt += 1\n\nprint(cnt)\n","model_generated_potentially_faster_code_col":"k, s = map(int, input().split())\n\n# Initialize count to 0\ncnt = 0\n\n# Iterate over possible values of i\nfor i in range(k + 1):\n    \n    # Calculate the minimum value of j based on the condition i + j > s\n    min_j = max(0, s - i)\n    \n    # Iterate over possible values of j starting from min_j\n    for j in range(min_j, k + 1):\n        \n        # Check the second condition\n        if s - i - j <= k:\n            \n            # Increment the count\n            cnt += 1\n\nprint(cnt)"}
{"problem_id":"p02537","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\n\n\n# N: \u51e6\u7406\u3059\u308b\u533a\u9593\u306e\u9577\u3055\n\n\n\nINF = 0\n\n\n\nmx = 300001\n\nLV = (mx-1).bit_length()\n\nN0 = 2**LV\n\ndata = [INF]*(2*N0)\n\nlazy = [None]*(2*N0)\n\n\n\n# \u4f1d\u642c\u5bfe\u8c61\u306e\u533a\u9593\u3092\u6c42\u3081\u308b\n\ndef gindex(l, r):\n\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n\n    lc = 0 if l & 1 else (L & -L).bit_length()\n\n    rc = 0 if r & 1 else (R & -R).bit_length()\n\n    for i in range(LV):\n\n        if rc <= i:\n\n            yield R\n\n        if L < R and lc <= i:\n\n            yield L\n\n        L >>= 1; R >>= 1\n\n\n\n# \u9045\u5ef6\u4f1d\u642c\u51e6\u7406\n\ndef propagates(*ids):\n\n    for i in reversed(ids):\n\n        v = lazy[i-1]\n\n        if v is None:\n\n            continue\n\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n\n        lazy[i-1] = None\n\n\n\n# \u533a\u9593[l, r)\u3092x\u3067\u66f4\u65b0\n\ndef update(l, r, x):\n\n    *ids, = gindex(l, r)\n\n    propagates(*ids)\n\n\n\n    L = N0 + l; R = N0 + r\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            lazy[R-1] = data[R-1] = x\n\n        if L & 1:\n\n            lazy[L-1] = data[L-1] = x\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    for i in ids:\n\n        data[i-1] = max(data[2*i-1], data[2*i])\n\n\n\n# \u533a\u9593[l, r)\u5185\u306e\u6700\u5c0f\u5024\u3092\u6c42\u3081\u308b\n\ndef query(l, r):\n\n    propagates(*gindex(l, r))\n\n    L = N0 + l; R = N0 + r\n\n\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = max(s, data[R-1])\n\n        if L & 1:\n\n            s = max(s, data[L-1])\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    return s\n\n\n\nupdate(As[0],As[0]+1,1)\n\nfor i, a in enumerate(As[1:]):\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n    upd = query(l,r+1)\n\n    if upd == -1:continue\n\n    # print(\"i\",i,\"a\",a,\"upd\",upd,\"l\",l,\"r\",r)\n\n    update(a, a+1, upd+1)\n\n\n\nans = 0\n\nfor a in set(As):\n\n    ans = max(ans,query(a,a+1))\n\nprint(ans)","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\n\n\n# N: \u51e6\u7406\u3059\u308b\u533a\u9593\u306e\u9577\u3055\n\n\n\nINF = 0\n\n\n\nmx = 300001\n\nLV = (mx-1).bit_length()\n\nN0 = 2**LV\n\ndata = [INF]*(2*N0)\n\nlazy = [None]*(2*N0)\n\n\n\n# \u4f1d\u642c\u5bfe\u8c61\u306e\u533a\u9593\u3092\u6c42\u3081\u308b\n\ndef gindex(l, r):\n\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n\n    lc = 0 if l & 1 else (L & -L).bit_length()\n\n    rc = 0 if r & 1 else (R & -R).bit_length()\n\n    for i in range(LV):\n\n        if rc <= i:\n\n            yield R\n\n        if L < R and lc <= i:\n\n            yield L\n\n        L >>= 1; R >>= 1\n\n\n\n# \u9045\u5ef6\u4f1d\u642c\u51e6\u7406\n\ndef propagates(*ids):\n\n    for i in reversed(ids):\n\n        v = lazy[i-1]\n\n        if v is None:\n\n            continue\n\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n\n        lazy[i-1] = None\n\n\n\n# \u533a\u9593[l, r)\u3092x\u3067\u66f4\u65b0\n\ndef update(l, r, x):\n\n    *ids, = gindex(l, r)\n\n    propagates(*ids)\n\n\n\n    L = N0 + l; R = N0 + r\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            lazy[R-1] = data[R-1] = x\n\n        if L & 1:\n\n            lazy[L-1] = data[L-1] = x\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    for i in ids:\n\n        data[i-1] = max(data[2*i-1], data[2*i])\n\n\n\n# \u533a\u9593[l, r)\u5185\u306e\u6700\u5c0f\u5024\u3092\u6c42\u3081\u308b\n\ndef query(l, r):\n\n    propagates(*gindex(l, r))\n\n    L = N0 + l; R = N0 + r\n\n\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = max(s, data[R-1])\n\n        if L & 1:\n\n            s = max(s, data[L-1])\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    return s\n\n\n\nans = 0\n\nupdate(As[0],As[0]+1,1)\n\nfor i, a in enumerate(As[1:]):\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n    upd = query(l,r+1)\n\n    if upd == -1:continue\n\n    # print(\"i\",i,\"a\",a,\"upd\",upd,\"l\",l,\"r\",r)\n\n    update(a, a+1, upd+1)\n\n    ans = max(ans, upd+1)\n\nprint(ans)\n\n\n","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\nn, k = map(int, input().split())\n\nAs = [int(input()) for _ in range(n)]\n\n# Initialize segment tree\nINF = float('-inf')\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\n\n# Index transformation functions\ndef index(i):\n    return N0 + i\n\ndef parent(i):\n    return i \/\/ 2\n\ndef left_child(i):\n    return 2 * i\n\ndef right_child(i):\n    return 2 * i + 1\n\n# Lazy propagation function\ndef propagate(i):\n    if lazy[i] is None:\n        return\n    data[i] = lazy[i]\n    if i < N0:\n        lazy[left_child(i)] = lazy[right_child(i)] = lazy[i]\n    lazy[i] = None\n\n# Update function\ndef update(l, r, val):\n    l = index(l)\n    r = index(r)\n    propagate(parent(l))\n    propagate(parent(r))\n    while l < r:\n        if l & 1:\n            data[l] = max(data[l], val)\n            l += 1\n        if r & 1:\n            r -= 1\n            data[r] = max(data[r], val)\n        l \/\/= 2\n        r \/\/= 2\n\n# Query function\ndef query(l, r):\n    l = index(l)\n    r = index(r)\n    propagate(parent(l))\n    propagate(parent(r))\n    res = INF\n    while l < r:\n        if l & 1:\n            res = max(res, data[l])\n            l += 1\n        if r & 1:\n            r -= 1\n            res = max(res, data[r])\n        l \/\/= 2\n        r \/\/= 2\n    return res\n\n# Initial update\nupdate(As[0], As[0] + 1, 1)\n\n# Process each subsequent element\nfor i, a in enumerate(As[1:], start=1):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r)\n    if upd != INF:\n        update(a, a + 1, upd + 1)\n\n# Find the maximum value in the final segment tree\nans = query(0, mx)\nprint(ans)"}
{"problem_id":"p02725","slow_code_col":"import numpy as np\n\n\n\nK, N = [int(i) for i in input().rstrip().split(' ')]\n\nA = [int(i) for i in input().rstrip().split(' ')]\n\n\n\nx = A[0]\n\ny = K - A[-1]\n\nn = [int(A[i+1] - A[i]) for i in range(N-1)]\n\nn.append(x+y)\n\n\n\nnp_list = np.array(n)\n\nn.pop(np_list.argmax())\n\nprint((sum(n)))","reference_code_col":"k,n = list(map(int,input().split()))\n\na = list(map(int,input().split()))\n\n\n\ndp = [0 for i in range(n)]\n\ndp[0] = abs(k-a[-1]) + a[0]\n\n\n\nfor i in range(1,n):\n\n    dp[i] = abs(a[i]-a[i-1])\n\n\n\nprint((sum(dp) - max(dp)))","model_generated_potentially_faster_code_col":"import numpy as np\n\nK, N = map(int, input().split())\nA = np.array(list(map(int, input().split())))\n\n# Calculate differences between consecutive elements and add x + y at the end\ndiffs = np.diff(A)\ndiffs = np.insert(diffs, 0, A[0])\ndiffs = np.append(diffs, K - A[-1])\n\n# Remove the maximum value and calculate the sum\nresult = np.sum(diffs) - np.max(diffs)\n\nprint(result)"}
{"problem_id":"p03371","slow_code_col":"a, b, c, x, y = list(map(int, input().split(' ')))\n\n\n\nc = int(c*2)\n\nm = float('inf')\n\nfor i in range(10**5+1):\n\n    m = min(m, a*max(0, x-i)+b*max(0,y-i)+c*i)\n\nprint(m)","reference_code_col":"import math\n\na, b, c, x, y = list(map(int, input().split(' ')))\n\nans = float('inf')\n\nc = c*2\n\nfor i in range(max(x, y)+1):\n\n    if i > x:\n\n        price = b*(y-i) + c*i\n\n    elif i > y:\n\n        price = a*(x-i) + c*i\n\n    else:\n\n        price = a*(x-i) + b*(y-i) + c*i\n\n\n\n    if ans > price:\n\n        ans = price\n\nprint(ans)","model_generated_potentially_faster_code_col":"a, b, c, x, y = map(int, input().split())\n\n# Calculate the minimum cost using a more efficient approach\nmin_cost = min(a * max(0, x) + b * max(0, y), \n               a * max(0, x - 10**5) + b * max(0, y - 10**5))\n\n# Add the remaining cost for the remaining distance\nremaining_distance = abs(x - y)\nif remaining_distance > 0:\n    min_cost += c * remaining_distance\n\nprint(min_cost)"}
{"problem_id":"p02983","slow_code_col":"l,r=list(map(int,input().split()))\n\ns=list(range(l,r+1))[:2019]\n\nprint((min(i*j%2019for i in s for j in s if i<j)))","reference_code_col":"l,r=list(map(int,input().split()));s=list(range(l,r+1))[:673];print((min(i*j%2019for i in s for j in s if i<j)))","model_generated_potentially_faster_code_col":"l, r = map(int, input().split())\n\nremainders = {}\n\nfor i in range(l, min(r + 1, 2020)):\n    for j in range(i + 1, 2020):\n        product = (i * j) % 2019\n        if product not in remainders:\n            remainders[product] = True\n\nprint(min(remainders.keys()))"}
{"problem_id":"p03796","slow_code_col":"import math\n\nmod = 10 ** 9 + 7\n\nn = int(eval(input()))\n\nprint((math.factorial(n) % mod))","reference_code_col":"mod = 10 ** 9 + 7\n\nn = int(eval(input()))\n\nans = 1\n\nfor i in range(1, n + 1):\n\n    ans *= i\n\n    ans %= mod\n\nprint(ans)","model_generated_potentially_faster_code_col":"mod = 10**9 + 7\n\ndef factorial_mod(n):\n    result = 1\n    for i in range(2, n+1):\n        result = (result * i) % mod\n    return result\n\nn = int(input())\nprint(factorial_mod(n))"}
{"problem_id":"p03416","slow_code_col":"A, B = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(A, B+1):\n\n    if(str(i) == str(i)[::-1]):\n\n        count += 1\n\nprint(count)\n","reference_code_col":"A, B = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(10):\n\n    for j in range(10):\n\n        for k in range(10):\n\n            if(A <= 10000*i + 1000*j + 100*k + 10*j +i <= B):\n\n                count += 1\n\nprint(count)","model_generated_potentially_faster_code_col":"def count_palindromes(A, B):\n    count = 0\n    for num in range(A, B + 1):\n        if num < 10:  # Single digit numbers are always palindromes\n            count += 1\n        elif num % 10 != 0:  # If last digit is 0, it cannot be a palindrome\n            half = num \/\/ 10\n            while half > 0:\n                if num % 10 != half % 10:  # Check if first and last digits match\n                    break\n                half \/\/= 10\n                num \/\/= 10\n            else:\n                count += 1\n    return count\n\nA, B = map(int, input().split())\nprint(count_palindromes(A, B))"}
{"problem_id":"p03013","slow_code_col":"Mod = 10**9+7\n\nN,M = list(map(int, input().split()))\n\na = [int(eval(input())) for _ in range(M)]\n\nb = [1]*(N+1)\n\nfor j in a:\n\n    b[j] = 0\n\nfor i in range(1,N+1):\n\n    if b[i] == 0:\n\n        continue\n\n    if i == 1:\n\n        b[1] = 1\n\n        continue\n\n    b[i] = b[i-1]+b[i-2]\n\n    if b[i] >= Mod:\n\n        b[i] %= Mod\n\nprint((b[N]))","reference_code_col":"# https:\/\/atcoder.jp\/contests\/abc129\/submissions\/5841482 \u3092\u53c2\u8003 \n\nN,M = list(map(int, input().split()))\n\nA = [int(eval(input())) for _ in range(M)]\n\nMOD = 10**9 + 7\n\nF = [1]*(N+1)\n\nfor j in A:\n\n    F[j-1] = 0\n\n \n\na = 1; b = 0\n\nfor i in range(N):\n\n    if not F[i]:    #F[i] == 0\n\n        a, b = 0, a\n\n    else:\n\n        a, b = ((a+b) % MOD), a\n\nprint(a)","model_generated_potentially_faster_code_col":"Mod = 10**9 + 7\n\nN, M = map(int, input().split())\n\n# Precompute Fibonacci sequence up to N\nfib = [0] * (N + 1)\nfib[1] = 1\nfor i in range(2, N + 1):\n    fib[i] = (fib[i - 1] + fib[i - 2]) % Mod\n\n# Initialize the result array\nb = [1] * (N + 1)\n\n# Mark elements that should be zero\na = set(map(int, (eval(input()) for _ in range(M))))\n\n# Calculate the final result using the precomputed Fibonacci sequence\nresult = 1\nfor i in range(1, N + 1):\n    if i not in a:\n        result = (result + fib[i]) % Mod\n\nprint(result)"}
{"problem_id":"p02555","slow_code_col":"n = int(eval(input()))\n\nmx = n\/\/3\n\nans = 0\n\nmod = 10**9+7\n\nimport math\n\ndef combinations_count(n, r): #\u7d44\u307f\u5408\u308f\u305b(nCr)\n\n    return math.factorial(n) \/\/ (math.factorial(n - r) * math.factorial(r))\n\nfor i in range(1,mx+1):\n\n    if i == 1:\n\n        ans += 1\n\n    else:\n\n        ans += combinations_count(n-2*i-1,i-1) % mod\n\nprint((ans%mod))","reference_code_col":"s = int(eval(input()))\n\ndp = [0]*(2001)\n\ndp[3] = 1\n\nmod = 10**9+7\n\nfor i in range(4,s+1):\n\n    dp[i] = (dp[i-1] + dp[i-3]) % mod\n\nprint((dp[s]))","model_generated_potentially_faster_code_col":"from math import comb\n\nn = int(eval(input()))\nmx = n \/\/ 3\nans = 0\nmod = 10 ** 9 + 7\n\n# Precompute factorials\nfact = [1] * (n + 1)\nfor i in range(1, n + 1):\n    fact[i] = fact[i - 1] * i % mod\n\n# Calculate combinations using precomputed factorials\nfor i in range(1, mx + 1):\n    if i == 1:\n        ans += 1\n    else:\n        ans += fact[n - 2 * i - 1] * pow(fact[i - 1], mod - 2, mod) * pow(fact[n - 3 * i], mod - 2, mod) % mod\n\nprint(ans % mod)"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\nn = int(eval(input()))\n\na_list = np.array(list(map(int, input().split())))\n\n\n\ncounter = 0\n\nwhile True:\n\n    if np.sum(a_list % 2) > 0:\n\n        break\n\n    counter += 1\n\n    a_list = a_list \/ 2\n\nprint(counter)\n","reference_code_col":"n = int(eval(input()))\n\na_list = list(map(int, input().split()))\n\n\n\nstatus = True\n\nexecute = 0\n\nwhile status:\n\n    for i in range(n):\n\n        if a_list[i] % 2 == 1:\n\n            status = False\n\n            break\n\n        else:\n\n            a_list[i] = a_list[i] \/ 2\n\n    if status:\n\n        execute += 1\n\nprint(execute)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\nn = int(eval(input()))\na_list = np.array(list(map(int, input().split())))\n\ncounter = 0\n\nwhile np.any(a_list & 1):\n    a_list >>= 1\n    counter += 1\n\nprint(counter)"}
{"problem_id":"p03568","slow_code_col":"import math\n\nimport string\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)\/\/(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\n\n\nn = int(eval(input()))\n\na = readints()\n\n\n\n\n\ndef func(l):\n\n    if len(l) == n:\n\n        for i in range(len(l)):\n\n            if l[i] % 2 == 0:\n\n                return 1\n\n\n\n        return 0\n\n    return func(l+[(a[len(l)])])+func(l+[(a[len(l)]-1)])+func(l+[(a[len(l)]+1)])\n\n\n\n\n\nprint((func([])))\n","reference_code_col":"import math\n\nimport string\n\n\n\n\n\ndef readints():\n\n    return list(map(int, input().split()))\n\n\n\n\n\ndef nCr(n, r):\n\n    return math.factorial(n)\/\/(math.factorial(n-r)*math.factorial(r))\n\n\n\n\n\ndef has_duplicates2(seq):\n\n    seen = []\n\n    for item in seq:\n\n        if not(item in seen):\n\n            seen.append(item)\n\n    return len(seq) != len(seen)\n\n\n\n\n\ndef divisor(n):\n\n    divisor = []\n\n    for i in range(1, n+1):\n\n        if n % i == 0:\n\n            divisor.append(i)\n\n    return divisor\n\n\n\n\n\n# coordinates\n\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\n\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\n\n\nn = int(eval(input()))\n\na = readints()\n\nsum = 1\n\nfor i in range(len(a)):\n\n    if a[i] % 2 == 0:\n\n        sum *= 2\n\n    else:\n\n        sum *= 1\n\nprint((3**len(a)-sum))\n","model_generated_potentially_faster_code_col":"import math\n\n# Precompute factorials up to a reasonable limit\nMAX_N = 100\nfactorials = [math.factorial(i) for i in range(MAX_N + 1)]\n\ndef nCr(n, r):\n    return factorials[n] \/\/ (factorials[n - r] * factorials[r])\n\ndef has_duplicates(seq):\n    return len(seq) != len(set(seq))\n\ndef divisor(n):\n    divisors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n \/\/ i:\n                divisors.append(n \/\/ i)\n    return sorted(divisors)\n\n# Coordinates\ndx = [-1, -1, -1, 0, 0, 1, 1, 1]\ndy = [-1, 0, 1, -1, 1, -1, 0, 1]\n\nn = int(input())\na = list(map(int, input().split()))\n\n@lru_cache(None)\ndef func(l):\n    if len(l) == n:\n        return any(x % 2 == 0 for x in l)\n    return (func(tuple(sorted(l + [a[len(l)]]))) +\n            func(tuple(sorted(l + [a[len(l)] - 1]))) +\n            func(tuple(sorted(l + [a[len(l)] + 1]))))\n\nprint(func(()))"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nN = int(eval(input()))\n\n\n\nnum = math.factorial(N)\n\n\n\nk, r = divmod(num, 10**9 + 7)\n\nprint(r)","reference_code_col":"N = int(eval(input()))\n\n\n\nFACTOR = 10 ** 9 + 7\n\n\n\nnum = 1\n\nfor i in range(1, N+1):\n\n    num *= i\n\n    k, r = divmod(num, FACTOR)\n\n    num = r\n\n\n\nprint(r)","model_generated_potentially_faster_code_col":"N = int(eval(input()))\n\nresult = 1\n\nfor i in range(2, N+1):\n    result = (result * i) % (10**9 + 7)\n\nprint(result)"}
{"problem_id":"p03241","slow_code_col":"def main():\n\n    N, M = (int(i) for i in input().split())\n\n\n\n    def trial_division(n):\n\n        divs = []\n\n        for i in range(1, int(n**0.5)+1):\n\n            if n % i == 0:\n\n                divs.append(i)\n\n                if i != n\/\/i:\n\n                    divs.append(n\/\/i)\n\n        divs.sort(reverse=True)\n\n        return divs\n\n    divs = trial_division(M)\n\n    for d in divs:\n\n        if d*N <= M:\n\n            return print(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"def main():\n\n    def trial_division(n):\n\n        divs = []\n\n        for i in range(1, int(n**0.5)+1):\n\n            if n % i == 0:\n\n                divs.append(i)\n\n                if i != n\/\/i:\n\n                    divs.append(n\/\/i)\n\n        divs.sort(reverse=True)\n\n        return divs\n\n\n\n    N, M = (int(i) for i in input().split())\n\n    divs = trial_division(M)\n\n    for d in divs:\n\n        if N*d <= M:\n\n            return print(d)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"def main():\n    N, M = map(int, input().split())\n\n    def trial_division(n):\n        max_div = 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                if i > max_div:\n                    max_div = i\n                if n \/\/ i > max_div:\n                    max_div = n \/\/ i\n        return max_div\n\n    div = trial_division(M)\n    if div * N <= M:\n        print(div)\n    else:\n        print(1)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03796","slow_code_col":"import math\n\n\n\nN = int(eval(input()))\n\nC = 10**9 + 7\n\n\n\nprint((math.factorial(N) % C))","reference_code_col":"N = int(eval(input()))\n\nC = 10**9+7\n\nans = 1\n\nfor i in range(1, N + 1):\n\n    ans *= i\n\n    ans %= C\n\nprint(ans)","model_generated_potentially_faster_code_col":"import functools\n\n\ndef factorial(n, mod):\n    if n == 0 or n == 1:\n        return 1\n\n    result = 1\n    for i in range(2, n+1):\n        result = (result * i) % mod\n    return result\n\n\nN = int(input())\nC = 10**9 + 7\n\nprint(factorial(N, C))"}
{"problem_id":"p04017","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nimport bisect\n\n\n\nn = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nl = int(eval(input()))\n\nU = 17\n\ndp = [[0]*n for _ in range(U+1)]\n\nfor i, x in enumerate(X):\n\n  t = bisect.bisect_left(X, x+l)\n\n  dp[0][i] = bisect.bisect_right(X, x+l) - 1\n\nfor k in range(U):\n\n  for i in range(n):\n\n    dp[k+1][i] = dp[k][dp[k][i]]\n\ndef test(x, a, b):\n\n  for i in range(U, -1, -1):\n\n    if x >> i & 1:\n\n      a = dp[i][a]\n\n  return a >= b\n\ndef solve(a, b):\n\n  if a > b:\n\n    a, b = b, a\n\n  ng = 0\n\n  ok = n-1\n\n  while ok - ng > 1:\n\n    mid = (ng + ok) \/\/ 2\n\n    if test(mid, a, b):\n\n      ok = mid\n\n    else:\n\n      ng = mid\n\n  print(ok)\n\nq = int(eval(input()))\n\nfor _ in range(q):\n\n  a, b = list(map(int, input().split()))\n\n  a -= 1\n\n  b -= 1\n\n  solve(a, b)","reference_code_col":"import sys\n\ninput = sys.stdin.readline\n\nimport bisect\n\n\n\nn = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nl = int(eval(input()))\n\nU = 17\n\ndp = [[0]*n for _ in range(U+1)]\n\nfor i, x in enumerate(X):\n\n  t = bisect.bisect_left(X, x+l)\n\n  dp[0][i] = bisect.bisect_right(X, x+l) - 1\n\nfor k in range(U):\n\n  for i in range(n):\n\n    dp[k+1][i] = dp[k][dp[k][i]]\n\nq = int(eval(input()))\n\nfor _ in range(q):\n\n  a, b = list(map(int, input().split()))\n\n  a -= 1\n\n  b -= 1\n\n  if a > b:\n\n    a, b = b, a\n\n  res = 1\n\n  for k in range(U, -1, -1):\n\n    if dp[k][a] < b:\n\n      a = dp[k][a]\n\n      res += (1<<k)\n\n    if a == b:\n\n      break\n\n  print(res)","model_generated_potentially_faster_code_col":"import sys\nfrom typing import List\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nX = list(map(int, data[1:n+1]))\nl = int(data[n+1])\n\nU = 17\n\n# Initialize DP table\ndp = [[0] * n for _ in range(U + 1)]\n\n# Fill the first row of DP table using binary search\nfor i, x in enumerate(X):\n    t = bisect.bisect_left(X, x + l)\n    dp[0][i] = bisect.bisect_right(X, x + l) - 1\n\n# Precompute the DP table\nfor k in range(U):\n    for i in range(n):\n        dp[k + 1][i] = dp[k][dp[k][i]]\n\n# Function to perform binary search using precomputed DP table\ndef test(x: int, a: int, b: int) -> bool:\n    for i in range(U, -1, -1):\n        if x >> i & 1:\n            a = dp[i][a]\n    return a >= b\n\n# Main function to solve the problem\ndef solve(a: int, b: int) -> None:\n    if a > b:\n        a, b = b, a\n\n    # Binary search to find the maximum index j\n    left, right = a, n - 1\n    while left < right:\n        mid = (left + right + 1) \/\/ 2\n        if test(mid, a, b):\n            left = mid\n        else:\n            right = mid - 1\n\n    print(left)\n\n# Read query count and process each query\nq = int(data[n + 2])\nqueries = [tuple(map(int, data[n + 3 + 2 * i:n + 5 + 2 * i])) for i in range(q)]\nfor a, b in queries:\n    a -= 1\n    b -= 1\n    solve(a, b)"}
{"problem_id":"p03164","slow_code_col":"#!\/usr\/bin\/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    np.set_printoptions(linewidth=200)\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i\u4ee5\u4e0a\u306e\u4fa1\u5024\u3092\u6301\u3064\u3068\u304d\u306e\u6700\u5c0f\u91cd\u91cf\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for n in range(N):\n\n        w, v = lst[n]\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    ans = 0\n\n    for i, w in enumerate(dp):\n\n        if w <= W:\n\n            ans = i\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"#!\/usr\/bin\/env python3\n\ndef main():\n\n    import numpy as np\n\n\n\n    N, W = list(map(int, input().split()))\n\n    lst = [list(map(int, input().split())) for _ in range(N)]\n\n    v_max = 10 ** 3 * 100 * 10\n\n    w_max = 10 ** 9 * v_max\n\n\n\n    # i\u4ee5\u4e0a\u306e\u4fa1\u5024\u3092\u6301\u3064\u3068\u304d\u306e\u6700\u5c0f\u91cd\u91cf\n\n    dp = np.full(v_max, w_max, dtype=np.int64)\n\n    # initialize\n\n    dp[0] = 0\n\n\n\n    for w, v in lst:\n\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n\n\n\n    print((np.asarray(dp <= W).nonzero()[0].max()))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env python3\n\nimport numpy as np\n\ndef main():\n    np.set_printoptions(linewidth=200)\n    \n    N, W = map(int, input().split())\n    lst = [tuple(map(int, input().split())) for _ in range(N)]\n    \n    v_max = 10**3 * 100 * 10\n    dp = np.ones(v_max, dtype=np.int64) * (W + 1)\n    dp[0] = 0\n    \n    for w, v in lst:\n        dp[v:] = np.minimum(dp[v:], dp[:-v] + w)\n    \n    ans = next(i for i, x in enumerate(dp) if x <= W)\n    print(ans)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02994","slow_code_col":"n, like = list(map(int, input().split()))\n\n\n\narr = [like + i for i in range(n)]\n\n\n\narr.sort(key=lambda x:abs(x))\n\n\n\nprint((sum(arr[1:])))\n","reference_code_col":"n, like = list(map(int, input().split()))\n\narr = [like + i for i in range(n)]\n\narr.sort(key=abs)\n\nprint((sum(arr[1:])))\n","model_generated_potentially_faster_code_col":"n, like = map(int, input().split())\n\ntotal_sum = (n * (2*like + n - 1)) \/\/ 2\n\nif like < 0:\n    total_sum -= abs(like) * (abs(like) + 1) \/\/ 2\nelse:\n    total_sum += abs(like) * (abs(like) + 1) \/\/ 2\n\nprint(total_sum)"}
{"problem_id":"p03371","slow_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\nans = float('inf')\n\nfor i in range(max(X,Y)+1):\n\n    cost = 2 * C * i + max(0,X-i)*A +max(0,Y-i)*B\n\n    ans = min(ans,cost)\n\nprint(ans)","reference_code_col":"A, B, C, X, Y = list(map(int, input().split()))\n\ntmp = A*X + B*Y\n\nif X >= Y:\n\n    tmp = min(tmp,2*Y*C+(X-Y)*A)\n\nelse:\n\n    tmp = min(tmp,2*X*C+(Y-X)*B)\n\ntmp = min(tmp,max(X,Y)*2*C)\n\nprint(tmp)","model_generated_potentially_faster_code_col":"A, B, C, X, Y = map(int, input().split())\n\n# Calculate the optimal cost using the derived formula\noptimal_cost = 2 * C * min(X, Y) + A * X + B * Y\n\nprint(optimal_cost)"}
{"problem_id":"p03828","slow_code_col":"#coding: UTF-8\n\nimport math\n\nN=int(eval(input()))\n\ndef prime_list(k):\n\n    lis=[True for i in range(1,k+1)]\n\n    lis[0]=False\n\n    for i in range(2,k+1):\n\n        j=2\n\n        while j*j<=i:\n\n            if i%j==0:\n\n                lis[i-1]=False\n\n                break\n\n            else:\n\n                j+=1\n\n    return lis\n\n#    print(lis)\n\ndef p_fact(k,N):\n\n    plist=prime_list(k)\n\n    lis=[0]*N\n\n    for i in range(0,k):\n\n        n=0\n\n        if plist[i]:\n\n            while k%(i+1)==0:\n\n                n+=1\n\n                k=k\/(i+1)\n\n        lis[i]=n\n\n    return lis\n\nout_lis=[0]*N\n\nfor i in range(1,N+1):\n\n    input_lis=p_fact(i,N)\n\n    out_lis=[out_lis[j]+input_lis[j] for j in range(0,N)]\n\n#print(out_lis)\n\nout=1\n\nfor i in range(0,N):\n\n    out=out*(out_lis[i]+1)\n\nprint((out%1000000007))","reference_code_col":"#coding: UTF-8\n\nimport math\n\nN=int(eval(input()))\n\ndef prime_list(k):\n\n    lis=[True for i in range(1,k+1)]\n\n    lis[0]=False\n\n    for i in range(2,k+1):\n\n        j=2\n\n        while j*j<=i:\n\n            if i%j==0:\n\n                lis[i-1]=False\n\n                break\n\n            else:\n\n                j+=1\n\n    return lis\n\n#    print(lis)\n\ndef p_fact(k,N,plist):\n\n#    plist=prime_list(k)\n\n    lis=[0]*N\n\n    for i in range(0,k):\n\n        n=0\n\n        if plist[i]:\n\n            while k%(i+1)==0:\n\n                n+=1\n\n                k=k\/(i+1)\n\n        lis[i]=n\n\n    return lis\n\n#    print(lis)\n\nout_lis=[0]*N\n\nplist=prime_list(N)\n\nfor i in range(1,N+1):\n\n    input_lis=p_fact(i,N,plist)\n\n    out_lis=[out_lis[j]+input_lis[j] for j in range(0,N)]\n\n#print(out_lis)\n\nout=1\n\nfor i in range(0,N):\n\n    out=out*(out_lis[i]+1)\n\n#print(out%1000000007)\n\nprint((out%(10**9+7)))","model_generated_potentially_faster_code_col":"# coding: UTF-8\n\nMOD = 1_000_000_007\n\nN = int(eval(input()))\n\ndef sieve_of_eratosthenes(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n + 1, i):\n                is_prime[j] = False\n    return is_prime\n\ndef factorial_mod(n, mod):\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    return fact\n\ndef p_fact(k, N, is_prime, fact):\n    lis = [0] * N\n    for i in range(2, k + 1):\n        if is_prime[i]:\n            count = 0\n            temp_k = k\n            while temp_k % i == 0:\n                count += 1\n                temp_k \/\/= i\n            lis[count - 1] += fact[k \/\/ i] * pow(fact[i], MOD - 2, MOD) % MOD\n    return lis\n\nis_prime = sieve_of_eratosthenes(N)\nfact = factorial_mod(N, MOD)\n\nout_lis = [0] * N\nfor i in range(1, N + 1):\n    input_lis = p_fact(i, N, is_prime, fact)\n    out_lis = [(out_lis[j] + input_lis[j]) % MOD for j in range(N)]\n\nresult = 1\nfor i in range(N):\n    result = result * (out_lis[i] + 1) % MOD\n\nprint(result)"}
{"problem_id":"p02245","slow_code_col":"import sys\n\nimport queue\n\n\n\nN = 3\n\nf= ''.join(sys.stdin.readline().split())\n\nf+= ''.join(sys.stdin.readline().split())\n\nf+= ''.join(sys.stdin.readline().split())\n\n\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\n\n\nQ = queue.Queue()\n\nV = dict()\n\n\n\nQ.put([f,f.index('0'),0])\n\nV[f] = True\n\n\n\nwhile not Q.empty():\n\n    u = Q.get()\n\n    if u[0] == '123456780':  break\n\n    sx, sy = u[1]\/\/N, u[1]%N\n\n    for dx, dy in dd:\n\n        tx, ty = sx+dx, sy+dy\n\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n\n        v = u[:]\n\n        n1, n2 = u[1], tx*N+ty\n\n        v[1] = n2\n\n        if n1>n2: n1, n2 = n2, n1\n\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n\n        if not V.get(v[0], False):\n\n            V[v[0]] = True\n\n            v[2] += 1                                                    \n\n            Q.put(v)\n\n\n\nprint((u[2]))\n","reference_code_col":"import sys\n\nimport queue\n\n\n\nN = 3\n\n\n\nf = ''.join(sys.stdin.readline().split())\n\nf += ''.join(sys.stdin.readline().split())\n\nf += ''.join(sys.stdin.readline().split())\n\n\n\ndd = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n\n\n\nQ = [[f,f.index('0'),0]]\n\nV = { f: True }\n\n\n\nwhile len(Q)>0:\n\n    u = Q.pop(0)\n\n    if u[0] == '123456780':  break\n\n    sx, sy = u[1]\/\/N, u[1]%N\n\n    for dx, dy in dd:\n\n        tx, ty = sx+dx, sy+dy\n\n        if tx<0 or ty<0 or tx>=N or ty>=N: continue\n\n        v = u[:]\n\n        n1, n2 = u[1], tx*N+ty\n\n        v[1] = n2\n\n        if n1>n2: n1, n2 = n2, n1\n\n        v[0] = v[0][0:n1]+v[0][n2]+v[0][n1+1:n2]+v[0][n1]+v[0][n2+1:]\n\n        if not V.get(v[0], False):\n\n            V[v[0]] = True\n\n            v[2] += 1 # dir[r]                                                       \n\n            Q.append(v)\n\n\n\nprint((u[2]))\n","model_generated_potentially_faster_code_col":"import sys\nfrom collections import deque\n\nN = 3\nf = ''.join(sys.stdin.readline().split()) + ''.join(sys.stdin.readline().split()) + ''.join(sys.stdin.readline().split())\n\ndd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n\nq = deque([(f, f.index('0'))])\nv = {f}\n\nwhile q:\n    s, z = q.popleft()\n    if s == '123456780':\n        print(q[-1][2] if q else 0)\n        break\n    sx, sy = divmod(z, N)\n    for dx, dy in dd:\n        tx, ty = sx + dx, sy + dy\n        if 0 <= tx < N and 0 <= ty < N:\n            i, j = tx * N + ty, min(tx * N + ty, z)\n            s_new = s[:i] + s[z] + s[i + 1:j] + s[i] + s[j + 1:]\n            if s_new not in v:\n                v.add(s_new)\n                q.append((s_new, i))"}
{"problem_id":"p03806","slow_code_col":"N,MA,MB = list(map(int,input().split()))\n\nsrc = [tuple(map(int,input().split())) for i in range(N)]\n\n\n\nINF = 10**9\n\ndp = [[INF for j in range(401)] for i in range(401)]\n\ndp[0][0] = 0\n\nmaxa = maxb = 0\n\nfor a,b,c in src:\n\n    for ai in range(maxa,-1,-1):\n\n        for bi in range(maxb,-1,-1):\n\n            dp[ai+a][bi+b] = min(dp[ai+a][bi+b], dp[ai][bi] + c)\n\n    maxa += a\n\n    maxb += b\n\n\n\nans = INF\n\nfor i in range(1,401):\n\n    if MA*i > 400 or MB*i > 400: break\n\n    ans = min(ans, dp[MA*i][MB*i])\n\nprint((-1 if ans == INF else ans))","reference_code_col":"N,MA,MB = list(map(int,input().split()))\n\nsrc = [tuple(map(int,input().split())) for i in range(N)]\n\n\n\nINF = 10**9\n\nMAX = 401\n\ndp = [[INF] * MAX for i in range(MAX)]\n\ndp[0][0] = 0\n\namax = bmax = 0\n\nfor a,b,n in src:\n\n    for i in reversed(list(range(bmax+1))):\n\n        for j in range(amax+1):\n\n            if dp[i][j] == INF: continue\n\n            dp[i+b][j+a] = min(dp[i+b][j+a], dp[i][j] + n)\n\n    amax += a\n\n    bmax += b\n\n\n\nans = INF\n\nfor i in range(1,MAX):\n\n    if i*MA >= MAX or i*MB >= MAX: break\n\n    ans = min(ans, dp[i*MB][i*MA])\n\nprint((-1 if ans == INF else ans))","model_generated_potentially_faster_code_col":"N, MA, MB = map(int, input().split())\nsrc = [tuple(map(int, input().split())) for _ in range(N)]\nINF = 10 ** 9\ndp = [[INF] * (MA + MB + 1) for _ in range(MA + MB + 1)]\ndp[0][0] = 0\nfor a, b, c in src:\n    for i in range(MA + MB, -1, -1):\n        for j in range(MB + 1, -1, -1):\n            if i >= a and j >= b:\n                dp[i][j] = min(dp[i][j], dp[i - a][j - b] + c)\nans = INF\nfor i in range(MA + 1):\n    for j in range(MB + 1):\n        if i * MA + j * MB <= 400:\n            ans = min(ans, dp[i][j])\nprint(-1 if ans == INF else ans)"}
{"problem_id":"p03253","slow_code_col":"import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\nfac = [1, 1]     # \u5143\u30c6\u30fc\u30d6\u30eb\n\nf_inv = [1, 1]   # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\ninv = [0, 1]     # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n        inv.append((-inv[mod % i] * (mod\/\/i)) % mod)\n\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * f_inv[r] * f_inv[n-r] % mod\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n \/\/= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    prepare(N+100, MOD)\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e, MOD)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nMOD = 10**9+7\n\n\n\nfac = [1, 1]     # \u5143\u30c6\u30fc\u30d6\u30eb\n\nf_inv = [1, 1]   # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\ninv = [0, 1]     # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * pow(fac[r],MOD-2,MOD) * pow(fac[n-r],MOD-2,MOD) % mod\n\n\n\n\n\ndef prime_factorization(n):\n\n    d = []\n\n    i, e = 2, 0  # factor, exponent\n\n    while i * i <= n:\n\n        while n % i == 0:\n\n            n \/\/= i\n\n            e += 1\n\n        if e > 0:\n\n            d.append((i, e))\n\n        i += 1\n\n        e = 0\n\n    if n > 1:\n\n        d.append((n, 1))\n\n    return d\n\n\n\n\n\ndef main():\n\n    N,M = list(map(int, readline().split()))\n\n\n\n    prepare(N+100, MOD)\n\n    d = prime_factorization(M)\n\n\n\n    ans = 1\n\n    for i, e in d:\n\n        ans *= cmb(N-1+e, e, MOD)\n\n        ans %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\n# Read input functions\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\n# Constants\nMOD = 10**9 + 7\n\n# Precomputed tables\nfac = [1, 1]\nf_inv = [1, 1]\ninv = [0, 1]\n\ndef prepare(n, mod):\n    \"\"\"Precompute factorials, modular inverses, and their inverses up to n.\"\"\"\n    for i in range(2, n + 1):\n        fac.append(fac[-1] * i % mod)\n        inv.append(-inv[mod % i] * (mod \/\/ i) % mod)\n        f_inv.append(f_inv[-1] * inv[-1] % mod)\n\ndef cmb(n, r, mod):\n    \"\"\"Calculate combination C(n, r) modulo mod.\"\"\"\n    if n < 0 or r < 0:\n        return 0\n    if r > n:\n        return 0\n    return fac[n] * f_inv[r] * f_inv[n - r] % mod\n\ndef prime_factorization(n):\n    \"\"\"Factorize n into its prime factors.\"\"\"\n    factors = []\n    i, e = 2, 0\n    while i * i <= n:\n        while n % i == 0:\n            n \/\/= i\n            e += 1\n        if e > 0:\n            factors.append((i, e))\n        i += 1\n        e = 0\n    if n > 1:\n        factors.append((n, 1))\n    return factors\n\ndef main():\n    N, M = map(int, readline().split())\n    \n    prepare(N + 100, MOD)\n    d = prime_factorization(M)\n    \n    ans = 1\n    for i, e in d:\n        ans *= cmb(N - 1 + e, e, MOD)\n        ans %= MOD\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03494","slow_code_col":"_,t=open(0);n=eval(t.replace(' ','|'));print((len(bin(n&-n))-3))","reference_code_col":"n=eval([*open(0)][1].replace(*' |'))\n\nprint((len(bin(n&-n))-3))","model_generated_potentially_faster_code_col":"_, t = open(0)  # Read input from stdin\nn = eval(t.replace(' ', '|'))  # Replace spaces with '|' and evaluate as an expression\nprint((len(bin(n & -n)) - 3))  # Find the position of the rightmost set bit"}
{"problem_id":"p02780","slow_code_col":"import numpy as np\n\n\n\nN, K= list(map(int, input().split()))\n\np = np.array(list(map(int, input().split())))\n\n\n\ntmp = np.sum(p[:K])\n\nmax = tmp\n\nfor i in range(N-K):\n\n    tmp = tmp-p[i]+p[i+K]\n\n    if tmp>max:\n\n        max = tmp\n\n\n\nprint(((max+K)\/2))","reference_code_col":"N, K= list(map(int, input().split()))\n\np = list(map(int, input().split()))\n\n\n\ntmp = sum(p[:K])\n\nmax = tmp\n\nfor i in range(N-K):\n\n    tmp = tmp-p[i]+p[i+K]\n\n    if tmp>max:\n\n        max = tmp\n\n\n\nprint(((max+K)\/2))","model_generated_potentially_faster_code_col":"import numpy as np\n\nN, K = map(int, input().split())\np = np.array(list(map(int, input().split())))\n\n# Calculate the initial sum of the first K elements\ninitial_sum = np.sum(p[:K])\nmax_sum = initial_sum\n\n# Use a sliding window approach to calculate the sum of the next windows\nfor i in range(1, N - K + 1):\n    current_sum = initial_sum - p[i - 1] + p[i + K - 1]\n    if current_sum > max_sum:\n        max_sum = current_sum\n    initial_sum = current_sum\n\nresult = (max_sum + K) \/ 2\nprint(result)"}
{"problem_id":"p03309","slow_code_col":"import statistics\n\nN = int(eval(input()))\n\nA = [int(a)-i-1 for i,a in enumerate(input().split(),1)]\n\nb = statistics.median_low(A)\n\nc = statistics.median_high(A)\n\nd = sum([abs(x-b) for x in A])\n\ne = sum([abs(x-c) for x in A])\n\nprint((min(d,e)))","reference_code_col":"N=int(eval(input()))\n\nA=sorted(a-i-1 for i,a in enumerate(map(int,input().split())))\n\nprint((sum(abs(a-A[N\/\/2]) for a in A)))","model_generated_potentially_faster_code_col":"import statistics\n\n# Read input\nN = int(input())\nA = [int(a) - i - 1 for i, a in enumerate(input().split())]\n\n# Calculate median\nb = statistics.median_low(A)\n# c = statistics.median_high(A)  # Uncomment this line if you need both medians\n\n# Calculate minimum sum of absolute differences\ndef min_abs_sum(A, b):\n    return sum(abs(x - b) for x in A)\n\nd = min_abs_sum(A, b)\n# e = min_abs_sum(A, c)  # Uncomment this line if you need both medians\n\nprint(min(d))"}
{"problem_id":"p03416","slow_code_col":"a,b = list(map(int,input().split()))\n\nc = 0\n\n\n\nfor i in range(a,b+1):\n\n  new = list(reversed(list(str(i))))\n\n  if new == list(str(i)):\n\n    c += 1\n\n    \n\n    \n\nprint(c)","reference_code_col":"a,b = list(map(int,input().split()))\n\nc = 0\n\n\n\nfor i in range(a,b+1):\n\n  if list(str(i)) == list(str(i))[::-1]:\n\n    c += 1\n\n    \n\n    \n\nprint(c)","model_generated_potentially_faster_code_col":"def is_palindrome(num):\n    if num < 0:\n        return False\n    if num < 10:\n        return True\n    original_num = num\n    reversed_num = 0\n    while num > 0:\n        digit = num % 10\n        reversed_num = reversed_num * 10 + digit\n        num \/\/= 10\n    return original_num == reversed_num\n\na, b = map(int, input().split())\ncount = sum(is_palindrome(i) for i in range(a, b + 1))\nprint(count)"}
{"problem_id":"p03013","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\nN, M = list(map(int,input().split()))\n\nhole = [0] * (N+1)\n\nfor i in range(M):\n\n    hole[int(eval(input()))] = 1\n\nif N == 1:\n\n    print((1))\n\n    exit()\n\nif N == 2:\n\n    if hole[1] == 1:\n\n        print((1))\n\n        exit()\n\n    if hole[1] == 0:\n\n        print((2))\n\n        exit()\n\nflg_one = False\n\nflg_two = False\n\nfirst = 1\n\nsecond = 2\n\nif hole[1] == 1:\n\n    first = 0\n\n    second = 1\n\n    flg_one = True\n\nif hole[2] == 1:\n\n    first = 1\n\n    second = 0\n\n    flg_two = True\n\nif flg_one and flg_two:\n\n    print((0))\n\n    exit()\n\n\n\nfor i in range(3,N):\n\n    if hole[i] == 1:\n\n        first = second\n\n        second = 0\n\n        continue\n\n    tmp = first + second\n\n    tmp %= 1000000007\n\n    first = second\n\n    second = tmp\n\ntmp = first + second\n\ntmp %= 1000000007\n\nprint(tmp)","reference_code_col":"MOD = 10**9 + 7\n\nN, M = list(map(int, input().split()))\n\nstairs = [0]*(N+1)\n\nfor _ in range(M):\n\n    stairs[int(eval(input()))] = 1\n\nif N == 1:\n\n    print((1))\n\n    exit()\n\nans = [0]*(N+1)\n\nans[1] = 1 if stairs[1] == 0 else 0\n\nans[2] = 1 + ans[1] if stairs[2] == 0 else 0\n\nfor i in range(3,N+1):\n\n    if stairs[i] == 1:\n\n        ans[i] = 0\n\n        continue\n\n    ans[i] = (ans[i-1] + ans[i-2]) % MOD\n\nprint((ans[N]))","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\n\nholes = set()\nfor _ in range(M):\n    hole = int(eval(input()))\n    holes.add(hole)\n\nresult = 1 if N == 1 else 2\n\nif 1 in holes:\n    result = 1\n\nif 2 in holes:\n    result = 0\n\nfor i in range(3, N):\n    if i in holes:\n        result = 0\n        break\n    result = (result << 1) % 1000000007\n\nprint(result)"}
{"problem_id":"p03558","slow_code_col":"#!usr\/bin\/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = SR()\n\n    return l\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    s = S()\n\n    t = S()\n\n    if s+t == t[::-1]+s[::-1]:\n\n        print(\"YES\")\n\n    else:\n\n        print(\"NO\")\n\n\n\n#B\n\ndef B():\n\n    n = I()\n\n    for i in range(int(n**0.5)+2)[::-1]:\n\n        if i*i <= n:\n\n            print((i*i))\n\n            quit()\n\n#C\n\ndef C():\n\n    n = I()\n\n    a = LI()\n\n    b = LI()\n\n    c = LI()\n\n    q = [0 for i in range(n)]\n\n    ans = 0\n\n    a.sort()\n\n    b.sort()\n\n    c.sort()\n\n    for i in range(n):\n\n        j = bisect.bisect_left(a,b[i])\n\n        q[i] = j\n\n    for i in range(n-1):\n\n        q[i+1] += q[i]\n\n    q.insert(0,0)\n\n    for i in range(n):\n\n        j = bisect.bisect_left(b,c[i])\n\n        ans += q[j]\n\n    print(ans)\n\n#D\n\ndef D():\n\n    def dijkstra():\n\n        d = [float(\"inf\") for i in range(k)]\n\n        q = [[0,1]]\n\n        d[1] = 0\n\n        while q:\n\n            dx,x = heappop(q)\n\n            for y,dy in v[x]:\n\n                if d[y] > dx+dy:\n\n                    d[y] = dx+dy\n\n                    heappush(q,[d[y],y])\n\n        print((d[0]+1))\n\n    k = I()\n\n    if k == 1:\n\n        print((1))\n\n        quit()\n\n    v = [[] for i in range(k)]\n\n    for i in range(1,k):\n\n        v[i].append([(i+1)%k,1])\n\n        v[i].append([i*10%k,0])\n\n    dijkstra()\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    return\n\n\n\n#G\n\ndef G():\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    D()\n","reference_code_col":"#!usr\/bin\/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    def v(n):\n\n        return [n*10%k, (n+1)%k]\n\n    k = I()\n\n    d = [float(\"inf\")]*k\n\n    d[1] = 1\n\n    q = deque([1])\n\n    while q:\n\n        x = q.popleft()\n\n        vx = v(x)\n\n        dx = d[x]\n\n        for c in range(2):\n\n            nd = dx+c\n\n            y = vx[c]\n\n            if nd < d[y]:\n\n                d[y] = nd\n\n                if c:\n\n                    q.append(y)\n\n                else:\n\n                    q.appendleft(y)\n\n    print((d[0]))\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n","model_generated_potentially_faster_code_col":"#!\/usr\/bin\/env python3\n\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef I():\n    return int(sys.stdin.readline())\n\ndef LS():\n    return list(map(list, sys.stdin.readline().split()))\n\ndef S():\n    return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n    return [I() for _ in range(n)]\n\ndef LIR(n):\n    return [LI() for _ in range(n)]\n\ndef SR(n):\n    return [S() for _ in range(n)]\n\ndef LSR(n):\n    return [SR() for _ in range(n)]\n\nmod = 1000000007\n\n# A\ndef A():\n    s = S()\n    t = S()\n    if s + t == t[::-1] + s[::-1]:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n# B\ndef B():\n    n = I()\n    i = int(math.isqrt(n))\n    while True:\n        if i * i <= n:\n            print(i * i)\n            break\n        i -= 1\n\n# C\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    c = LI()\n    a.sort()\n    b.sort()\n    c.sort()\n    ans = 0\n    for i in range(n):\n        j = bisect.bisect_left(a, b[i])\n        ans += j\n    for i in range(n):\n        j = bisect.bisect_left(b, c[i])\n        ans += j\n    print(ans)\n\n# D\ndef D():\n    def dijkstra():\n        d = [float(\"inf\")] * k\n        d[1] = 0\n        pq = [(0, 1)]\n        while pq:\n            dist, x = heappop(pq)\n            if dist > d[x]:\n                continue\n            for y, dy in v[x]:\n                new_dist = dist + dy\n                if new_dist < d[y]:\n                    d[y] = new_dist\n                    heappush(pq, (new_dist, y))\n        print(d[0] + 1)\n\n    k = I()\n    if k == 1:\n        print(1)\n        return\n\n    v = [[] for _ in range(k)]\n    for i in range(1, k):\n        v[i].append(((i + 1) % k, 1))\n        v[i].append((i * 10 % k, 0))\n\n    dijkstra()\n\n# E\ndef E():\n    pass\n\n# F\ndef F():\n    pass\n\n# G\ndef G():\n    pass\n\n# H\ndef H():\n    pass\n\n# Solve\nif __name__ == \"__main__\":\n    D()"}
{"problem_id":"p02994","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nN, L = list(map(int, input().split()))\n\n\n\n# \u5473\n\nLL = np.arange(L,L+N)\n\n\n\nm = abs(LL[0])\n\n\n\nfor i in range(N):\n\n    if abs(m) > abs(LL[i]):\n\n        m = LL[i]\n\n\n\nprint((np.sum(LL)-m))\n","reference_code_col":"N, L = list(map(int, input().split()))\n\n\n\nA = [i for i in range(L, L + N)]\n\n\n\nif A[0] < 0:\n\n    if A[-1] < 0:\n\n        print((sum(A) - max(A)))\n\n    else:\n\n        print((sum(A)))\n\nelse:\n\n    print((sum(A) - min(A)))\n","model_generated_potentially_faster_code_col":"import sys\nimport numpy as np\n\n# Read input values\nN, L = map(int, input().split())\n\n# Create the array using NumPy\nLL = np.arange(L, L + N)\n\n# Calculate the sum of the array\ntotal_sum = np.sum(LL)\n\n# Find the minimum value in the array\nmin_value = np.min(LL)\n\n# Print the result\nprint(total_sum - min_value)"}
{"problem_id":"p02537","slow_code_col":"import sys\n\ninput = sys.stdin.readline\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\n\n\n# N: \u51e6\u7406\u3059\u308b\u533a\u9593\u306e\u9577\u3055\n\n\n\nINF = 0\n\n\n\nmx = 300001\n\nLV = (mx-1).bit_length()\n\nN0 = 2**LV\n\ndata = [INF]*(2*N0)\n\nlazy = [None]*(2*N0)\n\n\n\n# \u4f1d\u642c\u5bfe\u8c61\u306e\u533a\u9593\u3092\u6c42\u3081\u308b\n\ndef gindex(l, r):\n\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n\n    lc = 0 if l & 1 else (L & -L).bit_length()\n\n    rc = 0 if r & 1 else (R & -R).bit_length()\n\n    for i in range(LV):\n\n        if rc <= i:\n\n            yield R\n\n        if L < R and lc <= i:\n\n            yield L\n\n        L >>= 1; R >>= 1\n\n\n\n# \u9045\u5ef6\u4f1d\u642c\u51e6\u7406\n\ndef propagates(*ids):\n\n    for i in reversed(ids):\n\n        v = lazy[i-1]\n\n        if v is None:\n\n            continue\n\n        lazy[2*i-1] = data[2*i-1] = lazy[2*i] = data[2*i] = v\n\n        lazy[i-1] = None\n\n\n\n# \u533a\u9593[l, r)\u3092x\u3067\u66f4\u65b0\n\ndef update(l, r, x):\n\n    *ids, = gindex(l, r)\n\n    propagates(*ids)\n\n\n\n    L = N0 + l; R = N0 + r\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            lazy[R-1] = data[R-1] = x\n\n        if L & 1:\n\n            lazy[L-1] = data[L-1] = x\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    for i in ids:\n\n        data[i-1] = max(data[2*i-1], data[2*i])\n\n\n\n# \u533a\u9593[l, r)\u5185\u306e\u6700\u5c0f\u5024\u3092\u6c42\u3081\u308b\n\ndef query(l, r):\n\n    propagates(*gindex(l, r))\n\n    L = N0 + l; R = N0 + r\n\n\n\n    s = INF\n\n    while L < R:\n\n        if R & 1:\n\n            R -= 1\n\n            s = max(s, data[R-1])\n\n        if L & 1:\n\n            s = max(s, data[L-1])\n\n            L += 1\n\n        L >>= 1; R >>= 1\n\n    return s\n\n\n\nans = 0\n\nupdate(As[0],As[0]+1,1)\n\nfor i, a in enumerate(As[1:]):\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n    upd = query(l,r+1)\n\n    if upd == -1:continue\n\n    # print(\"i\",i,\"a\",a,\"upd\",upd,\"l\",l,\"r\",r)\n\n    update(a, a+1, upd+1)\n\n    ans = max(ans, upd+1)\n\nprint(ans)\n\n\n","reference_code_col":"# \u30bb\u30b0\u30e1\u30f3\u30c8\u6728\n\n# segment tree\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nclass segmented_tree:\n\n    X_unit = 0\n\n    X_f = lambda self, a, b: max(a,b)\n\n    def __init__(self, N):\n\n        self.N = N\n\n        self.X = [self.X_unit] * (2*N)\n\n        \n\n    def build(self, seq):\n\n        for i, x in enumerate(seq, self.N):\n\n            self.X[i] = x \n\n        # \u5f8c\u308d\u304b\u3089\u5165\u308c\u3066\u3044\u304f\n\n        for i in range(self.N-1, 0, -1):\n\n            self.X[i] = self.X_f(self.X[i<<1], self.X[i<<1|1])\n\n\n\n    # 1\u70b9\u66f4\u65b0\n\n    def set_val(self, i, x):\n\n        i += self.N\n\n        self.X[i] = x\n\n        while i > 1:\n\n            i >>= 1\n\n            self.X[i] = self.X_f(self.X[i<<1],self.X[i<<1|1])\n\n    \n\n    # \u533a\u9593\u53d6\u5f97\n\n    def fold(self, l, r):\n\n        l += self.N\n\n        r += self.N\n\n        vl = self.X_unit\n\n        vr = self.X_unit\n\n        # \u5916\u304b\u3089\u6c7a\u3081\u3066\u3044\u304f\n\n        while l < r:\n\n            # print(l,r)\n\n            if l & 1:\n\n                vl = self.X_f(vl, self.X[l])\n\n                l += 1\n\n            if r & 1:\n\n                r -= 1\n\n                vr = self.X_f(vr, self.X[r])\n\n            l >>= 1\n\n            r >>= 1\n\n        return self.X_f(vl,vr)\n\n\n\nn,k = list(map(int, input().split()))\n\nAs = [int(eval(input())) for i in range(n)]\n\nmx = 300001\n\nans = 0\n\nsg = segmented_tree(330000)\n\n\n\nfor a in As:\n\n    l = max(0,a-k)\n\n    r = min(mx,a+k)\n\n\n\n    upd = sg.fold(l,r+1)\n\n    ans = max(ans, upd+1)\n\n\n\n    sg.set_val(a, upd+1)\n\nprint(ans)\n\n\n","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.read\n\ndata = []\nfor line in input().splitlines():\n    n, k = map(int, line.split())\n    As = list(map(int, line.split()))\n    break\n\nINF = float('-inf')\n\nmx = 300001\nLV = (mx - 1).bit_length()\nN0 = 2 ** LV\ndata = [INF] * (2 * N0)\nlazy = [None] * (2 * N0)\n\n\ndef gindex(l, r):\n    L = (l + N0) >> 1\n    R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & -L).bit_length()\n    rc = 0 if r & 1 else (R & -R).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if L < R and lc <= i:\n            yield L\n        L >>= 1\n        R >>= 1\n\n\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i - 1]\n        if v is None:\n            continue\n        lazy[2 * i - 1] = data[2 * i - 1] = lazy[2 * i] = data[2 * i] = v\n        lazy[i - 1] = None\n\n\ndef update(l, r, x):\n    *ids, = gindex(l, r)\n    propagates(*ids)\n\n    L = N0 + l\n    R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R - 1] = data[R - 1] = x\n        if L & 1:\n            lazy[L - 1] = data[L - 1] = x\n            L += 1\n        L >>= 1\n        R >>= 1\n\n    for i in ids:\n        data[i - 1] = max(data[2 * i - 1], data[2 * i])\n\n\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l\n    R = N0 + r\n\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R - 1])\n        if L & 1:\n            s = max(s, data[L - 1])\n            L += 1\n        L >>= 1\n        R >>= 1\n\n    return s\n\n\nans = 0\nupdate(As[0], As[0] + 1, 1)\nfor i, a in enumerate(As[1:], start=1):\n    l = max(0, a - k)\n    r = min(mx, a + k)\n    upd = query(l, r + 1)\n    if upd == -1:\n        continue\n    update(a, a + 1, upd + 1)\n    ans = max(ans, upd + 1)\n\nprint(ans)"}
{"problem_id":"p02596","slow_code_col":"# coding: utf-8\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    k = int(args[0])\n\n\n\n    l = 9*(k\/\/7 if k % 7 == 0 else k)\n\n    if l % 2 == 0 or l % 5 == 0:\n\n        return '-1'\n\n\n\n    r = phi = l\n\n    for i in range(2, int(-pow(l, 1\/2))):\n\n        if r % i == 0:\n\n            phi = phi\/\/i*(i-1)\n\n            while r % i:\n\n                r \/\/= i\n\n\n\n    a = 10 % l\n\n    ret = 1\n\n    while(a != 1):\n\n        a = a*10 % l\n\n        ret += 1\n\n        if phi < ret:\n\n            ret = -1\n\n            break\n\n\n\n    return str(ret)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n","reference_code_col":"# coding: utf-8\n\nfrom math import sqrt\n\n\n\n\n\ndef solve(*args: str) -> str:\n\n    k = int(args[0])\n\n\n\n    l = 9*(k\/\/7 if 0 == k % 7 else k)\n\n    if 0 == l % 2 or 0 == l % 5:\n\n        return '-1'\n\n\n\n    r = phi = l\n\n    for i in range(2, int(sqrt(l)+1)):\n\n        if 0 == r % i:\n\n            phi = phi*(i-1)\/\/i\n\n            while 0 == r % i:\n\n                r \/\/= i\n\n    if 1 < r:\n\n        phi = phi*(r-1)\/\/r\n\n\n\n    D = set()\n\n    for d in range(1, int(sqrt(phi)+1)):\n\n        if 0 == phi % d:\n\n            D.add(d)\n\n            D.add(phi\/\/d)\n\n\n\n    ret = -1\n\n    for m in sorted(D):\n\n        if 1 == pow(10, m, l):\n\n            ret = m\n\n            break\n\n\n\n    return str(ret)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    print((solve(*(open(0).read().splitlines()))))\n","model_generated_potentially_faster_code_col":"# coding: utf-8\n\n\ndef compute_phi(n):\n    result = n\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            result -= result \/\/ p\n            while n % p == 0:\n                n \/\/= p\n        p += 1\n    if n > 1:\n        result -= result \/\/ n\n    return result\n\n\n@lru_cache(maxsize=None)\ndef solve(k: int) -> str:\n    l = 9 * (k \/\/ 7 if k % 7 == 0 else k)\n\n    if l % 2 == 0 or l % 5 == 0:\n        return '-1'\n\n    phi = compute_phi(l)\n\n    a = 10 % l\n    ret = 1\n    while a != 1:\n        a = a * 10 % l\n        ret += 1\n        if phi < ret:\n            ret = -1\n            break\n\n    return str(ret)\n\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    results = [solve(int(line)) for line in data]\n    print('\\n'.join(results))"}
{"problem_id":"p03013","slow_code_col":"import sys\n\nsys.setrecursionlimit(100000)\n\n\n\ndef intinput(): return list(map(int,sys.stdin.readline().split()))\n\n\n\nfib={0:0,1:1,2:1}\n\nfor i in range(3,100003):\n\n    fib[i]=fib[i-1]+fib[i-2]\n\n  #  fib.append(fib[i-1]+fib[i-2])\n\n\n\nn,m=intinput()\n\nmod=10**9+7\n\na=[int(sys.stdin.readline()) for _ in range(m)]\n\nif m!=0:\n\n    l=[a[0]]\n\n    for i in range(len(a)-1):\n\n        l.append(a[i+1]-a[i]-1)\n\n    l.append(n-a[-1])\n\n    k=1\n\n    for i in l:\n\n        k=fib[i]*k%mod\n\n    print((k%mod))\n\nelse:\n\n    print((fib[n+1]%mod))","reference_code_col":"import sys\n\nsys.setrecursionlimit(100000)\n\n\n\ndef intinput(): return list(map(int,sys.stdin.readline().split()))\n\n\n\n\n\nn, m = intinput()\n\na = {int(sys.stdin.readline()) for _ in range(m)}\n\nmemo = [0 for x in range(n + 4)]\n\nmemo[0] = 1\n\nmod = 10 ** 9 + 7\n\nfor i in range(n):\n\n    if i + 1 not in a:\n\n        memo[i + 1] = (memo[i + 1] + memo[i]) % mod\n\n    if i + 2 not in a:\n\n        memo[i + 2] = (memo[i + 2] + memo[i]) % mod\n\nprint((memo[n]))","model_generated_potentially_faster_code_col":"import sys\n\n\ndef intinput():\n    return map(int, sys.stdin.read().split())\n\n\ndef fibonacci(n):\n    fib = [0] * (n + 1)\n    fib[1] = fib[2] = 1\n    for i in range(3, n + 1):\n        fib[i] = (fib[i - 1] + fib[i - 2]) % (10 ** 9 + 7)\n    return fib\n\n\nn, m = next(intinput())\nmod = 10 ** 9 + 7\na = list(next(intinput()) for _ in range(m))\n\nif m != 0:\n    l = [a[0]]\n    for i in range(len(a) - 1):\n        l.append(a[i + 1] - a[i] - 1)\n    l.append(n - a[-1])\n    fib = fibonacci(max(l))\n    k = 1\n    for i in l:\n        k = fib[i] * k % mod\n    print(k % mod)\nelse:\n    fib = fibonacci(n + 1)\n    print(fib[n + 1] % mod)"}
{"problem_id":"p03013","slow_code_col":"import sys\n\n\n\nmod = 10 ** 9 + 7\n\nn, m, *a = [int(x) for x in sys.stdin.read().split()]\n\n\n\nsafe = sorted(set(range(1,n+1)) - set(a))\n\ndp = [0] * (n + 2)\n\ndp[0] = 0\n\ndp[1] = 1\n\nfor i in safe:\n\n    dp[i+1] = (dp[i] + dp[i-1]) % mod\n\n\n\nprint((dp[-1]))","reference_code_col":"\n\n# 2019-11-14 10:01:24(JST)\n\nimport sys\n\n# import collections\n\n# import math\n\n# from string import ascii_lowercase, ascii_uppercase, digits\n\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n\n# import itertools\n\n# from functools import reduce\n\n# import operator as op\n\n# from scipy.misc import comb # float\n\n# import numpy as np \n\n\n\nmod = 10 ** 9 + 7\n\ndef main():\n\n    n, m, *a = [int(x) for x in sys.stdin.read().split()]\n\n\n\n    safe = sorted(set(range(1,n+1)) - set(a))\n\n    dp = [0] * (n + 2) # dp[i+1]: i\u6bb5\u76ee\u307e\u3067\u3044\u304f\u30d1\u30bf\u30fc\u30f3\u6570\n\n    dp[0] = 0  # -1\u6bb5\u76ee\u306b\u306f\u3044\u3051\u306a\u3044\n\n    dp[1] = 1  # \u521d\u671f\u6761\u4ef6(0\u6bb5\u76ee\u306b\u3044\u308b)\n\n    for i in safe:\n\n        dp[i+1] = (dp[i] + dp[i-1]) % mod\n\n\n\n    print((dp[-1]))\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\n\nmod = 10 ** 9 + 7\n\nn, m, *a = map(int, sys.stdin.read().split())\n\n# Create a dictionary for quick lookup of unsafe numbers\nunsafe = {x: True for x in a}\n\n# Initialize DP table with base cases\ndp = [0, 1]\n\n# Fill the DP table for all possible numbers up to n\nfor i in range(2, n+1):\n    if i not in unsafe:\n        dp.append((dp[-1] + dp[-2]) % mod)\n    else:\n        dp.append(dp[-1])\n\n# Output the result\nprint(dp[n])"}
{"problem_id":"p02767","slow_code_col":"N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nanswer = 10 ** 9\n\nfor i in range(1,101):\n\n    tmp = 0\n\n    for a in A:\n\n        tmp += abs(a-i) ** 2\n\n    answer = min(answer,tmp)\n\nprint(answer)","reference_code_col":"N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\nchushin = sum(A)\/\/N\n\nchushin_1 = sum(A)\/\/N +1\n\nanswer = 0\n\nanswer_1 = 0\n\nfor a in A:\n\n    answer += abs(a-chushin) ** 2\n\n    answer_1 += abs(a-chushin_1) ** 2\n\nprint((min(answer,answer_1)))","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(eval(input()))\nA = np.array(list(map(int, input().split())))\n\nanswer = 10 ** 9\n\nfor i in range(1,101):\n    tmp = np.sum((A - i)**2)\n    answer = min(answer,tmp)\n\nprint(answer)"}
{"problem_id":"p02691","slow_code_col":"# E - This Message Will Self-Distruct in 5s\n\n\n\nfrom collections import Counter\n\n\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\nassert len(a) == n\n\n\n\n# Ai + Aj == j - i\n\n# Aj - j == -Ai - i\n\n\n\n# Aj - j \u306e\u5404\u5024\u306e\u500b\u6570\n\ndiff = Counter(a[j] - (j+1) for j in range(n))\n\n\n\n# \u5404Ai\u306b\u3064\u3044\u3066 Aj - j == -Ai - i \u3068\u306a\u308bj\u306e\u500b\u6570\u3092\u6570\u3048\u308b\n\ncount = 0\n\nfor i in range(n):\n\n    diff[a[i] - (i+1)] -= 1  # i\u81ea\u8eab\u3092\u53d6\u308a\u9664\u304f\n\n    count += diff[-a[i] - (i+1)]\n\n\n\nprint(count)\n","reference_code_col":"# E - This Message Will Self-Distruct in 5s\n\n\n\nfrom collections import Counter\n\n\n\nn = int(eval(input()))\n\na = list(map(int, input().split()))\n\nassert len(a) == n\n\n\n\n# Aj - j \u306e\u5404\u5024\u306e\u500b\u6570\n\ndiff = Counter(a[j] - (j+1) for j in range(n))\n\n\n\n# Aj - j == -Ai - i \u3068\u306a\u308b(i,j)\u306e\u500b\u6570\n\ncount = sum(diff[-a[i] - (i+1)] for i in range(n))\n\nprint(count)\n","model_generated_potentially_faster_code_col":"n = int(input())\na = list(map(int, input().split()))\nassert len(a) == n\n\n# Aj - j \u306e\u5404\u5024\u306e\u500b\u6570\ndiff = {}\n\n# \u521d\u671f\u5316\nfor j in range(n):\n    key = a[j] - (j+1)\n    if key not in diff:\n        diff[key] = 0\n    diff[key] += 1\n\n# \u5404Ai\u306b\u3064\u3044\u3066 Aj - j == -Ai - i \u3068\u306a\u308bj\u306e\u500b\u6570\u3092\u6570\u3048\u308b\ncount = 0\nfor i in range(n):\n    key = a[i] - (i+1)\n    diff[key] -= 1  # i\u81ea\u8eab\u3092\u53d6\u308a\u9664\u304f\n    if -key in diff:\n        count += diff[-key]\n\nprint(count)"}
{"problem_id":"p03253","slow_code_col":"import sys\n\ninput = sys.stdin.buffer.readline\n\nfrom collections import defaultdict\n\nimport copy\n\n\n\ndef main():\n\n    N,M = list(map(int,input().split()))\n\n    d = defaultdict(int)\n\n    MOD = 10**9+7\n\n    R = 10**5+100\n\n    fac = [0 for _ in range(R+1)]\n\n    fac[0],fac[1] = 1,1\n\n    inv = copy.deepcopy(fac)\n\n    invfac = copy.deepcopy(fac)\n\n    \n\n    for i in range(2,R+1):\n\n        fac[i] = (fac[i-1]*i)%MOD\n\n        inv[i] = MOD-(MOD\/\/i)*inv[MOD%i]%MOD\n\n        invfac[i] = (invfac[i-1]*inv[i])%MOD\n\n        \n\n    def coef(x,y):\n\n        num = (((fac[x+y]*invfac[y])%MOD)*invfac[x]%MOD)\n\n        return num\n\n\n\n    while M%2 == 0:\n\n        d[2] += 1\n\n        M \/\/= 2\n\n    f = 3\n\n    while f ** 2 <= M:\n\n        if M % f == 0:\n\n            d[f] += 1\n\n            M \/\/= f\n\n        else:\n\n            f += 2\n\n    if M != 1:\n\n        d[M] += 1\n\n    \n\n    l = list(d.values())\n\n    ans = 1\n\n    for num in l:\n\n        ans *= coef(num,N-1)\n\n        ans %= MOD\n\n        \n\n    print(ans)\n\n    \n\nif __name__ == \"__main__\":\n\n    main()","reference_code_col":"import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\ndef main():\n\n    N,M = list(map(int,input().split()))\n\n    MOD = 10**9+7\n\n    \n\n    def factorization(n):\n\n        arr = []\n\n        temp = n\n\n        for i in range(2, int(-(-n**0.5\/\/1))+1):\n\n            if temp%i==0:\n\n                cnt=0\n\n                while temp%i==0:\n\n                    cnt+=1\n\n                    temp \/\/= i\n\n                arr.append([i, cnt])\n\n\n\n        if temp!=1:\n\n            arr.append([temp, 1])\n\n\n\n        return arr\n\n        \n\n    cl = factorization(M)\n\n    \n\n    def combinations(x,y,N):\n\n        fac = [0]*(N+1)\n\n        fac[0],fac[1] = 1,1\n\n        \n\n        for i in range(2,N+1):\n\n            fac[i] = (fac[i-1]*i)%MOD\n\n            \n\n        return (fac[x+y]*pow(fac[x],MOD-2,MOD)*pow(fac[y],MOD-2,MOD))%MOD\n\n        \n\n    ans = 1\n\n    for pr,num in cl:\n\n        ans *= combinations(N-1,num,N+num)\n\n        ans %= MOD\n\n    \n\n    print(ans)\n\n    \n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.buffer.readline\n\nMOD = 10**9 + 7\n\n# Function to calculate factorial modulo MOD\ndef factorial_mod(n):\n    fac = [0] * (n + 1)\n    fac[0] = fac[1] = 1\n    for i in range(2, n + 1):\n        fac[i] = (fac[i - 1] * i) % MOD\n    return fac\n\n# Function to calculate modular inverse using Fermat's Little Theorem\ndef mod_inverse(a, p=MOD):\n    return pow(a, p - 2, p)\n\n# Function to calculate inverse factorial modulo MOD\ndef inverse_factorial_mod(n, mod=MOD):\n    inv_fact = [0] * (n + 1)\n    inv_fact[n] = mod_inverse(factorial_mod(n)[n])\n    for i in range(n, 0, -1):\n        inv_fact[i - 1] = (inv_fact[i] * i) % mod\n    return inv_fact\n\n# Function to calculate binomial coefficient modulo MOD\ndef binomial_coefficient(n, k, mod=MOD):\n    if k > n:\n        return 0\n    return (factorial_mod(n)[n] * \n            inverse_factorial_mod(k, mod)[k] % mod * \n            inverse_factorial_mod(n - k, mod)[n - k] % mod) % mod\n\n# Main function\ndef main():\n    N, M = map(int, input().split())\n    d = defaultdict(int)\n    \n    # Calculate factorials and their inverses\n    fac = factorial_mod(max(N, M))\n    inv_fact = inverse_factorial_mod(max(N, M))\n    \n    # Prime factorization of M\n    while M % 2 == 0:\n        d[2] += 1\n        M \/\/= 2\n    \n    f = 3\n    while f * f <= M:\n        if M % f == 0:\n            d[f] += 1\n            M \/\/= f\n        else:\n            f += 2\n    \n    if M != 1:\n        d[M] += 1\n    \n    # Calculate the result\n    ans = 1\n    for count in d.values():\n        ans *= binomial_coefficient(N - 1, count)\n        ans %= MOD\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03000","slow_code_col":"import bisect\n\n\n\nN, X = list(map(int, input().split()))\n\nl = list(map(int, input().split()))\n\nd = [-1]*(N+1) #0-index #\u30d0\u30a6\u30f3\u30c9\u3059\u308b\u4f4d\u7f6e\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n\nd[0] = 0 #\u30d0\u30a6\u30f3\u30c9\u3059\u308b\u521d\u671f\u5024\u306f0\n\n\n\nfor i in range(1, N+1):\n\n    d[i] = d[i-1] + l[i-1]\n\n\n\n#print(d)\n\n#print('left:', bisect.bisect_left(d, X))\n\n#print('right:', bisect.bisect_right(d, X))\n\nprint((bisect.bisect_right(d, X)))","reference_code_col":"import bisect\n\n\n\nn,x = list(map(int, input().split()))\n\nl = tuple(map(int, input().split()))\n\n\n\nd = [-1]*(n+1)\n\nd[0] = 0\n\nfor i in range(1, n+1):\n\n    d[i] = d[i-1] + l[i-1]\n\nres = bisect.bisect_right(sorted(d), x)\n\nprint(res)","model_generated_potentially_faster_code_col":"import bisect\n\n\nN, X = map(int, input().split())\n\nl = list(map(int, input().split()))\n\n\nprint(bisect.bisect_right(l, X))"}
{"problem_id":"p00145","slow_code_col":"from functools import reduce\ndef f(a,b): return [Card[a][0], Card[b][1]]\n\nn = int(input())\n\nCard = [[] for _ in [0]*n]\n\nCost = {}\n\nfor i in range(n):\n\n  Card[i] = list(map(int, input().split()))\n\n  Cost[(i, i)] = 0\n\nfor i in range(1, n):\n\n  for j in range(0, n-i):\n\n    a = j+i\n\n    Cost[(j, a)] = min([reduce(lambda a,b: a*b, f(j, k) + f(k+1, a)) + Cost[(j, k)] + Cost[(k+1, a)] for k in range(j, j+i)])\n\nprint(Cost[0, n-1])","reference_code_col":"from functools import reduce\nn = int(input())\n\nCard = [[] for _ in [0]*n]\n\nCost = {}\n\nfor i in range(n):\n\n  Card[i] = list(map(int, input().split()))\n\n  Cost[(i, i)] = 0\n\nfor i in range(1, n):\n\n  for j in range(0, n-i):\n\n    a = j+i\n\n    Cost[(j, a)] = min([reduce(lambda a,b: a*b, [Card[j][0],Card[k][1],Card[k+1][0],Card[a][1]]) + Cost[(j, k)] + Cost[(k+1, a)] for k in range(j, j+i)])\n\nprint(Cost[0, n-1])","model_generated_potentially_faster_code_col":"from functools import reduce\n\ndef f(i, j):\n    return [Card[i][0], Card[j][1]]\n\nn = int(input())\n\nCard = []\nCost = []\n\nfor _ in range(n):\n    card = list(map(int, input().split()))\n    Card.append(card)\n    Cost.append([float('inf')] * n)\n\nfor i in range(n):\n    Cost[i][i] = 0\n\nfor length in range(2, n + 1):\n    for start in range(n - length + 1):\n        end = start + length - 1\n        for k in range(start, end):\n            cost = reduce(lambda x, y: x * y, f(start, k) + f(k + 1, end)) + Cost[start][k] + Cost[k + 1][end]\n            Cost[start][end] = min(Cost[start][end], cost)\n\nprint(Cost[0][n - 1])"}
{"problem_id":"p03039","slow_code_col":"def cmb(n, r, mod):\n\n    if ( r<0 or r>n ):\n\n        return 0\n\n    r = min(r, n-r)\n\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\n\nA=2*10**5\n\nmod = 10**9+7\n\ng1 = [1, 1]\n\ng2 = [1, 1]\n\ninverse = [0, 1]\n\n\n\nfor i in range( 2, A + 1 ):\n\n    g1.append( ( g1[-1] * i ) % mod )\n\n    inverse.append( ( -inverse[mod % i] * (mod\/\/i) ) % mod )\n\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\n\nN,M,K=list(map(int,input().split()))\n\nkeisuu=cmb(N*M-2,K-2,mod)\n\n\n\nsum_=0\n\nfor i in range(N):\n\n    a=min(abs(i),abs(N-i-1))\n\n    b=max(abs(i),abs(N-i-1))\n\n    sum_+=(M**2)*((a*(a+1)\/\/2)+(b*(b+1)\/\/2))\n\nfor i in range(M):\n\n    a=min(abs(i),abs(M-i-1))\n\n    b=max(abs(i),abs(M-i-1))\n\n    sum_+=(N**2)*((a*(a+1)\/\/2)+(b*(b+1)\/\/2))\n\nprint(((keisuu * (sum_\/\/2))%mod))","reference_code_col":"def power_mod(a,b,mod=10**9+7):\n\n    i,temp,box=0,b,[]\n\n    while(2**i<=b):\n\n        i+=1\n\n    for j in range(i-1,-1,-1):\n\n        box=[[j,temp\/\/2**j]]+box\n\n        temp-=2**j*(temp\/\/2**j)\n\n    box[0].append(a)\n\n    ans=box[0][1]*a%mod\n\n    for j in range(1,i):\n\n        box[j].append(box[j-1][2]**2%mod)\n\n        if box[j][1]==1:\n\n            ans=(ans*box[j][2])%mod\n\n    return ans\n\ndef n_func(n,mod=10**9+7):\n\n    ans=1\n\n    for i in range(1,n+1):\n\n        ans=(ans*i)%mod\n\n    return ans\n\ndef nPr(n,r,mod=10**9+7):\n\n    ans=n_func(n-r,mod)\n\n    ans=power_mod(ans,mod-2,mod)\n\n    return ans*n_func(n,mod)%mod\n\ndef nCr(n,r,mod=10**9+7):\n\n    ans=n_func(n-r,mod)*n_func(r,mod)%mod\n\n    ans=power_mod(ans,mod-2,mod)\n\n    return ans*n_func(n,mod)%mod\n\n\n\nN,M,K=list(map(int,input().split()))\n\nkeisuu=nCr(N*M-2,K-2)\n\nmod=10**9+7\n\n\n\nsum_=0\n\nfor i in range(N):\n\n    a=min(abs(i),abs(N-i-1))\n\n    b=max(abs(i),abs(N-i-1))\n\n    sum_+=(M**2)*((a*(a+1)\/\/2)+(b*(b+1)\/\/2))\n\nfor i in range(M):\n\n    a=min(abs(i),abs(M-i-1))\n\n    b=max(abs(i),abs(M-i-1))\n\n    sum_+=(N**2)*((a*(a+1)\/\/2)+(b*(b+1)\/\/2))\n\nprint(((keisuu * (sum_\/\/2))%mod))","model_generated_potentially_faster_code_col":"def cmb(n, r, mod):\n    if r < 0 or r > n:\n        return 0\n    r = min(r, n - r)\n    return g1[n] * g2[r] * g2[n - r] % mod\n\n\nA = 2 * 10 ** 5\nmod = 10 ** 9 + 7\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\n\n\nfor i in range(2, A + 1):\n    g1.append((g1[-1] * i) % mod)\n    inverse.append((-inverse[mod % i] * (mod \/\/ i)) % mod)\n    g2.append((g2[-1] * inverse[-1]) % mod)\n\n\nN, M, K = map(int, input().split())\n\n# Precompute sums of squares\nsum_squares_N = [0] * (N + 1)\nsum_squares_M = [0] * (M + 1)\nfor i in range(1, N + 1):\n    sum_squares_N[i] = sum_squares_N[i - 1] + i * i\nfor i in range(1, M + 1):\n    sum_squares_M[i] = sum_squares_M[i - 1] + i * i\n\nkeisuu = cmb(N * M - 2, K - 2, mod)\n\n# Use formula for sum of squares to calculate sum_\nsum_ = ((N ** 2) * sum_squares_N[N] + (M ** 2) * sum_squares_M[M]) % mod\n\nresult = (keisuu * (sum_ \/\/ 2)) % mod\nprint(result)"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\nn=int(eval(input()))\n\na=np.array(list(map(int,input().split())))\n\nb=0\n\nwhile np.all(a%2==0):\n\n\ta=a\/2\n\n\tb+=1\n\n\t\n\nprint(b)","reference_code_col":"a = int(eval(input(\"\")))\n\nb = input(\"\").split(\" \")\n\nc = 0\n\nd = []\n\n\n\nfor i in range(a):\n\n\tc = 0\n\n\twhile (int(b[i]) % 2 == 0):\n\n\t\tb[i] = int(b[i]) \/ 2\n\n\t\tc += 1\n\n\td.append(c)\n\nprint((min(d)))","model_generated_potentially_faster_code_col":"import numpy as np\n\nn = int(input())\n\na = np.array(list(map(int, input().split())))\n\nb = 0\n\nwhile np.all(a % 2 == 0):\n    a \/\/= 2\n    b += 1\n\nprint(b)"}
{"problem_id":"p02959","slow_code_col":"\n\nimport numpy as np\n\nN = int(eval(input()))\n\n\n\nA_ls = np.array(list(map(int,input().split(\" \"))))\n\nB_ls = np.array(list(map(int,input().split(\" \"))))\n\n\n\nS = 0\n\n\n\nfor i,b in enumerate(B_ls):\n\n    if b > A_ls[i]:\n\n        b -= A_ls[i]\n\n        S += A_ls[i]\n\n        if A_ls[i+1] >= b:\n\n            A_ls[i+1] -=b\n\n            S+=b\n\n        else:\n\n            S+=A_ls[i+1]\n\n            A_ls[i+1] = 0 \n\n    else:\n\n        S += b\n\n\n\nprint(S)\n","reference_code_col":"\n\nN = int(eval(input()))\n\n\n\nA_ls = list(map(int,input().split(\" \")))\n\nB_ls = list(map(int,input().split(\" \")))\n\n\n\nS = 0\n\n\n\nfor i,b in enumerate(B_ls):\n\n    if b > A_ls[i]:\n\n        b -= A_ls[i]\n\n        S += A_ls[i]\n\n        if A_ls[i+1] >= b:\n\n            A_ls[i+1] -=b\n\n            S+=b\n\n        else:\n\n            S+=A_ls[i+1]\n\n            A_ls[i+1] = 0 \n\n    else:\n\n        S += b\n\n\n\nprint(S)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(input())\nA_ls = np.array(list(map(int, input().split())))\nB_ls = np.array(list(map(int, input().split())))\n\n# Calculate the difference between B and A\ndiff = B_ls - A_ls\n\n# Find indices where B > A\nmask = diff > 0\n\n# Initialize S with the sum of elements where B <= A\nS = np.sum(B_ls[~mask])\n\n# Calculate the excess values where B > A\nexcess = diff[mask]\n\n# Add the minimum of excess and next element in A to S\nS += np.minimum(excess, np.roll(A_ls, -1)[mask])\n\n# Adjust the next element in A by subtracting the minimum of excess and next element in A\nA_ls[mask + 1] -= np.minimum(excess, np.roll(A_ls, -1)[mask])\n\nprint(S)"}
{"problem_id":"p02725","slow_code_col":"k,n = list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na.append(a[0]+k)\n\nlongd=0\n\nfor i in range(n):\n\n    tmp=abs(a[i+1]-a[i])\n\n    longd=max(longd,tmp)\n\nprint((k-longd))","reference_code_col":"k,n=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na.append(a[0]+k)\n\n\n\nx=0\n\nfor i in range(len(a)-1):\n\n    dis=abs(a[i+1]-a[i])\n\n    x=max(x,dis)\n\n\n\nprint((k-x))","model_generated_potentially_faster_code_col":"# Read input values\nk, n = map(int, input().split())\na = list(map(int, input().split()))\n\n# Append the first element plus k to the list\na.append(a[0] + k)\n\n# Initialize the longest distance variable\nlongd = 0\n\n# Iterate through the list to find the maximum distance between consecutive elements\nfor i in range(1, len(a)):\n    tmp = abs(a[i] - a[i - 1])\n    longd = max(longd, tmp)\n\n# Print the result (k minus the longest distance)\nprint(k - longd)"}
{"problem_id":"p02886","slow_code_col":"def ii():return int(eval(input()))\n\ndef iim():return list(map(int,input().split()))\n\ndef iil():return list(map(int,input().split()))\n\ndef ism():return list(map(str,input().split()))\n\ndef isl():return list(map(str,input().split()))\n\n\n\nn = ii()\n\nD = iil()\n\nans = 0\n\nfor i in range(n):\n\n    for j in range(i+1,n):\n\n#        print(i,j)\n\n        ans += D[i]*D[j] \n\nprint(ans)","reference_code_col":"def ii():return int(eval(input()))\n\ndef iim():return list(map(int,input().split()))\n\ndef iil():return list(map(int,input().split()))\n\ndef ism():return list(map(str,input().split()))\n\ndef isl():return list(map(str,input().split()))\n\n\n\nn = ii()\n\nD = iil()\n\nsumD = sum(D)\n\nans = 0\n\nfor i in range(n):\n\n    ans += D[i]*(sum(D)-D[i])\n\nprint((ans\/\/2))","model_generated_potentially_faster_code_col":"def ii():\n    return int(input())\n\ndef iil():\n    return list(map(int, input().split()))\n\nn = ii()\nD = iil()\n\n# Calculate prefix sums to avoid redundant multiplication\nprefix_sum = [0]\ncurrent_sum = 0\nfor value in D:\n    current_sum += value\n    prefix_sum.append(current_sum)\n\n# Use prefix sums to calculate the result\nans = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        ans += (prefix_sum[j] - prefix_sum[i]) * D[j]\n\nprint(ans)"}
{"problem_id":"p02702","slow_code_col":"s = input()[::-1]\n\nl = len(s)\n\nc = [0] * 2019\n\nc[0] = 1\n\nten = 1\n\nmod = 0\n\nans = 0\n\n\n\nfor i in range(l):\n\n    mod = (mod + int(s[i]) * ten) % 2019\n\n    ten = ten * 10 % 2019\n\n    c[mod] += 1\n\n\n\nfor i in c:\n\n    ans += i * (i - 1) \/\/ 2\n\n\n\nprint(ans)","reference_code_col":"s = input()[::-1]\n\nc = [0] * 2019\n\nc[0] = 1\n\nmod = 0\n\nten = 1\n\nans = 0\n\n\n\nfor i in s:\n\n    mod = (mod + int(i) * ten) % 2019\n\n    ten = ten * 10 % 2019\n\n    c[mod] += 1\n\n\n\nfor i in c:\n\n    ans += i * (i - 1) \/\/ 2\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"s = input()[::-1]\nn = len(s)\nmod_counts = {0: 1}\nmod_sum = 0\nans = 0\n\nfor i in range(n):\n    mod_sum = (mod_sum + int(s[i])) % 2019\n    if mod_sum in mod_counts:\n        ans += mod_counts[mod_sum]\n    mod_counts[mod_sum] = mod_counts.get(mod_sum, 0) + 1\n\nprint(ans)"}
{"problem_id":"p02994","slow_code_col":"import numpy as np\n\n\n\nn,l=list(map(int,input().split()))\n\nli=[]\n\nfor i in range(n):\n\n  li.append(l+i)\n\ns=sum(li)\n\np=np.array(li)\n\na=np.abs(p).tolist()\n\nk=min(a)\n\nb=a.index(k)\n\nprint((s-li[b]))","reference_code_col":"n,l=list(map(int,input().split()))\n\na=0\n\nfor i in range(n):\n\n  a+=i+l\n\nif l>=0:\n\n  print((a-l))\n\nelif l+n-1<0:\n\n  print((a-(l+n-1)))\n\nelse:\n\n  print(a)","model_generated_potentially_faster_code_col":"import numpy as np\n\n\nn, l = map(int, input().split())\n\n# Calculate the sum directly\ns = n * l + n * (n - 1) \/\/ 2\n\n# Calculate the minimum value without creating a new list\nmin_val = l + (n - 1)\n\n# Calculate the result directly\nresult = s - min_val\n\nprint(result)"}
{"problem_id":"p02780","slow_code_col":"import numpy as np\n\nN, K = list(map(int, input().split()))\n\nplist = list(map(int, input().split()))\n\nkitaiti = np.array([(0.5*(p+1)) for p in plist])\n\nans = 0\n\nval = sum(kitaiti[:K])\n\nans = max(ans, val)\n\nfor i in range(1, N-K+1):\n\n    # print(i-1, i+K)\n\n    val -= kitaiti[i-1]\n\n    val += kitaiti[i+K-1]\n\n    ans = max(ans, val)\n\nprint(ans)","reference_code_col":"N, K = list(map(int, input().split()))\n\nplist = [((num*(num+1))\/\/2)\/num for num in list(map(int, input().split()))]\n\n# print(plist)\n\nans = 0\n\nfor i in range(K):\n\n    ans += plist[i]\n\n_ = ans\n\nfor i in range(N-K):\n\n    temp = _\n\n    temp -= plist[i]\n\n    temp += plist[i+K]\n\n    # print(i, i+K, ans, temp)\n\n    ans = max(ans, temp)\n\n    _ = temp\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN, K = map(int, input().split())\nplist = list(map(int, input().split()))\n\n# Calculate the 'kitaiti' array using vectorized operation\nkitaiti = (np.array(plist) + 1) \/ 2\n\n# Initialize the answer with the sum of the first K elements\nans = np.sum(kitaiti[:K])\n\n# Use a sliding window to calculate the sum of the next windows efficiently\nfor i in range(K, N):\n    val = ans - kitaiti[i - K] + kitaiti[i]\n    ans = max(ans, val)\n\nprint(ans)"}
{"problem_id":"p03000","slow_code_col":"#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nimport numpy as np\n\njump = list(np.cumsum(L))\n\nfor j in jump:\n\n    if j <= X:\n\n        cnt+=1\n\nprint((cnt+1))","reference_code_col":"#ABC 130 B\n\nN,X=list(map(int,input().split()))\n\nL= [int(j) for j in input().split()]\n\ncnt=0\n\nimport numpy as np\n\njump = list(np.cumsum(L))\n\nfor j in jump:\n\n    if j <= X:\n\n        cnt+=1\n\n    else:\n\n        break\n\nprint((cnt+1))","model_generated_potentially_faster_code_col":"# ABC 130 B\n\nN, X = map(int, input().split())\n\nL = list(map(int, input().split()))\n\ncnt = 0\ncurrent_sum = 0\n\nfor j in L:\n    current_sum += j\n    if current_sum > X:\n        break\n    cnt += 1\n\nprint(cnt + 1)"}
{"problem_id":"p03371","slow_code_col":"#!usr\/bin\/env python3\n\nfrom collections import defaultdict\n\nfrom collections import deque\n\nfrom heapq import heappush, heappop\n\nimport sys\n\nimport math\n\nimport bisect\n\nimport random\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return list(map(list, sys.stdin.readline().split()))\n\ndef S(): return list(sys.stdin.readline())[:-1]\n\ndef IR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = I()\n\n    return l\n\ndef LIR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LI()\n\n    return l\n\ndef SR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = S()\n\n    return l\n\ndef LSR(n):\n\n    l = [None for i in range(n)]\n\n    for i in range(n):l[i] = LS()\n\n    return l\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\n#A\n\ndef A():\n\n    return\n\n\n\n#B\n\ndef B():\n\n    return\n\n\n\n#C\n\ndef C():\n\n    return\n\n\n\n#D\n\ndef D():\n\n    return\n\n\n\n#E\n\ndef E():\n\n    return\n\n\n\n#F\n\ndef F():\n\n    a,b,c,X,Y = LI()\n\n    ans = float(\"inf\")\n\n    for z in range(300001):\n\n        if z%2 == 0:\n\n            m = c*z\n\n            x = z\/\/2\n\n            y = z\/\/2\n\n            m += a*max(0,X-x)\n\n            m += b*max(0,Y-y)\n\n            if m < ans:\n\n                ans = m\n\n    print(ans)\n\n    return\n\n\n\n#G\n\ndef G():\n\n    n = I()\n\n    x = LI()\n\n    f = [(i,x[i]) for i in range(n)]\n\n    f.sort(key = lambda x:x[1])\n\n    g = [(f[i][0],i) for i in range(n)]\n\n    g.sort(key = lambda x:x[0])\n\n    for i in range(n):\n\n        if g[i][1] < n\/\/2:\n\n            print((f[n\/\/2][1]))\n\n        else:\n\n            print((f[n\/\/2-1][1]))\n\n    return\n\n\n\n#H\n\ndef H():\n\n    return\n\n\n\n#I\n\ndef I_():\n\n    return\n\n\n\n#J\n\ndef J():\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    F()\n","reference_code_col":"#!usr\/bin\/env python3\n\nfrom collections import defaultdict,deque\n\nfrom heapq import heappush, heappop\n\nfrom itertools import permutations\n\nimport sys\n\nimport math\n\nimport bisect\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef I(): return int(sys.stdin.readline())\n\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\n\ndef S():\n\n    res = list(sys.stdin.readline())\n\n    if res[-1] == \"\\n\":\n\n        return res[:-1]\n\n    return res\n\ndef IR(n):\n\n    return [I() for i in range(n)]\n\ndef LIR(n):\n\n    return [LI() for i in range(n)]\n\ndef SR(n):\n\n    return [S() for i in range(n)]\n\ndef LSR(n):\n\n    return [LS() for i in range(n)]\n\n\n\nsys.setrecursionlimit(1000000)\n\nmod = 1000000007\n\n\n\ndef solve():\n\n    A,B,C,x,y = LI()\n\n    ans = float(\"inf\")\n\n    for c in range(200001)[::2]:\n\n        a = b = c >> 1\n\n        a = max(0,x-a)\n\n        b = max(0,y-b)\n\n        s = A*a+B*b+C*c\n\n        if s < ans:\n\n            ans = s\n\n    print(ans)\n\n    return\n\n\n\n#Solve\n\nif __name__ == \"__main__\":\n\n    solve()\n","model_generated_potentially_faster_code_col":"def F():\n    a, b, c, X, Y = LI()\n    \n    # Initialize ans to infinity\n    ans = float(\"inf\")\n    \n    # Iterate over a more reasonable range of z\n    for z in range(min(X, Y) * 2 + 1):\n        m = c * z\n        x = z \/\/ 2\n        y = z \/\/ 2\n        \n        # Adjust x and y to ensure they are within bounds\n        if X > x:\n            m += a * (X - x)\n        if Y > y:\n            m += b * (Y - y)\n        \n        # Update ans if m is smaller\n        if m < ans:\n            ans = m\n    \n    print(ans)\n    return"}
{"problem_id":"p02612","slow_code_col":"n = int(eval(input())) % 1000\n\nif n == 0:\n\n    print((0))\n\nelse:\n\n    print((1000 - n))","reference_code_col":"n = int(eval(input()))\n\nprint(((1000 - n % 1000) % 1000))","model_generated_potentially_faster_code_col":"n = int(input()) % 1000\n\nprint(1000 - n if n != 0 else 0)"}
{"problem_id":"p02599","slow_code_col":"import sys\n\n\n\n\n\nclass BinaryIndexedTree():\n\n    '''\n\n    1-indexed\n\n    '''\n\n    def __init__(self, A):\n\n        self.__n = len(A)\n\n        self.__node = [0] * (self.__n + 1)\n\n        self.__data = [0] * (self.__n + 1)\n\n\n\n        S = [0] * (self.__n + 1)\n\n        for i in range(1, self.__n + 1):\n\n            S[i] = S[i - 1] + A[i - 1]\n\n            self.__data[i] = A[i - 1]\n\n            self.__node[i] = S[i] - S[i - (i & -i)]\n\n\n\n    def add(self, i, v):\n\n        self.__data[i] += v\n\n        while i <= self.__n:\n\n            self.__node[i] += v\n\n            i += i & -i\n\n\n\n    def sum(self, i):\n\n        ''' [1, i]\u306e\u548c\n\n        '''\n\n        rst = 0\n\n        while i > 0:\n\n            rst += self.__node[i]\n\n            i -= i & -i\n\n        return rst\n\n    \n\n    def get(self, i, j):\n\n        '''[i, j]\u306e\u548c\n\n        '''\n\n        if i == j:\n\n            return self.__data[i]\n\n        else:\n\n            return self.sum(j) - self.sum(i - 1)\n\n\n\n\n\ndef main():\n\n    N, Q = map(int, input().split())\n\n    C = list(map(int, input().split()))\n\n\n\n    P = [[] for _ in range(N)]\n\n    for i, c in enumerate(C):\n\n        P[c - 1].append(i)\n\n\n\n    right = [0] * N\n\n    for p in P:\n\n        if len(p):\n\n            right[p.pop()] = 1\n\n    BIT = BinaryIndexedTree(right)\n\n\n\n    query = [[] for _ in range(N)]\n\n    for i, s in enumerate(sys.stdin.readlines()):\n\n        l, r = map(int, s.split())\n\n        query[r - 1].append((l - 1, i))\n\n\n\n    ans = [None] * Q\n\n\n\n    cur = N - 1\n\n    for r, q in enumerate(reversed(query)):\n\n        r = (N - 1) - r\n\n        while q:\n\n            l, i = q.pop()\n\n            while r < cur:\n\n                c = C[cur] - 1\n\n                p = P[c]\n\n                if len(p):\n\n                    BIT.add(p.pop() + 1, 1)\n\n                cur -= 1\n\n            tmp = BIT.get(l + 1, r + 1)\n\n            ans[i] = tmp\n\n\n\n    print(*ans, sep='\\n')\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"import sys\n\n\n\n\n\nclass BinaryIndexedTree():\n\n    '''\n\n    1-indexed\n\n    '''\n\n    def __init__(self, A):\n\n        self.__n = len(A)\n\n        self.__node = [0] * (self.__n + 1)\n\n        self.__data = [0] * (self.__n + 1)\n\n\n\n        S = [0] * (self.__n + 1)\n\n        for i in range(self.__n):\n\n            S[i + 1] = S[i] + A[i]\n\n\n\n        for i in range(1, self.__n + 1):\n\n            self.__data[i] = A[i - 1]\n\n            self.__node[i] = S[i] - S[i - (i & -i)]\n\n\n\n    def add(self, i, v):\n\n        self.__data[i] += v\n\n        while i <= self.__n:\n\n            self.__node[i] += v\n\n            i += i & -i\n\n\n\n    def sum(self, i):\n\n        ''' [1, i]\u306e\u548c\n\n        '''\n\n        rst = 0\n\n        while i > 0:\n\n            rst += self.__node[i]\n\n            i -= i & -i\n\n        return rst\n\n    \n\n    def get(self, i, j):\n\n        '''[i, j]\u306e\u548c\n\n        '''\n\n        if i == j:\n\n            return self.__data[i]\n\n        else:\n\n            return self.sum(j) - self.sum(i - 1)\n\n\n\n\n\ndef main():\n\n    N, Q = map(int, input().split())\n\n    C = list(map(int, input().split()))\n\n\n\n    P = [[] for _ in range(N)]\n\n    for i, c in enumerate(C):\n\n        P[c - 1].append(i)\n\n\n\n    right = [0] * N\n\n    for p in P:\n\n        if len(p):\n\n            right[p.pop()] = 1\n\n    BIT = BinaryIndexedTree(right)\n\n\n\n    query = [[] for _ in range(N)]\n\n    for i, s in enumerate(sys.stdin.readlines()):\n\n        l, r = map(int, s.split())\n\n        query[r - 1].append((l - 1, i))\n\n\n\n    ans = [None] * Q\n\n\n\n    cur = N - 1\n\n    for r, q in enumerate(reversed(query)):\n\n        r = (N - 1) - r\n\n        while q:\n\n            l, i = q.pop()\n\n            while r < cur:\n\n                c = C[cur] - 1\n\n                p = P[c]\n\n                if len(p):\n\n                    BIT.add(p.pop() + 1, 1)\n\n                cur -= 1\n\n            tmp = BIT.get(l + 1, r + 1)\n\n            ans[i] = tmp\n\n\n\n    print(*ans, sep='\\n')\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\n\nclass BinaryIndexedTree():\n    def __init__(self, A):\n        self.n = len(A)\n        self.node = [0] * (self.n + 1)\n        self.data = [0] * (self.n + 1)\n        S = [0] * (self.n + 1)\n        for i, x in enumerate(A, start=1):\n            S[i] = S[i - 1] + x\n            self.data[i] = x\n            self.node[i] = S[i] - S[i - (i & -i)]\n\n    def add(self, i, v):\n        self.data[i] += v\n        while i <= self.n:\n            self.node[i] += v\n            i += i & -i\n\n    def sum(self, i):\n        return sum(self.node[j] for j in range(i, 0, -i))\n\n    def get(self, i, j):\n        return self.sum(j) - self.sum(i - 1)\n\n\ndef main():\n    N, Q = map(int, input().split())\n    C = list(map(int, input().split()))\n    P = [[] for _ in range(N)]\n    for i, c in enumerate(C, start=1):\n        P[c - 1].append(i - 1)\n    right = [0] * N\n    for p in P:\n        if p:\n            right[p.pop()] = 1\n    BIT = BinaryIndexedTree(right)\n    query = [[] for _ in range(N)]\n    for i, line in enumerate(sys.stdin.read().splitlines()):\n        l, r = map(int, line.split())\n        query[r - 1].append((l - 1, i))\n    ans = [None] * Q\n    cur = N - 1\n    for r, q in enumerate(reversed(query)):\n        r = (N - 1) - r\n        while q:\n            l, i = q.pop()\n            while r < cur:\n                c = C[cur]\n                p = P[c - 1]\n                if p:\n                    BIT.add(p.pop() + 1, 1)\n                cur -= 1\n            ans[i] = BIT.get(l + 1, r + 1)\n    print(*ans, sep='\\n')\n\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p02983","slow_code_col":"L ,R = list(map(int,input().split()))\n\n\n\nans =[]\n\nif R - L <= 2019:\n\n    for i in range(L,R+1):\n\n        for j in range(i+1,R+1):\n\n            ans.append(i*j%2019)\n\n\n\nelse:\n\n    for i in range(R-L-1010,R-L+1010):\n\n        for j in range(i,R-L+1010):\n\n            ans.append(i*j%2019)\n\n\n\nprint((min(ans)))\n","reference_code_col":"L ,R = list(map(int,input().split()))\n\n\n\nans =[]\n\nfor i in range(L,R+1):\n\n    for j in range(i+1,R+1):\n\n        ans.append(i*j%2019)\n\n        if (i * j % 2019) == 0:\n\n            break\n\n    else:\n\n        continue\n\n    break\n\n\n\nprint((min(ans)))","model_generated_potentially_faster_code_col":"L, R = map(int, input().split())\n\n# If the range is small enough, compute all products directly\nif R - L <= 2019:\n    min_product_mod_2019 = float('inf')\n    for i in range(L, R + 1):\n        for j in range(i, R + 1):\n            product_mod_2019 = (i * j) % 2019\n            if product_mod_2019 < min_product_mod_2019:\n                min_product_mod_2019 = product_mod_2019\n    print(min_product_mod_2019)\n\nelse:\n    # For larger ranges, find the smallest non-zero remainder when divided by 2019\n    min_non_zero_remainder = float('inf')\n    for i in range(1, 2020):\n        if i * i % 2019 == 0:\n            continue\n        min_non_zero_remainder = min(min_non_zero_remainder, i)\n    \n    # Find the smallest multiple of this remainder within the range [L, R]\n    start = (L \/\/ min_non_zero_remainder + 1) * min_non_zero_remainder\n    end = R\n    \n    min_product_mod_2019 = float('inf')\n    for i in range(start, end + 1, min_non_zero_remainder):\n        for j in range(i, end + 1, min_non_zero_remainder):\n            product_mod_2019 = (i * j) % 2019\n            if product_mod_2019 < min_product_mod_2019:\n                min_product_mod_2019 = product_mod_2019\n    print(min_product_mod_2019)"}
{"problem_id":"p02773","slow_code_col":"from collections import Counter\n\nimport heapq\n\n\n\nn = int(eval(input()))\n\nss = []\n\nfor _ in range(n):\n\n    ss.append(input().rstrip())\n\nctr = Counter(ss)\n\nheap = [(-v, k) for k, v in list(ctr.items())]\n\nheapq.heapify(heap)\n\nmaxv = heap[0][0]\n\nwhile heap:\n\n    c = heapq.heappop(heap)\n\n    if c[0] != maxv:\n\n        break\n\n    print((c[1]))\n","reference_code_col":"from collections import Counter\n\n\n\nn = int(eval(input()))\n\nss = []\n\nfor _ in range(n):\n\n    ss.append(input().rstrip())\n\nctr = Counter(ss)\n\n\n\na = sorted([(-v, k) for k, v in list(ctr.items())])\n\nmaxv = a[0][0]\n\nfor i in range(len(a)):\n\n    if a[i][0] != maxv:\n\n        break\n\n    print((a[i][1]))","model_generated_potentially_faster_code_col":"from collections import Counter\nimport heapq\n\nn = int(input())\nss = []\n\nfor _ in range(n):\n    ss.append(input().rstrip())\n\nctr = Counter(ss)\nheap = [(-v, k) for k, v in list(ctr.items())]\nheapq.heapify(heap)\n\nmaxv = heap[0][0]\n\nwhile heap:\n    c = heapq.heappop(heap)\n    if c[0] != maxv:\n        break\n    print(c[1])"}
{"problem_id":"p02685","slow_code_col":"import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\nfac = [1, 1]     # \u5143\u30c6\u30fc\u30d6\u30eb\n\nf_inv = [1, 1]   # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n\ninv = [0, 1]     # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n\n\ndef prepare(n, mod):\n\n    for i in range(2, n+1):\n\n        fac.append((fac[-1] * i) % mod)\n\n        inv.append((-inv[mod % i] * (mod\/\/i)) % mod)\n\n        f_inv.append((f_inv[-1] * inv[-1]) % mod)\n\n\n\ndef cmb(n, r, mod):\n\n    if n < 0 or r < 0:\n\n        return 0\n\n    if r > n:\n\n        return 0\n\n\n\n    return fac[n] * f_inv[r] * f_inv[n-r] % mod\n\n\n\n\n\ndef main():\n\n    N,M,K = list(map(int, readline().split()))\n\n\n\n    MOD = 998244353\n\n    prepare(N + 10, MOD)\n\n\n\n    if M == 1 and K == N - 1:\n\n        print((1))\n\n        exit()\n\n\n\n    m = M\n\n    for _ in range(N-1):\n\n        m *= M - 1\n\n        m %= MOD\n\n\n\n    ans = 0\n\n    for k in range(K+1):\n\n        ans += (m * cmb(N-1, k, MOD)) % MOD\n\n        ans %= MOD\n\n\n\n        m *= pow(M-1, MOD-2, MOD)\n\n        m %= MOD\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","reference_code_col":"import sys\n\nread = sys.stdin.read\n\nreadline = sys.stdin.readline\n\nreadlines = sys.stdin.readlines\n\n\n\n# 0^0 = 1\n\n\n\ndef main():\n\n    N,M,K = list(map(int, readline().split()))\n\n\n\n    MOD = 998244353\n\n\n\n    if M == 1:\n\n        if K == N - 1:\n\n            print((1))\n\n        else:\n\n            print((0))\n\n        exit()\n\n\n\n    m = pow(M-1, N-1, MOD)\n\n    m_1_inv = pow(M-1, MOD-2, MOD)\n\n    comb = 1\n\n    ans = comb * m\n\n    for k in range(1,K+1):\n\n        m *= m_1_inv\n\n        m %= MOD\n\n        comb *= N - k\n\n        comb %= MOD\n\n        comb *= pow(k, MOD-2, MOD)\n\n        \n\n        ans += (m * comb) % MOD\n\n        ans %= MOD\n\n\n\n    print((ans * M % MOD))\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nMOD = 998244353\n\n# Precompute factorials and their modular inverses\nfact = [1] * (MOD + 1)\ninv_fact = [1] * (MOD + 1)\n\nfor i in range(1, MOD + 1):\n    fact[i] = fact[i - 1] * i % MOD\n    inv_fact[i] = pow(fact[i], MOD - 2, MOD)\n\ndef nCr(n, r):\n    if r > n:\n        return 0\n    return fact[n] * inv_fact[r] * inv_fact[n - r] % MOD\n\ndef main():\n    N, M, K = map(int, readline().split())\n\n    if M == 1 and K == N - 1:\n        print(1)\n        return\n\n    m = pow(M - 1, N - 1, MOD)\n    ans = 0\n\n    for k in range(K + 1):\n        ans = (ans + m * nCr(N - 1, k)) % MOD\n        m = m * (M - 1) * pow(M - 2, MOD - 2, MOD) % MOD\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02748","slow_code_col":"# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\nfrom collections import Counter\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x \/\/ y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\ndef fft(A, B):\n\n    \"\"\" \n\n    \u9ad8\u901f\u30d5\u30fc\u30ea\u30a8\u5909\u63db(FFT)\n\n        A\uff1a\u51fa\u73fe\u56de\u6570\u3092\u30ab\u30a6\u30f3\u30c8\u3057\u305f\u30ea\u30b9\u30c8\n\n        B\uff1a\u51fa\u73fe\u56de\u6570\u3092\u30ab\u30a6\u30f3\u30c8\u3057\u305f\u30ea\u30b9\u30c8\n\n    \"\"\"\n\n    import numpy as np\n\n    from numpy.fft import rfft, irfft\n\n\n\n    # \u51fa\u73fe\u6570\u30ab\u30a6\u30f3\u30c8\n\n    MAXA = max(A)\n\n    MAXB = max(B)\n\n    C1 = [0] * (MAXA+1)\n\n    C2 = [0] * (MAXB+1)\n\n    for a in A:\n\n        C1[a] += 1\n\n    for b in B:\n\n        C2[b] += 1\n\n    # max(A)+max(B)\u3088\u308a\u5927\u304d\u30442\u51aa\n\n    L = 1\n\n    k = 0\n\n    while L <= MAXA + MAXB:\n\n        k += 1\n\n        L = 2**k\n\n    # FFT\n\n    res = irfft(rfft(C1, L) * rfft(C2, L), L)\n\n    # \u56db\u6368\u4e94\u5165\u3057\u3066\u6574\u6570\u306b\n\n    res = np.rint(res).astype(np.int64)\n\n    return res\n\n\n\nN, M, L = MAP()\n\nA = LIST()\n\nB = LIST()\n\n\n\nres = list(fft(A, B))\n\n\n\nmn = INF\n\nfor i, a in enumerate(res):\n\n    if a != 0:\n\n        mn = i\n\n        break\n\n\n\nfor _ in range(L):\n\n    x, y, c = MAP()\n\n    x -= 1; y -= 1\n\n    mn = min(mn, A[x] + B[y] - c)\n\nprint(mn)\n","reference_code_col":"# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\nfrom collections import Counter\n\n\n\ndef input(): return sys.stdin.readline().strip()\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1): return int(-(-x \/\/ y))\n\ndef INT(): return int(eval(input()))\n\ndef MAP(): return list(map(int, input().split()))\n\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes(): print('Yes')\n\ndef No(): print('No')\n\ndef YES(): print('YES')\n\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\n\nINF = 10 ** 18\n\nMOD = 10 ** 9 + 7\n\n\n\nN, M, L = MAP()\n\nA = LIST()\n\nB = LIST()\n\n\n\nmn = min(A) + min(B)\n\nfor _ in range(L):\n\n    x, y, c = MAP()\n\n    x -= 1; y -= 1\n\n    mn = min(mn, A[x] + B[y] - c)\n\nprint(mn)\n","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import Counter\nimport numpy as np\nfrom numpy.fft import rfft, irfft\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x \/\/ y))\ndef INT(): return int(eval(input()))\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\n\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\ndef fft(A, B):\n    \"\"\"\u9ad8\u901f\u30d5\u30fc\u30ea\u30a8\u5909\u63db(FFT)\"\"\"\n    MAXA = max(A)\n    MAXB = max(B)\n    \n    # \u51fa\u73fe\u6570\u30ab\u30a6\u30f3\u30c8\n    C1 = Counter(A)\n    C2 = Counter(B)\n    \n    # max(A)+max(B)\u3088\u308a\u5927\u304d\u30442\u51aa\n    L = 1\n    k = 0\n    while L <= MAXA + MAXB:\n        k += 1\n        L = 2**k\n    \n    # FFT\n    C1_fft = rfft(list(C1.values()), L)\n    C2_fft = rfft(list(C2.values()), L)\n    res_fft = C1_fft * C2_fft\n    \n    # \u623b\u3059\n    res = irfft(res_fft, L)\n    res = np.rint(res).astype(np.int64)\n    \n    return res\n\nN, M, L = MAP()\nA = LIST()\nB = LIST()\n\nres = list(fft(A, B))\n\nmn = INF\nfor i, a in enumerate(res):\n    if a != 0:\n        mn = min(mn, i)\n\nfor _ in range(L):\n    x, y, c = MAP()\n    x -= 1; y -= 1\n    mn = min(mn, A[x] + B[y] - c)\n\nprint(mn)"}
{"problem_id":"p02899","slow_code_col":"import numpy as np\n\n\n\nN = int(eval(input()))\n\nA = [int(_) for _ in input().split(\" \")]\n\n\n\ntmp = np.argsort(A)\n\ntmp2= tmp + np.ones(N)\n\ntmp3 = [int(_) for _ in tmp2.tolist()]\n\nans = [str(_) for _ in tmp3]\n\n\n\nprint((\" \".join(ans)))","reference_code_col":"N = int(eval(input()))\n\nA = [int(_) for _ in input().split(\" \")]\n\n\n\ntmp = sorted(list(range(1, len(A) + 1)), key=lambda x:A[x - 1])\n\nans = [str(_) for _ in tmp]\n\nprint((\" \".join(ans)))","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nA = np.array([int(_) for _ in input().split(\" \")])\n\nsorted_indices = np.argsort(A)\nsorted_indices += 1\nsorted_indices_str = sorted_indices.astype(str)\nresult = ' '.join(sorted_indices_str)\n\nprint(result)"}
{"problem_id":"p03037","slow_code_col":"# -*- coding: utf-8 -*-\n\n\n\nN, M = list(map(int, input().split()))\n\nL, R = [None] * M, [None] * M\n\nfor i in range(M):\n\n    L[i], R[i] = list(map(int, input().split()))\n\n\n\nl = max(L)\n\nr = min(R)\n\n\n\nans = max(r - l + 1, 0)\n\n\n\nprint(ans)\n","reference_code_col":"# -*- coding: utf-8 -*-\n\n\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\nN, M = list(map(int, input().split()))\n\nL, R = [None] * M, [None] * M\n\nfor i in range(M):\n\n    L[i], R[i] = list(map(int, input().split()))\n\n\n\nans = max(min(R) - max(L) + 1, 0)\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"# -*- coding: utf-8 -*-\n\nN, M = map(int, input().split())\n\nL = []\nR = []\n\nfor _ in range(M):\n    l, r = map(int, input().split())\n    L.append(l)\n    R.append(r)\n\nl = max(L)\nr = min(R)\n\nans = max(r - l + 1, 0)\n\nprint(ans)"}
{"problem_id":"p02881","slow_code_col":"import math\n\ninput_num = int(eval(input()))\n\nnum_sqrt = int(math.sqrt(input_num))\n\n\n\nminimam = input_num\n\nfor i in range(num_sqrt+1,0,-1):\n\n    q, mod = divmod(input_num, i)\n\n    distance = q + i -2\n\n    if mod == 0 and minimam > distance:\n\n        minimam = distance\n\nprint(minimam)","reference_code_col":"import math\n\ndef main1():\n\n    input_num = int(eval(input()))\n\n    num_sqrt = int(math.sqrt(input_num))\n\n\n\n    minimam = input_num\n\n    for i in range(num_sqrt+1,0,-1):\n\n        q, mod = divmod(input_num, i)\n\n        if mod == 0:\n\n            distance = q + i -2\n\n            if minimam > distance:\n\n                minimam = distance\n\n    print(minimam)\n\nmain1()","model_generated_potentially_faster_code_col":"import math\n\ndef min_steps(n):\n    return n - (n & -n) - 1\n\ninput_num = int(input())\nprint(min_steps(input_num))"}
{"problem_id":"p02881","slow_code_col":"# C - Walk on Multiplication Table\n\n# https:\/\/atcoder.jp\/contests\/abc144\/tasks\/abc144_c\n\n\n\nn = int(eval(input()))\n\n\n\nans = 10 ** 12\n\nfor i in range(1, 10 ** 6 + 1):\n\n  if n % i == 0:\n\n    ans = min(ans, n \/\/ i + i)\n\n\n\nprint((ans - 2))","reference_code_col":"# C - Walk on Multiplication Table\n\n# https:\/\/atcoder.jp\/contests\/abc144\/tasks\/abc144_c\n\n\n\nn = int(eval(input()))\n\n\n\nans = n\n\nfor i in range(1, int(n**.5) + 2):\n\n  if n % i == 0:\n\n    ans = min(ans, n \/\/ i + i - 2)\n\n\n\nprint(ans)","model_generated_potentially_faster_code_col":"import math\n\nn = int(eval(input()))\n\nans = float('inf')\n\nfor i in range(1, int(math.sqrt(n)) + 1):\n    if n % i == 0:\n        ans = min(ans, n \/\/ i + i)\n\nprint(ans - 2)"}
{"problem_id":"p04020","slow_code_col":"# AGC003B - Simplified mahjong\n\nimport sys\n\ninput = sys.stdin.readline\n\n\n\ndef main():\n\n    # split in subsequences when 0 appears -> sum up cur \/\/ 2\n\n    N = int(eval(input()))\n\n    A = list(map(int, [eval(input()) for _ in range(N)])) + [0]\n\n    ans, cur = 0, 0\n\n    for i in A:\n\n        if i:\n\n            cur += i\n\n        else:\n\n            ans += cur \/\/ 2\n\n            cur = 0\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()","reference_code_col":"# AGC003B - Simplified mahjong\n\ndef main():\n\n    # split in subsequences when 0 appears -> sum up cur \/\/ 2\n\n    N, *A = list(map(int, open(0).read().split()))\n\n    A.append(0)\n\n    ans, cur = 0, 0\n\n    for i in A:\n\n        if i:\n\n            cur += i\n\n        else:\n\n            ans += cur \/\/ 2\n\n            cur = 0\n\n    print(ans)\n\n\n\n\n\nif __name__ == \"__main__\":\n\n    main()","model_generated_potentially_faster_code_col":"import sys\n\ndef main():\n    # Read all lines at once\n    lines = sys.stdin.read().splitlines()\n\n    # Parse the number of elements\n    N = int(lines[0])\n\n    # Convert the list of strings to a list of integers and append 0\n    A = list(map(int, lines[1:N+1])) + [0]\n\n    ans, cur = 0, 0\n\n    for i in A:\n        if i:\n            cur += i\n        else:\n            ans += cur \/\/ 2\n            cur = 0\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02412","slow_code_col":"while True:\n\n    (n, x) = [int(i) for i in input().split()]\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    for a in range(1, n + 1):\n\n        for b in range(a + 1, n + 1):\n\n            for c in range(b + 1, n + 1):\n\n                if sum([a,b,c]) == x:\n\n                    count += 1\n\n\n\n    print(count)","reference_code_col":"while True:\n\n    (n, x) = [int(i) for i in input().split()]\n\n    if n == x == 0:\n\n        break\n\n\n\n    count = 0\n\n    limit = n if n < x else x\n\n    for a in range(1, limit + 1):\n\n        for b in range(a + 1, limit + 1):\n\n            for c in range(b + 1, limit + 1):\n\n                if sum([a,b,c]) == x:\n\n                    count += 1\n\n\n\n    print(count)","model_generated_potentially_faster_code_col":"while True:\n    n, x = map(int, input().split())\n    \n    if n == x == 0:\n        break\n    \n    count = 0\n    for a in range(1, n - 1):\n        for b in range(a + 1, n):\n            c = x - (a + b)\n            if c > b and c <= n:\n                count += 1\n    \n    print(count)"}
{"problem_id":"p04005","slow_code_col":"'''\n\n\u3042\u308b\u5e73\u9762\u306e\u30d6\u30ed\u30c3\u30af\u6570\u00d7(0,1)\n\n\u4e00\u3064\u3067\u3082\u5076\u6570\u304c\u3042\u308c\u3070\u3001\u5747\u7b49\u5206\u5272\u53ef\u80fd\n\n\u3059\u3079\u3066\u5947\u6570\u306e\u3068\u304d\u3001\n\n\u3042\u308b\u5e73\u9762\u306e\u30d6\u30ed\u30c3\u30af\u6570\u3092\u6700\u5c0f\u3068\u306a\u308b\u3088\u3046\u306b\u3059\u308b\u3068\u3001\u305d\u306e\u6570\u304c\u7b54\u3048\u306b\u306a\u308b\n\n'''\n\n\n\narr = list(map(int, input().split()))\n\n\n\nret = -1\n\nif 0 in list([x % 2 for x in arr]):\n\n    ret = 0\n\nelse:\n\n    arr_sorted = sorted(arr)\n\n    ret = arr_sorted[0] * arr_sorted[1]\n\nprint(ret)","reference_code_col":"a = list(map(int, input().split()))\n\n\n\nif any([x % 2 == 0 for x in a]):\n\n    print((0))\n\nelse:\n\n    a = list(sorted(a))\n\n    print((a[0] * a[1]))\n","model_generated_potentially_faster_code_col":"# Input: List of block counts on a plane\narr = list(map(int, input().split()))\n\n# Initialize the return value to -1 (default case)\nret = -1\n\n# Check if any block count is even\nif 0 in [x % 2 for x in arr]:\n    # If yes, then we can split the blocks evenly, so set ret to 0\n    ret = 0\nelse:\n    # If no, sort the block counts in ascending order\n    arr_sorted = sorted(arr)\n    \n    # Multiply the first two elements (smallest numbers) to get the minimum product\n    ret = arr_sorted[0] * arr_sorted[1]\n\n# Output the result\nprint(ret)"}
{"problem_id":"p03162","slow_code_col":"import numpy as np\n\nN = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    abc.append(list(map(int, input().split())))\n\n    \n\ndp = np.zeros(shape=(N, 3), dtype=int)\n\ndp[0, :] = abc[0]\n\nfor i in range(N-1):\n\n    dp[i+1, 0] = max(dp[i+1, 0], dp[i, 1] + abc[i+1][0], dp[i, 2] + abc[i+1][0])\n\n    dp[i+1, 1] = max(dp[i+1, 1], dp[i, 0] + abc[i+1][1], dp[i, 2] + abc[i+1][1])\n\n    dp[i+1, 2] = max(dp[i+1, 2], dp[i, 0] + abc[i+1][2], dp[i, 1] + abc[i+1][2])\n\nprint((max(dp[N-1, :])))","reference_code_col":"N = int(eval(input()))\n\nabc = []\n\nfor i in range(N):\n\n    data = list(map(int, input().split()))\n\n    abc.append(data)\n\n\n\ndp = [[0 for i in range(3)] for j in range(N)]\n\ndp[0][0] = abc[0][0]\n\ndp[0][1] = abc[0][1]\n\ndp[0][2] = abc[0][2]\n\n\n\nfor i in range(N-1):\n\n    for j in range(3):\n\n        if j == 0:\n\n            dp[i+1][1] = max(dp[i][0] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][2] = max(dp[i][0] + abc[i+1][2], dp[i+1][2])\n\n        if j == 1:\n\n            dp[i+1][0] = max(dp[i][1] + abc[i+1][0], dp[i+1][0])\n\n            dp[i+1][2] = max(dp[i][1] + abc[i+1][2], dp[i+1][2])\n\n        if j == 2:\n\n            dp[i+1][1] = max(dp[i][2] + abc[i+1][1], dp[i+1][1])\n\n            dp[i+1][0] = max(dp[i][2] + abc[i+1][0], dp[i+1][0])\n\n\n\nprint((max(dp[N-1])))","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(eval(input()))\nabc = [list(map(int, input().split())) for _ in range(N)]\n\ndp = np.array([[0, 0, 0]] * N)\ndp[0] = abc[0]\n\nfor i in range(1, N):\n    dp[i] = np.maximum(\n        dp[i - 1],\n        dp[i - 1].copy() + abc[i]\n    )\n\nprint(np.max(dp[-1]))"}
{"problem_id":"p02994","slow_code_col":"N , L = list(map(int , input().split()))\n\n\n\napple_taste = []\n\n\n\nfor i in range(N):\n\n    taste = L + i + 1 - 1\n\n    apple_taste.append(taste)\n\n    \n\nimport numpy as np\n\n\n\nabs_apple_taste = np.abs(apple_taste)\n\nm = min(abs_apple_taste)\n\n\n\nfor j in range(N):\n\n    if m == abs_apple_taste[j]:\n\n        apple_taste.remove(apple_taste[j])\n\n\n\npie_taste = 0       \n\n\n\nfor k in range(N-1):\n\n    pie_taste += apple_taste[k]\n\n    \n\nprint(pie_taste)","reference_code_col":"n,l = list(map(int,input().split()))\n\nans = l\n\neat = l\n\n\n\nfor i in range(n-1):\n\n    l += 1\n\n    ans += l\n\n    \n\n    if abs(l) < abs(eat):\n\n        eat = l\n\n        \n\nprint((ans-eat))","model_generated_potentially_faster_code_col":"N, L = map(int, input().split())\n\n# Initialize the list with the formula directly\napple_taste = [L + i for i in range(N)]\n\n# Calculate the sum of absolute differences without removing elements\nmin_val = min(apple_taste)\npie_taste = sum(abs(x - min_val) for x in apple_taste)\n\nprint(pie_taste)"}
{"problem_id":"p02245","slow_code_col":"from collections import deque\n\nN = 3\n\nm = {8: {7, 5}, 7: {8, 6, 4}, 6: {7, 3}, 5: {8, 4, 2}, 4: {7, 5, 3, 1}, 3: {6, 4, 0}, 2: {5, 1}, 1: {4, 2, 0},\n\n     0: {3, 1}}\n\ngoal = 123456780\n\ndef g(i, j, a):\n\n    t = a \/\/ (10 ** j) % 10\n\n    return a - t * (10 ** j) + t * (10 ** i)\n\ndef solve():\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    start = 8 - MAP.find(\"0\")\n\n    MAP = int(MAP)\n\n    if MAP == goal:\n\n        return 0\n\n    dp = deque([(0, start, MAP)])\n\n    LOG = {MAP}\n\n    while dp:\n\n        cnt, yx, M = dp.popleft()\n\n        if M == goal:\n\n            return cnt\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            CM = g(yx, nyx, M)\n\n            if not CM in LOG:\n\n                dp.append((cnt, nyx, CM))\n\n                LOG.add(CM)\n\ndef MAIN():\n\n    print((solve()))\n\nMAIN()\n\n\n","reference_code_col":"from collections import deque\n\nN = 3\n\nm = {8: {7, 5}, 7: {8, 6, 4}, 6: {7, 3}, 5: {8, 4, 2}, 4: {7, 5, 3, 1}, 3: {6, 4, 0}, 2: {5, 1}, 1: {4, 2, 0},\n\n     0: {3, 1}}\n\ngoal = 123456780\n\ndef g(i, j, a):\n\n    t = a \/\/ (10 ** j) % 10\n\n    return a - t * (10 ** j) + t * (10 ** i)\n\ndef solve():\n\n    MAP = \"\".join(input().replace(\" \", \"\") for _ in range(N))\n\n    zero = 8 - MAP.find(\"0\")\n\n    start = int(MAP)\n\n    if start == goal:\n\n        return 0\n\n    dp = deque([(0, start, zero, 1), (0, goal, 0, 0)])\n\n    TABLE = {start: (1, 0), goal: (0, 0)}\n\n    while dp:\n\n        cnt, M, yx, flg = dp.popleft()\n\n        cnt += 1\n\n        for nyx in m[yx]:\n\n            key = g(yx, nyx, M)\n\n            if key in TABLE:\n\n                if TABLE[key][0] != flg:\n\n                    return TABLE[key][1] + cnt\n\n                continue\n\n            TABLE[key] = (flg, cnt)\n\n            dp.append((cnt, key, nyx, flg))\n\ndef MAIN():\n\n    print((solve()))\n\nMAIN()\n\n\n","model_generated_potentially_faster_code_col":"from collections import deque\n\nN = 3\n\n# Define the graph as a dictionary of tuples\nm = {\n    8: {(7,), (5,)},\n    7: {(8,), (6,), (4,)},\n    6: {(7,), (3,)},\n    5: {(8,), (4,), (2,)},\n    4: {(7,), (5,), (3,), (1,)},\n    3: {(6,), (4,), (0,)},\n    2: {(5,), (1,)},\n    1: {(4,), (2,), (0,)},\n    0: {(3,), (1,)}\n}\n\ngoal_state = (1, 2, 3, 4, 5, 6, 7, 8, 0)\n\ndef get_moves(state):\n    zero_index = state.index(0)\n    moves = []\n    if zero_index % 3 != 0:  # Left move\n        moves.append(zero_index - 1)\n    if zero_index % 3 != 2:  # Right move\n        moves.append(zero_index + 1)\n    if zero_index >= 3:  # Up move\n        moves.append(zero_index - 3)\n    if zero_index < 6:  # Down move\n        moves.append(zero_index + 3)\n    return moves\n\ndef solve():\n    initial_state = tuple(map(int, input().replace(\" \", \"\")))\n    \n    if initial_state == goal_state:\n        return 0\n    \n    queue = deque([(initial_state, 0)])\n    visited = {initial_state}\n    \n    while queue:\n        current_state, depth = queue.popleft()\n        \n        if current_state == goal_state:\n            return depth\n        \n        zero_index = current_state.index(0)\n        for move in get_moves(current_state):\n            new_state = list(current_state)\n            new_state[zero_index], new_state[move] = new_state[move], new_state[zero_index]\n            new_state_tuple = tuple(new_state)\n            \n            if new_state_tuple not in visited:\n                visited.add(new_state_tuple)\n                queue.append((new_state_tuple, depth + 1))\n    \n    return -1  # If no solution found\n\ndef main():\n    print(solve())\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p03371","slow_code_col":"inf = (5000 * 10 ** 5) * 3\n\n\n\na, b, c, x, y = list(map(int, input().split()))\n\n\n\nret = inf\n\nfor cnt_ab in range(max(x, y) * 2 + 1):\n\n    d = cnt_ab \/\/ 2\n\n\n\n    cnt_a = max(0, x - d)\n\n    cnt_b = max(0, y - d)\n\n\n\n    t = cnt_ab * c + cnt_a * a + cnt_b * b\n\n    ret = min(ret, t)\n\nprint(ret)\n","reference_code_col":"def main():\n\n    A, B, AB, X, Y = list(map(int, input().split()))\n\n    M = max(X, Y)\n\n\n\n    k = 0\n\n    ans = A * X + B * Y\n\n    while True:\n\n        ans = min(\n\n            ans,\n\n            AB * k * 2 + max(0, X - k) * A + max(0, Y - k) * B\n\n        )\n\n\n\n        if k >= M: break\n\n        k += 1\n\n\n\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"inf = (5000 * 10 ** 5) * 3\n\n# Read input values\na, b, c, x, y = map(int, input().split())\n\n# Initialize result with infinity\nret = inf\n\n# Iterate over possible values of cnt_ab\nfor cnt_ab in range(max(x, y) * 2 + 1):\n    # Calculate d using integer division\n    d = cnt_ab \/\/ 2\n    \n    # Calculate cnt_a and cnt_b ensuring they are non-negative\n    cnt_a = max(0, x - d)\n    cnt_b = max(0, y - d)\n    \n    # Calculate total time t\n    t = cnt_ab * c + cnt_a * a + cnt_b * b\n    \n    # Update result if current time is less than previous minimum\n    ret = min(ret, t)\n\n# Print the result\nprint(ret)"}
{"problem_id":"p02555","slow_code_col":"S = int(eval(input()))\n\nf = [0]*(S+1)\n\nf[0] = 1\n\nif S >= 3: f[3] = 1\n\nif S >= 4: f[4] = 1\n\nif S >= 5: f[5] = 1\n\nfor i in range(6, S+1):\n\n    f[i] = sum(f[i-j] for j in range(3, i+1))%(10**9+7)\n\nprint((f[S]))\n","reference_code_col":"S=int(eval(input()))\n\nf=[1,0,0]\n\nfor i in range(S-2):f.append(f[i]+f[i+2])\n\nprint((f[S]%(10**9+7)))\n","model_generated_potentially_faster_code_col":"def count_ways(S):\n    MOD = 10**9 + 7\n    \n    # Initialize the DP array with zeros\n    dp = [0] * (S + 1)\n    \n    # Base cases\n    if S >= 3:\n        dp[3] = 1\n    if S >= 4:\n        dp[4] = 2\n    if S >= 5:\n        dp[5] = 4\n    \n    # Fill the DP array\n    for i in range(6, S + 1):\n        dp[i] = (dp[i-1] + dp[i-3]) % MOD\n    \n    return dp[S]\n\n# Read input\nS = int(input())\n\n# Get the result\nresult = count_ways(S)\n\n# Print the result\nprint(result)"}
{"problem_id":"p03806","slow_code_col":"import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\nN, Ma, Mb = list(map(int, input().split()))\n\nABC = [list(map(int, input().split())) for _ in range(N)]\n\n\n\nINF = 10 ** 15\n\ndp = [[INF for j in range(401)] for i in range(401)]\n\ndp[0][0] = 0\n\n\n\nfor a, b, c in ABC:\n\n  for i in range(400, -1, -1):\n\n    for j in range(400, -1, -1):\n\n      if dp[i][j] != INF:\n\n        dp[i + a][j + b] = min(dp[i + a][j + b], dp[i][j] + c)\n\n\n\nanswer = INF\n\nfor i in range(1, 401):\n\n  for j in range(1, 401):\n\n    if dp[i][j] != INF and i \/ j == Ma \/ Mb:\n\n      answer = min(answer, dp[i][j])\n\n      \n\nprint((answer if answer != INF else -1))","reference_code_col":"import sys\n\ninput = sys.stdin.buffer.readline\n\n\n\nN, Ma, Mb = list(map(int, input().split()))\n\nABC = [list(map(int, input().split())) for _ in range(N)]\n\n\n\nsumA = sum([ABC[i][0] for i in range(N)])\n\nsumB = sum([ABC[i][1] for i in range(N)])\n\n\n\nINF = 10 ** 15\n\ndp = [[INF for j in range(sumB + 1)] for i in range(sumA + 1)]\n\ndp[0][0] = 0\n\n\n\nfor a, b, c in ABC:\n\n  for i in range(sumA, -1, -1):\n\n    for j in range(sumB, -1, -1):\n\n      if dp[i][j] != INF:\n\n        dp[i + a][j + b] = min(dp[i + a][j + b], dp[i][j] + c)\n\n\n\nanswer = INF\n\nfor i in range(1, sumA + 1):\n\n  for j in range(1, sumB + 1):\n\n    if dp[i][j] != INF and i \/ j == Ma \/ Mb:\n\n      answer = min(answer, dp[i][j])\n\n      \n\nprint((answer if answer != INF else -1))","model_generated_potentially_faster_code_col":"import sys\n\ninput = sys.stdin.read\n\ndata = input().split()\n\nN, Ma, Mb = map(int, data[:3])\nABC = [map(int, data[3 + i * 3:6 + i * 3]) for i in range(N)]\n\nINF = 10 ** 15\n\ndp = [[INF for j in range(401)] for i in range(401)]\ndp[0][0] = 0\n\nfor a, b, c in ABC:\n  for i in range(400, -1, -1):\n    for j in range(400, -1, -1):\n      if dp[i][j] != INF:\n        dp[min(i + a, 400)][min(j + b, 400)] = min(dp[min(i + a, 400)][min(j + b, 400)], dp[i][j] + c)\n\nanswer = INF\nfor i in range(1, 401):\n  for j in range(1, 401):\n    if dp[i][j] != INF and i \/ j == Ma \/ Mb:\n      answer = min(answer, dp[i][j])\n\nprint((answer if answer != INF else -1))"}
{"problem_id":"p02555","slow_code_col":"from sys import stdin, stdout, setrecursionlimit\n\nfrom collections import deque, defaultdict, Counter\n\nfrom heapq import heappush, heappop\n\nfrom functools import lru_cache\n\nimport math\n\n\n\nsetrecursionlimit(10**6)\n\nrl = lambda: stdin.readline()\n\nrll = lambda: stdin.readline().split()\n\nrli = lambda: list(map(int, stdin.readline().split()))\n\nrlf = lambda: list(map(float, stdin.readline().split()))\n\n\n\nINF, NINF = float('inf'), float('-inf')\n\nMOD = 10**9 + 7\n\n\n\ndef main():\n\n\ts = int(rl())\n\n\n\n\t@lru_cache(None)\n\n\tdef dp(currsum):\n\n\t\tif currsum == s: return 1\n\n\t\tcnt = 0\n\n\t\tfor d in range(3, 2001):\n\n\t\t\tif currsum + d <= s:\n\n\t\t\t\tcnt += dp(currsum + d)\n\n\t\t\t\tcnt %= MOD \n\n\t\treturn cnt\n\n\tprint((dp(0)))\n\n\tstdout.close()\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()","reference_code_col":"from sys import stdin, stdout, setrecursionlimit\n\nfrom collections import deque, defaultdict, Counter\n\nfrom heapq import heappush, heappop\n\nfrom functools import lru_cache\n\nimport math\n\n\n\n#setrecursionlimit(10**6)\n\nrl = lambda: stdin.readline()\n\nrll = lambda: stdin.readline().split()\n\nrli = lambda: list(map(int, stdin.readline().split()))\n\nrlf = lambda: list(map(float, stdin.readline().split()))\n\n\n\nINF, NINF = float('inf'), float('-inf')\n\nMOD = 10**9 + 7\n\n\n\ndef main():\n\n\ts = int(rl())\n\n\n\n\tdef binom_tables(n, q):\n\n\t\tfact = [1 for _ in range(n + 1)]\n\n\t\tinv = [1 for _ in range(n + 1)]\n\n\t\tfor i in range(1, n+1):\n\n\t\t\tfact[i] = (fact[i-1] * i) % q\n\n\t\t\tinv[i] = pow(fact[i], q-2, q)\n\n\t\treturn fact, inv\n\n\n\n\tF, I = binom_tables(s + 700, MOD)\n\n\n\n\tdef binom(n, k, q):\n\n\t\treturn (F[n]*((I[k]*I[n-k])%q))%q\n\n\n\n\tans = 0\n\n\tfor r in range(1, 700):\n\n\t\tobjects = s - 3*r\n\n\t\tif objects + r - 1 < objects or objects < 0: \n\n\t\t\tbreak\n\n\t\tx = binom(objects + r - 1, objects, MOD)\n\n\t\tans += x\n\n\t\tans %= MOD \n\n\n\n\tprint(ans)\n\n\tstdout.close()\n\n\n\nif __name__ == \"__main__\":\n\n\tmain()","model_generated_potentially_faster_code_col":"from sys import stdin, stdout, setrecursionlimit\n\nsetrecursionlimit(10**6)\n\nrl = lambda: stdin.readline().strip()\nrli = lambda: list(map(int, rl().split()))\n\nINF, NINF = float('inf'), float('-inf')\nMOD = 10**9 + 7\n\n\ndef main():\n    s = rli()[0]\n\n    @lru_cache(None)\n    def dp(currsum):\n        if currsum == s:\n            return 1\n        elif currsum > s:\n            return 0\n        \n        count = 0\n        # Only consider valid digits (3-9)\n        for d in range(3, 10):\n            count += dp(currsum + d)\n            count %= MOD\n        return count\n\n    print(dp(0))\n    stdout.close()\n\n\nif __name__ == \"__main__\":\n    main()"}
{"problem_id":"p02688","slow_code_col":"N,K=list(map(int,input().split()))\n\na = [[0]*N]*K\n\na = [[0 for n in range(N)] for k in range(K)]\n\n\n\nfor k in range(K):\n\n    d=int(eval(input()))\n\n    have_k=list(map(int,input().split()))\n\n    for h in have_k:\n\n        a[k][h-1]=1\n\n\n\nan=[0]*N\n\nfor k in range(K):\n\n  for n in range(N):\n\n    an[n] = an[n]+a[k][n]\n\n\n\nresult=0\n\nfor i in an:\n\n  if i == 0:\n\n    result+=1\n\n\n\nprint(result)","reference_code_col":"N,K=list(map(int,input().split()))\n\na = [[0 for n in range(N)] for k in range(K)]\n\n\n\nfor k in range(K):\n\n    d=int(eval(input()))\n\n    have_k=list(map(int,input().split()))\n\n    for h in have_k:\n\n        a[k][h-1]=1\n\n\n\nan=[0]*N\n\nfor k in range(K):\n\n  for n in range(N):\n\n    an[n] = an[n]+a[k][n]\n\n\n\nresult=0\n\nfor i in an:\n\n  if i == 0:\n\n    result+=1\n\n\n\nprint(result)","model_generated_potentially_faster_code_col":"from collections import defaultdict\n\nN, K = map(int, input().split())\n\n# Create a dictionary to store the indices of non-zero elements in each row\nnon_zero_indices = defaultdict(set)\n\nfor k in range(K):\n    d = int(input())\n    have_k = list(map(int, input().split()))\n    non_zero_indices[k].update(have_k - {0})\n\n# Calculate the number of columns with only zeros\nresult = N - len(non_zero_indices)\n\nprint(result)"}
{"problem_id":"p02767","slow_code_col":"import numpy as np \n\nn = int(eval(input()))\n\nx = list(map(int, input().split()))\n\nx = np.array(x)\n\nans = float('inf')\n\nidx = 200\n\nfor i in range(100):\n\n  y = x \n\n  ans = min(ans, np.sum((y-i)**2))\n\n  \n\nprint(ans)","reference_code_col":"N = int(eval(input()))\n\nX = list(map(int, input().split()))\n\nmx = max(X)\n\nans = float('inf')\n\nfor i in range(mx+1):\n\n  tmp = 0\n\n  for x in X:\n\n    tmp += (x-(i+1))**2\n\n  ans = min(ans, tmp)\n\nprint(ans)","model_generated_potentially_faster_code_col":"import numpy as np\n\nn = int(input())\nx = list(map(int, input().split()))\nx = np.array(x)\n\n# Calculate mean to minimize sum of squared differences\nmean = np.mean(x)\n\n# Round the mean to nearest integer for optimal result\noptimal_i = round(mean)\n\n# Calculate minimum sum of squares\nmin_sum_of_squares = np.sum((x - optimal_i) ** 2)\n\nprint(min_sum_of_squares)"}
{"problem_id":"p03037","slow_code_col":"n,m=list(map(int,input().split()))\n\nc=[0]*(n+2)\n\nfor i in range(m):\n\n  l,r=list(map(int,input().split()))\n\n  c[l-1]+=1\n\n  c[r]-=1\n\nfor i in range(1,n+2):\n\n  c[i]=c[i]+c[i-1]\n\nans=0\n\nfor i in range(n+2):\n\n  if c[i]==m:\n\n    ans+=1\n\nprint(ans)","reference_code_col":"n,m=list(map(int,input().split()))\n\nl,r=list(map(int,input().split()))\n\nfor i in range(m-1):\n\n  tl,tr=list(map(int,input().split()))\n\n  if l<tl:\n\n    l=tl\n\n  if tr<r:\n\n    r=tr\n\nprint((max(r-l+1,0)))","model_generated_potentially_faster_code_col":"n,m=list(map(int,input().split()))\ncount={}\nfor i in range(m):\n  l,r=list(map(int,input().split()))\n  if l not in count:\n    count[l]=0\n  count[l]+=1\n  if r not in count:\n    count[r]=0\n  count[r]-=1\nfor key,val in count.items():\n  if val==m:\n    print(key)"}
{"problem_id":"p03287","slow_code_col":"n,m=list(map(int,input().split()))\n\na=[int(x) for x in input().split()]\n\nb=[0 for x in range(n+1)]\n\nl=list([0])\n\n\n\nfor i in range(1,n+1):\n\n  b[i]=b[i-1]+a[i-1]\n\n\n\nfor i in range(1,n+1):\n\n  l.append(b[i]%m)\n\n\n\nd=list()\n\nl.sort()\n\nt,c=0,1\n\nfor i in range(1,n+1):\n\n  if l[i]==l[i-1]:\n\n    c+=1\n\n  else:\n\n    if c!=1:\n\n      t += c*(c-1)\/\/2\n\n      c=1\n\n\n\nif c!=1:\n\n  t += c*(c-1)\/\/2  \n\n\n\nprint(t)\n","reference_code_col":"n,m=list(map(int,input().split()))\n\na=[int(x) for x in input().split()]\n\nl=list([0])\n\n\n\nb=0\n\nfor i in range(0,n):\n\n  b += a[i]\n\n  l.append(b%m)\n\nl.append(m)\n\n\n\nl.sort()\n\nt,c=0,1\n\nfor i in range(1,n+2):\n\n  if l[i]==l[i-1]:\n\n    c+=1\n\n  else:\n\n    if c!=1:\n\n      t += c*(c-1)\/\/2\n\n      c=1\n\nprint(t)\n","model_generated_potentially_faster_code_col":"n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = [0] * (n + 1)\nprefix_sum_mods = [0] * m\n\n# Calculate prefix sums modulo m\nfor i in range(1, n + 1):\n    b[i] = b[i - 1] + a[i - 1]\n    prefix_sum_mods[b[i] % m] += 1\n\n# Calculate the number of pairs with the same remainder\nt = sum(c * (c - 1) \/\/ 2 for c in prefix_sum_mods if c > 1)\n\nprint(t)"}
{"problem_id":"p03494","slow_code_col":"import numpy as np\n\n\n\nN = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nA = np.array(A)\n\ncounter = 0\n\nwhile True:\n\n    if all( i%2==0 for i in A):\n\n        counter  += 1\n\n        A = A\/2\n\n    else:\n\n        print(counter)\n\n        break","reference_code_col":"N = int(eval(input()))\n\nA = list(map(int, input().split()))\n\n\n\nc = 0\n\nwhile True:\n\n    if all(a% 2 ==0 for a in A):\n\n        c += 1\n\n        A = list([x\/\/2 for x in A])\n\n    else:\n\n        break\n\nprint(c)","model_generated_potentially_faster_code_col":"import numpy as np\n\nN = int(eval(input()))\nA = np.array(list(map(int, input().split())))\n\ncounter = 0\n\nwhile not (A % 2).any():\n    A \/= 2\n    counter += 1\n\nprint(counter)"}
{"problem_id":"p02850","slow_code_col":"import copy\n\n\n\nn=int(eval(input()))\n\norg_set=set([i for i in range(1,10**5)])\n\nedges=[]\n\nrelations={}\n\nnodes=[]\n\nfor i in range(n-1):\n\n    a,b=list(map(int,input().split(\" \")))\n\n    edges.append([a,b])\n\n    relations.setdefault(a,[]).append(b)\n\n    nodes.append([])\n\nnodes.append([])\n\nnodes.append([])\n\n\n\nmax_color=0\n\nfor start in range(1,n+1):\n\n    targets=relations.get(start,[])\n\n    color=1\n\n    for target in targets:\n\n        if color in nodes[start]:\n\n            color+=1\n\n        else:\n\n            pass\n\n        nodes[target].append(color)\n\n        if color>=max_color:\n\n            max_color=color\n\n        color+=1\n\n\n\nprint(max_color)\n\nfor edge in edges:\n\n    print((nodes[edge[1]][0]))","reference_code_col":"n=int(eval(input()))\n\nedges=[]\n\nrelations={}\n\nnodes=[0,0]\n\nfor i in range(n-1):\n\n    a,b=list(map(int,input().split(\" \")))\n\n    edges.append([a,b])\n\n    relations.setdefault(a,[]).append(b)\n\n    nodes.append(0)\n\n\n\nmax_color=0\n\nfor start in range(1,n+1):\n\n    targets=relations.get(start,[])\n\n    color=1\n\n    for target in targets:\n\n        if color == nodes[start]:\n\n            color+=1\n\n        else:\n\n            pass\n\n        nodes[target]=color\n\n        if color>=max_color:\n\n            max_color=color\n\n        color+=1\n\n\n\nprint(max_color)\n\nfor edge in edges:\n\n    print((nodes[edge[1]]))","model_generated_potentially_faster_code_col":"import sys\nsys.setrecursionlimit(10**6)\nfrom collections import defaultdict\n\nn = int(input())\norg_set = set(range(1, 10**5))\nedges = []\nrelations = defaultdict(list)\ncolors = [0] * (n + 2)\n\ndef dfs(node):\n    visited.add(node)\n    color = 1\n    while True:\n        if color not in colors[node]:\n            break\n        color += 1\n    colors[node] = color\n    max_color[0] = max(max_color[0], color)\n    for neighbor in relations[node]:\n        if neighbor not in visited:\n            dfs(neighbor)\n        elif colors[neighbor] == 0:\n            colors[neighbor] = color\n        else:\n            colors[neighbor] = min(colors[neighbor], color)\n    return color\n\nvisited = set()\nmax_color = [0]\n\ndfs(1)\n\nprint(max_color[0])\nfor edge in edges:\n    print(colors[edge[1]])"}
{"problem_id":"p03780","slow_code_col":"# x < y\u3067y\u304c\u4e0d\u8981\u3068\u3059\u308b\u3002y\u629c\u304d\u3067[K-y,K)\u3092\u4f5c\u308c\u308b\u3002\n\n# \u3053\u306e\u3068\u304d\u306bx\u3092\u4f7f\u3063\u3066\u3044\u306a\u3044\u306e\u306a\u3089\u3070\u3001x\u3082\u4e0d\u8981\u3002\n\n# x\u3092\u4f7f\u3063\u3066\u3044\u308b\u306e\u306a\u3089\u3070\u3001xy\u629c\u304d\u3067[K-x-y,K-x)\u3092\u4f5c\u308c\u308b\u3002\n\n# y\u3092\u52a0\u3048\u3066\u3001x\u629c\u304d\u3067[K-x,K)\u3092\u4f5c\u308c\u308b\u3002\n\n# \u3088\u3063\u3066y\u4e0d\u8981\u306a\u3089\u3070x\u4e0d\u8981\u3002\n\nimport numpy as np\n\nimport itertools\n\n\n\nN,K = list(map(int,input().split()))\n\nA = [int(x) for x in input().split()]\n\nA.sort()\n\n\n\n# \u30ab\u30fc\u30c9\u306f[0,N)-indexed\n\n\n\ndef test(i):\n\n  # i\u756a\u76ee\u306e\u30ab\u30fc\u30c9\u306f\u4e0d\u8981\n\n  dp = np.zeros(K,dtype=np.bool)\n\n  dp[0] = True\n\n  for a in itertools.chain(A[:i],A[i+1:]):\n\n    dp[a:] = np.logical_or(dp[a:],dp[:-a])\n\n  return not dp[-A[i]:].any()\n\n\n\nleft = -1 # \u4e0d\u8981\u3060\u3068\u5224\u660e\n\nright = N # \u4e0d\u8981\u3067\u306a\u3044\u3068\u5224\u660e\n\nwhile right - left > 1:\n\n  mid = (left+right)\/\/2\n\n  if test(mid):\n\n    left = mid\n\n  else:\n\n    right = mid\n\n\n\n   \n\nanswer = left+1\n\nprint(answer)","reference_code_col":"import sys\n\nread = sys.stdin.buffer.read\n\nreadline = sys.stdin.buffer.readline\n\nreadlines = sys.stdin.buffer.readlines\n\n\n\nimport itertools\n\n\n\n\"\"\"\n\n\u30fb\u300c\u5fc5\u8981\u300d\u3068\u306f\uff5e\uff5e\u304c\u5b58\u5728\n\n\u30fbx \u3092\u542b\u307e\u306a\u3044\u3001[K-x,K) \u5185\u306e\u7dcf\u548c\u304c\u5b58\u5728\n\n\u30fb\u96c6\u5408\u3092\u6307\u5b9a\u3059\u308b\u3068\u3001\u3042\u308b\u5024\u6bb5\u3088\u308a\u4e0a\u5074\n\n\u30fb\u5168\u4f53\u3068\u3057\u3066\u3082\u5358\u8abf\u6027\u304c\u3042\u308b\n\n\"\"\"\n\n\n\nN,K,*A = list(map(int,read().split()))\n\n\n\nA = [x if x <= K else K + 1 for x in A]\n\nA.sort()\n\n\n\nmask = (1 << K) - 1\n\n\n\ndef test(x):\n\n    # x\u756a\u76ee\u306f\u5fc5\u8981\n\n    if A[x] > K:\n\n        return True\n\n    dp = 1\n\n    for a in itertools.chain(A[:x], A[x+1:]):\n\n        dp |= (dp << a)\n\n        dp &= mask\n\n    dp >>= (K - A[x])\n\n    return (dp > 0)\n\n\n\nleft = -1 # \u5fc5\u8981\n\nright = N # \u4e0d\u8981\n\nwhile left + 1 < right:\n\n    x = (left + right) \/\/ 2\n\n    if test(x):\n\n        right = x\n\n    else:\n\n        left = x\n\n\n\nanswer = left + 1\n\nprint(answer)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\nN, K = map(int, input().split())\nA = sorted(map(int, input().split()))\n\ndef test(i):\n    dp = np.zeros(K, dtype=np.uint8)  # Use uint8 for faster bitwise operations\n    dp[0] = 1\n    for a in A[:i] + A[i+1:]:\n        dp |= (dp << a) & ((1 << K) - 1)\n    return (dp >> (K - A[i])) & 1 == 0\n\nleft = -1  # \u4e0d\u8981\u3060\u3068\u5224\u660e\nright = N  # \u4e0d\u8981\u3067\u306a\u3044\u3068\u5224\u660e\n\nwhile right - left > 1:\n    mid = (left + right) \/\/ 2\n    if test(mid):\n        left = mid\n    else:\n        right = mid\n\nanswer = left + 1\nprint(answer)"}
{"problem_id":"p02691","slow_code_col":"n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nk=[]\n\nans=0\n\nfor i in range(400005):\n\n  k.append(0)\n\nfor i in range(n):\n\n  if i-a[i]>=0:\n\n    ans+=k[i-a[i]]\n\n  if a[i]+i<400005:\n\n    k[a[i]+i]+=1\n\nprint(ans)","reference_code_col":"n=int(eval(input()))\n\na=list(map(int,input().split()))\n\nthing={}\n\nans=0\n\nfor i in range(n):\n\n  if i-a[i] in thing:\n\n    ans+=thing[i-a[i]]\n\n  if i+a[i] in thing:\n\n    thing[i+a[i]]+=1\n\n  else:\n\n    thing[i+a[i]]=1\n\nprint(ans)","model_generated_potentially_faster_code_col":"n = int(input())\na = list(map(int, input().split()))\nfreq = {}\nans = 0\n\nfor i in range(n):\n    key = a[i] + i\n    if key in freq:\n        ans += freq[key]\n    freq[key] = freq.get(key, 0) + 1\n\nprint(ans)"}
{"problem_id":"p03060","slow_code_col":"import sys\n\nimport numpy as np\n\n\n\nN = eval(input())\n\n\n\nV = input().split()\n\nv = np.array([ int(x) for x in V])\n\n\n\nC = input().split()\n\nc = np.array([ int(x) for x in C])\n\n\n\ndelt = v - c\n\nprint((delt[delt>0].sum()))","reference_code_col":"N = int(eval(input()))\n\nV = list(map(int, input().split()))\n\nC = list(map(int, input().split()))\n\n\n\nans = 0\n\nfor v, c in zip(V, C):\n\n    p = v - c\n\n    if p > 0:\n\n        ans += p\n\n\n\nprint(ans)\n","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read input values\nN = int(input())\nV = list(map(int, input().split()))\nC = list(map(int, input().split()))\n\n# Convert lists to NumPy arrays\nv = np.array(V)\nc = np.array(C)\n\n# Calculate differences and filter out non-positive values\ndifferences = v - c\npositive_differences = differences[differences > 0]\n\n# Print the sum of positive differences\nprint(positive_differences.sum())"}
{"problem_id":"p02881","slow_code_col":"import sys\n\nimport os\n\nimport math\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    N = ii()\n\n    ret = float('inf')\n\n    I = int(math.sqrt(N)) * 10\n\n    for i in range(1, I):\n\n        if N%i == 0:\n\n            j = N\/\/i\n\n            ret = min(ret, j + i - 2)\n\n\n\n    print(ret)\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","reference_code_col":"import sys\n\nimport os\n\n\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\n\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\n\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\n\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\n\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n\n\n\n\ndef main():\n\n    if os.getenv(\"LOCAL\"):\n\n        sys.stdin = open(\"input.txt\", \"r\")\n\n\n\n    N = ii()\n\n    m = int(N ** .5)\n\n    while N % m != 0:\n\n        m -= 1\n\n    else:\n\n        print((int(N \/ m + m - 2)))\n\n\n\n\n\nif __name__ == '__main__':\n\n    main()\n","model_generated_potentially_faster_code_col":"import sys\nimport os\nimport math\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\ndef main():\n    if os.getenv(\"LOCAL\"):\n        sys.stdin = open(\"input.txt\", \"r\")\n\n    N = ii()\n    ret = float('inf')\n    sqrt_N = int(math.isqrt(N))  # Use integer square root for better efficiency\n\n    for i in range(1, sqrt_N + 1):\n        if N % i == 0:\n            j = N \/\/ i\n            candidate = j + i - 2\n            if candidate < ret:\n                ret = candidate\n                if candidate == 0:\n                    break  # Early termination if candidate is 0\n\n    print(ret)\n\nif __name__ == '__main__':\n    main()"}
{"problem_id":"p03774","slow_code_col":"import numpy as np\n\nn, m = list(map(int, input().split()))\n\nab = [list(map(int, input().split())) for i in range(n)]\n\ncd = [list(map(int, input().split())) for i in range(m)]\n\n\n\ndist = np.zeros((n, m))\n\nfor i in range(n):\n\n  for j in range(m):\n\n    dist[i, j] = abs(ab[i][0] - cd[j][0]) + abs(ab[i][1] - cd[j][1])\n\n\n\nfor dis in dist:\n\n  print((dis.argmin()+1))","reference_code_col":"n, m = list(map(int, input().split()))\n\nab = [list(map(int, input().split())) for i in range(n)]\n\ncd = [list(map(int, input().split())) for i in range(m)]\n\n\n\nfor i in range(n):\n\n  a, b = ab[i]\n\n  \n\n  dist = 1e+15\n\n  ans = 0\n\n  for j in range(m):\n\n    c, d = cd[j]    \n\n\n\n    if dist > abs(a - c) + abs(b - d):\n\n      ans = j\n\n      dist = abs(a - c) + abs(b - d)\n\n  \n\n  print((ans+1))\n\n    \n\n    \n\n    ","model_generated_potentially_faster_code_col":"import numpy as np\n\n# Read inputs\nn, m = map(int, input().split())\n\nab = np.array([list(map(int, input().split())) for _ in range(n)])\ncd = np.array([list(map(int, input().split())) for _ in range(m)])\n\n# Compute distances using broadcasting\ndistances = np.abs(ab[:, None, 0] - cd[None, :, 0]) + np.abs(ab[:, None, 1] - cd[None, :, 1])\n\n# Find indices of minimum distance for each row and add 1 (as per problem statement)\nresult = np.argmin(distances, axis=1) + 1\n\n# Print results\nprint(*result, sep='\\n')"}
